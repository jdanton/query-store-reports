"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/@tediousjs/connection-string/lib/parser/connection-string.js
var require_connection_string = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/parser/connection-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CollectionMode;
    (function(CollectionMode2) {
      CollectionMode2[CollectionMode2["key"] = 0] = "key";
      CollectionMode2[CollectionMode2["value"] = 1] = "value";
    })(CollectionMode || (CollectionMode = {}));
    var CONFIG = Object.freeze({
      key: {
        terminator: "=",
        quotes: {}
      },
      value: {
        terminator: ";",
        quotes: {
          '"': '"',
          "'": "'",
          "{": "}"
        }
      }
    });
    function connectionStringParser(connectionString, parserConfig = CONFIG) {
      const parsed = {};
      let collectionMode = CollectionMode.key;
      let started = false;
      let finished = false;
      let quoted = false;
      let quote = "";
      let buffer = "";
      let currentKey = "";
      let pointer = 0;
      function start() {
        started = true;
      }
      function finish() {
        finished = true;
      }
      function reset() {
        started = false;
        finished = false;
        quoted = false;
        quote = "";
        buffer = "";
      }
      function config() {
        return collectionMode === CollectionMode.key ? parserConfig.key : parserConfig.value;
      }
      function isTerminator(char) {
        return config().terminator === char;
      }
      function isStartQuote(char) {
        return Object.keys(config().quotes).some((val) => char === val);
      }
      function isEndQuote(char) {
        return quoted && char === config().quotes[quote];
      }
      function push(char) {
        buffer += char;
      }
      function collect() {
        if (!quoted) {
          buffer = buffer.trim();
        }
        switch (collectionMode) {
          case CollectionMode.key:
            currentKey = buffer.toLowerCase();
            collectionMode = CollectionMode.value;
            break;
          case CollectionMode.value:
            collectionMode = CollectionMode.key;
            parsed[currentKey] = buffer;
            currentKey = "";
            break;
        }
        reset();
      }
      while (pointer < connectionString.length) {
        const current = connectionString.charAt(pointer);
        if (!finished) {
          if (!started) {
            if (current.trim()) {
              start();
              if (isStartQuote(current)) {
                quoted = true;
                quote = current;
              } else {
                push(current);
              }
            }
          } else {
            if (quoted && isEndQuote(current)) {
              const next = connectionString.charAt(pointer + 1);
              if (current === next) {
                push(current);
                pointer++;
              } else {
                finish();
              }
            } else if (!quoted && isTerminator(current)) {
              const next = connectionString.charAt(pointer + 1);
              if (current === next) {
                push(current);
                pointer++;
              } else {
                collect();
              }
            } else {
              push(current);
            }
          }
        } else if (isTerminator(current)) {
          collect();
        } else if (current.trim()) {
          throw new Error("Malformed connection string");
        }
        pointer++;
      }
      if (quoted && !finished) {
        throw new Error("Connection string terminated unexpectedly");
      } else {
        collect();
      }
      return parsed;
    }
    exports2.default = connectionStringParser;
  }
});

// node_modules/@tediousjs/connection-string/lib/parser/sql-connection-string.js
var require_sql_connection_string = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/parser/sql-connection-string.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SCHEMA = exports2.SchemaTypes = void 0;
    var connection_string_1 = __importDefault2(require_connection_string());
    var SchemaTypes;
    (function(SchemaTypes2) {
      SchemaTypes2[SchemaTypes2["BOOL"] = 0] = "BOOL";
      SchemaTypes2[SchemaTypes2["STRING"] = 1] = "STRING";
      SchemaTypes2[SchemaTypes2["NUMBER"] = 2] = "NUMBER";
    })(SchemaTypes = exports2.SchemaTypes || (exports2.SchemaTypes = {}));
    exports2.SCHEMA = {
      "Application Name": {
        type: SchemaTypes.STRING,
        aliases: ["App"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "ApplicationIntent": {
        type: SchemaTypes.STRING,
        allowedValues: ["ReadOnly", "ReadWrite"],
        default: "ReadWrite"
      },
      "Asynchronous Processing": {
        type: SchemaTypes.BOOL,
        default: false,
        aliases: ["Async"]
      },
      "AttachDBFilename": {
        type: SchemaTypes.STRING,
        aliases: ["Extended Properties", "Initial File Name"]
      },
      "Authentication": {
        type: SchemaTypes.STRING,
        allowedValues: ["Active Directory Integrated", "Active Directory Password", "Sql Password"]
      },
      "Column Encryption Setting": {
        type: SchemaTypes.STRING
      },
      "Connection Timeout": {
        type: SchemaTypes.NUMBER,
        aliases: ["Connect Timeout", "Timeout"],
        default: 15
      },
      "Connection Lifetime": {
        type: SchemaTypes.NUMBER,
        aliases: ["Load Balance Timeout"],
        default: 0
      },
      "ConnectRetryCount": {
        type: SchemaTypes.NUMBER,
        default: 1,
        validator(val) {
          return val > 0 && val <= 255;
        }
      },
      "ConnectRetryInterval": {
        type: SchemaTypes.NUMBER,
        default: 10
      },
      "Context Connection": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Current Language": {
        aliases: ["Language"],
        type: SchemaTypes.STRING,
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Data Source": {
        aliases: ["Addr", "Address", "Server", "Network Address"],
        type: SchemaTypes.STRING
      },
      "Encrypt": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Enlist": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "Failover Partner": {
        type: SchemaTypes.STRING
      },
      "Initial Catalog": {
        type: SchemaTypes.STRING,
        aliases: ["Database"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Integrated Security": {
        type: SchemaTypes.BOOL,
        aliases: ["Trusted_Connection"],
        coerce(val) {
          return val === "sspi" || null;
        }
      },
      "Max Pool Size": {
        type: SchemaTypes.NUMBER,
        default: 100,
        validator(val) {
          return val >= 1;
        }
      },
      "Min Pool Size": {
        type: SchemaTypes.NUMBER,
        default: 0,
        validator(val) {
          return val >= 0;
        }
      },
      "MultipleActiveResultSets": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "MultiSubnetFailover": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Network Library": {
        type: SchemaTypes.STRING,
        aliases: ["Network", "Net"],
        allowedValues: ["dbnmpntw", "dbmsrpcn", "dbmsadsn", "dbmsgnet", "dbmslpcn", "dbmsspxn", "dbmssocn", "Dbmsvinn"]
      },
      "Packet Size": {
        type: SchemaTypes.NUMBER,
        default: 8e3,
        validator(val) {
          return val >= 512 && val <= 32768;
        }
      },
      "Password": {
        type: SchemaTypes.STRING,
        aliases: ["PWD"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "Persist Security Info": {
        type: SchemaTypes.BOOL,
        aliases: ["PersistSecurityInfo"],
        default: false
      },
      "PoolBlockingPeriod": {
        type: SchemaTypes.NUMBER,
        default: 0,
        coerce(val) {
          if (typeof val !== "string") {
            return null;
          }
          switch (val.toLowerCase()) {
            case "alwaysblock":
              return 1;
            case "auto":
              return 0;
            case "neverblock":
              return 2;
          }
          return null;
        }
      },
      "Pooling": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "Replication": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Transaction Binding": {
        type: SchemaTypes.STRING,
        allowedValues: ["Implicit Unbind", "Explicit Unbind"],
        default: "Implicit Unbind"
      },
      "TransparentNetworkIPResolution": {
        type: SchemaTypes.BOOL,
        default: true
      },
      "TrustServerCertificate": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Type System Version": {
        type: SchemaTypes.STRING,
        allowedValues: ["SQL Server 2012", "SQL Server 2008", "SQL Server 2005", "Latest"]
      },
      "User ID": {
        type: SchemaTypes.STRING,
        aliases: ["UID"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      },
      "User Instance": {
        type: SchemaTypes.BOOL,
        default: false
      },
      "Workstation ID": {
        type: SchemaTypes.STRING,
        aliases: ["WSID"],
        validator(val) {
          return typeof val === "string" && val.length <= 128;
        }
      }
    };
    function guessType(value) {
      if (value.trim() === "") {
        return SchemaTypes.STRING;
      }
      const asNum = parseInt(value, 10);
      if (!Number.isNaN(asNum) && asNum.toString() === value) {
        return SchemaTypes.NUMBER;
      }
      if (["true", "false", "yes", "no"].includes(value.toLowerCase())) {
        return SchemaTypes.BOOL;
      }
      return SchemaTypes.STRING;
    }
    function coerce(value, type, coercer) {
      if (coercer) {
        const coerced = coercer(value);
        if (coerced !== null) {
          return coerced;
        }
      }
      switch (type) {
        case SchemaTypes.BOOL:
          if (["true", "yes", "1"].includes(value.toLowerCase())) {
            return true;
          }
          if (["false", "no", "0"].includes(value.toLowerCase())) {
            return false;
          }
          return value;
        case SchemaTypes.NUMBER:
          return parseInt(value, 10);
      }
      return value;
    }
    function validate2(value, allowedValues, validator) {
      let valid = true;
      if (validator) {
        valid = validator(value);
      }
      if (valid) {
        valid = (allowedValues === null || allowedValues === void 0 ? void 0 : allowedValues.includes(value)) || false;
      }
      return valid;
    }
    function parseSqlConnectionString(connectionString, canonicalProps = false, allowUnknown = false, strict = false, schema = exports2.SCHEMA) {
      const flattenedSchema = Object.entries(schema).reduce((flattened, [key, item]) => {
        var _a;
        Object.assign(flattened, {
          [key.toLowerCase()]: item
        });
        return ((_a = item.aliases) === null || _a === void 0 ? void 0 : _a.reduce((accum, alias) => {
          return Object.assign(accum, {
            [alias.toLowerCase()]: {
              ...item,
              canonical: key.toLowerCase()
            }
          });
        }, flattened)) || flattened;
      }, {});
      return Object.entries((0, connection_string_1.default)(connectionString)).reduce((config, [prop, value]) => {
        if (!Object.prototype.hasOwnProperty.call(flattenedSchema, prop)) {
          return Object.assign(config, {
            [prop]: coerce(value, guessType(value))
          });
        }
        let coercedValue = coerce(value, flattenedSchema[prop].type, flattenedSchema[prop].coerce);
        if (strict && !validate2(coercedValue, flattenedSchema[prop].allowedValues, flattenedSchema[prop].validator)) {
          coercedValue = flattenedSchema[prop].default;
        }
        const propName = canonicalProps ? flattenedSchema[prop].canonical || prop : prop;
        return Object.assign(config, {
          [propName]: coercedValue
        });
      }, {});
    }
    exports2.default = parseSqlConnectionString;
  }
});

// node_modules/@tediousjs/connection-string/lib/builder/index.js
var require_builder = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildConnectionString = void 0;
    function isQuoted(val) {
      if (val[0] !== "{") {
        return false;
      }
      for (let i = 1; i < val.length; i++) {
        if (val[i] === "}") {
          if (i + 1 === val.length) {
            return true;
          } else if (val[i + 1] !== "}") {
            return false;
          } else {
            i++;
          }
        }
      }
      return false;
    }
    function needsQuotes(val) {
      var _a;
      return !isQuoted(val) && !!((_a = val.match(/\[|]|{|}|\|\(|\)|,|;|\?|\*|=|!|@/)) === null || _a === void 0 ? void 0 : _a.length);
    }
    function encodeTuple(key, value) {
      if (value === null || value === void 0) {
        return [key, ""];
      }
      switch (typeof value) {
        case "boolean":
          return [key, value ? "Yes" : "No"];
        default: {
          const strVal = value.toString();
          if (needsQuotes(strVal)) {
            return [key, `{${strVal.replace(/}/g, "}}")}}`];
          }
          return [key, strVal];
        }
      }
    }
    function buildConnectionString(data) {
      return Object.entries(data).map(([key, value]) => {
        return encodeTuple(key.trim(), value).join("=");
      }).join(";");
    }
    exports2.buildConnectionString = buildConnectionString;
  }
});

// node_modules/@tediousjs/connection-string/lib/index.js
var require_lib = __commonJS({
  "node_modules/@tediousjs/connection-string/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSqlConnectionString = exports2.parseConnectionString = void 0;
    var connection_string_1 = __importDefault2(require_connection_string());
    exports2.parseConnectionString = connection_string_1.default;
    var sql_connection_string_1 = __importDefault2(require_sql_connection_string());
    exports2.parseSqlConnectionString = sql_connection_string_1.default;
    __exportStar2(require_builder(), exports2);
  }
});

// node_modules/tarn/dist/TimeoutError.js
var require_TimeoutError = __commonJS({
  "node_modules/tarn/dist/TimeoutError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TimeoutError = class extends Error {
    };
    exports2.TimeoutError = TimeoutError;
  }
});

// node_modules/tarn/dist/PromiseInspection.js
var require_PromiseInspection = __commonJS({
  "node_modules/tarn/dist/PromiseInspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PromiseInspection = class {
      constructor(args) {
        this._value = args.value;
        this._error = args.error;
      }
      value() {
        return this._value;
      }
      reason() {
        return this._error;
      }
      isRejected() {
        return !!this._error;
      }
      isFulfilled() {
        return !!this._value;
      }
    };
    exports2.PromiseInspection = PromiseInspection;
  }
});

// node_modules/tarn/dist/utils.js
var require_utils = __commonJS({
  "node_modules/tarn/dist/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PromiseInspection_1 = require_PromiseInspection();
    function defer() {
      let resolve = null;
      let reject = null;
      const promise = new Promise((resolver, rejecter) => {
        resolve = resolver;
        reject = rejecter;
      });
      return {
        promise,
        resolve,
        reject
      };
    }
    exports2.defer = defer;
    function now() {
      return Date.now();
    }
    exports2.now = now;
    function duration(t1, t2) {
      return Math.abs(t2 - t1);
    }
    exports2.duration = duration;
    function checkOptionalTime(time) {
      if (typeof time === "undefined") {
        return true;
      }
      return checkRequiredTime(time);
    }
    exports2.checkOptionalTime = checkOptionalTime;
    function checkRequiredTime(time) {
      return typeof time === "number" && time === Math.round(time) && time > 0;
    }
    exports2.checkRequiredTime = checkRequiredTime;
    function delay(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
    exports2.delay = delay;
    function reflect(promise) {
      return promise.then((value) => {
        return new PromiseInspection_1.PromiseInspection({ value });
      }).catch((error) => {
        return new PromiseInspection_1.PromiseInspection({ error });
      });
    }
    exports2.reflect = reflect;
    function tryPromise(cb) {
      try {
        const result = cb();
        return Promise.resolve(result);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    exports2.tryPromise = tryPromise;
  }
});

// node_modules/tarn/dist/PendingOperation.js
var require_PendingOperation = __commonJS({
  "node_modules/tarn/dist/PendingOperation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TimeoutError_1 = require_TimeoutError();
    var utils_1 = require_utils();
    var PendingOperation = class {
      constructor(timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
        this.deferred = utils_1.defer();
        this.possibleTimeoutCause = null;
        this.isRejected = false;
        this.promise = timeout(this.deferred.promise, timeoutMillis).catch((err) => {
          if (err instanceof TimeoutError_1.TimeoutError) {
            if (this.possibleTimeoutCause) {
              err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
            } else {
              err = new TimeoutError_1.TimeoutError("operation timed out for an unknown reason");
            }
          }
          this.isRejected = true;
          return Promise.reject(err);
        });
      }
      abort() {
        this.reject(new Error("aborted"));
      }
      reject(err) {
        this.deferred.reject(err);
      }
      resolve(value) {
        this.deferred.resolve(value);
      }
    };
    exports2.PendingOperation = PendingOperation;
    function timeout(promise, time) {
      return new Promise((resolve, reject) => {
        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time);
        promise.then((result) => {
          clearTimeout(timeoutHandle);
          resolve(result);
        }).catch((err) => {
          clearTimeout(timeoutHandle);
          reject(err);
        });
      });
    }
  }
});

// node_modules/tarn/dist/Resource.js
var require_Resource = __commonJS({
  "node_modules/tarn/dist/Resource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils();
    var Resource = class _Resource {
      constructor(resource) {
        this.resource = resource;
        this.resource = resource;
        this.timestamp = utils_1.now();
        this.deferred = utils_1.defer();
      }
      get promise() {
        return this.deferred.promise;
      }
      resolve() {
        this.deferred.resolve(void 0);
        return new _Resource(this.resource);
      }
    };
    exports2.Resource = Resource;
  }
});

// node_modules/tarn/dist/Pool.js
var require_Pool = __commonJS({
  "node_modules/tarn/dist/Pool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PendingOperation_1 = require_PendingOperation();
    var Resource_1 = require_Resource();
    var utils_1 = require_utils();
    var events_1 = require("events");
    var timers_1 = require("timers");
    var Pool = class {
      constructor(opt) {
        this.destroyed = false;
        this.emitter = new events_1.EventEmitter();
        opt = opt || {};
        if (!opt.create) {
          throw new Error("Tarn: opt.create function most be provided");
        }
        if (!opt.destroy) {
          throw new Error("Tarn: opt.destroy function most be provided");
        }
        if (typeof opt.min !== "number" || opt.min < 0 || opt.min !== Math.round(opt.min)) {
          throw new Error("Tarn: opt.min must be an integer >= 0");
        }
        if (typeof opt.max !== "number" || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
          throw new Error("Tarn: opt.max must be an integer > 0");
        }
        if (opt.min > opt.max) {
          throw new Error("Tarn: opt.max is smaller than opt.min");
        }
        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.acquireTimeoutMillis " + JSON.stringify(opt.acquireTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.createTimeoutMillis " + JSON.stringify(opt.createTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.destroyTimeoutMillis " + JSON.stringify(opt.destroyTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.idleTimeoutMillis " + JSON.stringify(opt.idleTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
          throw new Error("Tarn: invalid opt.reapIntervalMillis " + JSON.stringify(opt.reapIntervalMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
          throw new Error("Tarn: invalid opt.createRetryIntervalMillis " + JSON.stringify(opt.createRetryIntervalMillis));
        }
        const allowedKeys = {
          create: true,
          validate: true,
          destroy: true,
          log: true,
          min: true,
          max: true,
          acquireTimeoutMillis: true,
          createTimeoutMillis: true,
          destroyTimeoutMillis: true,
          idleTimeoutMillis: true,
          reapIntervalMillis: true,
          createRetryIntervalMillis: true,
          propagateCreateError: true
        };
        for (const key of Object.keys(opt)) {
          if (!allowedKeys[key]) {
            throw new Error(`Tarn: unsupported option opt.${key}`);
          }
        }
        this.creator = opt.create;
        this.destroyer = opt.destroy;
        this.validate = typeof opt.validate === "function" ? opt.validate : () => true;
        this.log = opt.log || (() => {
        });
        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 3e4;
        this.createTimeoutMillis = opt.createTimeoutMillis || 3e4;
        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5e3;
        this.idleTimeoutMillis = opt.idleTimeoutMillis || 3e4;
        this.reapIntervalMillis = opt.reapIntervalMillis || 1e3;
        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
        this.propagateCreateError = !!opt.propagateCreateError;
        this.min = opt.min;
        this.max = opt.max;
        this.used = [];
        this.free = [];
        this.pendingCreates = [];
        this.pendingAcquires = [];
        this.pendingDestroys = [];
        this.pendingValidations = [];
        this.destroyed = false;
        this.interval = null;
        this.eventId = 1;
      }
      numUsed() {
        return this.used.length;
      }
      numFree() {
        return this.free.length;
      }
      numPendingAcquires() {
        return this.pendingAcquires.length;
      }
      numPendingValidations() {
        return this.pendingValidations.length;
      }
      numPendingCreates() {
        return this.pendingCreates.length;
      }
      acquire() {
        const eventId = this.eventId++;
        this._executeEventHandlers("acquireRequest", eventId);
        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
        this.pendingAcquires.push(pendingAcquire);
        pendingAcquire.promise = pendingAcquire.promise.then((resource) => {
          this._executeEventHandlers("acquireSuccess", eventId, resource);
          return resource;
        }).catch((err) => {
          this._executeEventHandlers("acquireFail", eventId, err);
          remove(this.pendingAcquires, pendingAcquire);
          return Promise.reject(err);
        });
        this._tryAcquireOrCreate();
        return pendingAcquire;
      }
      release(resource) {
        this._executeEventHandlers("release", resource);
        for (let i = 0, l = this.used.length; i < l; ++i) {
          const used = this.used[i];
          if (used.resource === resource) {
            this.used.splice(i, 1);
            this.free.push(used.resolve());
            this._tryAcquireOrCreate();
            return true;
          }
        }
        return false;
      }
      isEmpty() {
        return [
          this.numFree(),
          this.numUsed(),
          this.numPendingAcquires(),
          this.numPendingValidations(),
          this.numPendingCreates()
        ].reduce((total, value) => total + value) === 0;
      }
      /**
       * Reaping cycle.
       */
      check() {
        const timestamp = utils_1.now();
        const newFree = [];
        const minKeep = this.min - this.used.length;
        const maxDestroy = this.free.length - minKeep;
        let numDestroyed = 0;
        this.free.forEach((free) => {
          if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {
            numDestroyed++;
            this._destroy(free.resource);
          } else {
            newFree.push(free);
          }
        });
        this.free = newFree;
        if (this.isEmpty()) {
          this._stopReaping();
        }
      }
      destroy() {
        const eventId = this.eventId++;
        this._executeEventHandlers("poolDestroyRequest", eventId);
        this._stopReaping();
        this.destroyed = true;
        return utils_1.reflect(Promise.all(this.pendingCreates.map((create) => utils_1.reflect(create.promise))).then(() => {
          return new Promise((resolve, reject) => {
            if (this.numPendingValidations() === 0) {
              resolve();
              return;
            }
            const interval = setInterval(() => {
              if (this.numPendingValidations() === 0) {
                timers_1.clearInterval(interval);
                resolve();
              }
            }, 100);
          });
        }).then(() => {
          return Promise.all(this.used.map((used) => utils_1.reflect(used.promise)));
        }).then(() => {
          return Promise.all(this.pendingAcquires.map((acquire) => {
            acquire.abort();
            return utils_1.reflect(acquire.promise);
          }));
        }).then(() => {
          return Promise.all(this.free.map((free) => utils_1.reflect(this._destroy(free.resource))));
        }).then(() => {
          return Promise.all(this.pendingDestroys.map((pd) => pd.promise));
        }).then(() => {
          this.free = [];
          this.pendingAcquires = [];
        })).then((res) => {
          this._executeEventHandlers("poolDestroySuccess", eventId);
          this.emitter.removeAllListeners();
          return res;
        });
      }
      on(event, listener) {
        this.emitter.on(event, listener);
      }
      removeListener(event, listener) {
        this.emitter.removeListener(event, listener);
      }
      removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
      }
      /**
       * The most important method that is called always when resources
       * are created / destroyed / acquired / released. In other words
       * every time when resources are moved from used to free or vice
       * versa.
       *
       * Either assigns free resources to pendingAcquires or creates new
       * resources if there is room for it in the pool.
       */
      _tryAcquireOrCreate() {
        if (this.destroyed) {
          return;
        }
        if (this._hasFreeResources()) {
          this._doAcquire();
        } else if (this._shouldCreateMoreResources()) {
          this._doCreate();
        }
      }
      _hasFreeResources() {
        return this.free.length > 0;
      }
      _doAcquire() {
        while (this._canAcquire()) {
          const pendingAcquire = this.pendingAcquires.shift();
          const free = this.free.pop();
          if (free === void 0 || pendingAcquire === void 0) {
            const errMessage = "this.free was empty while trying to acquire resource";
            this.log(`Tarn: ${errMessage}`, "warn");
            throw new Error(`Internal error, should never happen. ${errMessage}`);
          }
          this.pendingValidations.push(pendingAcquire);
          this.used.push(free);
          const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
          pendingAcquire.promise.catch((err) => {
            abortAbleValidation.abort();
          });
          abortAbleValidation.promise.catch((err) => {
            this.log("Tarn: resource validator threw an exception " + err.stack, "warn");
            return false;
          }).then((validationSuccess) => {
            try {
              if (validationSuccess && !pendingAcquire.isRejected) {
                this._startReaping();
                pendingAcquire.resolve(free.resource);
              } else {
                remove(this.used, free);
                if (!validationSuccess) {
                  this._destroy(free.resource);
                  setTimeout(() => {
                    this._tryAcquireOrCreate();
                  }, 0);
                } else {
                  this.free.push(free);
                }
                if (!pendingAcquire.isRejected) {
                  this.pendingAcquires.unshift(pendingAcquire);
                }
              }
            } finally {
              remove(this.pendingValidations, pendingAcquire);
            }
          });
          this._validateResource(free.resource).then((validationSuccess) => {
            abortAbleValidation.resolve(validationSuccess);
          }).catch((err) => {
            abortAbleValidation.reject(err);
          });
        }
      }
      _canAcquire() {
        return this.free.length > 0 && this.pendingAcquires.length > 0;
      }
      _validateResource(resource) {
        try {
          return Promise.resolve(this.validate(resource));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _shouldCreateMoreResources() {
        return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;
      }
      _doCreate() {
        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
        const pendingCreate = this._create();
        pendingCreate.promise.then(() => {
          this._tryAcquireOrCreate();
          return null;
        }).catch((err) => {
          if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
            this.pendingAcquires[0].reject(err);
          }
          pendingAcquiresBeforeCreate.forEach((pendingAcquire) => {
            pendingAcquire.possibleTimeoutCause = err;
          });
          utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
        });
      }
      _create() {
        const eventId = this.eventId++;
        this._executeEventHandlers("createRequest", eventId);
        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
        pendingCreate.promise = pendingCreate.promise.catch((err) => {
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          throw err;
        });
        this.pendingCreates.push(pendingCreate);
        callbackOrPromise(this.creator).then((resource) => {
          if (pendingCreate.isRejected) {
            this.destroyer(resource);
            return null;
          }
          remove(this.pendingCreates, pendingCreate);
          this.free.push(new Resource_1.Resource(resource));
          pendingCreate.resolve(resource);
          this._executeEventHandlers("createSuccess", eventId, resource);
          return null;
        }).catch((err) => {
          if (pendingCreate.isRejected) {
            return null;
          }
          if (remove(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          pendingCreate.reject(err);
          return null;
        });
        return pendingCreate;
      }
      _destroy(resource) {
        const eventId = this.eventId++;
        this._executeEventHandlers("destroyRequest", eventId, resource);
        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
        const retVal = Promise.resolve().then(() => this.destroyer(resource));
        retVal.then(() => {
          pendingDestroy.resolve(resource);
        }).catch((err) => {
          pendingDestroy.reject(err);
        });
        this.pendingDestroys.push(pendingDestroy);
        return pendingDestroy.promise.then((res) => {
          this._executeEventHandlers("destroySuccess", eventId, resource);
          return res;
        }).catch((err) => this._logDestroyerError(eventId, resource, err)).then((res) => {
          const index = this.pendingDestroys.findIndex((pd) => pd === pendingDestroy);
          this.pendingDestroys.splice(index, 1);
          return res;
        });
      }
      _logDestroyerError(eventId, resource, err) {
        this._executeEventHandlers("destroyFail", eventId, resource, err);
        this.log("Tarn: resource destroyer threw an exception " + err.stack, "warn");
      }
      _startReaping() {
        if (!this.interval) {
          this._executeEventHandlers("startReaping");
          this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
        }
      }
      _stopReaping() {
        if (this.interval !== null) {
          this._executeEventHandlers("stopReaping");
          timers_1.clearInterval(this.interval);
        }
        this.interval = null;
      }
      _executeEventHandlers(eventName, ...args) {
        const listeners = this.emitter.listeners(eventName);
        listeners.forEach((listener) => {
          try {
            listener(...args);
          } catch (err) {
            this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, "warn");
          }
        });
      }
    };
    exports2.Pool = Pool;
    function remove(arr, item) {
      const idx = arr.indexOf(item);
      if (idx === -1) {
        return false;
      } else {
        arr.splice(idx, 1);
        return true;
      }
    }
    function callbackOrPromise(func) {
      return new Promise((resolve, reject) => {
        const callback = (err, resource) => {
          if (err) {
            reject(err);
          } else {
            resolve(resource);
          }
        };
        utils_1.tryPromise(() => func(callback)).then((res) => {
          if (res) {
            resolve(res);
          }
        }).catch((err) => {
          reject(err);
        });
      });
    }
  }
});

// node_modules/tarn/dist/tarn.js
var require_tarn = __commonJS({
  "node_modules/tarn/dist/tarn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Pool_1 = require_Pool();
    exports2.Pool = Pool_1.Pool;
    var TimeoutError_1 = require_TimeoutError();
    exports2.TimeoutError = TimeoutError_1.TimeoutError;
    module2.exports = {
      Pool: Pool_1.Pool,
      TimeoutError: TimeoutError_1.TimeoutError
    };
  }
});

// node_modules/mssql/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/mssql/lib/utils.js"(exports2, module2) {
    var IDS = /* @__PURE__ */ new WeakMap();
    var INCREMENT = {
      Connection: 1,
      ConnectionPool: 1,
      Request: 1,
      Transaction: 1,
      PreparedStatement: 1
    };
    module2.exports = {
      objectHasProperty: (object, property) => Object.prototype.hasOwnProperty.call(object, property),
      INCREMENT,
      IDS: {
        get: IDS.get.bind(IDS),
        add: (object, type, id) => {
          if (id)
            return IDS.set(object, id);
          IDS.set(object, INCREMENT[type]++);
        }
      }
    };
  }
});

// node_modules/mssql/lib/error/mssql-error.js
var require_mssql_error = __commonJS({
  "node_modules/mssql/lib/error/mssql-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = class extends Error {
      /**
       * Creates a new ConnectionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        if (message instanceof Error) {
          super(message.message);
          this.code = message.code || code;
          Error.captureStackTrace(this, this.constructor);
          Object.defineProperty(this, "originalError", { enumerable: true, value: message });
        } else {
          super(message);
          this.code = code;
        }
        this.name = "MSSQLError";
      }
    };
    module2.exports = MSSQLError;
  }
});

// node_modules/mssql/lib/error/connection-error.js
var require_connection_error = __commonJS({
  "node_modules/mssql/lib/error/connection-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var ConnectionError = class extends MSSQLError {
      /**
       * Creates a new ConnectionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "ConnectionError";
      }
    };
    module2.exports = ConnectionError;
  }
});

// node_modules/mssql/lib/datatypes.js
var require_datatypes = __commonJS({
  "node_modules/mssql/lib/datatypes.js"(exports2, module2) {
    "use strict";
    var objectHasProperty = require_utils2().objectHasProperty;
    var inspect = Symbol.for("nodejs.util.inspect.custom");
    var TYPES = {
      VarChar(length) {
        return { type: TYPES.VarChar, length };
      },
      NVarChar(length) {
        return { type: TYPES.NVarChar, length };
      },
      Text() {
        return { type: TYPES.Text };
      },
      Int() {
        return { type: TYPES.Int };
      },
      BigInt() {
        return { type: TYPES.BigInt };
      },
      TinyInt() {
        return { type: TYPES.TinyInt };
      },
      SmallInt() {
        return { type: TYPES.SmallInt };
      },
      Bit() {
        return { type: TYPES.Bit };
      },
      Float() {
        return { type: TYPES.Float };
      },
      Numeric(precision, scale) {
        return { type: TYPES.Numeric, precision, scale };
      },
      Decimal(precision, scale) {
        return { type: TYPES.Decimal, precision, scale };
      },
      Real() {
        return { type: TYPES.Real };
      },
      Date() {
        return { type: TYPES.Date };
      },
      DateTime() {
        return { type: TYPES.DateTime };
      },
      DateTime2(scale) {
        return { type: TYPES.DateTime2, scale };
      },
      DateTimeOffset(scale) {
        return { type: TYPES.DateTimeOffset, scale };
      },
      SmallDateTime() {
        return { type: TYPES.SmallDateTime };
      },
      Time(scale) {
        return { type: TYPES.Time, scale };
      },
      UniqueIdentifier() {
        return { type: TYPES.UniqueIdentifier };
      },
      SmallMoney() {
        return { type: TYPES.SmallMoney };
      },
      Money() {
        return { type: TYPES.Money };
      },
      Binary(length) {
        return { type: TYPES.Binary, length };
      },
      VarBinary(length) {
        return { type: TYPES.VarBinary, length };
      },
      Image() {
        return { type: TYPES.Image };
      },
      Xml() {
        return { type: TYPES.Xml };
      },
      Char(length) {
        return { type: TYPES.Char, length };
      },
      NChar(length) {
        return { type: TYPES.NChar, length };
      },
      NText() {
        return { type: TYPES.NText };
      },
      TVP(tvpType) {
        return { type: TYPES.TVP, tvpType };
      },
      UDT() {
        return { type: TYPES.UDT };
      },
      Geography() {
        return { type: TYPES.Geography };
      },
      Geometry() {
        return { type: TYPES.Geometry };
      },
      Variant() {
        return { type: TYPES.Variant };
      }
    };
    module2.exports.TYPES = TYPES;
    module2.exports.DECLARATIONS = {};
    var zero = function(value, length) {
      if (length == null)
        length = 2;
      value = String(value);
      if (value.length < length) {
        for (let i = 1; i <= length - value.length; i++) {
          value = `0${value}`;
        }
      }
      return value;
    };
    for (const key in TYPES) {
      if (objectHasProperty(TYPES, key)) {
        const value = TYPES[key];
        value.declaration = key.toLowerCase();
        module2.exports.DECLARATIONS[value.declaration] = value;
        ((key2, value2) => {
          value2[inspect] = () => `[sql.${key2}]`;
        })(key, value);
      }
    }
    module2.exports.declare = (type, options) => {
      switch (type) {
        case TYPES.VarChar:
        case TYPES.VarBinary:
          return `${type.declaration} (${options.length > 8e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
        case TYPES.NVarChar:
          return `${type.declaration} (${options.length > 4e3 ? "MAX" : options.length == null ? "MAX" : options.length})`;
        case TYPES.Char:
        case TYPES.NChar:
        case TYPES.Binary:
          return `${type.declaration} (${options.length == null ? 1 : options.length})`;
        case TYPES.Decimal:
        case TYPES.Numeric:
          return `${type.declaration} (${options.precision == null ? 18 : options.precision}, ${options.scale == null ? 0 : options.scale})`;
        case TYPES.Time:
        case TYPES.DateTime2:
        case TYPES.DateTimeOffset:
          return `${type.declaration} (${options.scale == null ? 7 : options.scale})`;
        case TYPES.TVP:
          return `${options.tvpType} readonly`;
        default:
          return type.declaration;
      }
    };
    module2.exports.cast = (value, type, options) => {
      if (value == null) {
        return null;
      }
      switch (typeof value) {
        case "string":
          return `N'${value.replace(/'/g, "''")}'`;
        case "number":
        case "bigint":
          return value;
        case "boolean":
          return value ? 1 : 0;
        case "object":
          if (value instanceof Date) {
            let ns = value.getUTCMilliseconds() / 1e3;
            if (value.nanosecondDelta != null) {
              ns += value.nanosecondDelta;
            }
            const scale = options.scale == null ? 7 : options.scale;
            if (scale > 0) {
              ns = String(ns).substr(1, scale + 1);
            } else {
              ns = "";
            }
            return `N'${value.getUTCFullYear()}-${zero(value.getUTCMonth() + 1)}-${zero(value.getUTCDate())} ${zero(value.getUTCHours())}:${zero(value.getUTCMinutes())}:${zero(value.getUTCSeconds())}${ns}'`;
          } else if (Buffer.isBuffer(value)) {
            return `0x${value.toString("hex")}`;
          }
          return null;
        default:
          return null;
      }
    };
  }
});

// node_modules/mssql/lib/table.js
var require_table = __commonJS({
  "node_modules/mssql/lib/table.js"(exports2, module2) {
    "use strict";
    var TYPES = require_datatypes().TYPES;
    var declareType = require_datatypes().declare;
    var objectHasProperty = require_utils2().objectHasProperty;
    var MAX = 65535;
    var JSON_COLUMN_ID = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
    function Table(name) {
      if (name) {
        const parsed = Table.parseName(name);
        this.name = parsed.name;
        this.schema = parsed.schema;
        this.database = parsed.database;
        this.path = (this.database ? `[${this.database}].` : "") + (this.schema ? `[${this.schema}].` : "") + `[${this.name}]`;
        this.temporary = this.name.charAt(0) === "#";
      }
      this.columns = [];
      this.rows = [];
      Object.defineProperty(this.columns, "add", {
        value(name2, column, options) {
          if (column == null) {
            throw new Error("Column data type is not defined.");
          }
          if (column instanceof Function) {
            column = column();
          }
          options = options || {};
          column.name = name2;
          ["nullable", "primary", "identity", "readOnly", "length"].forEach((prop) => {
            if (objectHasProperty(options, prop)) {
              column[prop] = options[prop];
            }
          });
          return this.push(column);
        }
      });
      Object.defineProperty(
        this.rows,
        "add",
        {
          value() {
            return this.push(Array.prototype.slice.call(arguments));
          }
        }
      );
      Object.defineProperty(
        this.rows,
        "clear",
        {
          value() {
            return this.splice(0, this.length);
          }
        }
      );
    }
    Table.prototype._makeBulk = function _makeBulk() {
      for (let i = 0; i < this.columns.length; i++) {
        const col = this.columns[i];
        switch (col.type) {
          case TYPES.Date:
          case TYPES.DateTime:
          case TYPES.DateTime2:
            for (let j = 0; j < this.rows.length; j++) {
              const dateValue = this.rows[j][i];
              if (typeof dateValue === "string" || typeof dateValue === "number") {
                const date = new Date(dateValue);
                if (isNaN(date.getDate())) {
                  throw new TypeError("Invalid date value passed to bulk rows");
                }
                this.rows[j][i] = date;
              }
            }
            break;
          case TYPES.Xml:
            col.type = TYPES.NVarChar(MAX).type;
            break;
          case TYPES.UDT:
          case TYPES.Geography:
          case TYPES.Geometry:
            col.type = TYPES.VarBinary(MAX).type;
            break;
          default:
            break;
        }
      }
      return this;
    };
    Table.prototype.declare = function declare() {
      const pkey = this.columns.filter((col) => col.primary === true).map((col) => `[${col.name}]`);
      const cols = this.columns.map((col) => {
        const def = [`[${col.name}] ${declareType(col.type, col)}`];
        if (col.nullable === true) {
          def.push("null");
        } else if (col.nullable === false) {
          def.push("not null");
        }
        if (col.primary === true && pkey.length === 1) {
          def.push("primary key");
        }
        return def.join(" ");
      });
      const constraint = pkey.length > 1 ? `, constraint [PK_${this.temporary ? this.name.substr(1) : this.name}] primary key (${pkey.join(", ")})` : "";
      return `create table ${this.path} (${cols.join(", ")}${constraint})`;
    };
    Table.fromRecordset = function fromRecordset(recordset, name) {
      const t = new this(name);
      for (const colName in recordset.columns) {
        if (objectHasProperty(recordset.columns, colName)) {
          const col = recordset.columns[colName];
          t.columns.add(colName, {
            type: col.type,
            length: col.length,
            scale: col.scale,
            precision: col.precision
          }, {
            nullable: col.nullable,
            identity: col.identity,
            readOnly: col.readOnly
          });
        }
      }
      if (t.columns.length === 1 && t.columns[0].name === JSON_COLUMN_ID) {
        for (let i = 0; i < recordset.length; i++) {
          t.rows.add(JSON.stringify(recordset[i]));
        }
      } else {
        for (let i = 0; i < recordset.length; i++) {
          t.rows.add.apply(t.rows, t.columns.map((col) => recordset[i][col.name]));
        }
      }
      return t;
    };
    Table.parseName = function parseName(name) {
      const length = name.length;
      let cursor = -1;
      let buffer = "";
      let escaped = false;
      const path2 = [];
      while (++cursor < length) {
        const char = name.charAt(cursor);
        if (char === "[") {
          if (escaped) {
            buffer += char;
          } else {
            escaped = true;
          }
        } else if (char === "]") {
          if (escaped) {
            escaped = false;
          } else {
            throw new Error("Invalid table name.");
          }
        } else if (char === ".") {
          if (escaped) {
            buffer += char;
          } else {
            path2.push(buffer);
            buffer = "";
          }
        } else {
          buffer += char;
        }
      }
      if (buffer) {
        path2.push(buffer);
      }
      switch (path2.length) {
        case 1:
          return {
            name: path2[0],
            schema: null,
            database: null
          };
        case 2:
          return {
            name: path2[1],
            schema: path2[0],
            database: null
          };
        case 3:
          return {
            name: path2[2],
            schema: path2[1],
            database: path2[0]
          };
        default:
          throw new Error("Invalid table name.");
      }
    };
    module2.exports = Table;
  }
});

// node_modules/mssql/lib/shared.js
var require_shared = __commonJS({
  "node_modules/mssql/lib/shared.js"(exports2, module2) {
    "use strict";
    var TYPES = require_datatypes().TYPES;
    var Table = require_table();
    var PromiseLibrary = Promise;
    var driver = {};
    var map = [];
    map.register = function(jstype, sqltype) {
      for (let index = 0; index < this.length; index++) {
        const item = this[index];
        if (item.js === jstype) {
          this.splice(index, 1);
          break;
        }
      }
      this.push({
        js: jstype,
        sql: sqltype
      });
      return null;
    };
    map.register(String, TYPES.NVarChar);
    map.register(Number, TYPES.Int);
    map.register(Boolean, TYPES.Bit);
    map.register(Date, TYPES.DateTime);
    map.register(Buffer, TYPES.VarBinary);
    map.register(Table, TYPES.TVP);
    var getTypeByValue = function(value) {
      if (value === null || value === void 0) {
        return TYPES.NVarChar;
      }
      switch (typeof value) {
        case "string":
          for (const item of Array.from(map)) {
            if (item.js === String) {
              return item.sql;
            }
          }
          return TYPES.NVarChar;
        case "number":
          if (value % 1 === 0) {
            if (value < -2147483648 || value > 2147483647) {
              return TYPES.BigInt;
            } else {
              return TYPES.Int;
            }
          } else {
            return TYPES.Float;
          }
        case "bigint":
          if (value < -2147483648n || value > 2147483647n) {
            return TYPES.BigInt;
          } else {
            return TYPES.Int;
          }
        case "boolean":
          for (const item of Array.from(map)) {
            if (item.js === Boolean) {
              return item.sql;
            }
          }
          return TYPES.Bit;
        case "object":
          for (const item of Array.from(map)) {
            if (value instanceof item.js) {
              return item.sql;
            }
          }
          return TYPES.NVarChar;
        default:
          return TYPES.NVarChar;
      }
    };
    module2.exports = {
      driver,
      getTypeByValue,
      map
    };
    Object.defineProperty(module2.exports, "Promise", {
      get: () => {
        return PromiseLibrary;
      },
      set: (value) => {
        PromiseLibrary = value;
      }
    });
    Object.defineProperty(module2.exports, "valueHandler", {
      enumerable: true,
      value: /* @__PURE__ */ new Map(),
      writable: false,
      configurable: false
    });
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            const index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/rfdc/default.js
var require_default = __commonJS({
  "node_modules/rfdc/default.js"(exports2, module2) {
    "use strict";
    module2.exports = require_rfdc()();
  }
});

// node_modules/mssql/lib/error/prepared-statement-error.js
var require_prepared_statement_error = __commonJS({
  "node_modules/mssql/lib/error/prepared-statement-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var PreparedStatementError = class extends MSSQLError {
      /**
       * Creates a new PreparedStatementError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "PreparedStatementError";
      }
    };
    module2.exports = PreparedStatementError;
  }
});

// node_modules/mssql/lib/error/request-error.js
var require_request_error = __commonJS({
  "node_modules/mssql/lib/error/request-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var RequestError = class extends MSSQLError {
      /**
       * Creates a new RequestError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        if (message instanceof Error) {
          if (message.info) {
            this.number = message.info.number || message.code;
            this.lineNumber = message.info.lineNumber;
            this.state = message.info.state || message.sqlstate;
            this.class = message.info.class;
            this.serverName = message.info.serverName;
            this.procName = message.info.procName;
          } else {
            this.number = message.code;
            this.lineNumber = message.lineNumber;
            this.state = message.sqlstate;
            this.class = message.severity;
            this.serverName = message.serverName;
            this.procName = message.procName;
          }
        }
        this.name = "RequestError";
        const parsedMessage = /^\[Microsoft\]\[SQL Server Native Client 11\.0\](?:\[SQL Server\])?([\s\S]*)$/.exec(this.message);
        if (parsedMessage) {
          this.message = parsedMessage[1];
        }
      }
    };
    module2.exports = RequestError;
  }
});

// node_modules/mssql/lib/error/transaction-error.js
var require_transaction_error = __commonJS({
  "node_modules/mssql/lib/error/transaction-error.js"(exports2, module2) {
    "use strict";
    var MSSQLError = require_mssql_error();
    var TransactionError = class extends MSSQLError {
      /**
       * Creates a new TransactionError.
       *
       * @param {String} message Error message.
       * @param {String} [code] Error code.
       */
      constructor(message, code) {
        super(message, code);
        this.name = "TransactionError";
      }
    };
    module2.exports = TransactionError;
  }
});

// node_modules/mssql/lib/error/index.js
var require_error = __commonJS({
  "node_modules/mssql/lib/error/index.js"(exports2, module2) {
    "use strict";
    var ConnectionError = require_connection_error();
    var MSSQLError = require_mssql_error();
    var PreparedStatementError = require_prepared_statement_error();
    var RequestError = require_request_error();
    var TransactionError = require_transaction_error();
    module2.exports = {
      ConnectionError,
      MSSQLError,
      PreparedStatementError,
      RequestError,
      TransactionError
    };
  }
});

// node_modules/mssql/lib/base/connection-pool.js
var require_connection_pool = __commonJS({
  "node_modules/mssql/lib/base/connection-pool.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("node:events");
    var debug = require_src()("mssql:base");
    var { parseSqlConnectionString } = require_lib();
    var tarn = require_tarn();
    var { IDS } = require_utils2();
    var ConnectionError = require_connection_error();
    var shared = require_shared();
    var clone = require_default();
    var { MSSQLError } = require_error();
    var ConnectionPool2 = class extends EventEmitter {
      /**
       * Create new Connection.
       *
       * @param {Object|String} config Connection configuration object or connection string.
       * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.
       */
      constructor(config, callback) {
        super();
        IDS.add(this, "ConnectionPool");
        debug("pool(%d): created", IDS.get(this));
        this._connectStack = [];
        this._closeStack = [];
        this._connected = false;
        this._connecting = false;
        this._healthy = false;
        if (typeof config === "string") {
          try {
            this.config = this.constructor.parseConnectionString(config);
          } catch (ex) {
            if (typeof callback === "function") {
              return setImmediate(callback, ex);
            }
            throw ex;
          }
        } else {
          this.config = clone(config);
        }
        this.config.port = this.config.port || 1433;
        this.config.options = this.config.options || {};
        this.config.stream = this.config.stream || false;
        this.config.parseJSON = this.config.parseJSON || false;
        this.config.arrayRowMode = this.config.arrayRowMode || false;
        this.config.validateConnection = "validateConnection" in this.config ? this.config.validateConnection : true;
        const namedServer = /^(.*)\\(.*)$/.exec(this.config.server);
        if (namedServer) {
          this.config.server = namedServer[1];
          this.config.options.instanceName = namedServer[2];
        }
        if (typeof this.config.options.useColumnNames !== "undefined" && this.config.options.useColumnNames !== true) {
          const ex = new MSSQLError("Invalid options `useColumnNames`, use `arrayRowMode` instead");
          if (typeof callback === "function") {
            return setImmediate(callback, ex);
          }
          throw ex;
        }
        if (typeof callback === "function") {
          this.connect(callback);
        }
      }
      get connected() {
        return this._connected;
      }
      get connecting() {
        return this._connecting;
      }
      get healthy() {
        return this._healthy;
      }
      static parseConnectionString(connectionString) {
        return this._parseConnectionString(connectionString);
      }
      static _parseAuthenticationType(type, entries) {
        switch (type.toLowerCase()) {
          case "active directory integrated":
            if (entries.includes("token")) {
              return "azure-active-directory-access-token";
            } else if (["client id", "client secret", "tenant id"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-service-principal-secret";
            } else if (["client id", "msi endpoint", "msi secret"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-msi-app-service";
            } else if (["client id", "msi endpoint"].every((entry) => entries.includes(entry))) {
              return "azure-active-directory-msi-vm";
            }
            return "azure-active-directory-default";
          case "active directory password":
            return "azure-active-directory-password";
          case "ntlm":
            return "ntlm";
          default:
            return "default";
        }
      }
      static _parseConnectionString(connectionString) {
        const parsed = parseSqlConnectionString(connectionString, true, true);
        return Object.entries(parsed).reduce((config, [key, value]) => {
          switch (key) {
            case "application name":
              break;
            case "applicationintent":
              Object.assign(config.options, {
                readOnlyIntent: value === "readonly"
              });
              break;
            case "asynchronous processing":
              break;
            case "attachdbfilename":
              break;
            case "authentication":
              Object.assign(config, {
                authentication_type: this._parseAuthenticationType(value, Object.keys(parsed))
              });
              break;
            case "column encryption setting":
              break;
            case "connection timeout":
              Object.assign(config, {
                connectionTimeout: value * 1e3
              });
              break;
            case "connection lifetime":
              break;
            case "connectretrycount":
              break;
            case "connectretryinterval":
              Object.assign(config.options, {
                connectionRetryInterval: value * 1e3
              });
              break;
            case "context connection":
              break;
            case "client id":
              Object.assign(config, {
                clientId: value
              });
              break;
            case "client secret":
              Object.assign(config, {
                clientSecret: value
              });
              break;
            case "current language":
              Object.assign(config.options, {
                language: value
              });
              break;
            case "data source": {
              let server = value;
              let instanceName;
              let port = 1433;
              if (/^np:/i.test(server)) {
                throw new Error("Connection via Named Pipes is not supported.");
              }
              if (/^tcp:/i.test(server)) {
                server = server.substr(4);
              }
              const namedServerParts = /^(.*)\\(.*)$/.exec(server);
              if (namedServerParts) {
                server = namedServerParts[1].trim();
                instanceName = namedServerParts[2].trim();
              }
              const serverParts = /^(.*),(.*)$/.exec(server);
              if (serverParts) {
                server = serverParts[1].trim();
                port = parseInt(serverParts[2].trim(), 10);
              } else {
                const instanceParts = /^(.*),(.*)$/.exec(instanceName);
                if (instanceParts) {
                  instanceName = instanceParts[1].trim();
                  port = parseInt(instanceParts[2].trim(), 10);
                }
              }
              if (server === "." || server === "(.)" || server.toLowerCase() === "(localdb)" || server.toLowerCase() === "(local)") {
                server = "localhost";
              }
              Object.assign(config, {
                port,
                server
              });
              if (instanceName) {
                Object.assign(config.options, {
                  instanceName
                });
              }
              break;
            }
            case "encrypt":
              Object.assign(config.options, {
                encrypt: !!value
              });
              break;
            case "enlist":
              break;
            case "failover partner":
              break;
            case "initial catalog":
              Object.assign(config, {
                database: value
              });
              break;
            case "integrated security":
              break;
            case "max pool size":
              Object.assign(config.pool, {
                max: value
              });
              break;
            case "min pool size":
              Object.assign(config.pool, {
                min: value
              });
              break;
            case "msi endpoint":
              Object.assign(config, {
                msiEndpoint: value
              });
              break;
            case "msi secret":
              Object.assign(config, {
                msiSecret: value
              });
              break;
            case "multipleactiveresultsets":
              break;
            case "multisubnetfailover":
              Object.assign(config.options, {
                multiSubnetFailover: value
              });
              break;
            case "network library":
              break;
            case "packet size":
              Object.assign(config.options, {
                packetSize: value
              });
              break;
            case "password":
              Object.assign(config, {
                password: value
              });
              break;
            case "persist security info":
              break;
            case "poolblockingperiod":
              break;
            case "pooling":
              break;
            case "replication":
              break;
            case "tenant id":
              Object.assign(config, {
                tenantId: value
              });
              break;
            case "token":
              Object.assign(config, {
                token: value
              });
              break;
            case "transaction binding":
              Object.assign(config.options, {
                enableImplicitTransactions: value.toLowerCase() === "implicit unbind"
              });
              break;
            case "transparentnetworkipresolution":
              break;
            case "trustservercertificate":
              Object.assign(config.options, {
                trustServerCertificate: value
              });
              break;
            case "type system version":
              break;
            case "user id": {
              let user = value;
              let domain;
              const domainUser = /^(.*)\\(.*)$/.exec(user);
              if (domainUser) {
                domain = domainUser[1];
                user = domainUser[2];
              }
              if (domain) {
                Object.assign(config, {
                  domain
                });
              }
              if (user) {
                Object.assign(config, {
                  user
                });
              }
              break;
            }
            case "user instance":
              break;
            case "workstation id":
              Object.assign(config.options, {
                workstationId: value
              });
              break;
            case "request timeout":
              Object.assign(config, {
                requestTimeout: parseInt(value, 10)
              });
              break;
            case "stream":
              Object.assign(config, {
                stream: !!value
              });
              break;
            case "useutc":
              Object.assign(config.options, {
                useUTC: !!value
              });
              break;
            case "parsejson":
              Object.assign(config, {
                parseJSON: !!value
              });
              break;
          }
          return config;
        }, { options: {}, pool: {} });
      }
      /**
       * Acquire connection from this connection pool.
       *
       * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.
       * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      acquire(requester, callback) {
        const acquirePromise = shared.Promise.resolve(this._acquire()).catch((err) => {
          this.emit("error", err);
          throw err;
        });
        if (typeof callback === "function") {
          acquirePromise.then((connection) => callback(null, connection, this.config)).catch(callback);
          return this;
        }
        return acquirePromise;
      }
      _acquire() {
        if (!this.pool) {
          return shared.Promise.reject(new ConnectionError("Connection not yet open.", "ENOTOPEN"));
        } else if (this.pool.destroyed) {
          return shared.Promise.reject(new ConnectionError("Connection is closing", "ENOTOPEN"));
        }
        return this.pool.acquire().promise;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {ConnectionPool}
       */
      release(connection) {
        debug("connection(%d): released", IDS.get(connection));
        if (this.pool) {
          this.pool.release(connection);
        }
        return this;
      }
      /**
       * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.
       *
       * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      connect(callback) {
        if (typeof callback === "function") {
          this._connect(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          return this._connect((err) => {
            if (err)
              return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _connect(callback) {
        if (this._connected) {
          debug("pool(%d): already connected, executing connect callback immediately", IDS.get(this));
          return setImmediate(callback, null, this);
        }
        this._connectStack.push(callback);
        if (this._connecting) {
          return;
        }
        this._connecting = true;
        debug("pool(%d): connecting", IDS.get(this));
        this._poolCreate().then((connection) => {
          debug("pool(%d): connected", IDS.get(this));
          this._healthy = true;
          return this._poolDestroy(connection).then(() => {
            this.pool = new tarn.Pool(
              Object.assign({
                create: () => this._poolCreate().then((connection2) => {
                  this._healthy = true;
                  return connection2;
                }).catch((err) => {
                  if (this.pool.numUsed() + this.pool.numFree() <= 0) {
                    this._healthy = false;
                  }
                  throw err;
                }),
                validate: this._poolValidate.bind(this),
                destroy: this._poolDestroy.bind(this),
                max: 10,
                min: 0,
                idleTimeoutMillis: 3e4,
                propagateCreateError: true
              }, this.config.pool)
            );
            this._connecting = false;
            this._connected = true;
          });
        }).then(() => {
          this._connectStack.forEach((cb) => {
            setImmediate(cb, null, this);
          });
        }).catch((err) => {
          this._connecting = false;
          this._connectStack.forEach((cb) => {
            setImmediate(cb, err);
          });
        }).then(() => {
          this._connectStack = [];
        });
      }
      get size() {
        return this.pool.numFree() + this.pool.numUsed() + this.pool.numPendingCreates();
      }
      get available() {
        return this.pool.numFree();
      }
      get pending() {
        return this.pool.numPendingAcquires();
      }
      get borrowed() {
        return this.pool.numUsed();
      }
      /**
       * Close all active connections in the pool.
       *
       * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.
       * @return {ConnectionPool|Promise}
       */
      close(callback) {
        if (typeof callback === "function") {
          this._close(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._close((err) => {
            if (err)
              return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _close(callback) {
        if (this._connecting) {
          debug("pool(%d): close called while connecting", IDS.get(this));
          setImmediate(callback, new ConnectionError("Cannot close a pool while it is connecting"));
        }
        if (!this.pool) {
          debug("pool(%d): already closed, executing close callback immediately", IDS.get(this));
          return setImmediate(callback, null);
        }
        this._closeStack.push(callback);
        if (this.pool.destroyed)
          return;
        this._connecting = this._connected = this._healthy = false;
        this.pool.destroy().then(() => {
          debug("pool(%d): pool closed, removing pool reference and executing close callbacks", IDS.get(this));
          this.pool = null;
          this._closeStack.forEach((cb) => {
            setImmediate(cb, null);
          });
        }).catch((err) => {
          this.pool = null;
          this._closeStack.forEach((cb) => {
            setImmediate(cb, err);
          });
        }).then(() => {
          this._closeStack = [];
        });
      }
      /**
       * Returns new request using this connection.
       *
       * @return {Request}
       */
      request() {
        return new shared.driver.Request(this);
      }
      /**
       * Returns new transaction using this connection.
       *
       * @return {Transaction}
       */
      transaction() {
        return new shared.driver.Transaction(this);
      }
      /**
       * Creates a new query using this connection from a tagged template string.
       *
       * @variation 1
       * @param {Array} strings Array of string literals.
       * @param {...*} keys Values.
       * @return {Request}
       */
      /**
       * Execute the SQL command.
       *
       * @variation 2
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      query() {
        if (typeof arguments[0] === "string") {
          return new shared.driver.Request(this).query(arguments[0], arguments[1]);
        }
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return new shared.driver.Request(this)._template(strings, values, "query");
      }
      /**
       * Creates a new batch using this connection from a tagged template string.
       *
       * @variation 1
       * @param {Array} strings Array of string literals.
       * @param {...*} keys Values.
       * @return {Request}
       */
      /**
       * Execute the SQL command.
       *
       * @variation 2
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      batch() {
        if (typeof arguments[0] === "string") {
          return new shared.driver.Request(this).batch(arguments[0], arguments[1]);
        }
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return new shared.driver.Request(this)._template(strings, values, "batch");
      }
    };
    module2.exports = ConnectionPool2;
  }
});

// node_modules/mssql/lib/global-connection.js
var require_global_connection = __commonJS({
  "node_modules/mssql/lib/global-connection.js"(exports2, module2) {
    "use strict";
    var shared = require_shared();
    var globalConnection = null;
    var globalConnectionHandlers = {};
    function connect(config, callback) {
      if (!globalConnection) {
        globalConnection = new shared.driver.ConnectionPool(config);
        for (const event in globalConnectionHandlers) {
          for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
            globalConnection.on(event, globalConnectionHandlers[event][i]);
          }
        }
        const ogClose = globalConnection.close;
        const globalClose = function(callback2) {
          for (const event in globalConnectionHandlers) {
            for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
              this.removeListener(event, globalConnectionHandlers[event][i]);
            }
          }
          this.on("error", (err) => {
            if (globalConnectionHandlers.error) {
              for (let i = 0, l = globalConnectionHandlers.error.length; i < l; i++) {
                globalConnectionHandlers.error[i].call(this, err);
              }
            }
          });
          globalConnection = null;
          return ogClose.call(this, callback2);
        };
        globalConnection.close = globalClose.bind(globalConnection);
      }
      if (typeof callback === "function") {
        return globalConnection.connect((err, connection) => {
          if (err) {
            globalConnection = null;
          }
          callback(err, connection);
        });
      }
      return globalConnection.connect().catch((err) => {
        globalConnection = null;
        return shared.Promise.reject(err);
      });
    }
    function close(callback) {
      if (globalConnection) {
        const gc = globalConnection;
        globalConnection = null;
        return gc.close(callback);
      }
      if (typeof callback === "function") {
        setImmediate(callback);
        return null;
      }
      return new shared.Promise((resolve) => {
        resolve(globalConnection);
      });
    }
    function on(event, handler) {
      if (!globalConnectionHandlers[event])
        globalConnectionHandlers[event] = [];
      globalConnectionHandlers[event].push(handler);
      if (globalConnection)
        globalConnection.on(event, handler);
      return globalConnection;
    }
    function removeListener(event, handler) {
      if (!globalConnectionHandlers[event])
        return globalConnection;
      const index = globalConnectionHandlers[event].indexOf(handler);
      if (index === -1)
        return globalConnection;
      globalConnectionHandlers[event].splice(index, 1);
      if (globalConnectionHandlers[event].length === 0)
        globalConnectionHandlers[event] = void 0;
      if (globalConnection)
        globalConnection.removeListener(event, handler);
      return globalConnection;
    }
    function query() {
      if (typeof arguments[0] === "string") {
        return new shared.driver.Request().query(arguments[0], arguments[1]);
      }
      const values = Array.prototype.slice.call(arguments);
      const strings = values.shift();
      return new shared.driver.Request()._template(strings, values, "query");
    }
    function batch() {
      if (typeof arguments[0] === "string") {
        return new shared.driver.Request().batch(arguments[0], arguments[1]);
      }
      const values = Array.prototype.slice.call(arguments);
      const strings = values.shift();
      return new shared.driver.Request()._template(strings, values, "batch");
    }
    module2.exports = {
      batch,
      close,
      connect,
      off: removeListener,
      on,
      query,
      removeListener
    };
    Object.defineProperty(module2.exports, "pool", {
      get: () => {
        return globalConnection;
      },
      set: () => {
      }
    });
  }
});

// node_modules/mssql/lib/base/prepared-statement.js
var require_prepared_statement = __commonJS({
  "node_modules/mssql/lib/base/prepared-statement.js"(exports2, module2) {
    "use strict";
    var debug = require_src()("mssql:base");
    var { EventEmitter } = require("node:events");
    var { IDS, objectHasProperty } = require_utils2();
    var globalConnection = require_global_connection();
    var { TransactionError, PreparedStatementError } = require_error();
    var shared = require_shared();
    var { TYPES, declare } = require_datatypes();
    var PreparedStatement = class extends EventEmitter {
      /**
       * Creates a new Prepared Statement.
       *
       * @param {ConnectionPool|Transaction} [holder]
       */
      constructor(parent) {
        super();
        IDS.add(this, "PreparedStatement");
        debug("ps(%d): created", IDS.get(this));
        this.parent = parent || globalConnection.pool;
        this._handle = 0;
        this.prepared = false;
        this.parameters = {};
      }
      get config() {
        return this.parent.config;
      }
      get connected() {
        return this.parent.connected;
      }
      /**
       * Acquire connection from connection pool.
       *
       * @param {Request} request Request.
       * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      acquire(request, callback) {
        if (!this._acquiredConnection) {
          setImmediate(callback, new PreparedStatementError("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
          return this;
        }
        if (this._activeRequest) {
          setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
          return this;
        }
        this._activeRequest = request;
        setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
        return this;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {PreparedStatement}
       */
      release(connection) {
        if (connection === this._acquiredConnection) {
          this._activeRequest = null;
        }
        return this;
      }
      /**
       * Add an input parameter to the prepared statement.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} type SQL data type of input parameter.
       * @return {PreparedStatement}
       */
      input(name, type) {
        if (/--| |\/\*|\*\/|'/.test(name)) {
          throw new PreparedStatementError(`SQL injection warning for param '${name}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", "EARGS");
        }
        if (type instanceof Function) {
          type = type();
        }
        if (objectHasProperty(this.parameters, name)) {
          throw new PreparedStatementError(`The parameter name ${name} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name] = {
          name,
          type: type.type,
          io: 1,
          length: type.length,
          scale: type.scale,
          precision: type.precision,
          tvpType: type.tvpType
        };
        return this;
      }
      /**
       * Replace an input parameter on the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      replaceInput(name, type, value) {
        delete this.parameters[name];
        return this.input(name, type, value);
      }
      /**
       * Add an output parameter to the prepared statement.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @return {PreparedStatement}
       */
      output(name, type) {
        if (/--| |\/\*|\*\/|'/.test(name)) {
          throw new PreparedStatementError(`SQL injection warning for param '${name}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new PreparedStatementError("Invalid number of arguments. 2 arguments expected.", "EARGS");
        }
        if (type instanceof Function)
          type = type();
        if (objectHasProperty(this.parameters, name)) {
          throw new PreparedStatementError(`The parameter name ${name} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name] = {
          name,
          type: type.type,
          io: 2,
          length: type.length,
          scale: type.scale,
          precision: type.precision
        };
        return this;
      }
      /**
       * Replace an output parameter on the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @return {PreparedStatement}
       */
      replaceOutput(name, type) {
        delete this.parameters[name];
        return this.output(name, type);
      }
      /**
       * Prepare a statement.
       *
       * @param {String} statement SQL statement to prepare.
       * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      prepare(statement, callback) {
        if (typeof callback === "function") {
          this._prepare(statement, callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._prepare(statement, (err) => {
            if (err)
              return reject(err);
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {String} statement
       * @param {basicCallback} callback
       */
      _prepare(statement, callback) {
        debug("ps(%d): prepare", IDS.get(this));
        if (typeof statement === "function") {
          callback = statement;
          statement = void 0;
        }
        if (this.prepared) {
          return setImmediate(callback, new PreparedStatementError("Statement is already prepared.", "EALREADYPREPARED"));
        }
        this.statement = statement || this.statement;
        this.parent.acquire(this, (err, connection, config) => {
          if (err)
            return callback(err);
          this._acquiredConnection = connection;
          this._acquiredConfig = config;
          const req = new shared.driver.Request(this);
          req.stream = false;
          req.output("handle", TYPES.Int);
          req.input("params", TYPES.NVarChar, (() => {
            const result = [];
            for (const name in this.parameters) {
              if (!objectHasProperty(this.parameters, name)) {
                continue;
              }
              const param = this.parameters[name];
              result.push(`@${name} ${declare(param.type, param)}${param.io === 2 ? " output" : ""}`);
            }
            return result;
          })().join(","));
          req.input("stmt", TYPES.NVarChar, this.statement);
          req.execute("sp_prepare", (err2, result) => {
            if (err2) {
              this.parent.release(this._acquiredConnection);
              this._acquiredConnection = null;
              this._acquiredConfig = null;
              return callback(err2);
            }
            debug("ps(%d): prepared", IDS.get(this));
            this._handle = result.output.handle;
            this.prepared = true;
            callback(null);
          });
        });
      }
      /**
       * Execute a prepared statement.
       *
       * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.
       * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      execute(values, callback) {
        if (this.stream || typeof callback === "function") {
          return this._execute(values, callback);
        }
        return new shared.Promise((resolve, reject) => {
          this._execute(values, (err, recordset) => {
            if (err)
              return reject(err);
            resolve(recordset);
          });
        });
      }
      /**
       * @private
       * @param {Object} values
       * @param {basicCallback} callback
       */
      _execute(values, callback) {
        const req = new shared.driver.Request(this);
        req.stream = this.stream;
        req.arrayRowMode = this.arrayRowMode;
        req.input("handle", TYPES.Int, this._handle);
        for (const name in this.parameters) {
          if (!objectHasProperty(this.parameters, name)) {
            continue;
          }
          const param = this.parameters[name];
          req.parameters[name] = {
            name,
            type: param.type,
            io: param.io,
            value: values[name],
            length: param.length,
            scale: param.scale,
            precision: param.precision
          };
        }
        req.execute("sp_execute", (err, result) => {
          if (err)
            return callback(err);
          callback(null, result);
        });
        return req;
      }
      /**
       * Unprepare a prepared statement.
       *
       * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.
       * @return {PreparedStatement|Promise}
       */
      unprepare(callback) {
        if (typeof callback === "function") {
          this._unprepare(callback);
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._unprepare((err) => {
            if (err)
              return reject(err);
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} callback
       */
      _unprepare(callback) {
        debug("ps(%d): unprepare", IDS.get(this));
        if (!this.prepared) {
          return setImmediate(callback, new PreparedStatementError("Statement is not prepared. Call prepare() first.", "ENOTPREPARED"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't unprepare the statement. There is a request in progress.", "EREQINPROG"));
        }
        const req = new shared.driver.Request(this);
        req.stream = false;
        req.input("handle", TYPES.Int, this._handle);
        req.execute("sp_unprepare", (err) => {
          if (err)
            return callback(err);
          this.parent.release(this._acquiredConnection);
          this._acquiredConnection = null;
          this._acquiredConfig = null;
          this._handle = 0;
          this.prepared = false;
          debug("ps(%d): unprepared", IDS.get(this));
          return callback(null);
        });
      }
    };
    module2.exports = PreparedStatement;
  }
});

// node_modules/mssql/lib/base/request.js
var require_request = __commonJS({
  "node_modules/mssql/lib/base/request.js"(exports2, module2) {
    "use strict";
    var debug = require_src()("mssql:base");
    var { EventEmitter } = require("node:events");
    var { Readable } = require("node:stream");
    var { IDS, objectHasProperty } = require_utils2();
    var globalConnection = require_global_connection();
    var { RequestError, ConnectionError } = require_error();
    var { TYPES } = require_datatypes();
    var shared = require_shared();
    var Request = class extends EventEmitter {
      /**
       * Create new Request.
       *
       * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If omitted, global connection is used instead.
       */
      constructor(parent) {
        super();
        IDS.add(this, "Request");
        debug("request(%d): created", IDS.get(this));
        this.canceled = false;
        this._paused = false;
        this.parent = parent || globalConnection.pool;
        this.parameters = {};
        this.stream = null;
        this.arrayRowMode = null;
      }
      get paused() {
        return this._paused;
      }
      /**
       * Generate sql string and set input parameters from tagged template string.
       *
       * @param {Template literal} template
       * @return {String}
       */
      template() {
        const values = Array.prototype.slice.call(arguments);
        const strings = values.shift();
        return this._template(strings, values);
      }
      /**
       * Fetch request from tagged template string.
       *
       * @private
       * @param {Array} strings
       * @param {Array} values
       * @param {String} [method] If provided, method is automatically called with serialized command on this object.
       * @return {Request}
       */
      _template(strings, values, method) {
        const command = [strings[0]];
        for (let index = 0; index < values.length; index++) {
          const value = values[index];
          if (Array.isArray(value)) {
            for (let parameterIndex = 0; parameterIndex < value.length; parameterIndex++) {
              this.input(`param${index + 1}_${parameterIndex}`, value[parameterIndex]);
              command.push(`@param${index + 1}_${parameterIndex}`);
              if (parameterIndex < value.length - 1) {
                command.push(", ");
              }
            }
            command.push(strings[index + 1]);
          } else {
            this.input(`param${index + 1}`, value);
            command.push(`@param${index + 1}`, strings[index + 1]);
          }
        }
        if (method) {
          return this[method](command.join(""));
        } else {
          return command.join("");
        }
      }
      /**
       * Add an input parameter to the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      input(name, type, value) {
        if (/--| |\/\*|\*\/|'/.test(name)) {
          throw new RequestError(`SQL injection warning for param '${name}'`, "EINJECT");
        }
        if (arguments.length < 2) {
          throw new RequestError("Invalid number of arguments. At least 2 arguments expected.", "EARGS");
        } else if (arguments.length === 2) {
          value = type;
          type = shared.getTypeByValue(value);
        }
        if (value && typeof value.valueOf === "function" && !(value instanceof Date))
          value = value.valueOf();
        if (value === void 0)
          value = null;
        if (typeof value === "number" && isNaN(value))
          value = null;
        if (type instanceof Function)
          type = type();
        if (objectHasProperty(this.parameters, name)) {
          throw new RequestError(`The parameter name ${name} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name] = {
          name,
          type: type.type,
          io: 1,
          value,
          length: type.length,
          scale: type.scale,
          precision: type.precision,
          tvpType: type.tvpType
        };
        return this;
      }
      /**
       * Replace an input parameter on the request.
       *
       * @param {String} name Name of the input parameter without @ char.
       * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
       * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
       * @return {Request}
       */
      replaceInput(name, type, value) {
        delete this.parameters[name];
        return this.input(name, type, value);
      }
      /**
       * Add an output parameter to the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
       * @return {Request}
       */
      output(name, type, value) {
        if (!type) {
          type = TYPES.NVarChar;
        }
        if (/--| |\/\*|\*\/|'/.test(name)) {
          throw new RequestError(`SQL injection warning for param '${name}'`, "EINJECT");
        }
        if (type === TYPES.Text || type === TYPES.NText || type === TYPES.Image) {
          throw new RequestError("Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.", "EDEPRECATED");
        }
        if (value && typeof value.valueOf === "function" && !(value instanceof Date))
          value = value.valueOf();
        if (value === void 0)
          value = null;
        if (typeof value === "number" && isNaN(value))
          value = null;
        if (type instanceof Function)
          type = type();
        if (objectHasProperty(this.parameters, name)) {
          throw new RequestError(`The parameter name ${name} has already been declared. Parameter names must be unique`, "EDUPEPARAM");
        }
        this.parameters[name] = {
          name,
          type: type.type,
          io: 2,
          value,
          length: type.length,
          scale: type.scale,
          precision: type.precision
        };
        return this;
      }
      /**
       * Replace an output parameter on the request.
       *
       * @param {String} name Name of the output parameter without @ char.
       * @param {*} type SQL data type of output parameter.
       * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
       * @return {Request}
       */
      replaceOutput(name, type, value) {
        delete this.parameters[name];
        return this.output(name, type, value);
      }
      /**
       * Execute the SQL batch.
       *
       * @param {String} batch T-SQL batch to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      batch(batch, callback) {
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._batch(batch, (err, recordsets, output, rowsAffected) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return callback(err);
            callback(null, {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            });
          });
          return this;
        }
        if (typeof batch === "object") {
          const values = Array.prototype.slice.call(arguments);
          const strings = values.shift();
          batch = this._template(strings, values);
        }
        return new shared.Promise((resolve, reject) => {
          this._batch(batch, (err, recordsets, output, rowsAffected) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return reject(err);
            resolve({
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            });
          });
        });
      }
      /**
       * @private
       * @param {String} batch
       * @param {Request~requestCallback} callback
       */
      _batch(batch, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Bulk load.
       *
       * @param {Table} table SQL table.
       * @param {object} [options] Options to be passed to the underlying driver (tedious only).
       * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      bulk(table, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (typeof options === "undefined") {
          options = {};
        }
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        if (this.stream || typeof callback === "function") {
          this._bulk(table, options, (err, rowsAffected) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              return this.emit("done", {
                rowsAffected
              });
            }
            if (err)
              return callback(err);
            callback(null, {
              rowsAffected
            });
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._bulk(table, options, (err, rowsAffected) => {
            if (err)
              return reject(err);
            resolve({
              rowsAffected
            });
          });
        });
      }
      /**
       * @private
       * @param {Table} table
       * @param {object} options
       * @param {Request~bulkCallback} callback
       */
      _bulk(table, options, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Wrap original request in a Readable stream that supports back pressure and return.
       * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
       *
       * @param {Object} streamOptions - optional options to configure the readable stream with like highWaterMark
       * @return {Stream}
       */
      toReadableStream(streamOptions = {}) {
        this.stream = true;
        this.pause();
        const readableStream = new Readable({
          ...streamOptions,
          objectMode: true,
          read: () => {
            this.resume();
          }
        });
        this.on("row", (row) => {
          if (!readableStream.push(row)) {
            this.pause();
          }
        });
        this.on("error", (error) => {
          readableStream.emit("error", error);
        });
        this.on("done", () => {
          readableStream.push(null);
        });
        return readableStream;
      }
      /**
       * Wrap original request in a Readable stream that supports back pressure and pipe to the Writable stream.
       * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
       *
       * @param {Stream} stream Stream to pipe data into.
       * @return {Stream}
       */
      pipe(writableStream) {
        const readableStream = this.toReadableStream();
        return readableStream.pipe(writableStream);
      }
      /**
       * Execute the SQL command.
       *
       * @param {String} command T-SQL command to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      query(command, callback) {
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._query(command, (err, recordsets, output, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return callback(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            };
            if (this.arrayRowMode)
              result.columns = columns;
            callback(null, result);
          });
          return this;
        }
        if (typeof command === "object") {
          const values = Array.prototype.slice.call(arguments);
          const strings = values.shift();
          command = this._template(strings, values);
        }
        return new shared.Promise((resolve, reject) => {
          this._query(command, (err, recordsets, output, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected
              });
            }
            if (err)
              return reject(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected
            };
            if (this.arrayRowMode)
              result.columns = columns;
            resolve(result);
          });
        });
      }
      /**
       * @private
       * @param {String} command
       * @param {Request~bulkCallback} callback
       */
      _query(command, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Call a stored procedure.
       *
       * @param {String} procedure Name of the stored procedure to be executed.
       * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
       * @return {Request|Promise}
       */
      execute(command, callback) {
        if (this.stream === null && this.parent)
          this.stream = this.parent.config.stream;
        if (this.arrayRowMode === null && this.parent)
          this.arrayRowMode = this.parent.config.arrayRowMode;
        this.rowsAffected = 0;
        if (typeof callback === "function") {
          this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected,
                returnValue
              });
            }
            if (err)
              return callback(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected,
              returnValue
            };
            if (this.arrayRowMode)
              result.columns = columns;
            callback(null, result);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
            if (this.stream) {
              if (err)
                this.emit("error", err);
              err = null;
              this.emit("done", {
                output,
                rowsAffected,
                returnValue
              });
            }
            if (err)
              return reject(err);
            const result = {
              recordsets,
              recordset: recordsets && recordsets[0],
              output,
              rowsAffected,
              returnValue
            };
            if (this.arrayRowMode)
              result.columns = columns;
            resolve(result);
          });
        });
      }
      /**
       * @private
       * @param {String} procedure
       * @param {Request~bulkCallback} callback
       */
      _execute(procedure, callback) {
        if (!this.parent) {
          return setImmediate(callback, new RequestError("No connection is specified for that request.", "ENOCONN"));
        }
        if (!this.parent.connected) {
          return setImmediate(callback, new ConnectionError("Connection is closed.", "ECONNCLOSED"));
        }
        this.canceled = false;
        setImmediate(callback);
      }
      /**
       * Cancel currently executed request.
       *
       * @return {Boolean}
       */
      cancel() {
        this._cancel();
        return true;
      }
      /**
       * @private
       */
      _cancel() {
        this.canceled = true;
      }
      pause() {
        if (this.stream) {
          this._pause();
          return true;
        }
        return false;
      }
      _pause() {
        this._paused = true;
      }
      resume() {
        if (this.stream) {
          this._resume();
          return true;
        }
        return false;
      }
      _resume() {
        this._paused = false;
      }
      _setCurrentRequest(request) {
        this._currentRequest = request;
        if (this._paused) {
          this.pause();
        }
        return this;
      }
    };
    module2.exports = Request;
  }
});

// node_modules/mssql/lib/isolationlevel.js
var require_isolationlevel = __commonJS({
  "node_modules/mssql/lib/isolationlevel.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
  }
});

// node_modules/mssql/lib/base/transaction.js
var require_transaction = __commonJS({
  "node_modules/mssql/lib/base/transaction.js"(exports2, module2) {
    "use strict";
    var debug = require_src()("mssql:base");
    var { EventEmitter } = require("node:events");
    var { IDS } = require_utils2();
    var globalConnection = require_global_connection();
    var { TransactionError } = require_error();
    var shared = require_shared();
    var ISOLATION_LEVEL = require_isolationlevel();
    var Transaction = class _Transaction extends EventEmitter {
      /**
       * Create new Transaction.
       *
       * @param {Connection} [parent] If ommited, global connection is used instead.
       */
      constructor(parent) {
        super();
        IDS.add(this, "Transaction");
        debug("transaction(%d): created", IDS.get(this));
        this.parent = parent || globalConnection.pool;
        this.isolationLevel = _Transaction.defaultIsolationLevel;
        this.name = "";
      }
      get config() {
        return this.parent.config;
      }
      get connected() {
        return this.parent.connected;
      }
      /**
       * Acquire connection from connection pool.
       *
       * @param {Request} request Request.
       * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      acquire(request, callback) {
        if (!this._acquiredConnection) {
          setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
          return this;
        }
        if (this._activeRequest) {
          setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", "EREQINPROG"));
          return this;
        }
        this._activeRequest = request;
        setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
        return this;
      }
      /**
       * Release connection back to the pool.
       *
       * @param {Connection} connection Previously acquired connection.
       * @return {Transaction}
       */
      release(connection) {
        if (connection === this._acquiredConnection) {
          this._activeRequest = null;
        }
        return this;
      }
      /**
       * Begin a transaction.
       *
       * @param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.
       * @param {basicCallback} [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      begin(isolationLevel, callback) {
        if (isolationLevel instanceof Function) {
          callback = isolationLevel;
          isolationLevel = void 0;
        }
        if (typeof callback === "function") {
          this._begin(isolationLevel, (err) => {
            if (!err) {
              this.emit("begin");
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._begin(isolationLevel, (err) => {
            if (err)
              return reject(err);
            this.emit("begin");
            resolve(this);
          });
        });
      }
      /**
       * @private
       * @param {Number} [isolationLevel]
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _begin(isolationLevel, callback) {
        if (this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has already begun.", "EALREADYBEGUN"));
        }
        this._aborted = false;
        this._rollbackRequested = false;
        if (isolationLevel) {
          if (Object.keys(ISOLATION_LEVEL).some((key) => {
            return ISOLATION_LEVEL[key] === isolationLevel;
          })) {
            this.isolationLevel = isolationLevel;
          } else {
            throw new TransactionError("Invalid isolation level.");
          }
        }
        setImmediate(callback);
      }
      /**
       * Commit a transaction.
       *
       * @param {basicCallback} [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      commit(callback) {
        if (typeof callback === "function") {
          this._commit((err) => {
            if (!err) {
              this.emit("commit");
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          this._commit((err) => {
            if (err)
              return reject(err);
            this.emit("commit");
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _commit(callback) {
        if (this._aborted) {
          return setImmediate(callback, new TransactionError("Transaction has been aborted.", "EABORT"));
        }
        if (!this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't commit transaction. There is a request in progress.", "EREQINPROG"));
        }
        setImmediate(callback);
      }
      /**
       * Returns new request using this transaction.
       *
       * @return {Request}
       */
      request() {
        return new shared.driver.Request(this);
      }
      /**
       * Rollback a transaction.
       *
       * @param {basicCallback} [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.
       * @return {Transaction|Promise}
       */
      rollback(callback) {
        if (typeof callback === "function") {
          this._rollback((err) => {
            if (!err) {
              this.emit("rollback", this._aborted);
            }
            callback(err);
          });
          return this;
        }
        return new shared.Promise((resolve, reject) => {
          return this._rollback((err) => {
            if (err)
              return reject(err);
            this.emit("rollback", this._aborted);
            resolve();
          });
        });
      }
      /**
       * @private
       * @param {basicCallback} [callback]
       * @return {Transaction}
       */
      _rollback(callback) {
        if (this._aborted) {
          return setImmediate(callback, new TransactionError("Transaction has been aborted.", "EABORT"));
        }
        if (!this._acquiredConnection) {
          return setImmediate(callback, new TransactionError("Transaction has not begun. Call begin() first.", "ENOTBEGUN"));
        }
        if (this._activeRequest) {
          return setImmediate(callback, new TransactionError("Can't rollback transaction. There is a request in progress.", "EREQINPROG"));
        }
        this._rollbackRequested = true;
        setImmediate(callback);
      }
    };
    Transaction.defaultIsolationLevel = ISOLATION_LEVEL.READ_COMMITTED;
    module2.exports = Transaction;
  }
});

// node_modules/mssql/lib/base/index.js
var require_base = __commonJS({
  "node_modules/mssql/lib/base/index.js"(exports2, module2) {
    "use strict";
    var ConnectionPool2 = require_connection_pool();
    var PreparedStatement = require_prepared_statement();
    var Request = require_request();
    var Transaction = require_transaction();
    var { ConnectionError, TransactionError, RequestError, PreparedStatementError, MSSQLError } = require_error();
    var shared = require_shared();
    var Table = require_table();
    var ISOLATION_LEVEL = require_isolationlevel();
    var { TYPES } = require_datatypes();
    var { connect, close, on, off, removeListener, query, batch } = require_global_connection();
    module2.exports = {
      ConnectionPool: ConnectionPool2,
      Transaction,
      Request,
      PreparedStatement,
      ConnectionError,
      TransactionError,
      RequestError,
      PreparedStatementError,
      MSSQLError,
      driver: shared.driver,
      exports: {
        ConnectionError,
        TransactionError,
        RequestError,
        PreparedStatementError,
        MSSQLError,
        Table,
        ISOLATION_LEVEL,
        TYPES,
        MAX: 65535,
        // (1 << 16) - 1
        map: shared.map,
        getTypeByValue: shared.getTypeByValue,
        connect,
        close,
        on,
        removeListener,
        off,
        query,
        batch
      }
    };
    Object.defineProperty(module2.exports, "Promise", {
      enumerable: true,
      get: () => {
        return shared.Promise;
      },
      set: (value) => {
        shared.Promise = value;
      }
    });
    Object.defineProperty(module2.exports, "valueHandler", {
      enumerable: true,
      value: shared.valueHandler,
      writable: false,
      configurable: false
    });
    for (const key in TYPES) {
      const value = TYPES[key];
      module2.exports.exports[key] = value;
      module2.exports.exports[key.toUpperCase()] = value;
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js
var require_writable_tracking_buffer = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var ZERO_LENGTH_BUFFER = Buffer.alloc(0);
    var WritableTrackingBuffer = class {
      constructor(initialSize, encoding, doubleSizeGrowth) {
        this.initialSize = initialSize;
        this.encoding = encoding || "ucs2";
        this.doubleSizeGrowth = doubleSizeGrowth || false;
        this.buffer = Buffer.alloc(this.initialSize, 0);
        this.compositeBuffer = ZERO_LENGTH_BUFFER;
        this.position = 0;
      }
      get data() {
        this.newBuffer(0);
        return this.compositeBuffer;
      }
      copyFrom(buffer) {
        const length = buffer.length;
        this.makeRoomFor(length);
        buffer.copy(this.buffer, this.position);
        this.position += length;
      }
      makeRoomFor(requiredLength) {
        if (this.buffer.length - this.position < requiredLength) {
          if (this.doubleSizeGrowth) {
            let size = Math.max(128, this.buffer.length * 2);
            while (size < requiredLength) {
              size *= 2;
            }
            this.newBuffer(size);
          } else {
            this.newBuffer(requiredLength);
          }
        }
      }
      newBuffer(size) {
        const buffer = this.buffer.slice(0, this.position);
        this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);
        this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);
        this.position = 0;
      }
      writeUInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeUInt8(value, this.position);
        this.position += length;
      }
      writeUInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16LE(value, this.position);
        this.position += length;
      }
      writeUShort(value) {
        this.writeUInt16LE(value);
      }
      writeUInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16BE(value, this.position);
        this.position += length;
      }
      writeUInt24LE(value) {
        const length = 3;
        this.makeRoomFor(length);
        this.buffer[this.position + 2] = value >>> 16 & 255;
        this.buffer[this.position + 1] = value >>> 8 & 255;
        this.buffer[this.position] = value & 255;
        this.position += length;
      }
      writeUInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32LE(value, this.position);
        this.position += length;
      }
      writeBigInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigInt64LE(value, this.position);
        this.position += length;
      }
      writeInt64LE(value) {
        this.writeBigInt64LE(BigInt(value));
      }
      writeUInt64LE(value) {
        this.writeBigUInt64LE(BigInt(value));
      }
      writeBigUInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigUInt64LE(value, this.position);
        this.position += length;
      }
      writeUInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32BE(value, this.position);
        this.position += length;
      }
      writeUInt40LE(value) {
        this.writeInt32LE(value & -1);
        this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));
      }
      writeInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeInt8(value, this.position);
        this.position += length;
      }
      writeInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16LE(value, this.position);
        this.position += length;
      }
      writeInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16BE(value, this.position);
        this.position += length;
      }
      writeInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32LE(value, this.position);
        this.position += length;
      }
      writeInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32BE(value, this.position);
        this.position += length;
      }
      writeFloatLE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeFloatLE(value, this.position);
        this.position += length;
      }
      writeDoubleLE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeDoubleLE(value, this.position);
        this.position += length;
      }
      writeString(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        const length = Buffer.byteLength(value, encoding);
        this.makeRoomFor(length);
        this.buffer.write(value, this.position, encoding);
        this.position += length;
      }
      writeBVarchar(value, encoding) {
        this.writeUInt8(value.length);
        this.writeString(value, encoding);
      }
      writeUsVarchar(value, encoding) {
        this.writeUInt16LE(value.length);
        this.writeString(value, encoding);
      }
      // TODO: Figure out what types are passed in other than `Buffer`
      writeUsVarbyte(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeUInt16LE(length);
        if (value instanceof Buffer) {
          this.writeBuffer(value);
        } else {
          this.makeRoomFor(length);
          this.buffer.write(value, this.position, encoding);
          this.position += length;
        }
      }
      writePLPBody(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeBuffer(UNKNOWN_PLP_LEN);
        if (length > 0) {
          this.writeUInt32LE(length);
          if (value instanceof Buffer) {
            this.writeBuffer(value);
          } else {
            this.makeRoomFor(length);
            this.buffer.write(value, this.position, encoding);
            this.position += length;
          }
        }
        this.writeUInt32LE(0);
      }
      writeBuffer(value) {
        const length = value.length;
        this.makeRoomFor(length);
        value.copy(this.buffer, this.position);
        this.position += length;
      }
      writeMoney(value) {
        this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));
        this.writeInt32LE(value & -1);
      }
    };
    var _default = exports2.default = WritableTrackingBuffer;
    module2.exports = WritableTrackingBuffer;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/token.js
var require_token = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Token = exports2.TYPE = exports2.SSPIToken = exports2.RowToken = exports2.RoutingEnvChangeToken = exports2.RollbackTransactionEnvChangeToken = exports2.ReturnValueToken = exports2.ReturnStatusToken = exports2.ResetConnectionEnvChangeToken = exports2.PacketSizeEnvChangeToken = exports2.OrderToken = exports2.NBCRowToken = exports2.LoginAckToken = exports2.LanguageEnvChangeToken = exports2.InfoMessageToken = exports2.FedAuthInfoToken = exports2.FeatureExtAckToken = exports2.ErrorMessageToken = exports2.DoneToken = exports2.DoneProcToken = exports2.DoneInProcToken = exports2.DatabaseMirroringPartnerEnvChangeToken = exports2.DatabaseEnvChangeToken = exports2.CommitTransactionEnvChangeToken = exports2.CollationChangeToken = exports2.ColMetadataToken = exports2.CharsetEnvChangeToken = exports2.BeginTransactionEnvChangeToken = void 0;
    var TYPE = exports2.TYPE = {
      ALTMETADATA: 136,
      ALTROW: 211,
      COLMETADATA: 129,
      COLINFO: 165,
      DONE: 253,
      DONEPROC: 254,
      DONEINPROC: 255,
      ENVCHANGE: 227,
      ERROR: 170,
      FEATUREEXTACK: 174,
      FEDAUTHINFO: 238,
      INFO: 171,
      LOGINACK: 173,
      NBCROW: 210,
      OFFSET: 120,
      ORDER: 169,
      RETURNSTATUS: 121,
      RETURNVALUE: 172,
      ROW: 209,
      SSPI: 237,
      TABNAME: 164
    };
    var Token = class {
      constructor(name, handlerName) {
        this.name = name;
        this.handlerName = handlerName;
      }
    };
    exports2.Token = Token;
    var ColMetadataToken = class extends Token {
      constructor(columns) {
        super("COLMETADATA", "onColMetadata");
        this.columns = columns;
      }
    };
    exports2.ColMetadataToken = ColMetadataToken;
    var DoneToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONE", "onDone");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports2.DoneToken = DoneToken;
    var DoneInProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEINPROC", "onDoneInProc");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports2.DoneInProcToken = DoneInProcToken;
    var DoneProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEPROC", "onDoneProc");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports2.DoneProcToken = DoneProcToken;
    var DatabaseEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseChange");
        this.type = "DATABASE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.DatabaseEnvChangeToken = DatabaseEnvChangeToken;
    var LanguageEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onLanguageChange");
        this.type = "LANGUAGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.LanguageEnvChangeToken = LanguageEnvChangeToken;
    var CharsetEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCharsetChange");
        this.type = "CHARSET";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.CharsetEnvChangeToken = CharsetEnvChangeToken;
    var PacketSizeEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onPacketSizeChange");
        this.type = "PACKET_SIZE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.PacketSizeEnvChangeToken = PacketSizeEnvChangeToken;
    var BeginTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onBeginTransaction");
        this.type = "BEGIN_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.BeginTransactionEnvChangeToken = BeginTransactionEnvChangeToken;
    var CommitTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCommitTransaction");
        this.type = "COMMIT_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.CommitTransactionEnvChangeToken = CommitTransactionEnvChangeToken;
    var RollbackTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRollbackTransaction");
        this.type = "ROLLBACK_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.RollbackTransactionEnvChangeToken = RollbackTransactionEnvChangeToken;
    var DatabaseMirroringPartnerEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseMirroringPartner");
        this.type = "DATABASE_MIRRORING_PARTNER";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.DatabaseMirroringPartnerEnvChangeToken = DatabaseMirroringPartnerEnvChangeToken;
    var ResetConnectionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onResetConnection");
        this.type = "RESET_CONNECTION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.ResetConnectionEnvChangeToken = ResetConnectionEnvChangeToken;
    var CollationChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onSqlCollationChange");
        this.type = "SQL_COLLATION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.CollationChangeToken = CollationChangeToken;
    var RoutingEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRoutingChange");
        this.type = "ROUTING_CHANGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports2.RoutingEnvChangeToken = RoutingEnvChangeToken;
    var FeatureExtAckToken = class extends Token {
      /** Value of UTF8_SUPPORT acknowledgement.
       *
       * undefined when UTF8_SUPPORT not included in token. */
      constructor(fedAuth, utf8Support) {
        super("FEATUREEXTACK", "onFeatureExtAck");
        this.fedAuth = fedAuth;
        this.utf8Support = utf8Support;
      }
    };
    exports2.FeatureExtAckToken = FeatureExtAckToken;
    var FedAuthInfoToken = class extends Token {
      constructor(spn, stsurl) {
        super("FEDAUTHINFO", "onFedAuthInfo");
        this.spn = spn;
        this.stsurl = stsurl;
      }
    };
    exports2.FedAuthInfoToken = FedAuthInfoToken;
    var InfoMessageToken = class extends Token {
      constructor({
        number,
        state,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("INFO", "onInfoMessage");
        this.number = number;
        this.state = state;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports2.InfoMessageToken = InfoMessageToken;
    var ErrorMessageToken = class extends Token {
      constructor({
        number,
        state,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("ERROR", "onErrorMessage");
        this.number = number;
        this.state = state;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports2.ErrorMessageToken = ErrorMessageToken;
    var LoginAckToken = class extends Token {
      constructor({
        interface: interfaze,
        tdsVersion,
        progName,
        progVersion
      }) {
        super("LOGINACK", "onLoginAck");
        this.interface = interfaze;
        this.tdsVersion = tdsVersion;
        this.progName = progName;
        this.progVersion = progVersion;
      }
    };
    exports2.LoginAckToken = LoginAckToken;
    var NBCRowToken = class extends Token {
      constructor(columns) {
        super("NBCROW", "onRow");
        this.columns = columns;
      }
    };
    exports2.NBCRowToken = NBCRowToken;
    var OrderToken = class extends Token {
      constructor(orderColumns) {
        super("ORDER", "onOrder");
        this.orderColumns = orderColumns;
      }
    };
    exports2.OrderToken = OrderToken;
    var ReturnStatusToken = class extends Token {
      constructor(value) {
        super("RETURNSTATUS", "onReturnStatus");
        this.value = value;
      }
    };
    exports2.ReturnStatusToken = ReturnStatusToken;
    var ReturnValueToken = class extends Token {
      constructor({
        paramOrdinal,
        paramName,
        metadata,
        value
      }) {
        super("RETURNVALUE", "onReturnValue");
        this.paramOrdinal = paramOrdinal;
        this.paramName = paramName;
        this.metadata = metadata;
        this.value = value;
      }
    };
    exports2.ReturnValueToken = ReturnValueToken;
    var RowToken = class extends Token {
      constructor(columns) {
        super("ROW", "onRow");
        this.columns = columns;
      }
    };
    exports2.RowToken = RowToken;
    var SSPIToken = class extends Token {
      constructor(ntlmpacket, ntlmpacketBuffer) {
        super("SSPICHALLENGE", "onSSPI");
        this.ntlmpacket = ntlmpacket;
        this.ntlmpacketBuffer = ntlmpacketBuffer;
      }
    };
    exports2.SSPIToken = SSPIToken;
  }
});

// node_modules/mssql/node_modules/tedious/lib/bulk-load.js
var require_bulk_load = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/bulk-load.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _events = require("events");
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _stream = require("stream");
    var _token = require_token();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var FLAGS = {
      nullable: 1 << 0,
      caseSen: 1 << 1,
      updateableReadWrite: 1 << 2,
      updateableUnknown: 1 << 3,
      identity: 1 << 4,
      computed: 1 << 5,
      // introduced in TDS 7.2
      fixedLenCLRType: 1 << 8,
      // introduced in TDS 7.2
      sparseColumnSet: 1 << 10,
      // introduced in TDS 7.3.B
      hidden: 1 << 13,
      // introduced in TDS 7.2
      key: 1 << 14,
      // introduced in TDS 7.2
      nullableUnknown: 1 << 15
      // introduced in TDS 7.2
    };
    var DONE_STATUS = {
      FINAL: 0,
      MORE: 1,
      ERROR: 2,
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    var rowTokenBuffer = Buffer.from([_token.TYPE.ROW]);
    var textPointerAndTimestampBuffer = Buffer.from([
      // TextPointer length
      16,
      // TextPointer
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // Timestamp
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var textPointerNullBuffer = Buffer.from([0]);
    var RowTransform = class extends _stream.Transform {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      constructor(bulkLoad) {
        super({
          writableObjectMode: true
        });
        this.bulkLoad = bulkLoad;
        this.mainOptions = bulkLoad.options;
        this.columns = bulkLoad.columns;
        this.columnMetadataWritten = false;
      }
      /**
       * @private
       */
      _transform(row, _encoding, callback) {
        if (!this.columnMetadataWritten) {
          this.push(this.bulkLoad.getColMetaData());
          this.columnMetadataWritten = true;
        }
        this.push(rowTokenBuffer);
        for (let i = 0; i < this.columns.length; i++) {
          const c = this.columns[i];
          let value = Array.isArray(row) ? row[i] : row[c.objName];
          if (!this.bulkLoad.firstRowWritten) {
            try {
              value = c.type.validate(value, c.collation);
            } catch (error) {
              return callback(error);
            }
          }
          const parameter = {
            length: c.length,
            scale: c.scale,
            precision: c.precision,
            value
          };
          if (c.type.name === "Text" || c.type.name === "Image" || c.type.name === "NText") {
            if (value == null) {
              this.push(textPointerNullBuffer);
              continue;
            }
            this.push(textPointerAndTimestampBuffer);
          }
          try {
            this.push(c.type.generateParameterLength(parameter, this.mainOptions));
            for (const chunk of c.type.generateParameterData(parameter, this.mainOptions)) {
              this.push(chunk);
            }
          } catch (error) {
            return callback(error);
          }
        }
        process.nextTick(callback);
      }
      /**
       * @private
       */
      _flush(callback) {
        this.push(this.bulkLoad.createDoneToken());
        process.nextTick(callback);
      }
    };
    var BulkLoad = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      constructor(table, collation, connectionOptions, {
        checkConstraints = false,
        fireTriggers = false,
        keepNulls = false,
        lockTable = false,
        order = {}
      }, callback) {
        if (typeof checkConstraints !== "boolean") {
          throw new TypeError('The "options.checkConstraints" property must be of type boolean.');
        }
        if (typeof fireTriggers !== "boolean") {
          throw new TypeError('The "options.fireTriggers" property must be of type boolean.');
        }
        if (typeof keepNulls !== "boolean") {
          throw new TypeError('The "options.keepNulls" property must be of type boolean.');
        }
        if (typeof lockTable !== "boolean") {
          throw new TypeError('The "options.lockTable" property must be of type boolean.');
        }
        if (typeof order !== "object" || order === null) {
          throw new TypeError('The "options.order" property must be of type object.');
        }
        for (const [column, direction] of Object.entries(order)) {
          if (direction !== "ASC" && direction !== "DESC") {
            throw new TypeError('The value of the "' + column + '" key in the "options.order" object must be either "ASC" or "DESC".');
          }
        }
        super();
        this.error = void 0;
        this.canceled = false;
        this.executionStarted = false;
        this.collation = collation;
        this.table = table;
        this.options = connectionOptions;
        this.callback = callback;
        this.columns = [];
        this.columnsByName = {};
        this.firstRowWritten = false;
        this.streamingMode = false;
        this.rowToPacketTransform = new RowTransform(this);
        this.bulkOptions = {
          checkConstraints,
          fireTriggers,
          keepNulls,
          lockTable,
          order
        };
      }
      /**
       * Adds a column to the bulk load.
       *
       * The column definitions should match the table you are trying to insert into.
       * Attempting to call addColumn after the first row has been added will throw an exception.
       *
       * ```js
       * bulkLoad.addColumn('MyIntColumn', TYPES.Int, { nullable: false });
       * ```
       *
       * @param name The name of the column.
       * @param type One of the supported `data types`.
       * @param __namedParameters Additional column type information. At a minimum, `nullable` must be set to true or false.
       * @param length For VarChar, NVarChar, VarBinary. Use length as `Infinity` for VarChar(max), NVarChar(max) and VarBinary(max).
       * @param nullable Indicates whether the column accepts NULL values.
       * @param objName If the name of the column is different from the name of the property found on `rowObj` arguments passed to [[addRow]] or [[Connection.execBulkLoad]], then you can use this option to specify the property name.
       * @param precision For Numeric, Decimal.
       * @param scale For Numeric, Decimal, Time, DateTime2, DateTimeOffset.
      */
      addColumn(name, type, {
        output = false,
        length,
        precision,
        scale,
        objName = name,
        nullable = true
      }) {
        if (this.firstRowWritten) {
          throw new Error("Columns cannot be added to bulk insert after the first row has been written.");
        }
        if (this.executionStarted) {
          throw new Error("Columns cannot be added to bulk insert after execution has started.");
        }
        const column = {
          type,
          name,
          value: null,
          output,
          length,
          precision,
          scale,
          objName,
          nullable,
          collation: this.collation
        };
        if ((type.id & 48) === 32) {
          if (column.length == null && type.resolveLength) {
            column.length = type.resolveLength(column);
          }
        }
        if (type.resolvePrecision && column.precision == null) {
          column.precision = type.resolvePrecision(column);
        }
        if (type.resolveScale && column.scale == null) {
          column.scale = type.resolveScale(column);
        }
        this.columns.push(column);
        this.columnsByName[name] = column;
      }
      /**
       * @private
       */
      getOptionsSql() {
        const addOptions = [];
        if (this.bulkOptions.checkConstraints) {
          addOptions.push("CHECK_CONSTRAINTS");
        }
        if (this.bulkOptions.fireTriggers) {
          addOptions.push("FIRE_TRIGGERS");
        }
        if (this.bulkOptions.keepNulls) {
          addOptions.push("KEEP_NULLS");
        }
        if (this.bulkOptions.lockTable) {
          addOptions.push("TABLOCK");
        }
        if (this.bulkOptions.order) {
          const orderColumns = [];
          for (const [column, direction] of Object.entries(this.bulkOptions.order)) {
            orderColumns.push(`${column} ${direction}`);
          }
          if (orderColumns.length) {
            addOptions.push(`ORDER (${orderColumns.join(", ")})`);
          }
        }
        if (addOptions.length > 0) {
          return ` WITH (${addOptions.join(",")})`;
        } else {
          return "";
        }
      }
      /**
       * @private
       */
      getBulkInsertSql() {
        let sql10 = "insert bulk " + this.table + "(";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql10 += ", ";
          }
          sql10 += "[" + c.name + "] " + c.type.declaration(c);
        }
        sql10 += ")";
        sql10 += this.getOptionsSql();
        return sql10;
      }
      /**
       * This is simply a helper utility function which returns a `CREATE TABLE SQL` statement based on the columns added to the bulkLoad object.
       * This may be particularly handy when you want to insert into a temporary table (a table which starts with `#`).
       *
       * ```js
       * var sql = bulkLoad.getTableCreationSql();
       * ```
       *
       * A side note on bulk inserting into temporary tables: if you want to access a local temporary table after executing the bulk load,
       * you'll need to use the same connection and execute your requests using [[Connection.execSqlBatch]] instead of [[Connection.execSql]]
       */
      getTableCreationSql() {
        let sql10 = "CREATE TABLE " + this.table + "(\n";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql10 += ",\n";
          }
          sql10 += "[" + c.name + "] " + c.type.declaration(c);
          if (c.nullable !== void 0) {
            sql10 += " " + (c.nullable ? "NULL" : "NOT NULL");
          }
        }
        sql10 += "\n)";
        return sql10;
      }
      /**
       * @private
       */
      getColMetaData() {
        const tBuf = new _writableTrackingBuffer.default(100, null, true);
        tBuf.writeUInt8(_token.TYPE.COLMETADATA);
        tBuf.writeUInt16LE(this.columns.length);
        for (let j = 0, len = this.columns.length; j < len; j++) {
          const c = this.columns[j];
          if (this.options.tdsVersion < "7_2") {
            tBuf.writeUInt16LE(0);
          } else {
            tBuf.writeUInt32LE(0);
          }
          let flags = FLAGS.updateableReadWrite;
          if (c.nullable) {
            flags |= FLAGS.nullable;
          } else if (c.nullable === void 0 && this.options.tdsVersion >= "7_2") {
            flags |= FLAGS.nullableUnknown;
          }
          tBuf.writeUInt16LE(flags);
          tBuf.writeBuffer(c.type.generateTypeInfo(c, this.options));
          if (c.type.hasTableName) {
            tBuf.writeUsVarchar(this.table, "ucs2");
          }
          tBuf.writeBVarchar(c.name, "ucs2");
        }
        return tBuf.data;
      }
      /**
       * Sets a timeout for this bulk load.
       *
       * ```js
       * bulkLoad.setTimeout(timeout);
       * ```
       *
       * @param timeout The number of milliseconds before the bulk load is considered failed, or 0 for no timeout.
       *   When no timeout is set for the bulk load, the [[ConnectionOptions.requestTimeout]] of the Connection is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
      /**
       * @private
       */
      createDoneToken() {
        const tBuf = new _writableTrackingBuffer.default(this.options.tdsVersion < "7_2" ? 9 : 13);
        tBuf.writeUInt8(_token.TYPE.DONE);
        const status = DONE_STATUS.FINAL;
        tBuf.writeUInt16LE(status);
        tBuf.writeUInt16LE(0);
        tBuf.writeUInt32LE(0);
        if (this.options.tdsVersion >= "7_2") {
          tBuf.writeUInt32LE(0);
        }
        return tBuf.data;
      }
      /**
       * @private
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
    };
    var _default = exports2.default = BulkLoad;
    module2.exports = BulkLoad;
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f)
        i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++)
      if (k[i] !== "default")
        __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async)
        inner = dispose;
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    if (inner)
      dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1)
          return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async)
            return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
        } else
          s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1)
      return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError)
      throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path2, preserveJsx) {
  if (typeof path2 === "string" && /^\.\.?\//.test(path2)) {
    return path2.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path2;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// node_modules/@azure/identity/dist/commonjs/constants.js
var require_constants = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_TOKEN_CACHE_NAME = exports2.CACHE_NON_CAE_SUFFIX = exports2.CACHE_CAE_SUFFIX = exports2.ALL_TENANTS = exports2.DefaultAuthority = exports2.DefaultAuthorityHost = exports2.AzureAuthorityHosts = exports2.DefaultTenantId = exports2.DeveloperSignOnClientId = exports2.SDK_VERSION = void 0;
    exports2.SDK_VERSION = `4.13.0`;
    exports2.DeveloperSignOnClientId = "04b07795-8ddb-461a-bbee-02f9e1bf7b46";
    exports2.DefaultTenantId = "common";
    var AzureAuthorityHosts;
    (function(AzureAuthorityHosts2) {
      AzureAuthorityHosts2["AzureChina"] = "https://login.chinacloudapi.cn";
      AzureAuthorityHosts2["AzureGermany"] = "https://login.microsoftonline.de";
      AzureAuthorityHosts2["AzureGovernment"] = "https://login.microsoftonline.us";
      AzureAuthorityHosts2["AzurePublicCloud"] = "https://login.microsoftonline.com";
    })(AzureAuthorityHosts || (exports2.AzureAuthorityHosts = AzureAuthorityHosts = {}));
    exports2.DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;
    exports2.DefaultAuthority = "login.microsoftonline.com";
    exports2.ALL_TENANTS = ["*"];
    exports2.CACHE_CAE_SUFFIX = "cae";
    exports2.CACHE_NON_CAE_SUFFIX = "nocae";
    exports2.DEFAULT_TOKEN_CACHE_NAME = "msal.cache";
  }
});

// node_modules/@azure/identity/dist/commonjs/msal/nodeFlows/msalPlugins.js
var require_msalPlugins = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/msal/nodeFlows/msalPlugins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.msalPlugins = exports2.msalNodeFlowVSCodeCredentialControl = exports2.msalNodeFlowNativeBrokerControl = exports2.vsCodeBrokerInfo = exports2.vsCodeAuthRecordPath = exports2.nativeBrokerInfo = exports2.msalNodeFlowCacheControl = exports2.persistenceProvider = void 0;
    exports2.hasNativeBroker = hasNativeBroker;
    exports2.hasVSCodePlugin = hasVSCodePlugin;
    var constants_js_1 = require_constants();
    exports2.persistenceProvider = void 0;
    exports2.msalNodeFlowCacheControl = {
      setPersistence(pluginProvider) {
        exports2.persistenceProvider = pluginProvider;
      }
    };
    exports2.nativeBrokerInfo = void 0;
    exports2.vsCodeAuthRecordPath = void 0;
    exports2.vsCodeBrokerInfo = void 0;
    function hasNativeBroker() {
      return exports2.nativeBrokerInfo !== void 0;
    }
    function hasVSCodePlugin() {
      return exports2.vsCodeAuthRecordPath !== void 0 && exports2.vsCodeBrokerInfo !== void 0;
    }
    exports2.msalNodeFlowNativeBrokerControl = {
      setNativeBroker(broker) {
        exports2.nativeBrokerInfo = {
          broker
        };
      }
    };
    exports2.msalNodeFlowVSCodeCredentialControl = {
      setVSCodeAuthRecordPath(path2) {
        exports2.vsCodeAuthRecordPath = path2;
      },
      setVSCodeBroker(broker) {
        exports2.vsCodeBrokerInfo = {
          broker
        };
      }
    };
    function generatePluginConfiguration(options) {
      const config = {
        cache: {},
        broker: {
          ...options.brokerOptions,
          isEnabled: options.brokerOptions?.enabled ?? false,
          enableMsaPassthrough: options.brokerOptions?.legacyEnableMsaPassthrough ?? false
        }
      };
      if (options.tokenCachePersistenceOptions?.enabled) {
        if (exports2.persistenceProvider === void 0) {
          throw new Error([
            "Persistent token caching was requested, but no persistence provider was configured.",
            "You must install the identity-cache-persistence plugin package (`npm install --save @azure/identity-cache-persistence`)",
            "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
            "`useIdentityPlugin(cachePersistencePlugin)` before using `tokenCachePersistenceOptions`."
          ].join(" "));
        }
        const cacheBaseName = options.tokenCachePersistenceOptions.name || constants_js_1.DEFAULT_TOKEN_CACHE_NAME;
        config.cache.cachePlugin = (0, exports2.persistenceProvider)({
          name: `${cacheBaseName}.${constants_js_1.CACHE_NON_CAE_SUFFIX}`,
          ...options.tokenCachePersistenceOptions
        });
        config.cache.cachePluginCae = (0, exports2.persistenceProvider)({
          name: `${cacheBaseName}.${constants_js_1.CACHE_CAE_SUFFIX}`,
          ...options.tokenCachePersistenceOptions
        });
      }
      if (options.brokerOptions?.enabled) {
        config.broker.nativeBrokerPlugin = getBrokerPlugin(options.isVSCodeCredential || false);
      }
      return config;
    }
    var brokerErrorTemplates = {
      missing: (credentialName, packageName, pluginVar) => [
        `${credentialName} was requested, but no plugin was configured or no authentication record was found.`,
        `You must install the ${packageName} plugin package (npm install --save ${packageName})`,
        "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
        `useIdentityPlugin(${pluginVar}) before using enableBroker.`
      ].join(" "),
      unavailable: (credentialName, packageName) => [
        `${credentialName} was requested, and the plugin is configured, but the broker is unavailable.`,
        `Ensure the ${credentialName} plugin is properly installed and configured.`,
        "Check for missing native dependencies and ensure the package is properly installed.",
        `See the README for prerequisites on installing and using ${packageName}.`
      ].join(" ")
    };
    var brokerConfig = {
      vsCode: {
        credentialName: "Visual Studio Code Credential",
        packageName: "@azure/identity-vscode",
        pluginVar: "vsCodePlugin",
        get brokerInfo() {
          return exports2.vsCodeBrokerInfo;
        }
      },
      native: {
        credentialName: "Broker for WAM",
        packageName: "@azure/identity-broker",
        pluginVar: "nativeBrokerPlugin",
        get brokerInfo() {
          return exports2.nativeBrokerInfo;
        }
      }
    };
    function getBrokerPlugin(isVSCodePlugin) {
      const { credentialName, packageName, pluginVar, brokerInfo } = brokerConfig[isVSCodePlugin ? "vsCode" : "native"];
      if (brokerInfo === void 0) {
        throw new Error(brokerErrorTemplates.missing(credentialName, packageName, pluginVar));
      }
      if (brokerInfo.broker.isBrokerAvailable === false) {
        throw new Error(brokerErrorTemplates.unavailable(credentialName, packageName));
      }
      return brokerInfo.broker;
    }
    exports2.msalPlugins = {
      generatePluginConfiguration
    };
  }
});

// node_modules/@azure/identity/dist/commonjs/plugins/consumer.js
var require_consumer = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/plugins/consumer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.useIdentityPlugin = useIdentityPlugin;
    var msalPlugins_js_1 = require_msalPlugins();
    var pluginContext = {
      cachePluginControl: msalPlugins_js_1.msalNodeFlowCacheControl,
      nativeBrokerPluginControl: msalPlugins_js_1.msalNodeFlowNativeBrokerControl,
      vsCodeCredentialControl: msalPlugins_js_1.msalNodeFlowVSCodeCredentialControl
    };
    function useIdentityPlugin(plugin) {
      plugin(pluginContext);
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/errors.js
var require_errors = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthenticationRequiredError = exports2.AggregateAuthenticationError = exports2.AggregateAuthenticationErrorName = exports2.AuthenticationError = exports2.AuthenticationErrorName = exports2.CredentialUnavailableError = exports2.CredentialUnavailableErrorName = void 0;
    function isErrorResponse(errorResponse) {
      return errorResponse && typeof errorResponse.error === "string" && typeof errorResponse.error_description === "string";
    }
    exports2.CredentialUnavailableErrorName = "CredentialUnavailableError";
    var CredentialUnavailableError = class extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = exports2.CredentialUnavailableErrorName;
      }
    };
    exports2.CredentialUnavailableError = CredentialUnavailableError;
    exports2.AuthenticationErrorName = "AuthenticationError";
    var AuthenticationError = class extends Error {
      /**
       * The HTTP status code returned from the authentication request.
       */
      statusCode;
      /**
       * The error response details.
       */
      errorResponse;
      constructor(statusCode, errorBody, options) {
        let errorResponse = {
          error: "unknown",
          errorDescription: "An unknown error occurred and no additional details are available."
        };
        if (isErrorResponse(errorBody)) {
          errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
        } else if (typeof errorBody === "string") {
          try {
            const oauthErrorResponse = JSON.parse(errorBody);
            errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
          } catch (e) {
            if (statusCode === 400) {
              errorResponse = {
                error: "invalid_request",
                errorDescription: `The service indicated that the request was invalid.

${errorBody}`
              };
            } else {
              errorResponse = {
                error: "unknown_error",
                errorDescription: `An unknown error has occurred. Response body:

${errorBody}`
              };
            }
          }
        } else {
          errorResponse = {
            error: "unknown_error",
            errorDescription: "An unknown error occurred and no additional details are available."
          };
        }
        super(`${errorResponse.error} Status code: ${statusCode}
More details:
${errorResponse.errorDescription},`, options);
        this.statusCode = statusCode;
        this.errorResponse = errorResponse;
        this.name = exports2.AuthenticationErrorName;
      }
    };
    exports2.AuthenticationError = AuthenticationError;
    exports2.AggregateAuthenticationErrorName = "AggregateAuthenticationError";
    var AggregateAuthenticationError = class extends Error {
      /**
       * The array of error objects that were thrown while trying to authenticate
       * with the credentials in a {@link ChainedTokenCredential}.
       */
      errors;
      constructor(errors, errorMessage) {
        const errorDetail = errors.join("\n");
        super(`${errorMessage}
${errorDetail}`);
        this.errors = errors;
        this.name = exports2.AggregateAuthenticationErrorName;
      }
    };
    exports2.AggregateAuthenticationError = AggregateAuthenticationError;
    function convertOAuthErrorResponseToErrorResponse(errorBody) {
      return {
        error: errorBody.error,
        errorDescription: errorBody.error_description,
        correlationId: errorBody.correlation_id,
        errorCodes: errorBody.error_codes,
        timestamp: errorBody.timestamp,
        traceId: errorBody.trace_id
      };
    }
    var AuthenticationRequiredError = class extends Error {
      /**
       * The list of scopes for which the token will have access.
       */
      scopes;
      /**
       * The options passed to the getToken request.
       */
      getTokenOptions;
      constructor(options) {
        super(options.message, options.cause ? { cause: options.cause } : void 0);
        this.scopes = options.scopes;
        this.getTokenOptions = options.getTokenOptions;
        this.name = "AuthenticationRequiredError";
      }
    };
    exports2.AuthenticationRequiredError = AuthenticationRequiredError;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/log.js
var require_log = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/log.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.log = log2;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_os_1 = require("node:os");
    var node_util_1 = tslib_1.__importDefault(require("node:util"));
    var node_process_1 = tslib_1.__importDefault(require("node:process"));
    function log2(message, ...args) {
      node_process_1.default.stderr.write(`${node_util_1.default.format(message, ...args)}${node_os_1.EOL}`);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/debug.js
var require_debug = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/debug.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var log_js_1 = require_log();
    var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
    var enabledString;
    var enabledNamespaces = [];
    var skippedNamespaces = [];
    var debuggers = [];
    if (debugEnvVariable) {
      enable(debugEnvVariable);
    }
    var debugObj = Object.assign((namespace) => {
      return createDebugger(namespace);
    }, {
      enable,
      enabled,
      disable,
      log: log_js_1.log
    });
    function enable(namespaces) {
      enabledString = namespaces;
      enabledNamespaces = [];
      skippedNamespaces = [];
      const namespaceList = namespaces.split(",").map((ns) => ns.trim());
      for (const ns of namespaceList) {
        if (ns.startsWith("-")) {
          skippedNamespaces.push(ns.substring(1));
        } else {
          enabledNamespaces.push(ns);
        }
      }
      for (const instance of debuggers) {
        instance.enabled = enabled(instance.namespace);
      }
    }
    function enabled(namespace) {
      if (namespace.endsWith("*")) {
        return true;
      }
      for (const skipped of skippedNamespaces) {
        if (namespaceMatches(namespace, skipped)) {
          return false;
        }
      }
      for (const enabledNamespace of enabledNamespaces) {
        if (namespaceMatches(namespace, enabledNamespace)) {
          return true;
        }
      }
      return false;
    }
    function namespaceMatches(namespace, patternToMatch) {
      if (patternToMatch.indexOf("*") === -1) {
        return namespace === patternToMatch;
      }
      let pattern = patternToMatch;
      if (patternToMatch.indexOf("**") !== -1) {
        const patternParts = [];
        let lastCharacter = "";
        for (const character of patternToMatch) {
          if (character === "*" && lastCharacter === "*") {
            continue;
          } else {
            lastCharacter = character;
            patternParts.push(character);
          }
        }
        pattern = patternParts.join("");
      }
      let namespaceIndex = 0;
      let patternIndex = 0;
      const patternLength = pattern.length;
      const namespaceLength = namespace.length;
      let lastWildcard = -1;
      let lastWildcardNamespace = -1;
      while (namespaceIndex < namespaceLength && patternIndex < patternLength) {
        if (pattern[patternIndex] === "*") {
          lastWildcard = patternIndex;
          patternIndex++;
          if (patternIndex === patternLength) {
            return true;
          }
          while (namespace[namespaceIndex] !== pattern[patternIndex]) {
            namespaceIndex++;
            if (namespaceIndex === namespaceLength) {
              return false;
            }
          }
          lastWildcardNamespace = namespaceIndex;
          namespaceIndex++;
          patternIndex++;
          continue;
        } else if (pattern[patternIndex] === namespace[namespaceIndex]) {
          patternIndex++;
          namespaceIndex++;
        } else if (lastWildcard >= 0) {
          patternIndex = lastWildcard + 1;
          namespaceIndex = lastWildcardNamespace + 1;
          if (namespaceIndex === namespaceLength) {
            return false;
          }
          while (namespace[namespaceIndex] !== pattern[patternIndex]) {
            namespaceIndex++;
            if (namespaceIndex === namespaceLength) {
              return false;
            }
          }
          lastWildcardNamespace = namespaceIndex;
          namespaceIndex++;
          patternIndex++;
          continue;
        } else {
          return false;
        }
      }
      const namespaceDone = namespaceIndex === namespace.length;
      const patternDone = patternIndex === pattern.length;
      const trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === "*";
      return namespaceDone && (patternDone || trailingWildCard);
    }
    function disable() {
      const result = enabledString || "";
      enable("");
      return result;
    }
    function createDebugger(namespace) {
      const newDebugger = Object.assign(debug, {
        enabled: enabled(namespace),
        destroy,
        log: debugObj.log,
        namespace,
        extend
      });
      function debug(...args) {
        if (!newDebugger.enabled) {
          return;
        }
        if (args.length > 0) {
          args[0] = `${namespace} ${args[0]}`;
        }
        newDebugger.log(...args);
      }
      debuggers.push(newDebugger);
      return newDebugger;
    }
    function destroy() {
      const index = debuggers.indexOf(this);
      if (index >= 0) {
        debuggers.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace) {
      const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
      newDebugger.log = this.log;
      return newDebugger;
    }
    exports2.default = debugObj;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/logger.js
var require_logger = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeSpecRuntimeLogger = void 0;
    exports2.createLoggerContext = createLoggerContext;
    exports2.setLogLevel = setLogLevel;
    exports2.getLogLevel = getLogLevel;
    exports2.createClientLogger = createClientLogger;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var debug_js_1 = tslib_1.__importDefault(require_debug());
    var TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    var levelMap = {
      verbose: 400,
      info: 300,
      warning: 200,
      error: 100
    };
    function patchLogMethod(parent, child) {
      child.log = (...args) => {
        parent.log(...args);
      };
    }
    function isTypeSpecRuntimeLogLevel(level) {
      return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
    }
    function createLoggerContext(options) {
      const registeredLoggers = /* @__PURE__ */ new Set();
      const logLevelFromEnv = typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName] || void 0;
      let logLevel;
      const clientLogger = (0, debug_js_1.default)(options.namespace);
      clientLogger.log = (...args) => {
        debug_js_1.default.log(...args);
      };
      function contextSetLogLevel(level) {
        if (level && !isTypeSpecRuntimeLogLevel(level)) {
          throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
        }
        logLevel = level;
        const enabledNamespaces = [];
        for (const logger of registeredLoggers) {
          if (shouldEnable(logger)) {
            enabledNamespaces.push(logger.namespace);
          }
        }
        debug_js_1.default.enable(enabledNamespaces.join(","));
      }
      if (logLevelFromEnv) {
        if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
          contextSetLogLevel(logLevelFromEnv);
        } else {
          console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
        }
      }
      function shouldEnable(logger) {
        return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);
      }
      function createLogger(parent, level) {
        const logger = Object.assign(parent.extend(level), {
          level
        });
        patchLogMethod(parent, logger);
        if (shouldEnable(logger)) {
          const enabledNamespaces = debug_js_1.default.disable();
          debug_js_1.default.enable(enabledNamespaces + "," + logger.namespace);
        }
        registeredLoggers.add(logger);
        return logger;
      }
      function contextGetLogLevel() {
        return logLevel;
      }
      function contextCreateClientLogger(namespace) {
        const clientRootLogger = clientLogger.extend(namespace);
        patchLogMethod(clientLogger, clientRootLogger);
        return {
          error: createLogger(clientRootLogger, "error"),
          warning: createLogger(clientRootLogger, "warning"),
          info: createLogger(clientRootLogger, "info"),
          verbose: createLogger(clientRootLogger, "verbose")
        };
      }
      return {
        setLogLevel: contextSetLogLevel,
        getLogLevel: contextGetLogLevel,
        createClientLogger: contextCreateClientLogger,
        logger: clientLogger
      };
    }
    var context = createLoggerContext({
      logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
      namespace: "typeSpecRuntime"
    });
    exports2.TypeSpecRuntimeLogger = context.logger;
    function setLogLevel(logLevel) {
      context.setLogLevel(logLevel);
    }
    function getLogLevel() {
      return context.getLogLevel();
    }
    function createClientLogger(namespace) {
      return context.createClientLogger(namespace);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/internal.js
var require_internal = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/internal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLoggerContext = void 0;
    var logger_js_1 = require_logger();
    Object.defineProperty(exports2, "createLoggerContext", { enumerable: true, get: function() {
      return logger_js_1.createLoggerContext;
    } });
  }
});

// node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/@azure/logger/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureLogger = void 0;
    exports2.setLogLevel = setLogLevel;
    exports2.getLogLevel = getLogLevel;
    exports2.createClientLogger = createClientLogger;
    var logger_1 = require_internal();
    var context = (0, logger_1.createLoggerContext)({
      logLevelEnvVarName: "AZURE_LOG_LEVEL",
      namespace: "azure"
    });
    exports2.AzureLogger = context.logger;
    function setLogLevel(level) {
      context.setLogLevel(level);
    }
    function getLogLevel() {
      return context.getLogLevel();
    }
    function createClientLogger(namespace) {
      return context.createClientLogger(namespace);
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/util/logging.js
var require_logging = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/util/logging.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logger = void 0;
    exports2.processEnvVars = processEnvVars;
    exports2.logEnvVars = logEnvVars;
    exports2.formatSuccess = formatSuccess;
    exports2.formatError = formatError;
    exports2.credentialLoggerInstance = credentialLoggerInstance;
    exports2.credentialLogger = credentialLogger;
    var logger_1 = require_commonjs();
    exports2.logger = (0, logger_1.createClientLogger)("identity");
    function processEnvVars(supportedEnvVars) {
      return supportedEnvVars.reduce((acc, envVariable) => {
        if (process.env[envVariable]) {
          acc.assigned.push(envVariable);
        } else {
          acc.missing.push(envVariable);
        }
        return acc;
      }, { missing: [], assigned: [] });
    }
    function logEnvVars(credentialName, supportedEnvVars) {
      const { assigned } = processEnvVars(supportedEnvVars);
      exports2.logger.info(`${credentialName} => Found the following environment variables: ${assigned.join(", ")}`);
    }
    function formatSuccess(scope) {
      return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
    }
    function formatError(scope, error) {
      let message = "ERROR.";
      if (scope?.length) {
        message += ` Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
      }
      return `${message} Error message: ${typeof error === "string" ? error : error.message}.`;
    }
    function credentialLoggerInstance(title, parent, log2 = exports2.logger) {
      const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;
      function info(message) {
        log2.info(`${fullTitle} =>`, message);
      }
      function warning(message) {
        log2.warning(`${fullTitle} =>`, message);
      }
      function verbose(message) {
        log2.verbose(`${fullTitle} =>`, message);
      }
      function error(message) {
        log2.error(`${fullTitle} =>`, message);
      }
      return {
        title,
        fullTitle,
        info,
        warning,
        verbose,
        error
      };
    }
    function credentialLogger(title, log2 = exports2.logger) {
      const credLogger = credentialLoggerInstance(title, void 0, log2);
      return {
        ...credLogger,
        parent: log2,
        getToken: credentialLoggerInstance("=> getToken()", credLogger, log2)
      };
    }
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js
var require_tracingContext = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TracingContextImpl = exports2.knownContextKeys = void 0;
    exports2.createTracingContext = createTracingContext;
    exports2.knownContextKeys = {
      span: Symbol.for("@azure/core-tracing span"),
      namespace: Symbol.for("@azure/core-tracing namespace")
    };
    function createTracingContext(options = {}) {
      let context = new TracingContextImpl(options.parentContext);
      if (options.span) {
        context = context.setValue(exports2.knownContextKeys.span, options.span);
      }
      if (options.namespace) {
        context = context.setValue(exports2.knownContextKeys.namespace, options.namespace);
      }
      return context;
    }
    var TracingContextImpl = class _TracingContextImpl {
      _contextMap;
      constructor(initialContext) {
        this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
      }
      setValue(key, value) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
      }
      getValue(key) {
        return this._contextMap.get(key);
      }
      deleteValue(key) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
      }
    };
    exports2.TracingContextImpl = TracingContextImpl;
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/state.js
var require_state = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.state = void 0;
    exports2.state = {
      instrumenterImplementation: void 0
    };
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js
var require_instrumenter = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultTracingSpan = createDefaultTracingSpan;
    exports2.createDefaultInstrumenter = createDefaultInstrumenter;
    exports2.useInstrumenter = useInstrumenter;
    exports2.getInstrumenter = getInstrumenter;
    var tracingContext_js_1 = require_tracingContext();
    var state_js_1 = require_state();
    function createDefaultTracingSpan() {
      return {
        end: () => {
        },
        isRecording: () => false,
        recordException: () => {
        },
        setAttribute: () => {
        },
        setStatus: () => {
        },
        addEvent: () => {
        }
      };
    }
    function createDefaultInstrumenter() {
      return {
        createRequestHeaders: () => {
          return {};
        },
        parseTraceparentHeader: () => {
          return void 0;
        },
        startSpan: (_name, spanOptions) => {
          return {
            span: createDefaultTracingSpan(),
            tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
          };
        },
        withContext(_context, callback, ...callbackArgs) {
          return callback(...callbackArgs);
        }
      };
    }
    function useInstrumenter(instrumenter) {
      state_js_1.state.instrumenterImplementation = instrumenter;
    }
    function getInstrumenter() {
      if (!state_js_1.state.instrumenterImplementation) {
        state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
      }
      return state_js_1.state.instrumenterImplementation;
    }
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js
var require_tracingClient = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTracingClient = createTracingClient;
    var instrumenter_js_1 = require_instrumenter();
    var tracingContext_js_1 = require_tracingContext();
    function createTracingClient(options) {
      const { namespace, packageName, packageVersion } = options;
      function startSpan(name, operationOptions, spanOptions) {
        const startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, {
          ...spanOptions,
          packageName,
          packageVersion,
          tracingContext: operationOptions?.tracingOptions?.tracingContext
        });
        let tracingContext = startSpanResult.tracingContext;
        const span = startSpanResult.span;
        if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace)) {
          tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
        }
        span.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
        const updatedOptions = Object.assign({}, operationOptions, {
          tracingOptions: { ...operationOptions?.tracingOptions, tracingContext }
        });
        return {
          span,
          updatedOptions
        };
      }
      async function withSpan(name, operationOptions, callback, spanOptions) {
        const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
        try {
          const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
          span.setStatus({ status: "success" });
          return result;
        } catch (err) {
          span.setStatus({ status: "error", error: err });
          throw err;
        } finally {
          span.end();
        }
      }
      function withContext(context, callback, ...callbackArgs) {
        return (0, instrumenter_js_1.getInstrumenter)().withContext(context, callback, ...callbackArgs);
      }
      function parseTraceparentHeader(traceparentHeader) {
        return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
      }
      function createRequestHeaders(tracingContext) {
        return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
      }
      return {
        startSpan,
        withSpan,
        withContext,
        parseTraceparentHeader,
        createRequestHeaders
      };
    }
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "node_modules/@azure/core-tracing/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTracingClient = exports2.useInstrumenter = void 0;
    var instrumenter_js_1 = require_instrumenter();
    Object.defineProperty(exports2, "useInstrumenter", { enumerable: true, get: function() {
      return instrumenter_js_1.useInstrumenter;
    } });
    var tracingClient_js_1 = require_tracingClient();
    Object.defineProperty(exports2, "createTracingClient", { enumerable: true, get: function() {
      return tracingClient_js_1.createTracingClient;
    } });
  }
});

// node_modules/@azure/identity/dist/commonjs/util/tracing.js
var require_tracing = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/util/tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tracingClient = void 0;
    var constants_js_1 = require_constants();
    var core_tracing_1 = require_commonjs2();
    exports2.tracingClient = (0, core_tracing_1.createTracingClient)({
      namespace: "Microsoft.AAD",
      packageName: "@azure/identity",
      packageVersion: constants_js_1.SDK_VERSION
    });
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/chainedTokenCredential.js
var require_chainedTokenCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/chainedTokenCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChainedTokenCredential = exports2.logger = void 0;
    var errors_js_1 = require_errors();
    var logging_js_1 = require_logging();
    var tracing_js_1 = require_tracing();
    exports2.logger = (0, logging_js_1.credentialLogger)("ChainedTokenCredential");
    var ChainedTokenCredential = class {
      _sources = [];
      /**
       * Creates an instance of ChainedTokenCredential using the given credentials.
       *
       * @param sources - `TokenCredential` implementations to be tried in order.
       *
       * Example usage:
       * ```ts snippet:chained_token_credential_example
       * import { ClientSecretCredential, ChainedTokenCredential } from "@azure/identity";
       *
       * const tenantId = "<tenant-id>";
       * const clientId = "<client-id>";
       * const clientSecret = "<client-secret>";
       * const anotherClientId = "<another-client-id>";
       * const anotherSecret = "<another-client-secret>";
       *
       * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
       * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
       *
       * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
       * ```
       */
      constructor(...sources) {
        this._sources = sources;
      }
      /**
       * Returns the first access token returned by one of the chained
       * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
       * when one or more credentials throws an {@link AuthenticationError} and
       * no credentials have returned an access token.
       *
       * This method is called automatically by Azure SDK client libraries. You may call this method
       * directly, but you must also handle token caching and token refreshing.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                `TokenCredential` implementation might make.
       */
      async getToken(scopes, options = {}) {
        const { token } = await this.getTokenInternal(scopes, options);
        return token;
      }
      async getTokenInternal(scopes, options = {}) {
        let token = null;
        let successfulCredential;
        const errors = [];
        return tracing_js_1.tracingClient.withSpan("ChainedTokenCredential.getToken", options, async (updatedOptions) => {
          for (let i = 0; i < this._sources.length && token === null; i++) {
            try {
              token = await this._sources[i].getToken(scopes, updatedOptions);
              successfulCredential = this._sources[i];
            } catch (err) {
              if (err.name === "CredentialUnavailableError" || err.name === "AuthenticationRequiredError") {
                errors.push(err);
              } else {
                exports2.logger.getToken.info((0, logging_js_1.formatError)(scopes, err));
                throw err;
              }
            }
          }
          if (!token && errors.length > 0) {
            const err = new errors_js_1.AggregateAuthenticationError(errors, "ChainedTokenCredential authentication failed.");
            exports2.logger.getToken.info((0, logging_js_1.formatError)(scopes, err));
            throw err;
          }
          exports2.logger.getToken.info(`Result for ${successfulCredential.constructor.name}: ${(0, logging_js_1.formatSuccess)(scopes)}`);
          if (token === null) {
            throw new errors_js_1.CredentialUnavailableError("Failed to retrieve a valid token");
          }
          return { token, successfulCredential };
        });
      }
    };
    exports2.ChainedTokenCredential = ChainedTokenCredential;
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-node/md5.js"() {
    import_crypto2 = __toESM(require("crypto"));
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto3.default.createHash("sha1").update(bytes).digest();
}
var import_crypto3, sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-node/sha1.js"() {
    import_crypto3 = __toESM(require("crypto"));
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/@azure/msal-common/lib/index-node-BtzY9XyU.js
var require_index_node_BtzY9XyU = __commonJS({
  "node_modules/@azure/msal-common/lib/index-node-BtzY9XyU.js"(exports2) {
    "use strict";
    var Constants = {
      LIBRARY_NAME: "MSAL.JS",
      SKU: "msal.js.common",
      // default authority
      DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
      DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
      DEFAULT_COMMON_TENANT: "common",
      // ADFS String
      ADFS: "adfs",
      DSTS: "dstsv2",
      // Default AAD Instance Discovery Endpoint
      AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
      // CIAM URL
      CIAM_AUTH_URL: ".ciamlogin.com",
      AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
      // Resource delimiter - used for certain cache entries
      RESOURCE_DELIM: "|",
      // Placeholder for non-existent account ids/objects
      NO_ACCOUNT: "NO_ACCOUNT",
      // Claims
      CLAIMS: "claims",
      // Consumer UTID
      CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
      // Default scopes
      OPENID_SCOPE: "openid",
      PROFILE_SCOPE: "profile",
      OFFLINE_ACCESS_SCOPE: "offline_access",
      EMAIL_SCOPE: "email",
      CODE_GRANT_TYPE: "authorization_code",
      RT_GRANT_TYPE: "refresh_token",
      S256_CODE_CHALLENGE_METHOD: "S256",
      URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
      AUTHORIZATION_PENDING: "authorization_pending",
      NOT_DEFINED: "not_defined",
      EMPTY_STRING: "",
      NOT_APPLICABLE: "N/A",
      NOT_AVAILABLE: "Not Available",
      FORWARD_SLASH: "/",
      IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
      IMDS_VERSION: "2020-06-01",
      IMDS_TIMEOUT: 2e3,
      AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
      REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
      KNOWN_PUBLIC_CLOUDS: [
        "login.microsoftonline.com",
        "login.windows.net",
        "login.microsoft.com",
        "sts.windows.net"
      ],
      SHR_NONCE_VALIDITY: 240,
      INVALID_INSTANCE: "invalid_instance"
    };
    var HttpStatus = {
      SUCCESS: 200,
      SUCCESS_RANGE_START: 200,
      SUCCESS_RANGE_END: 299,
      REDIRECT: 302,
      CLIENT_ERROR: 400,
      CLIENT_ERROR_RANGE_START: 400,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      NOT_FOUND: 404,
      REQUEST_TIMEOUT: 408,
      GONE: 410,
      TOO_MANY_REQUESTS: 429,
      CLIENT_ERROR_RANGE_END: 499,
      SERVER_ERROR: 500,
      SERVER_ERROR_RANGE_START: 500,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      SERVER_ERROR_RANGE_END: 599,
      MULTI_SIDED_ERROR: 600
    };
    var HttpMethod = {
      GET: "GET",
      POST: "POST"
    };
    var OIDC_DEFAULT_SCOPES = [
      Constants.OPENID_SCOPE,
      Constants.PROFILE_SCOPE,
      Constants.OFFLINE_ACCESS_SCOPE
    ];
    var OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants.EMAIL_SCOPE];
    var HeaderNames = {
      CONTENT_TYPE: "Content-Type",
      CONTENT_LENGTH: "Content-Length",
      RETRY_AFTER: "Retry-After",
      CCS_HEADER: "X-AnchorMailbox",
      WWWAuthenticate: "WWW-Authenticate",
      AuthenticationInfo: "Authentication-Info",
      X_MS_REQUEST_ID: "x-ms-request-id",
      X_MS_HTTP_VERSION: "x-ms-httpver"
    };
    var PersistentCacheKeys = {
      ACTIVE_ACCOUNT_FILTERS: "active-account-filters"
      // new cache entry for active_account for a more robust version for browser
    };
    var AADAuthorityConstants = {
      COMMON: "common",
      ORGANIZATIONS: "organizations",
      CONSUMERS: "consumers"
    };
    var ClaimsRequestKeys = {
      ACCESS_TOKEN: "access_token",
      XMS_CC: "xms_cc"
    };
    var PromptValue = {
      LOGIN: "login",
      SELECT_ACCOUNT: "select_account",
      CONSENT: "consent",
      NONE: "none",
      CREATE: "create",
      NO_SESSION: "no_session"
    };
    var CodeChallengeMethodValues = {
      PLAIN: "plain",
      S256: "S256"
    };
    var OAuthResponseType = {
      CODE: "code",
      IDTOKEN_TOKEN: "id_token token",
      IDTOKEN_TOKEN_REFRESHTOKEN: "id_token token refresh_token"
    };
    var ServerResponseType = {
      QUERY: "query",
      FRAGMENT: "fragment"
    };
    var ResponseMode = {
      QUERY: "query",
      FRAGMENT: "fragment",
      FORM_POST: "form_post"
    };
    var GrantType = {
      IMPLICIT_GRANT: "implicit",
      AUTHORIZATION_CODE_GRANT: "authorization_code",
      CLIENT_CREDENTIALS_GRANT: "client_credentials",
      RESOURCE_OWNER_PASSWORD_GRANT: "password",
      REFRESH_TOKEN_GRANT: "refresh_token",
      DEVICE_CODE_GRANT: "device_code",
      JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer"
    };
    var CacheAccountType = {
      MSSTS_ACCOUNT_TYPE: "MSSTS",
      ADFS_ACCOUNT_TYPE: "ADFS",
      MSAV1_ACCOUNT_TYPE: "MSA",
      GENERIC_ACCOUNT_TYPE: "Generic"
      // NTLM, Kerberos, FBA, Basic etc
    };
    var Separators = {
      CACHE_KEY_SEPARATOR: "-",
      CLIENT_INFO_SEPARATOR: "."
    };
    var CredentialType = {
      ID_TOKEN: "IdToken",
      ACCESS_TOKEN: "AccessToken",
      ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",
      REFRESH_TOKEN: "RefreshToken"
    };
    var CacheType = {
      ADFS: 1001,
      MSA: 1002,
      MSSTS: 1003,
      GENERIC: 1004,
      ACCESS_TOKEN: 2001,
      REFRESH_TOKEN: 2002,
      ID_TOKEN: 2003,
      APP_METADATA: 3001,
      UNDEFINED: 9999
    };
    var APP_METADATA = "appmetadata";
    var CLIENT_INFO$1 = "client_info";
    var THE_FAMILY_ID = "1";
    var AUTHORITY_METADATA_CONSTANTS = {
      CACHE_KEY: "authority-metadata",
      REFRESH_TIME_SECONDS: 3600 * 24
      // 24 Hours
    };
    var AuthorityMetadataSource = {
      CONFIG: "config",
      CACHE: "cache",
      NETWORK: "network",
      HARDCODED_VALUES: "hardcoded_values"
    };
    var SERVER_TELEM_CONSTANTS = {
      SCHEMA_VERSION: 5,
      MAX_LAST_HEADER_BYTES: 330,
      MAX_CACHED_ERRORS: 50,
      CACHE_KEY: "server-telemetry",
      CATEGORY_SEPARATOR: "|",
      VALUE_SEPARATOR: ",",
      OVERFLOW_TRUE: "1",
      OVERFLOW_FALSE: "0",
      UNKNOWN_ERROR: "unknown_error"
    };
    var AuthenticationScheme = {
      BEARER: "Bearer",
      POP: "pop",
      SSH: "ssh-cert"
    };
    var ThrottlingConstants = {
      // Default time to throttle RequestThumbprint in seconds
      DEFAULT_THROTTLE_TIME_SECONDS: 60,
      // Default maximum time to throttle in seconds, overrides what the server sends back
      DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
      // Prefix for storing throttling entries
      THROTTLING_PREFIX: "throttling",
      // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
      X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
    };
    var Errors = {
      INVALID_GRANT_ERROR: "invalid_grant",
      CLIENT_MISMATCH_ERROR: "client_mismatch"
    };
    var PasswordGrantConstants = {
      username: "username",
      password: "password"
    };
    var RegionDiscoverySources = {
      FAILED_AUTO_DETECTION: "1",
      INTERNAL_CACHE: "2",
      ENVIRONMENT_VARIABLE: "3",
      IMDS: "4"
    };
    var RegionDiscoveryOutcomes = {
      CONFIGURED_NO_AUTO_DETECTION: "2",
      AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",
      AUTO_DETECTION_REQUESTED_FAILED: "5"
    };
    var CacheOutcome = {
      // When a token is found in the cache or the cache is not supposed to be hit when making the request
      NOT_APPLICABLE: "0",
      // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
      FORCE_REFRESH_OR_CLAIMS: "1",
      // When the token request goes to the identity provider because no cached access token exists
      NO_CACHED_ACCESS_TOKEN: "2",
      // When the token request goes to the identity provider because cached access token expired
      CACHED_ACCESS_TOKEN_EXPIRED: "3",
      // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
      PROACTIVELY_REFRESHED: "4"
    };
    var JsonWebTokenTypes = {
      Jwt: "JWT",
      Jwk: "JWK",
      Pop: "pop"
    };
    var ONE_DAY_IN_MS = 864e5;
    var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
    var EncodingTypes = {
      BASE64: "base64",
      HEX: "hex",
      UTF8: "utf-8"
    };
    var unexpectedError = "unexpected_error";
    var postRequestFailed = "post_request_failed";
    var AuthErrorCodes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      postRequestFailed,
      unexpectedError
    });
    var AuthErrorMessages = {
      [unexpectedError]: "Unexpected error in authentication.",
      [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
    };
    var AuthErrorMessage = {
      unexpectedError: {
        code: unexpectedError,
        desc: AuthErrorMessages[unexpectedError]
      },
      postRequestFailed: {
        code: postRequestFailed,
        desc: AuthErrorMessages[postRequestFailed]
      }
    };
    var AuthError = class _AuthError extends Error {
      constructor(errorCode, errorMessage, suberror) {
        const errorString = errorMessage ? `${errorCode}: ${errorMessage}` : errorCode;
        super(errorString);
        Object.setPrototypeOf(this, _AuthError.prototype);
        this.errorCode = errorCode || Constants.EMPTY_STRING;
        this.errorMessage = errorMessage || Constants.EMPTY_STRING;
        this.subError = suberror || Constants.EMPTY_STRING;
        this.name = "AuthError";
      }
      setCorrelationId(correlationId) {
        this.correlationId = correlationId;
      }
    };
    function createAuthError(code, additionalMessage) {
      return new AuthError(code, additionalMessage ? `${AuthErrorMessages[code]} ${additionalMessage}` : AuthErrorMessages[code]);
    }
    var clientInfoDecodingError = "client_info_decoding_error";
    var clientInfoEmptyError = "client_info_empty_error";
    var tokenParsingError = "token_parsing_error";
    var nullOrEmptyToken = "null_or_empty_token";
    var endpointResolutionError = "endpoints_resolution_error";
    var networkError = "network_error";
    var openIdConfigError = "openid_config_error";
    var hashNotDeserialized = "hash_not_deserialized";
    var invalidState = "invalid_state";
    var stateMismatch = "state_mismatch";
    var stateNotFound = "state_not_found";
    var nonceMismatch = "nonce_mismatch";
    var authTimeNotFound = "auth_time_not_found";
    var maxAgeTranspired = "max_age_transpired";
    var multipleMatchingTokens = "multiple_matching_tokens";
    var multipleMatchingAccounts = "multiple_matching_accounts";
    var multipleMatchingAppMetadata = "multiple_matching_appMetadata";
    var requestCannotBeMade = "request_cannot_be_made";
    var cannotRemoveEmptyScope = "cannot_remove_empty_scope";
    var cannotAppendScopeSet = "cannot_append_scopeset";
    var emptyInputScopeSet = "empty_input_scopeset";
    var deviceCodePollingCancelled = "device_code_polling_cancelled";
    var deviceCodeExpired = "device_code_expired";
    var deviceCodeUnknownError = "device_code_unknown_error";
    var noAccountInSilentRequest = "no_account_in_silent_request";
    var invalidCacheRecord = "invalid_cache_record";
    var invalidCacheEnvironment = "invalid_cache_environment";
    var noAccountFound = "no_account_found";
    var noCryptoObject = "no_crypto_object";
    var unexpectedCredentialType = "unexpected_credential_type";
    var invalidAssertion = "invalid_assertion";
    var invalidClientCredential = "invalid_client_credential";
    var tokenRefreshRequired = "token_refresh_required";
    var userTimeoutReached = "user_timeout_reached";
    var tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";
    var authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";
    var bindingKeyNotRemoved = "binding_key_not_removed";
    var endSessionEndpointNotSupported = "end_session_endpoint_not_supported";
    var keyIdMissing = "key_id_missing";
    var noNetworkConnectivity = "no_network_connectivity";
    var userCanceled = "user_canceled";
    var missingTenantIdError = "missing_tenant_id_error";
    var methodNotImplemented = "method_not_implemented";
    var nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";
    var platformBrokerError = "platform_broker_error";
    var ClientAuthErrorCodes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      authTimeNotFound,
      authorizationCodeMissingFromServerResponse,
      bindingKeyNotRemoved,
      cannotAppendScopeSet,
      cannotRemoveEmptyScope,
      clientInfoDecodingError,
      clientInfoEmptyError,
      deviceCodeExpired,
      deviceCodePollingCancelled,
      deviceCodeUnknownError,
      emptyInputScopeSet,
      endSessionEndpointNotSupported,
      endpointResolutionError,
      hashNotDeserialized,
      invalidAssertion,
      invalidCacheEnvironment,
      invalidCacheRecord,
      invalidClientCredential,
      invalidState,
      keyIdMissing,
      maxAgeTranspired,
      methodNotImplemented,
      missingTenantIdError,
      multipleMatchingAccounts,
      multipleMatchingAppMetadata,
      multipleMatchingTokens,
      nestedAppAuthBridgeDisabled,
      networkError,
      noAccountFound,
      noAccountInSilentRequest,
      noCryptoObject,
      noNetworkConnectivity,
      nonceMismatch,
      nullOrEmptyToken,
      openIdConfigError,
      platformBrokerError,
      requestCannotBeMade,
      stateMismatch,
      stateNotFound,
      tokenClaimsCnfRequiredForSignedJwt,
      tokenParsingError,
      tokenRefreshRequired,
      unexpectedCredentialType,
      userCanceled,
      userTimeoutReached
    });
    var ClientAuthErrorMessages = {
      [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",
      [clientInfoEmptyError]: "The client info was empty",
      [tokenParsingError]: "Token cannot be parsed",
      [nullOrEmptyToken]: "The token is null or empty",
      [endpointResolutionError]: "Endpoints cannot be resolved",
      [networkError]: "Network request failed",
      [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",
      [hashNotDeserialized]: "The hash parameters could not be deserialized",
      [invalidState]: "State was not the expected format",
      [stateMismatch]: "State mismatch error",
      [stateNotFound]: "State not found",
      [nonceMismatch]: "Nonce mismatch error",
      [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information.",
      [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",
      [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account.",
      [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",
      [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",
      [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",
      [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",
      [cannotAppendScopeSet]: "Cannot append ScopeSet",
      [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",
      [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",
      [deviceCodeExpired]: "Device code is expired.",
      [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",
      [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",
      [invalidCacheRecord]: "Cache record object was null or undefined.",
      [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",
      [noAccountFound]: "No account found in cache for given key.",
      [noCryptoObject]: "No crypto object detected.",
      [unexpectedCredentialType]: "Unexpected credential type.",
      [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",
      [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",
      [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",
      [userTimeoutReached]: "User defined timeout for device code polling reached",
      [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",
      [authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",
      [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
      [endSessionEndpointNotSupported]: "The provided authority does not support logout",
      [keyIdMissing]: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
      [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",
      [userCanceled]: "User cancelled the flow.",
      [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",
      [methodNotImplemented]: "This method has not been implemented",
      [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled",
      [platformBrokerError]: "An error occurred in the native broker. See the platformBrokerError property for details."
    };
    var ClientAuthErrorMessage = {
      clientInfoDecodingError: {
        code: clientInfoDecodingError,
        desc: ClientAuthErrorMessages[clientInfoDecodingError]
      },
      clientInfoEmptyError: {
        code: clientInfoEmptyError,
        desc: ClientAuthErrorMessages[clientInfoEmptyError]
      },
      tokenParsingError: {
        code: tokenParsingError,
        desc: ClientAuthErrorMessages[tokenParsingError]
      },
      nullOrEmptyToken: {
        code: nullOrEmptyToken,
        desc: ClientAuthErrorMessages[nullOrEmptyToken]
      },
      endpointResolutionError: {
        code: endpointResolutionError,
        desc: ClientAuthErrorMessages[endpointResolutionError]
      },
      networkError: {
        code: networkError,
        desc: ClientAuthErrorMessages[networkError]
      },
      unableToGetOpenidConfigError: {
        code: openIdConfigError,
        desc: ClientAuthErrorMessages[openIdConfigError]
      },
      hashNotDeserialized: {
        code: hashNotDeserialized,
        desc: ClientAuthErrorMessages[hashNotDeserialized]
      },
      invalidStateError: {
        code: invalidState,
        desc: ClientAuthErrorMessages[invalidState]
      },
      stateMismatchError: {
        code: stateMismatch,
        desc: ClientAuthErrorMessages[stateMismatch]
      },
      stateNotFoundError: {
        code: stateNotFound,
        desc: ClientAuthErrorMessages[stateNotFound]
      },
      nonceMismatchError: {
        code: nonceMismatch,
        desc: ClientAuthErrorMessages[nonceMismatch]
      },
      authTimeNotFoundError: {
        code: authTimeNotFound,
        desc: ClientAuthErrorMessages[authTimeNotFound]
      },
      maxAgeTranspired: {
        code: maxAgeTranspired,
        desc: ClientAuthErrorMessages[maxAgeTranspired]
      },
      multipleMatchingTokens: {
        code: multipleMatchingTokens,
        desc: ClientAuthErrorMessages[multipleMatchingTokens]
      },
      multipleMatchingAccounts: {
        code: multipleMatchingAccounts,
        desc: ClientAuthErrorMessages[multipleMatchingAccounts]
      },
      multipleMatchingAppMetadata: {
        code: multipleMatchingAppMetadata,
        desc: ClientAuthErrorMessages[multipleMatchingAppMetadata]
      },
      tokenRequestCannotBeMade: {
        code: requestCannotBeMade,
        desc: ClientAuthErrorMessages[requestCannotBeMade]
      },
      removeEmptyScopeError: {
        code: cannotRemoveEmptyScope,
        desc: ClientAuthErrorMessages[cannotRemoveEmptyScope]
      },
      appendScopeSetError: {
        code: cannotAppendScopeSet,
        desc: ClientAuthErrorMessages[cannotAppendScopeSet]
      },
      emptyInputScopeSetError: {
        code: emptyInputScopeSet,
        desc: ClientAuthErrorMessages[emptyInputScopeSet]
      },
      DeviceCodePollingCancelled: {
        code: deviceCodePollingCancelled,
        desc: ClientAuthErrorMessages[deviceCodePollingCancelled]
      },
      DeviceCodeExpired: {
        code: deviceCodeExpired,
        desc: ClientAuthErrorMessages[deviceCodeExpired]
      },
      DeviceCodeUnknownError: {
        code: deviceCodeUnknownError,
        desc: ClientAuthErrorMessages[deviceCodeUnknownError]
      },
      NoAccountInSilentRequest: {
        code: noAccountInSilentRequest,
        desc: ClientAuthErrorMessages[noAccountInSilentRequest]
      },
      invalidCacheRecord: {
        code: invalidCacheRecord,
        desc: ClientAuthErrorMessages[invalidCacheRecord]
      },
      invalidCacheEnvironment: {
        code: invalidCacheEnvironment,
        desc: ClientAuthErrorMessages[invalidCacheEnvironment]
      },
      noAccountFound: {
        code: noAccountFound,
        desc: ClientAuthErrorMessages[noAccountFound]
      },
      noCryptoObj: {
        code: noCryptoObject,
        desc: ClientAuthErrorMessages[noCryptoObject]
      },
      unexpectedCredentialType: {
        code: unexpectedCredentialType,
        desc: ClientAuthErrorMessages[unexpectedCredentialType]
      },
      invalidAssertion: {
        code: invalidAssertion,
        desc: ClientAuthErrorMessages[invalidAssertion]
      },
      invalidClientCredential: {
        code: invalidClientCredential,
        desc: ClientAuthErrorMessages[invalidClientCredential]
      },
      tokenRefreshRequired: {
        code: tokenRefreshRequired,
        desc: ClientAuthErrorMessages[tokenRefreshRequired]
      },
      userTimeoutReached: {
        code: userTimeoutReached,
        desc: ClientAuthErrorMessages[userTimeoutReached]
      },
      tokenClaimsRequired: {
        code: tokenClaimsCnfRequiredForSignedJwt,
        desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt]
      },
      noAuthorizationCodeFromServer: {
        code: authorizationCodeMissingFromServerResponse,
        desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse]
      },
      bindingKeyNotRemovedError: {
        code: bindingKeyNotRemoved,
        desc: ClientAuthErrorMessages[bindingKeyNotRemoved]
      },
      logoutNotSupported: {
        code: endSessionEndpointNotSupported,
        desc: ClientAuthErrorMessages[endSessionEndpointNotSupported]
      },
      keyIdMissing: {
        code: keyIdMissing,
        desc: ClientAuthErrorMessages[keyIdMissing]
      },
      noNetworkConnectivity: {
        code: noNetworkConnectivity,
        desc: ClientAuthErrorMessages[noNetworkConnectivity]
      },
      userCanceledError: {
        code: userCanceled,
        desc: ClientAuthErrorMessages[userCanceled]
      },
      missingTenantIdError: {
        code: missingTenantIdError,
        desc: ClientAuthErrorMessages[missingTenantIdError]
      },
      nestedAppAuthBridgeDisabled: {
        code: nestedAppAuthBridgeDisabled,
        desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled]
      },
      platformBrokerError: {
        code: platformBrokerError,
        desc: ClientAuthErrorMessages[platformBrokerError]
      }
    };
    var ClientAuthError = class _ClientAuthError extends AuthError {
      constructor(errorCode, additionalMessage) {
        super(errorCode, additionalMessage ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}` : ClientAuthErrorMessages[errorCode]);
        this.name = "ClientAuthError";
        Object.setPrototypeOf(this, _ClientAuthError.prototype);
      }
    };
    function createClientAuthError(errorCode, additionalMessage) {
      return new ClientAuthError(errorCode, additionalMessage);
    }
    function extractTokenClaims(encodedToken, base64Decode) {
      const jswPayload = getJWSPayload(encodedToken);
      try {
        const base64Decoded = base64Decode(jswPayload);
        return JSON.parse(base64Decoded);
      } catch (err) {
        throw createClientAuthError(tokenParsingError);
      }
    }
    function isKmsi(idTokenClaims) {
      if (!idTokenClaims.signin_state) {
        return false;
      }
      const kmsiClaims = ["kmsi", "dvc_dmjd"];
      const kmsi = idTokenClaims.signin_state.some((value) => kmsiClaims.includes(value.trim().toLowerCase()));
      return kmsi;
    }
    function getJWSPayload(authToken) {
      if (!authToken) {
        throw createClientAuthError(nullOrEmptyToken);
      }
      const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
      const matches = tokenPartsRegex.exec(authToken);
      if (!matches || matches.length < 4) {
        throw createClientAuthError(tokenParsingError);
      }
      return matches[2];
    }
    function checkMaxAge(authTime, maxAge) {
      const fiveMinuteSkew = 3e5;
      if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
        throw createClientAuthError(maxAgeTranspired);
      }
    }
    var AuthToken = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      checkMaxAge,
      extractTokenClaims,
      getJWSPayload,
      isKmsi
    });
    var AuthorityType = {
      Default: 0,
      Adfs: 1,
      Dsts: 2,
      Ciam: 3
    };
    function isOpenIdConfigResponse(response) {
      return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
    }
    var redirectUriEmpty = "redirect_uri_empty";
    var claimsRequestParsingError = "claims_request_parsing_error";
    var authorityUriInsecure = "authority_uri_insecure";
    var urlParseError = "url_parse_error";
    var urlEmptyError = "empty_url_error";
    var emptyInputScopesError = "empty_input_scopes_error";
    var invalidClaims = "invalid_claims";
    var tokenRequestEmpty = "token_request_empty";
    var logoutRequestEmpty = "logout_request_empty";
    var invalidCodeChallengeMethod = "invalid_code_challenge_method";
    var pkceParamsMissing = "pkce_params_missing";
    var invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";
    var invalidAuthorityMetadata = "invalid_authority_metadata";
    var untrustedAuthority = "untrusted_authority";
    var missingSshJwk = "missing_ssh_jwk";
    var missingSshKid = "missing_ssh_kid";
    var missingNonceAuthenticationHeader = "missing_nonce_authentication_header";
    var invalidAuthenticationHeader = "invalid_authentication_header";
    var cannotSetOIDCOptions = "cannot_set_OIDCOptions";
    var cannotAllowPlatformBroker = "cannot_allow_platform_broker";
    var authorityMismatch = "authority_mismatch";
    var invalidRequestMethodForEAR = "invalid_request_method_for_EAR";
    var invalidAuthorizePostBodyParameters = "invalid_authorize_post_body_parameters";
    var invalidPlatformBrokerConfiguration = "invalid_platform_broker_configuration";
    var ClientConfigurationErrorCodes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      authorityMismatch,
      authorityUriInsecure,
      cannotAllowPlatformBroker,
      cannotSetOIDCOptions,
      claimsRequestParsingError,
      emptyInputScopesError,
      invalidAuthenticationHeader,
      invalidAuthorityMetadata,
      invalidAuthorizePostBodyParameters,
      invalidClaims,
      invalidCloudDiscoveryMetadata,
      invalidCodeChallengeMethod,
      invalidPlatformBrokerConfiguration,
      invalidRequestMethodForEAR,
      logoutRequestEmpty,
      missingNonceAuthenticationHeader,
      missingSshJwk,
      missingSshKid,
      pkceParamsMissing,
      redirectUriEmpty,
      tokenRequestEmpty,
      untrustedAuthority,
      urlEmptyError,
      urlParseError
    });
    var ClientConfigurationErrorMessages = {
      [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",
      [claimsRequestParsingError]: "Could not parse the given claims request object.",
      [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
      [urlParseError]: "URL could not be parsed into appropriate segments.",
      [urlEmptyError]: "URL was empty or null.",
      [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
      [invalidClaims]: "Given claims parameter must be a stringified JSON object.",
      [tokenRequestEmpty]: "Token request was empty and not found in cache.",
      [logoutRequestEmpty]: "The logout request was null or undefined.",
      [invalidCodeChallengeMethod]: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
      [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
      [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
      [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
      [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
      [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
      [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
      [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
      [invalidAuthenticationHeader]: "Invalid authentication header provided",
      [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",
      [cannotAllowPlatformBroker]: "Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.",
      [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority.",
      [invalidAuthorizePostBodyParameters]: "Invalid authorize post body parameters provided. If you are using authorizePostBodyParameters, the request method must be POST. Please check the request method and parameters.",
      [invalidRequestMethodForEAR]: "Invalid request method for EAR protocol mode. The request method cannot be GET when using EAR protocol mode. Please change the request method to POST.",
      [invalidPlatformBrokerConfiguration]: "Invalid platform broker configuration. `allowPlatformBrokerWithDOM` can only be enabled when `allowPlatformBroker` is enabled."
    };
    var ClientConfigurationErrorMessage = {
      redirectUriNotSet: {
        code: redirectUriEmpty,
        desc: ClientConfigurationErrorMessages[redirectUriEmpty]
      },
      claimsRequestParsingError: {
        code: claimsRequestParsingError,
        desc: ClientConfigurationErrorMessages[claimsRequestParsingError]
      },
      authorityUriInsecure: {
        code: authorityUriInsecure,
        desc: ClientConfigurationErrorMessages[authorityUriInsecure]
      },
      urlParseError: {
        code: urlParseError,
        desc: ClientConfigurationErrorMessages[urlParseError]
      },
      urlEmptyError: {
        code: urlEmptyError,
        desc: ClientConfigurationErrorMessages[urlEmptyError]
      },
      emptyScopesError: {
        code: emptyInputScopesError,
        desc: ClientConfigurationErrorMessages[emptyInputScopesError]
      },
      invalidClaimsRequest: {
        code: invalidClaims,
        desc: ClientConfigurationErrorMessages[invalidClaims]
      },
      tokenRequestEmptyError: {
        code: tokenRequestEmpty,
        desc: ClientConfigurationErrorMessages[tokenRequestEmpty]
      },
      logoutRequestEmptyError: {
        code: logoutRequestEmpty,
        desc: ClientConfigurationErrorMessages[logoutRequestEmpty]
      },
      invalidCodeChallengeMethod: {
        code: invalidCodeChallengeMethod,
        desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod]
      },
      invalidCodeChallengeParams: {
        code: pkceParamsMissing,
        desc: ClientConfigurationErrorMessages[pkceParamsMissing]
      },
      invalidCloudDiscoveryMetadata: {
        code: invalidCloudDiscoveryMetadata,
        desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata]
      },
      invalidAuthorityMetadata: {
        code: invalidAuthorityMetadata,
        desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata]
      },
      untrustedAuthority: {
        code: untrustedAuthority,
        desc: ClientConfigurationErrorMessages[untrustedAuthority]
      },
      missingSshJwk: {
        code: missingSshJwk,
        desc: ClientConfigurationErrorMessages[missingSshJwk]
      },
      missingSshKid: {
        code: missingSshKid,
        desc: ClientConfigurationErrorMessages[missingSshKid]
      },
      missingNonceAuthenticationHeader: {
        code: missingNonceAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader]
      },
      invalidAuthenticationHeader: {
        code: invalidAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader]
      },
      cannotSetOIDCOptions: {
        code: cannotSetOIDCOptions,
        desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions]
      },
      cannotAllowPlatformBroker: {
        code: cannotAllowPlatformBroker,
        desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker]
      },
      authorityMismatch: {
        code: authorityMismatch,
        desc: ClientConfigurationErrorMessages[authorityMismatch]
      },
      invalidAuthorizePostBodyParameters: {
        code: invalidAuthorizePostBodyParameters,
        desc: ClientConfigurationErrorMessages[invalidAuthorizePostBodyParameters]
      },
      invalidRequestMethodForEAR: {
        code: invalidRequestMethodForEAR,
        desc: ClientConfigurationErrorMessages[invalidRequestMethodForEAR]
      },
      invalidPlatformBrokerConfiguration: {
        code: invalidPlatformBrokerConfiguration,
        desc: ClientConfigurationErrorMessages[invalidPlatformBrokerConfiguration]
      }
    };
    var ClientConfigurationError = class _ClientConfigurationError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ClientConfigurationErrorMessages[errorCode]);
        this.name = "ClientConfigurationError";
        Object.setPrototypeOf(this, _ClientConfigurationError.prototype);
      }
    };
    function createClientConfigurationError(errorCode) {
      return new ClientConfigurationError(errorCode);
    }
    var StringUtils = class {
      /**
       * Check if stringified object is empty
       * @param strObj
       */
      static isEmptyObj(strObj) {
        if (strObj) {
          try {
            const obj = JSON.parse(strObj);
            return Object.keys(obj).length === 0;
          } catch (e) {
          }
        }
        return true;
      }
      static startsWith(str, search) {
        return str.indexOf(search) === 0;
      }
      static endsWith(str, search) {
        return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
      }
      /**
       * Parses string into an object.
       *
       * @param query
       */
      static queryStringToObject(query) {
        const obj = {};
        const params = query.split("&");
        const decode = (s) => decodeURIComponent(s.replace(/\+/g, " "));
        params.forEach((pair) => {
          if (pair.trim()) {
            const [key, value] = pair.split(/=(.+)/g, 2);
            if (key && value) {
              obj[decode(key)] = decode(value);
            }
          }
        });
        return obj;
      }
      /**
       * Trims entries in an array.
       *
       * @param arr
       */
      static trimArrayEntries(arr) {
        return arr.map((entry) => entry.trim());
      }
      /**
       * Removes empty strings from array
       * @param arr
       */
      static removeEmptyStringsFromArray(arr) {
        return arr.filter((entry) => {
          return !!entry;
        });
      }
      /**
       * Attempts to parse a string into JSON
       * @param str
       */
      static jsonParseHelper(str) {
        try {
          return JSON.parse(str);
        } catch (e) {
          return null;
        }
      }
      /**
       * Tests if a given string matches a given pattern, with support for wildcards and queries.
       * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
       * @param input String to match against
       */
      static matchPattern(pattern, input) {
        const regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
        return regex.test(input);
      }
    };
    function canonicalizeUrl(url) {
      if (!url) {
        return url;
      }
      let lowerCaseUrl = url.toLowerCase();
      if (StringUtils.endsWith(lowerCaseUrl, "?")) {
        lowerCaseUrl = lowerCaseUrl.slice(0, -1);
      } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
        lowerCaseUrl = lowerCaseUrl.slice(0, -2);
      }
      if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
        lowerCaseUrl += "/";
      }
      return lowerCaseUrl;
    }
    function stripLeadingHashOrQuery(responseString) {
      if (responseString.startsWith("#/")) {
        return responseString.substring(2);
      } else if (responseString.startsWith("#") || responseString.startsWith("?")) {
        return responseString.substring(1);
      }
      return responseString;
    }
    function getDeserializedResponse(responseString) {
      if (!responseString || responseString.indexOf("=") < 0) {
        return null;
      }
      try {
        const normalizedResponse = stripLeadingHashOrQuery(responseString);
        const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
        if (deserializedHash.code || deserializedHash.ear_jwe || deserializedHash.error || deserializedHash.error_description || deserializedHash.state) {
          return deserializedHash;
        }
      } catch (e) {
        throw createClientAuthError(hashNotDeserialized);
      }
      return null;
    }
    function mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {
      const queryParameterArray = new Array();
      parameters.forEach((value, key) => {
        if (!encodeExtraParams && extraQueryParameters && key in extraQueryParameters) {
          queryParameterArray.push(`${key}=${value}`);
        } else {
          queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);
        }
      });
      return queryParameterArray.join("&");
    }
    function normalizeUrlForComparison(url) {
      if (!url) {
        return url;
      }
      const urlWithoutHash = url.split("#")[0];
      try {
        const urlObj = new URL(urlWithoutHash);
        const normalizedUrl = urlObj.origin + urlObj.pathname + urlObj.search;
        return canonicalizeUrl(normalizedUrl);
      } catch (e) {
        return canonicalizeUrl(urlWithoutHash);
      }
    }
    var UrlUtils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getDeserializedResponse,
      mapToQueryString,
      normalizeUrlForComparison,
      stripLeadingHashOrQuery
    });
    var UrlString = class _UrlString {
      get urlString() {
        return this._urlString;
      }
      constructor(url) {
        this._urlString = url;
        if (!this._urlString) {
          throw createClientConfigurationError(urlEmptyError);
        }
        if (!url.includes("#")) {
          this._urlString = _UrlString.canonicalizeUri(url);
        }
      }
      /**
       * Ensure urls are lower case and end with a / character.
       * @param url
       */
      static canonicalizeUri(url) {
        if (url) {
          let lowerCaseUrl = url.toLowerCase();
          if (StringUtils.endsWith(lowerCaseUrl, "?")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -1);
          } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -2);
          }
          if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
            lowerCaseUrl += "/";
          }
          return lowerCaseUrl;
        }
        return url;
      }
      /**
       * Throws if urlString passed is not a valid authority URI string.
       */
      validateAsUri() {
        let components;
        try {
          components = this.getUrlComponents();
        } catch (e) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.HostNameAndPort || !components.PathSegments) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
          throw createClientConfigurationError(authorityUriInsecure);
        }
      }
      /**
       * Given a url and a query string return the url with provided query string appended
       * @param url
       * @param queryString
       */
      static appendQueryString(url, queryString) {
        if (!queryString) {
          return url;
        }
        return url.indexOf("?") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;
      }
      /**
       * Returns a url with the hash removed
       * @param url
       */
      static removeHashFromUrl(url) {
        return _UrlString.canonicalizeUri(url.split("#")[0]);
      }
      /**
       * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
       * @param href The url
       * @param tenantId The tenant id to replace
       */
      replaceTenantPath(tenantId) {
        const urlObject = this.getUrlComponents();
        const pathArray = urlObject.PathSegments;
        if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {
          pathArray[0] = tenantId;
        }
        return _UrlString.constructAuthorityUriFromObject(urlObject);
      }
      /**
       * Parses out the components from a url string.
       * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
       */
      getUrlComponents() {
        const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        const match = this.urlString.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        const urlComponents = {
          Protocol: match[1],
          HostNameAndPort: match[4],
          AbsolutePath: match[5],
          QueryString: match[7]
        };
        let pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter((val) => val && val.length > 0);
        urlComponents.PathSegments = pathSegments;
        if (urlComponents.QueryString && urlComponents.QueryString.endsWith("/")) {
          urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
        }
        return urlComponents;
      }
      static getDomainFromUrl(url) {
        const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
        const match = url.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        return match[2];
      }
      static getAbsoluteUrl(relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
          const url = new _UrlString(baseUrl);
          const baseComponents = url.getUrlComponents();
          return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
        }
        return relativeUrl;
      }
      static constructAuthorityUriFromObject(urlObject) {
        return new _UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
      }
      /**
       * Check if the hash of the URL string contains known properties
       * @deprecated This API will be removed in a future version
       */
      static hashContainsKnownProperties(response) {
        return !!getDeserializedResponse(response);
      }
    };
    var rawMetdataJSON = {
      endpointMetadata: {
        "login.microsoftonline.com": {
          token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout"
        },
        "login.chinacloudapi.cn": {
          token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
          authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout"
        },
        "login.microsoftonline.us": {
          token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout"
        },
        "login.sovcloud-identity.fr": {
          token_endpoint: "https://login.sovcloud-identity.fr/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.sovcloud-identity.fr/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.sovcloud-identity.fr/{tenantid}/v2.0",
          authorization_endpoint: "https://login.sovcloud-identity.fr/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.sovcloud-identity.fr/{tenantid}/oauth2/v2.0/logout"
        },
        "login.sovcloud-identity.de": {
          token_endpoint: "https://login.sovcloud-identity.de/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.sovcloud-identity.de/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.sovcloud-identity.de/{tenantid}/v2.0",
          authorization_endpoint: "https://login.sovcloud-identity.de/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.sovcloud-identity.de/{tenantid}/oauth2/v2.0/logout"
        },
        "login.sovcloud-identity.sg": {
          token_endpoint: "https://login.sovcloud-identity.sg/common/oauth2/v2.0/token",
          jwks_uri: "https://login.sovcloud-identity.sg/common/discovery/v2.0/keys",
          issuer: "https://login.sovcloud-identity.sg/{tenantid}/v2.0",
          authorization_endpoint: "https://login.sovcloud-identity.sg/common/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.sovcloud-identity.sg/common/oauth2/v2.0/logout"
        }
      },
      instanceDiscoveryMetadata: {
        metadata: [
          {
            preferred_network: "login.microsoftonline.com",
            preferred_cache: "login.windows.net",
            aliases: [
              "login.microsoftonline.com",
              "login.windows.net",
              "login.microsoft.com",
              "sts.windows.net"
            ]
          },
          {
            preferred_network: "login.partner.microsoftonline.cn",
            preferred_cache: "login.partner.microsoftonline.cn",
            aliases: [
              "login.partner.microsoftonline.cn",
              "login.chinacloudapi.cn"
            ]
          },
          {
            preferred_network: "login.microsoftonline.de",
            preferred_cache: "login.microsoftonline.de",
            aliases: ["login.microsoftonline.de"]
          },
          {
            preferred_network: "login.microsoftonline.us",
            preferred_cache: "login.microsoftonline.us",
            aliases: [
              "login.microsoftonline.us",
              "login.usgovcloudapi.net"
            ]
          },
          {
            preferred_network: "login-us.microsoftonline.com",
            preferred_cache: "login-us.microsoftonline.com",
            aliases: ["login-us.microsoftonline.com"]
          },
          {
            preferred_network: "login.sovcloud-identity.fr",
            preferred_cache: "login.sovcloud-identity.fr",
            aliases: ["login.sovcloud-identity.fr"]
          },
          {
            preferred_network: "login.sovcloud-identity.de",
            preferred_cache: "login.sovcloud-identity.de",
            aliases: ["login.sovcloud-identity.de"]
          },
          {
            preferred_network: "login.sovcloud-identity.sg",
            preferred_cache: "login.sovcloud-identity.sg",
            aliases: ["login.sovcloud-identity.sg"]
          }
        ]
      }
    };
    var EndpointMetadata = rawMetdataJSON.endpointMetadata;
    var InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
    var InstanceDiscoveryMetadataAliases = /* @__PURE__ */ new Set();
    InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
      metadataEntry.aliases.forEach((alias) => {
        InstanceDiscoveryMetadataAliases.add(alias);
      });
    });
    function getAliasesFromStaticSources(staticAuthorityOptions, logger) {
      let staticAliases;
      const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
      if (canonicalAuthority) {
        const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
        staticAliases = getAliasesFromMetadata(authorityHost, staticAuthorityOptions.cloudDiscoveryMetadata?.metadata, AuthorityMetadataSource.CONFIG, logger) || getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger) || staticAuthorityOptions.knownAuthorities;
      }
      return staticAliases || [];
    }
    function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source, logger) {
      logger?.trace(`getAliasesFromMetadata called with source: ${source}`);
      if (authorityHost && cloudDiscoveryMetadata) {
        const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);
        if (metadata) {
          logger?.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source}, returning aliases`);
          return metadata.aliases;
        } else {
          logger?.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source}`);
        }
      }
      return null;
    }
    function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
      const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);
      return metadata;
    }
    function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
      for (let i = 0; i < response.length; i++) {
        const metadata = response[i];
        if (metadata.aliases.includes(authorityHost)) {
          return metadata;
        }
      }
      return null;
    }
    var ProtocolMode = {
      /**
       * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features
       */
      AAD: "AAD",
      /**
       * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.
       * Support is limited for this mode.
       */
      OIDC: "OIDC",
      /**
       * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features
       */
      EAR: "EAR"
    };
    var AzureCloudInstance = {
      // AzureCloudInstance is not specified.
      None: "none",
      // Microsoft Azure public cloud
      AzurePublic: "https://login.microsoftonline.com",
      // Microsoft PPE
      AzurePpe: "https://login.windows-ppe.net",
      // Microsoft Chinese national/regional cloud
      AzureChina: "https://login.chinacloudapi.cn",
      // Microsoft German national/regional cloud ("Black Forest")
      AzureGermany: "https://login.microsoftonline.de",
      // US Government cloud
      AzureUsGovernment: "https://login.microsoftonline.us"
    };
    function isCloudInstanceDiscoveryResponse(response) {
      return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
    }
    function isCloudInstanceDiscoveryErrorResponse(response) {
      return response.hasOwnProperty("error") && response.hasOwnProperty("error_description");
    }
    var PerformanceEvents = {
      /**
       * acquireTokenByCode API (msal-browser and msal-node).
       * Used to acquire tokens by trading an authorization code against the token endpoint.
       */
      AcquireTokenByCode: "acquireTokenByCode",
      /**
       * acquireTokenByRefreshToken API (msal-browser and msal-node).
       * Used to renew an access token using a refresh token against the token endpoint.
       */
      AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",
      /**
       * acquireTokenSilent API (msal-browser and msal-node).
       * Used to silently acquire a new access token (from the cache or the network).
       */
      AcquireTokenSilent: "acquireTokenSilent",
      /**
       * acquireTokenSilentAsync (msal-browser).
       * Internal API for acquireTokenSilent.
       */
      AcquireTokenSilentAsync: "acquireTokenSilentAsync",
      /**
       * acquireTokenPopup (msal-browser).
       * Used to acquire a new access token interactively through pop ups
       */
      AcquireTokenPopup: "acquireTokenPopup",
      /**
       * acquireTokenPreRedirect (msal-browser).
       * First part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenPreRedirect: "acquireTokenPreRedirect",
      /**
       * acquireTokenRedirect (msal-browser).
       * Second part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenRedirect: "acquireTokenRedirect",
      /**
       * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
       * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
       */
      CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",
      /**
       * signJwt API in CryptoOpts class (msal-browser).
       * Used to signed a pop token.
       */
      CryptoOptsSignJwt: "cryptoOptsSignJwt",
      /**
       * acquireToken API in the SilentCacheClient class (msal-browser).
       * Used to read access tokens from the cache.
       */
      SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",
      /**
       * acquireToken API in the SilentIframeClient class (msal-browser).
       * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
       */
      SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",
      AwaitConcurrentIframe: "awaitConcurrentIframe",
      /**
       * acquireToken API in SilentRereshClient (msal-browser).
       * Used to acquire a new set of tokens from the token endpoint using a refresh token.
       */
      SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",
      /**
       * ssoSilent API (msal-browser).
       * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
       */
      SsoSilent: "ssoSilent",
      /**
       * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
       * Used to load authority metadata for a request.
       */
      StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",
      /**
       * acquireToken APIs in msal-browser.
       * Used to make an /authorize endpoint call with native brokering enabled.
       */
      FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",
      /**
       * acquireToken API in NativeInteractionClient class (msal-browser).
       * Used to acquire a token from Native component when native brokering is enabled.
       */
      NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",
      /**
       * Time spent creating default headers for requests to token endpoint
       */
      BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",
      /**
       * Time spent sending/waiting for the response of a request to the token endpoint
       */
      NetworkClientSendPostRequestAsync: "networkClientSendPostRequestAsync",
      RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",
      AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",
      /**
       * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
       */
      BrokerHandhshake: "brokerHandshake",
      /**
       * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
       */
      AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",
      /**
       * Time taken for token acquisition by broker
       */
      AcquireTokenByBroker: "acquireTokenByBroker",
      /**
       * Time spent on the network for refresh token acquisition
       */
      RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",
      /**
       * Time taken for acquiring refresh token , records RT size
       */
      RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",
      /**
       * Time taken for acquiring cached refresh token
       */
      RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",
      /**
       * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",
      /**
       * Helper function to create token request body in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",
      /**
       * acquireTokenFromCache (msal-browser).
       * Internal API for acquiring token from cache
       */
      AcquireTokenFromCache: "acquireTokenFromCache",
      SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",
      SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",
      /**
       * acquireTokenBySilentIframe (msal-browser).
       * Internal API for acquiring token by silent Iframe
       */
      AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",
      /**
       * Internal API for initializing base request in BaseInteractionClient (msal-browser)
       */
      InitializeBaseRequest: "initializeBaseRequest",
      /**
       * Internal API for initializing silent request in SilentCacheClient (msal-browser)
       */
      InitializeSilentRequest: "initializeSilentRequest",
      InitializeClientApplication: "initializeClientApplication",
      InitializeCache: "initializeCache",
      /**
       * Helper function in SilentIframeClient class (msal-browser).
       */
      SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",
      /**
       * SilentHandler
       */
      SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",
      SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",
      SilentHandlerLoadFrame: "silentHandlerLoadFrame",
      SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",
      /**
       * Helper functions in StandardInteractionClient class (msal-browser)
       */
      StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",
      StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",
      StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",
      /**
       * getAuthCodeUrl API (msal-browser and msal-node).
       */
      GetAuthCodeUrl: "getAuthCodeUrl",
      GetStandardParams: "getStandardParams",
      /**
       * Functions from InteractionHandler (msal-browser)
       */
      HandleCodeResponseFromServer: "handleCodeResponseFromServer",
      HandleCodeResponse: "handleCodeResponse",
      HandleResponseEar: "handleResponseEar",
      HandleResponsePlatformBroker: "handleResponsePlatformBroker",
      HandleResponseCode: "handleResponseCode",
      UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",
      /**
       * APIs in Authorization Code Client (msal-common)
       */
      AuthClientAcquireToken: "authClientAcquireToken",
      AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",
      AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",
      /**
       * Generate functions in PopTokenGenerator (msal-common)
       */
      PopTokenGenerateCnf: "popTokenGenerateCnf",
      PopTokenGenerateKid: "popTokenGenerateKid",
      /**
       * handleServerTokenResponse API in ResponseHandler (msal-common)
       */
      HandleServerTokenResponse: "handleServerTokenResponse",
      DeserializeResponse: "deserializeResponse",
      /**
       * Authority functions
       */
      AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",
      AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",
      AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",
      AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",
      AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",
      AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",
      AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",
      AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",
      /**
       * Region Discovery functions
       */
      RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",
      RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",
      RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",
      AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",
      GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",
      GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",
      HandleRedirectPromiseMeasurement: "handleRedirectPromise",
      HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",
      UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",
      UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",
      NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",
      NativeGenerateAuthResult: "nativeGenerateAuthResult",
      RemoveHiddenIframe: "removeHiddenIframe",
      /**
       * Cache operations
       */
      ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",
      CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",
      ImportExistingCache: "importExistingCache",
      SetUserData: "setUserData",
      LocalStorageUpdated: "localStorageUpdated",
      /**
       * Crypto Operations
       */
      GeneratePkceCodes: "generatePkceCodes",
      GenerateCodeVerifier: "generateCodeVerifier",
      GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",
      Sha256Digest: "sha256Digest",
      GetRandomValues: "getRandomValues",
      GenerateHKDF: "generateHKDF",
      GenerateBaseKey: "generateBaseKey",
      Base64Decode: "base64Decode",
      UrlEncodeArr: "urlEncodeArr",
      Encrypt: "encrypt",
      Decrypt: "decrypt",
      GenerateEarKey: "generateEarKey",
      DecryptEarResponse: "decryptEarResponse",
      LoadExternalTokens: "LoadExternalTokens",
      LoadAccount: "loadAccount",
      LoadIdToken: "loadIdToken",
      LoadAccessToken: "loadAccessToken",
      LoadRefreshToken: "loadRefreshToken",
      /**
       * SSO capability verification call (msal-browser).
       * Fire-and-forget SSO verification call made after interactive authentication completes.
       */
      SsoCapable: "ssoCapable"
    };
    var PerformanceEventAbbreviations = /* @__PURE__ */ new Map([
      [PerformanceEvents.AcquireTokenByCode, "ATByCode"],
      [PerformanceEvents.AcquireTokenByRefreshToken, "ATByRT"],
      [PerformanceEvents.AcquireTokenSilent, "ATS"],
      [PerformanceEvents.AcquireTokenSilentAsync, "ATSAsync"],
      [PerformanceEvents.AcquireTokenPopup, "ATPopup"],
      [PerformanceEvents.AcquireTokenRedirect, "ATRedirect"],
      [
        PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,
        "CryptoGetPKThumb"
      ],
      [PerformanceEvents.CryptoOptsSignJwt, "CryptoSignJwt"],
      [PerformanceEvents.SilentCacheClientAcquireToken, "SltCacheClientAT"],
      [PerformanceEvents.SilentIframeClientAcquireToken, "SltIframeClientAT"],
      [PerformanceEvents.SilentRefreshClientAcquireToken, "SltRClientAT"],
      [PerformanceEvents.SsoSilent, "SsoSlt"],
      [
        PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,
        "StdIntClientGetDiscAuth"
      ],
      [
        PerformanceEvents.FetchAccountIdWithNativeBroker,
        "FetchAccIdWithNtvBroker"
      ],
      [
        PerformanceEvents.NativeInteractionClientAcquireToken,
        "NtvIntClientAT"
      ],
      [
        PerformanceEvents.BaseClientCreateTokenRequestHeaders,
        "BaseClientCreateTReqHead"
      ],
      [
        PerformanceEvents.NetworkClientSendPostRequestAsync,
        "NetClientSendPost"
      ],
      [
        PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,
        "RTClientExecPost"
      ],
      [
        PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,
        "AuthCodeClientExecPost"
      ],
      [PerformanceEvents.BrokerHandhshake, "BrokerHandshake"],
      [
        PerformanceEvents.AcquireTokenByRefreshTokenInBroker,
        "ATByRTInBroker"
      ],
      [PerformanceEvents.AcquireTokenByBroker, "ATByBroker"],
      [
        PerformanceEvents.RefreshTokenClientExecuteTokenRequest,
        "RTClientExecTReq"
      ],
      [PerformanceEvents.RefreshTokenClientAcquireToken, "RTClientAT"],
      [
        PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
        "RTClientATWithCachedRT"
      ],
      [
        PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,
        "RTClientATByRT"
      ],
      [
        PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,
        "RTClientCreateTReqBody"
      ],
      [PerformanceEvents.AcquireTokenFromCache, "ATFromCache"],
      [
        PerformanceEvents.SilentFlowClientAcquireCachedToken,
        "SltFlowClientATCached"
      ],
      [
        PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
        "SltFlowClientGenResFromCache"
      ],
      [PerformanceEvents.AcquireTokenBySilentIframe, "ATBySltIframe"],
      [PerformanceEvents.InitializeBaseRequest, "InitBaseReq"],
      [PerformanceEvents.InitializeSilentRequest, "InitSltReq"],
      [
        PerformanceEvents.InitializeClientApplication,
        "InitClientApplication"
      ],
      [PerformanceEvents.InitializeCache, "InitCache"],
      [PerformanceEvents.ImportExistingCache, "importCache"],
      [PerformanceEvents.SetUserData, "setUserData"],
      [PerformanceEvents.LocalStorageUpdated, "localStorageUpdated"],
      [PerformanceEvents.SilentIframeClientTokenHelper, "SIClientTHelper"],
      [
        PerformanceEvents.SilentHandlerInitiateAuthRequest,
        "SHandlerInitAuthReq"
      ],
      [
        PerformanceEvents.SilentHandlerMonitorIframeForHash,
        "SltHandlerMonitorIframeForHash"
      ],
      [PerformanceEvents.SilentHandlerLoadFrame, "SHandlerLoadFrame"],
      [PerformanceEvents.SilentHandlerLoadFrameSync, "SHandlerLoadFrameSync"],
      [
        PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,
        "StdIntClientCreateAuthCodeClient"
      ],
      [
        PerformanceEvents.StandardInteractionClientGetClientConfiguration,
        "StdIntClientGetClientConf"
      ],
      [
        PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,
        "StdIntClientInitAuthReq"
      ],
      [PerformanceEvents.GetAuthCodeUrl, "GetAuthCodeUrl"],
      [
        PerformanceEvents.HandleCodeResponseFromServer,
        "HandleCodeResFromServer"
      ],
      [PerformanceEvents.HandleCodeResponse, "HandleCodeResp"],
      [PerformanceEvents.HandleResponseEar, "HandleRespEar"],
      [PerformanceEvents.HandleResponseCode, "HandleRespCode"],
      [
        PerformanceEvents.HandleResponsePlatformBroker,
        "HandleRespPlatBroker"
      ],
      [PerformanceEvents.UpdateTokenEndpointAuthority, "UpdTEndpointAuth"],
      [PerformanceEvents.AuthClientAcquireToken, "AuthClientAT"],
      [PerformanceEvents.AuthClientExecuteTokenRequest, "AuthClientExecTReq"],
      [
        PerformanceEvents.AuthClientCreateTokenRequestBody,
        "AuthClientCreateTReqBody"
      ],
      [PerformanceEvents.PopTokenGenerateCnf, "PopTGenCnf"],
      [PerformanceEvents.PopTokenGenerateKid, "PopTGenKid"],
      [PerformanceEvents.HandleServerTokenResponse, "HandleServerTRes"],
      [PerformanceEvents.DeserializeResponse, "DeserializeRes"],
      [
        PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,
        "AuthFactCreateDiscInst"
      ],
      [
        PerformanceEvents.AuthorityResolveEndpointsAsync,
        "AuthResolveEndpointsAsync"
      ],
      [
        PerformanceEvents.AuthorityResolveEndpointsFromLocalSources,
        "AuthResolveEndpointsFromLocal"
      ],
      [
        PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,
        "AuthGetCDMetaFromNet"
      ],
      [
        PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,
        "AuthUpdCDMeta"
      ],
      [
        PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,
        "AuthUpdCDMetaFromNet"
      ],
      [
        PerformanceEvents.AuthorityUpdateEndpointMetadata,
        "AuthUpdEndpointMeta"
      ],
      [
        PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
        "AuthUpdMetaWithRegInfo"
      ],
      [PerformanceEvents.RegionDiscoveryDetectRegion, "RegDiscDetectReg"],
      [
        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
        "RegDiscGetRegFromIMDS"
      ],
      [
        PerformanceEvents.RegionDiscoveryGetCurrentVersion,
        "RegDiscGetCurrentVer"
      ],
      [PerformanceEvents.AcquireTokenByCodeAsync, "ATByCodeAsync"],
      [
        PerformanceEvents.GetEndpointMetadataFromNetwork,
        "GetEndpointMetaFromNet"
      ],
      [
        PerformanceEvents.GetCloudDiscoveryMetadataFromNetworkMeasurement,
        "GetCDMetaFromNet"
      ],
      [
        PerformanceEvents.HandleRedirectPromiseMeasurement,
        "HandleRedirectPromise"
      ],
      [
        PerformanceEvents.HandleNativeRedirectPromiseMeasurement,
        "HandleNtvRedirectPromise"
      ],
      [
        PerformanceEvents.UpdateCloudDiscoveryMetadataMeasurement,
        "UpdateCDMeta"
      ],
      [
        PerformanceEvents.UsernamePasswordClientAcquireToken,
        "UserPassClientAT"
      ],
      [
        PerformanceEvents.NativeMessageHandlerHandshake,
        "NtvMsgHandlerHandshake"
      ],
      [PerformanceEvents.NativeGenerateAuthResult, "NtvGenAuthRes"],
      [PerformanceEvents.RemoveHiddenIframe, "RemoveHiddenIframe"],
      [
        PerformanceEvents.ClearTokensAndKeysWithClaims,
        "ClearTAndKeysWithClaims"
      ],
      [PerformanceEvents.CacheManagerGetRefreshToken, "CacheManagerGetRT"],
      [PerformanceEvents.GeneratePkceCodes, "GenPkceCodes"],
      [PerformanceEvents.GenerateCodeVerifier, "GenCodeVerifier"],
      [
        PerformanceEvents.GenerateCodeChallengeFromVerifier,
        "GenCodeChallengeFromVerifier"
      ],
      [PerformanceEvents.Sha256Digest, "Sha256Digest"],
      [PerformanceEvents.GetRandomValues, "GetRandomValues"],
      [PerformanceEvents.GenerateHKDF, "genHKDF"],
      [PerformanceEvents.GenerateBaseKey, "genBaseKey"],
      [PerformanceEvents.Base64Decode, "b64Decode"],
      [PerformanceEvents.UrlEncodeArr, "urlEncArr"],
      [PerformanceEvents.Encrypt, "encrypt"],
      [PerformanceEvents.Decrypt, "decrypt"],
      [PerformanceEvents.GenerateEarKey, "genEarKey"],
      [PerformanceEvents.DecryptEarResponse, "decryptEarResp"],
      [PerformanceEvents.SsoCapable, "SsoCapable"]
    ]);
    var PerformanceEventStatus = {
      NotStarted: 0,
      InProgress: 1,
      Completed: 2
    };
    var IntFields = /* @__PURE__ */ new Set([
      "accessTokenSize",
      "durationMs",
      "idTokenSize",
      "matsSilentStatus",
      "matsHttpStatus",
      "refreshTokenSize",
      "queuedTimeMs",
      "startTimeMs",
      "status",
      "multiMatchedAT",
      "multiMatchedID",
      "multiMatchedRT",
      "unencryptedCacheCount",
      "encryptedCacheExpiredCount",
      "oldAccountCount",
      "oldAccessCount",
      "oldIdCount",
      "oldRefreshCount",
      "currAccountCount",
      "currAccessCount",
      "currIdCount",
      "currRefreshCount",
      "expiredCacheRemovedCount",
      "upgradedCacheCount"
    ]);
    var invoke = (callback, eventName, logger, telemetryClient, correlationId) => {
      return (...args) => {
        logger.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        try {
          const result = callback(...args);
          inProgressEvent?.end({
            success: true
          });
          logger.trace(`Returning result from ${eventName}`);
          return result;
        } catch (e) {
          logger.trace(`Error occurred in ${eventName}`);
          try {
            logger.trace(JSON.stringify(e));
          } catch (e2) {
            logger.trace("Unable to print error message.");
          }
          inProgressEvent?.end({
            success: false
          }, e);
          throw e;
        }
      };
    };
    var invokeAsync = (callback, eventName, logger, telemetryClient, correlationId) => {
      return (...args) => {
        logger.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        telemetryClient?.setPreQueueTime(eventName, correlationId);
        return callback(...args).then((response) => {
          logger.trace(`Returning result from ${eventName}`);
          inProgressEvent?.end({
            success: true
          });
          return response;
        }).catch((e) => {
          logger.trace(`Error occurred in ${eventName}`);
          try {
            logger.trace(JSON.stringify(e));
          } catch (e2) {
            logger.trace("Unable to print error message.");
          }
          inProgressEvent?.end({
            success: false
          }, e);
          throw e;
        });
      };
    };
    var RegionDiscovery = class _RegionDiscovery {
      constructor(networkInterface, logger, performanceClient, correlationId) {
        this.networkInterface = networkInterface;
        this.logger = logger;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
      }
      /**
       * Detect the region from the application's environment.
       *
       * @returns Promise<string | null>
       */
      async detectRegion(environmentRegion, regionDiscoveryMetadata) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
        let autodetectedRegionName = environmentRegion;
        if (!autodetectedRegionName) {
          const options = _RegionDiscovery.IMDS_OPTIONS;
          try {
            const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);
            if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {
              autodetectedRegionName = localIMDSVersionResponse.body;
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
            }
            if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {
              const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);
              if (!currentIMDSVersion) {
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                return null;
              }
              const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);
              if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {
                autodetectedRegionName = currentIMDSVersionResponse.body;
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
              }
            }
          } catch (e) {
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
            return null;
          }
        } else {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
        }
        if (!autodetectedRegionName) {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
        }
        return autodetectedRegionName || null;
      }
      /**
       * Make the call to the IMDS endpoint
       *
       * @param imdsEndpointUrl
       * @returns Promise<NetworkResponse<string>>
       */
      async getRegionFromIMDS(version3, options) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
        return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version3}&format=text`, options, Constants.IMDS_TIMEOUT);
      }
      /**
       * Get the most recent version of the IMDS endpoint available
       *
       * @returns Promise<string | null>
       */
      async getCurrentVersion(options) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);
          if (response.status === HttpStatus.BAD_REQUEST && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
            return response.body["newest-versions"][0];
          }
          return null;
        } catch (e) {
          return null;
        }
      }
    };
    RegionDiscovery.IMDS_OPTIONS = {
      headers: {
        Metadata: "true"
      }
    };
    function nowSeconds() {
      return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    }
    function toSecondsFromDate(date) {
      return date.getTime() / 1e3;
    }
    function toDateFromSeconds(seconds) {
      if (seconds) {
        return new Date(Number(seconds) * 1e3);
      }
      return /* @__PURE__ */ new Date();
    }
    function isTokenExpired(expiresOn, offset) {
      const expirationSec = Number(expiresOn) || 0;
      const offsetCurrentTimeSec = nowSeconds() + offset;
      return offsetCurrentTimeSec > expirationSec;
    }
    function isCacheExpired(lastUpdatedAt, cacheRetentionDays) {
      const cacheExpirationTimestamp = Number(lastUpdatedAt) + cacheRetentionDays * 24 * 60 * 60 * 1e3;
      return Date.now() > cacheExpirationTimestamp;
    }
    function wasClockTurnedBack(cachedAt) {
      const cachedAtSec = Number(cachedAt);
      return cachedAtSec > nowSeconds();
    }
    function delay(t, value) {
      return new Promise((resolve) => setTimeout(() => resolve(value), t));
    }
    var TimeUtils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      delay,
      isCacheExpired,
      isTokenExpired,
      nowSeconds,
      toDateFromSeconds,
      toSecondsFromDate,
      wasClockTurnedBack
    });
    function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
      const idTokenEntity = {
        credentialType: CredentialType.ID_TOKEN,
        homeAccountId,
        environment,
        clientId,
        secret: idToken,
        realm: tenantId,
        lastUpdatedAt: Date.now().toString()
        // Set the last updated time to now
      };
      return idTokenEntity;
    }
    function createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
      const atEntity = {
        homeAccountId,
        credentialType: CredentialType.ACCESS_TOKEN,
        secret: accessToken,
        cachedAt: nowSeconds().toString(),
        expiresOn: expiresOn.toString(),
        extendedExpiresOn: extExpiresOn.toString(),
        environment,
        clientId,
        realm: tenantId,
        target: scopes,
        tokenType: tokenType || AuthenticationScheme.BEARER,
        lastUpdatedAt: Date.now().toString()
        // Set the last updated time to now
      };
      if (userAssertionHash) {
        atEntity.userAssertionHash = userAssertionHash;
      }
      if (refreshOn) {
        atEntity.refreshOn = refreshOn.toString();
      }
      if (requestedClaims) {
        atEntity.requestedClaims = requestedClaims;
        atEntity.requestedClaimsHash = requestedClaimsHash;
      }
      if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {
        atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        switch (atEntity.tokenType) {
          case AuthenticationScheme.POP:
            const tokenClaims = extractTokenClaims(accessToken, base64Decode);
            if (!tokenClaims?.cnf?.kid) {
              throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
            }
            atEntity.keyId = tokenClaims.cnf.kid;
            break;
          case AuthenticationScheme.SSH:
            atEntity.keyId = keyId;
        }
      }
      return atEntity;
    }
    function createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {
      const rtEntity = {
        credentialType: CredentialType.REFRESH_TOKEN,
        homeAccountId,
        environment,
        clientId,
        secret: refreshToken,
        lastUpdatedAt: Date.now().toString()
      };
      if (userAssertionHash) {
        rtEntity.userAssertionHash = userAssertionHash;
      }
      if (familyId) {
        rtEntity.familyId = familyId;
      }
      if (expiresOn) {
        rtEntity.expiresOn = expiresOn.toString();
      }
      return rtEntity;
    }
    function isCredentialEntity(entity) {
      return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret");
    }
    function isAccessTokenEntity(entity) {
      if (!entity) {
        return false;
      }
      return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
    }
    function isIdTokenEntity(entity) {
      if (!entity) {
        return false;
      }
      return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity["credentialType"] === CredentialType.ID_TOKEN;
    }
    function isRefreshTokenEntity(entity) {
      if (!entity) {
        return false;
      }
      return isCredentialEntity(entity) && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
    }
    function isServerTelemetryEntity(key, entity) {
      const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
      let validateEntity = true;
      if (entity) {
        validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
      }
      return validateKey && validateEntity;
    }
    function isThrottlingEntity(key, entity) {
      let validateKey = false;
      if (key) {
        validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
      }
      let validateEntity = true;
      if (entity) {
        validateEntity = entity.hasOwnProperty("throttleTime");
      }
      return validateKey && validateEntity;
    }
    function generateAppMetadataKey({ environment, clientId }) {
      const appMetaDataKeyArray = [
        APP_METADATA,
        environment,
        clientId
      ];
      return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }
    function isAppMetadataEntity(key, entity) {
      if (!entity) {
        return false;
      }
      return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
    }
    function isAuthorityMetadataEntity(key, entity) {
      if (!entity) {
        return false;
      }
      return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
    }
    function generateAuthorityMetadataExpiresAt() {
      return nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
    }
    function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
      authorityMetadata.authorization_endpoint = updatedValues.authorization_endpoint;
      authorityMetadata.token_endpoint = updatedValues.token_endpoint;
      authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
      authorityMetadata.issuer = updatedValues.issuer;
      authorityMetadata.endpointsFromNetwork = fromNetwork;
      authorityMetadata.jwks_uri = updatedValues.jwks_uri;
    }
    function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
      authorityMetadata.aliases = updatedValues.aliases;
      authorityMetadata.preferred_cache = updatedValues.preferred_cache;
      authorityMetadata.preferred_network = updatedValues.preferred_network;
      authorityMetadata.aliasesFromNetwork = fromNetwork;
    }
    function isAuthorityMetadataExpired(metadata) {
      return metadata.expiresAt <= nowSeconds();
    }
    var CacheHelpers = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      createAccessTokenEntity,
      createIdTokenEntity,
      createRefreshTokenEntity,
      generateAppMetadataKey,
      generateAuthorityMetadataExpiresAt,
      isAccessTokenEntity,
      isAppMetadataEntity,
      isAuthorityMetadataEntity,
      isAuthorityMetadataExpired,
      isCredentialEntity,
      isIdTokenEntity,
      isRefreshTokenEntity,
      isServerTelemetryEntity,
      isThrottlingEntity,
      updateAuthorityEndpointMetadata,
      updateCloudDiscoveryMetadata
    });
    var Authority = class _Authority {
      constructor(authority, networkInterface, cacheManager, authorityOptions, logger, correlationId, performanceClient, managedIdentity) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscoveryMetadata = {
          region_used: void 0,
          region_source: void 0,
          region_outcome: void 0
        };
        this.logger = logger;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
        this.managedIdentity = managedIdentity || false;
        this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);
      }
      /**
       * Get {@link AuthorityType}
       * @param authorityUri {@link IUri}
       * @private
       */
      getAuthorityType(authorityUri) {
        if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
          return AuthorityType.Ciam;
        }
        const pathSegments = authorityUri.PathSegments;
        if (pathSegments.length) {
          switch (pathSegments[0].toLowerCase()) {
            case Constants.ADFS:
              return AuthorityType.Adfs;
            case Constants.DSTS:
              return AuthorityType.Dsts;
          }
        }
        return AuthorityType.Default;
      }
      // See above for AuthorityType
      get authorityType() {
        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
      }
      /**
       * ProtocolMode enum representing the way endpoints are constructed.
       */
      get protocolMode() {
        return this.authorityOptions.protocolMode;
      }
      /**
       * Returns authorityOptions which can be used to reinstantiate a new authority instance
       */
      get options() {
        return this.authorityOptions;
      }
      /**
       * A URL that is the authority set by the developer
       */
      get canonicalAuthority() {
        return this._canonicalAuthority.urlString;
      }
      /**
       * Sets canonical authority.
       */
      set canonicalAuthority(url) {
        this._canonicalAuthority = new UrlString(url);
        this._canonicalAuthority.validateAsUri();
        this._canonicalAuthorityUrlComponents = null;
      }
      /**
       * Get authority components.
       */
      get canonicalAuthorityUrlComponents() {
        if (!this._canonicalAuthorityUrlComponents) {
          this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
        }
        return this._canonicalAuthorityUrlComponents;
      }
      /**
       * Get hostname and port i.e. login.microsoftonline.com
       */
      get hostnameAndPort() {
        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
      }
      /**
       * Get tenant for authority.
       */
      get tenant() {
        return this.canonicalAuthorityUrlComponents.PathSegments[0];
      }
      /**
       * OAuth /authorize endpoint for requests
       */
      get authorizationEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.authorization_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth /token endpoint for requests
       */
      get tokenEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      get deviceCodeEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth logout endpoint for requests
       */
      get endSessionEndpoint() {
        if (this.discoveryComplete()) {
          if (!this.metadata.end_session_endpoint) {
            throw createClientAuthError(endSessionEndpointNotSupported);
          }
          return this.replacePath(this.metadata.end_session_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth issuer for requests
       */
      get selfSignedJwtAudience() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.issuer);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Jwks_uri for token signing keys
       */
      get jwksUri() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.jwks_uri);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
       * @param authorityUri {@link IUri}
       * @private
       */
      canReplaceTenant(authorityUri) {
        return authorityUri.PathSegments.length === 1 && !_Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) && this.getAuthorityType(authorityUri) === AuthorityType.Default && this.protocolMode !== ProtocolMode.OIDC;
      }
      /**
       * Replaces tenant in url path with current tenant. Defaults to common.
       * @param urlString
       */
      replaceTenant(urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
      }
      /**
       * Replaces path such as tenant or policy with the current tenant or policy.
       * @param urlString
       */
      replacePath(urlString) {
        let endpoint = urlString;
        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach((currentPart, index) => {
          let cachedPart = cachedAuthorityParts[index];
          if (index === 0 && this.canReplaceTenant(cachedAuthorityUrlComponents)) {
            const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
            if (cachedPart !== tenantId) {
              this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
              cachedPart = tenantId;
            }
          }
          if (currentPart !== cachedPart) {
            endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
          }
        });
        return this.replaceTenant(endpoint);
      }
      /**
       * The default open id configuration endpoint for any canonical authority.
       */
      get defaultOpenIdConfigurationEndpoint() {
        const canonicalAuthorityHost = this.hostnameAndPort;
        if (this.canonicalAuthority.endsWith("v2.0/") || this.authorityType === AuthorityType.Adfs || this.protocolMode === ProtocolMode.OIDC && !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost)) {
          return `${this.canonicalAuthority}.well-known/openid-configuration`;
        }
        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
      }
      /**
       * Boolean that returns whether or not tenant discovery has been completed.
       */
      discoveryComplete() {
        return !!this.metadata;
      }
      /**
       * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
       * and the /authorize, /token and logout endpoints.
       */
      async resolveEndpointsAsync() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
        const metadataEntity = this.getCurrentMetadataEntity();
        const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
        const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
          source: endpointSource
        });
        this.performanceClient?.addFields({
          cloudDiscoverySource,
          authorityEndpointSource: endpointSource
        }, this.correlationId);
      }
      /**
       * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
       * from the configured canonical authority
       * @returns
       */
      getCurrentMetadataEntity() {
        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
        if (!metadataEntity) {
          metadataEntity = {
            aliases: [],
            preferred_cache: this.hostnameAndPort,
            preferred_network: this.hostnameAndPort,
            canonical_authority: this.canonicalAuthority,
            authorization_endpoint: "",
            token_endpoint: "",
            end_session_endpoint: "",
            issuer: "",
            aliasesFromNetwork: false,
            endpointsFromNetwork: false,
            expiresAt: generateAuthorityMetadataExpiresAt(),
            jwks_uri: ""
          };
        }
        return metadataEntity;
      }
      /**
       * Updates cached metadata based on metadata source and sets the instance's metadata
       * property to the same value
       * @param metadataEntity
       * @param cloudDiscoverySource
       * @param endpointMetadataResult
       */
      updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE) {
          metadataEntity.expiresAt = generateAuthorityMetadataExpiresAt();
          metadataEntity.canonical_authority = this.canonicalAuthority;
        }
        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
        this.metadata = metadataEntity;
      }
      /**
       * Update AuthorityMetadataEntity with new endpoints and return where the information came from
       * @param metadataEntity
       */
      async updateEndpointMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
        const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
        if (localMetadata) {
          if (localMetadata.source === AuthorityMetadataSource.HARDCODED_VALUES) {
            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
              if (localMetadata.metadata) {
                const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);
                updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
                metadataEntity.canonical_authority = this.canonicalAuthority;
              }
            }
          }
          return localMetadata.source;
        }
        let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
            metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);
          }
          updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        } else {
          throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
        }
      }
      /**
       * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
       * response if the source is hardcoded metadata
       * @param metadataEntity
       * @returns
       */
      updateEndpointMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get endpoint metadata from authority configuration");
        const configMetadata = this.getEndpointMetadataFromConfig();
        if (configMetadata) {
          this.logger.verbose("Found endpoint metadata in authority configuration");
          updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
          return {
            source: AuthorityMetadataSource.CONFIG
          };
        }
        this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");
        if (this.authorityOptions.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
          if (hardcodedMetadata) {
            updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
            return {
              source: AuthorityMetadataSource.HARDCODED_VALUES,
              metadata: hardcodedMetadata
            };
          } else {
            this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");
          }
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found endpoint metadata in the cache.");
          return { source: AuthorityMetadataSource.CACHE };
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Compares the number of url components after the domain to determine if the cached
       * authority metadata can be used for the requested authority. Protects against same domain different
       * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
       * @param metadataEntity
       */
      isAuthoritySameType(metadataEntity) {
        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
      }
      /**
       * Parse authorityMetadata config option
       */
      getEndpointMetadataFromConfig() {
        if (this.authorityOptions.authorityMetadata) {
          try {
            return JSON.parse(this.authorityOptions.authorityMetadata);
          } catch (e) {
            throw createClientConfigurationError(invalidAuthorityMetadata);
          }
        }
        return null;
      }
      /**
       * Gets OAuth endpoints from the given OpenID configuration endpoint.
       *
       * @param hasHardcodedMetadata boolean
       */
      async getEndpointMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
        const options = {};
        const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);
          const isValidResponse = isOpenIdConfigResponse(response.body);
          if (isValidResponse) {
            return response.body;
          } else {
            this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);
            return null;
          }
        } catch (e) {
          this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
          return null;
        }
      }
      /**
       * Get OAuth endpoints for common authorities.
       */
      getEndpointMetadataFromHardcodedValues() {
        if (this.hostnameAndPort in EndpointMetadata) {
          return EndpointMetadata[this.hostnameAndPort];
        }
        return null;
      }
      /**
       * Update the retrieved metadata with regional information.
       * User selected Azure region will be used if configured.
       */
      async updateMetadataWithRegionalInformation(metadata) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
        const userConfiguredAzureRegion = this.authorityOptions.azureRegionConfiguration?.azureRegion;
        if (userConfiguredAzureRegion) {
          if (userConfiguredAzureRegion !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
            this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
            return _Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
          }
          const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)(this.authorityOptions.azureRegionConfiguration?.environmentRegion, this.regionDiscoveryMetadata);
          if (autodetectedRegionName) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
            this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
            return _Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
          }
          this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
        }
        return metadata;
      }
      /**
       * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
       * and returns where the information was retrieved from
       * @param metadataEntity
       * @returns AuthorityMetadataSource
       */
      async updateCloudDiscoveryMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
        const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
        if (localMetadataSource) {
          return localMetadataSource;
        }
        const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        }
        throw createClientConfigurationError(untrustedAuthority);
      }
      updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");
        this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`);
        const metadata = this.getCloudDiscoveryMetadataFromConfig();
        if (metadata) {
          this.logger.verbose("Found cloud discovery metadata in authority configuration");
          updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
          return AuthorityMetadataSource.CONFIG;
        }
        this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");
        if (this.options.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);
          if (hardcodedMetadata) {
            this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
            updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
            return AuthorityMetadataSource.HARDCODED_VALUES;
          }
          this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found cloud discovery metadata in the cache.");
          return AuthorityMetadataSource.CACHE;
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Parse cloudDiscoveryMetadata config or check knownAuthorities
       */
      getCloudDiscoveryMetadataFromConfig() {
        if (this.authorityType === AuthorityType.Ciam) {
          this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        if (this.authorityOptions.cloudDiscoveryMetadata) {
          this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
          try {
            this.logger.verbose("Attempting to parse the cloud discovery metadata.");
            const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
            const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
            this.logger.verbose("Parsed the cloud discovery metadata.");
            if (metadata) {
              this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
              return metadata;
            } else {
              this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
            }
          } catch (e) {
            this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
            throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
          }
        }
        if (this.isInKnownAuthorities()) {
          this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return null;
      }
      /**
       * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
       *
       * @param hasHardcodedMetadata boolean
       */
      async getCloudDiscoveryMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
        const options = {};
        let match = null;
        try {
          const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);
          let typedResponseBody;
          let metadata;
          if (isCloudInstanceDiscoveryResponse(response.body)) {
            typedResponseBody = response.body;
            metadata = typedResponseBody.metadata;
            this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);
          } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
            this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);
            typedResponseBody = response.body;
            if (typedResponseBody.error === Constants.INVALID_INSTANCE) {
              this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
              return null;
            }
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);
            this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
            metadata = [];
          } else {
            this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
            return null;
          }
          this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
          match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
        } catch (error) {
          if (error instanceof AuthError) {
            this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.
Error: ${error.errorCode}
Error Description: ${error.errorMessage}`);
          } else {
            const typedError = error;
            this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.
Error: ${typedError.name}
Error Description: ${typedError.message}`);
          }
          return null;
        }
        if (!match) {
          this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
          this.logger.verbose("Creating custom Authority for custom domain scenario.");
          match = _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return match;
      }
      /**
       * Helper function to determine if this host is included in the knownAuthorities config option
       */
      isInKnownAuthorities() {
        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {
          return authority && UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;
        });
        return matches.length > 0;
      }
      /**
       * helper function to populate the authority based on azureCloudOptions
       * @param authorityString
       * @param azureCloudOptions
       */
      static generateAuthority(authorityString, azureCloudOptions) {
        let authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
          const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
          authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
      }
      /**
       * Creates cloud discovery metadata object from a given host
       * @param host
       */
      static createCloudDiscoveryMetadataFromHost(host) {
        return {
          preferred_network: host,
          preferred_cache: host,
          aliases: [host]
        };
      }
      /**
       * helper function to generate environment from authority object
       */
      getPreferredCache() {
        if (this.managedIdentity) {
          return Constants.DEFAULT_AUTHORITY_HOST;
        } else if (this.discoveryComplete()) {
          return this.metadata.preferred_cache;
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns whether or not the provided host is an alias of this authority instance
       * @param host
       */
      isAlias(host) {
        return this.metadata.aliases.indexOf(host) > -1;
      }
      /**
       * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
       * @param host
       */
      isAliasOfKnownMicrosoftAuthority(host) {
        return InstanceDiscoveryMetadataAliases.has(host);
      }
      /**
       * Checks whether the provided host is that of a public cloud authority
       *
       * @param authority string
       * @returns bool
       */
      static isPublicCloudAuthority(host) {
        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
      }
      /**
       * Rebuild the authority string with the region
       *
       * @param host string
       * @param region string
       */
      static buildRegionalAuthorityString(host, region, queryString) {
        const authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        const authorityUrlParts = authorityUrlInstance.getUrlComponents();
        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
          hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
        }
        const url = UrlString.constructAuthorityUriFromObject({
          ...authorityUrlInstance.getUrlComponents(),
          HostNameAndPort: hostNameAndPort
        }).urlString;
        if (queryString)
          return `${url}?${queryString}`;
        return url;
      }
      /**
       * Replace the endpoints in the metadata object with their regional equivalents.
       *
       * @param metadata OpenIdConfigResponse
       * @param azureRegion string
       */
      static replaceWithRegionalInformation(metadata, azureRegion) {
        const regionalMetadata = { ...metadata };
        regionalMetadata.authorization_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);
        regionalMetadata.token_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);
        if (regionalMetadata.end_session_endpoint) {
          regionalMetadata.end_session_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);
        }
        return regionalMetadata;
      }
      /**
       * Transform CIAM_AUTHORIY as per the below rules:
       * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
       *
       * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
       * `ciamlogin.com` can also change in the future and we should accommodate the same
       *
       * @param authority
       */
      static transformCIAMAuthority(authority) {
        let ciamAuthority = authority;
        const authorityUrl = new UrlString(authority);
        const authorityUrlComponents = authorityUrl.getUrlComponents();
        if (authorityUrlComponents.PathSegments.length === 0 && authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
          const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
          ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;
        }
        return ciamAuthority;
      }
    };
    Authority.reservedTenantDomains = /* @__PURE__ */ new Set([
      "{tenant}",
      "{tenantid}",
      AADAuthorityConstants.COMMON,
      AADAuthorityConstants.CONSUMERS,
      AADAuthorityConstants.ORGANIZATIONS
    ]);
    function getTenantFromAuthorityString(authority) {
      const authorityUrl = new UrlString(authority);
      const authorityUrlComponents = authorityUrl.getUrlComponents();
      const tenantId = authorityUrlComponents.PathSegments.slice(-1)[0]?.toLowerCase();
      switch (tenantId) {
        case AADAuthorityConstants.COMMON:
        case AADAuthorityConstants.ORGANIZATIONS:
        case AADAuthorityConstants.CONSUMERS:
          return void 0;
        default:
          return tenantId;
      }
    }
    function formatAuthorityUri(authorityUri) {
      return authorityUri.endsWith(Constants.FORWARD_SLASH) ? authorityUri : `${authorityUri}${Constants.FORWARD_SLASH}`;
    }
    function buildStaticAuthorityOptions(authOptions) {
      const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
      let cloudDiscoveryMetadata = void 0;
      if (rawCloudDiscoveryMetadata) {
        try {
          cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
        } catch (e) {
          throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
        }
      }
      return {
        canonicalAuthority: authOptions.authority ? formatAuthorityUri(authOptions.authority) : void 0,
        knownAuthorities: authOptions.knownAuthorities,
        cloudDiscoveryMetadata
      };
    }
    async function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient) {
      performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
      const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
      const acquireTokenAuthority = new Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient);
      try {
        await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger, performanceClient, correlationId)();
        return acquireTokenAuthority;
      } catch (e) {
        throw createClientAuthError(endpointResolutionError);
      }
    }
    var AuthorityFactory = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      createDiscoveredInstance
    });
    var CLIENT_ID = "client_id";
    var REDIRECT_URI = "redirect_uri";
    var RESPONSE_TYPE = "response_type";
    var RESPONSE_MODE = "response_mode";
    var GRANT_TYPE = "grant_type";
    var CLAIMS = "claims";
    var SCOPE = "scope";
    var ERROR = "error";
    var ERROR_DESCRIPTION = "error_description";
    var ACCESS_TOKEN = "access_token";
    var ID_TOKEN = "id_token";
    var REFRESH_TOKEN = "refresh_token";
    var EXPIRES_IN = "expires_in";
    var REFRESH_TOKEN_EXPIRES_IN = "refresh_token_expires_in";
    var STATE = "state";
    var NONCE = "nonce";
    var PROMPT = "prompt";
    var SESSION_STATE = "session_state";
    var CLIENT_INFO = "client_info";
    var CODE = "code";
    var CODE_CHALLENGE = "code_challenge";
    var CODE_CHALLENGE_METHOD = "code_challenge_method";
    var CODE_VERIFIER = "code_verifier";
    var CLIENT_REQUEST_ID = "client-request-id";
    var X_CLIENT_SKU = "x-client-SKU";
    var X_CLIENT_VER = "x-client-VER";
    var X_CLIENT_OS = "x-client-OS";
    var X_CLIENT_CPU = "x-client-CPU";
    var X_CLIENT_CURR_TELEM = "x-client-current-telemetry";
    var X_CLIENT_LAST_TELEM = "x-client-last-telemetry";
    var X_MS_LIB_CAPABILITY = "x-ms-lib-capability";
    var X_APP_NAME = "x-app-name";
    var X_APP_VER = "x-app-ver";
    var POST_LOGOUT_URI = "post_logout_redirect_uri";
    var ID_TOKEN_HINT = "id_token_hint";
    var DEVICE_CODE = "device_code";
    var CLIENT_SECRET = "client_secret";
    var CLIENT_ASSERTION = "client_assertion";
    var CLIENT_ASSERTION_TYPE = "client_assertion_type";
    var TOKEN_TYPE = "token_type";
    var REQ_CNF = "req_cnf";
    var OBO_ASSERTION = "assertion";
    var REQUESTED_TOKEN_USE = "requested_token_use";
    var ON_BEHALF_OF = "on_behalf_of";
    var FOCI = "foci";
    var CCS_HEADER = "X-AnchorMailbox";
    var RETURN_SPA_CODE = "return_spa_code";
    var NATIVE_BROKER = "nativebroker";
    var LOGOUT_HINT = "logout_hint";
    var SID = "sid";
    var LOGIN_HINT = "login_hint";
    var DOMAIN_HINT = "domain_hint";
    var X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";
    var BROKER_CLIENT_ID = "brk_client_id";
    var BROKER_REDIRECT_URI = "brk_redirect_uri";
    var INSTANCE_AWARE = "instance_aware";
    var EAR_JWK = "ear_jwk";
    var EAR_JWE_CRYPTO = "ear_jwe_crypto";
    var AADServerParamKeys = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ACCESS_TOKEN,
      BROKER_CLIENT_ID,
      BROKER_REDIRECT_URI,
      CCS_HEADER,
      CLAIMS,
      CLIENT_ASSERTION,
      CLIENT_ASSERTION_TYPE,
      CLIENT_ID,
      CLIENT_INFO,
      CLIENT_REQUEST_ID,
      CLIENT_SECRET,
      CODE,
      CODE_CHALLENGE,
      CODE_CHALLENGE_METHOD,
      CODE_VERIFIER,
      DEVICE_CODE,
      DOMAIN_HINT,
      EAR_JWE_CRYPTO,
      EAR_JWK,
      ERROR,
      ERROR_DESCRIPTION,
      EXPIRES_IN,
      FOCI,
      GRANT_TYPE,
      ID_TOKEN,
      ID_TOKEN_HINT,
      INSTANCE_AWARE,
      LOGIN_HINT,
      LOGOUT_HINT,
      NATIVE_BROKER,
      NONCE,
      OBO_ASSERTION,
      ON_BEHALF_OF,
      POST_LOGOUT_URI,
      PROMPT,
      REDIRECT_URI,
      REFRESH_TOKEN,
      REFRESH_TOKEN_EXPIRES_IN,
      REQUESTED_TOKEN_USE,
      REQ_CNF,
      RESPONSE_MODE,
      RESPONSE_TYPE,
      RETURN_SPA_CODE,
      SCOPE,
      SESSION_STATE,
      SID,
      STATE,
      TOKEN_TYPE,
      X_APP_NAME,
      X_APP_VER,
      X_CLIENT_CPU,
      X_CLIENT_CURR_TELEM,
      X_CLIENT_EXTRA_SKU,
      X_CLIENT_LAST_TELEM,
      X_CLIENT_OS,
      X_CLIENT_SKU,
      X_CLIENT_VER,
      X_MS_LIB_CAPABILITY
    });
    var DEFAULT_CRYPTO_IMPLEMENTATION = {
      createNewGuid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Decode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Encode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64UrlEncode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      encodeKid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      async getPublicKeyThumbprint() {
        throw createClientAuthError(methodNotImplemented);
      },
      async removeTokenBindingKey() {
        throw createClientAuthError(methodNotImplemented);
      },
      async clearKeystore() {
        throw createClientAuthError(methodNotImplemented);
      },
      async signJwt() {
        throw createClientAuthError(methodNotImplemented);
      },
      async hashString() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
    exports2.LogLevel = void 0;
    (function(LogLevel) {
      LogLevel[LogLevel["Error"] = 0] = "Error";
      LogLevel[LogLevel["Warning"] = 1] = "Warning";
      LogLevel[LogLevel["Info"] = 2] = "Info";
      LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
      LogLevel[LogLevel["Trace"] = 4] = "Trace";
    })(exports2.LogLevel || (exports2.LogLevel = {}));
    var Logger = class _Logger {
      constructor(loggerOptions, packageName, packageVersion) {
        this.level = exports2.LogLevel.Info;
        const defaultLoggerCallback = () => {
          return;
        };
        const setLoggerOptions = loggerOptions || _Logger.createDefaultLoggerOptions();
        this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback;
        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
        this.level = typeof setLoggerOptions.logLevel === "number" ? setLoggerOptions.logLevel : exports2.LogLevel.Info;
        this.correlationId = setLoggerOptions.correlationId || Constants.EMPTY_STRING;
        this.packageName = packageName || Constants.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
      }
      static createDefaultLoggerOptions() {
        return {
          loggerCallback: () => {
          },
          piiLoggingEnabled: false,
          logLevel: exports2.LogLevel.Info
        };
      }
      /**
       * Create new Logger with existing configurations.
       */
      clone(packageName, packageVersion, correlationId) {
        return new _Logger({
          loggerCallback: this.localCallback,
          piiLoggingEnabled: this.piiLoggingEnabled,
          logLevel: this.level,
          correlationId: correlationId || this.correlationId
        }, packageName, packageVersion);
      }
      /**
       * Log message with required options.
       */
      logMessage(logMessage, options) {
        if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
          return;
        }
        const timestamp = (/* @__PURE__ */ new Date()).toUTCString();
        const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ""}]`;
        const log2 = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${exports2.LogLevel[options.logLevel]} - ${logMessage}`;
        this.executeCallback(options.logLevel, log2, options.containsPii || false);
      }
      /**
       * Execute callback with message.
       */
      executeCallback(level, message, containsPii) {
        if (this.localCallback) {
          this.localCallback(level, message, containsPii);
        }
      }
      /**
       * Logs error messages.
       */
      error(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Error,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs error messages with PII.
       */
      errorPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Error,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages.
       */
      warning(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Warning,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages with PII.
       */
      warningPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Warning,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs info messages.
       */
      info(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Info,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs info messages with PII.
       */
      infoPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Info,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages.
       */
      verbose(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Verbose,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages with PII.
       */
      verbosePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Verbose,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages.
       */
      trace(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Trace,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages with PII.
       */
      tracePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Trace,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      }
      /**
       * Returns whether PII Logging is enabled or not.
       */
      isPiiLoggingEnabled() {
        return this.piiLoggingEnabled || false;
      }
    };
    var name = "@azure/msal-common";
    var version2 = "15.15.0";
    var ScopeSet = class _ScopeSet {
      constructor(inputScopes) {
        const scopeArr = inputScopes ? StringUtils.trimArrayEntries([...inputScopes]) : [];
        const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        if (!filteredInput || !filteredInput.length) {
          throw createClientConfigurationError(emptyInputScopesError);
        }
        this.scopes = /* @__PURE__ */ new Set();
        filteredInput.forEach((scope) => this.scopes.add(scope));
      }
      /**
       * Factory method to create ScopeSet from space-delimited string
       * @param inputScopeString
       * @param appClientId
       * @param scopesRequired
       */
      static fromString(inputScopeString) {
        const scopeString = inputScopeString || Constants.EMPTY_STRING;
        const inputScopes = scopeString.split(" ");
        return new _ScopeSet(inputScopes);
      }
      /**
       * Creates the set of scopes to search for in cache lookups
       * @param inputScopeString
       * @returns
       */
      static createSearchScopes(inputScopeString) {
        const scopesToUse = inputScopeString && inputScopeString.length > 0 ? inputScopeString : [...OIDC_DEFAULT_SCOPES];
        const scopeSet = new _ScopeSet(scopesToUse);
        if (!scopeSet.containsOnlyOIDCScopes()) {
          scopeSet.removeOIDCScopes();
        } else {
          scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
        }
        return scopeSet;
      }
      /**
       * Check if a given scope is present in this set of scopes.
       * @param scope
       */
      containsScope(scope) {
        const lowerCaseScopes = this.printScopesLowerCase().split(" ");
        const lowerCaseScopesSet = new _ScopeSet(lowerCaseScopes);
        return scope ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
      }
      /**
       * Check if a set of scopes is present in this set of scopes.
       * @param scopeSet
       */
      containsScopeSet(scopeSet) {
        if (!scopeSet || scopeSet.scopes.size <= 0) {
          return false;
        }
        return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every((scope) => this.containsScope(scope));
      }
      /**
       * Check if set of scopes contains only the defaults
       */
      containsOnlyOIDCScopes() {
        let defaultScopeCount = 0;
        OIDC_SCOPES.forEach((defaultScope) => {
          if (this.containsScope(defaultScope)) {
            defaultScopeCount += 1;
          }
        });
        return this.scopes.size === defaultScopeCount;
      }
      /**
       * Appends single scope if passed
       * @param newScope
       */
      appendScope(newScope) {
        if (newScope) {
          this.scopes.add(newScope.trim());
        }
      }
      /**
       * Appends multiple scopes if passed
       * @param newScopes
       */
      appendScopes(newScopes) {
        try {
          newScopes.forEach((newScope) => this.appendScope(newScope));
        } catch (e) {
          throw createClientAuthError(cannotAppendScopeSet);
        }
      }
      /**
       * Removes element from set of scopes.
       * @param scope
       */
      removeScope(scope) {
        if (!scope) {
          throw createClientAuthError(cannotRemoveEmptyScope);
        }
        this.scopes.delete(scope.trim());
      }
      /**
       * Removes default scopes from set of scopes
       * Primarily used to prevent cache misses if the default scopes are not returned from the server
       */
      removeOIDCScopes() {
        OIDC_SCOPES.forEach((defaultScope) => {
          this.scopes.delete(defaultScope);
        });
      }
      /**
       * Combines an array of scopes with the current set of scopes.
       * @param otherScopes
       */
      unionScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        const unionScopes = /* @__PURE__ */ new Set();
        otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        return unionScopes;
      }
      /**
       * Check if scopes intersect between this set and another.
       * @param otherScopes
       */
      intersectingScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        if (!otherScopes.containsOnlyOIDCScopes()) {
          otherScopes.removeOIDCScopes();
        }
        const unionScopes = this.unionScopeSets(otherScopes);
        const sizeOtherScopes = otherScopes.getScopeCount();
        const sizeThisScopes = this.getScopeCount();
        const sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
      }
      /**
       * Returns size of set of scopes.
       */
      getScopeCount() {
        return this.scopes.size;
      }
      /**
       * Returns the scopes as an array of string values
       */
      asArray() {
        const array = [];
        this.scopes.forEach((val) => array.push(val));
        return array;
      }
      /**
       * Prints scopes into a space-delimited string
       */
      printScopes() {
        if (this.scopes) {
          const scopeArr = this.asArray();
          return scopeArr.join(" ");
        }
        return Constants.EMPTY_STRING;
      }
      /**
       * Prints scopes into a space-delimited lower-case string (used for caching)
       */
      printScopesLowerCase() {
        return this.printScopes().toLowerCase();
      }
    };
    function buildClientInfo(rawClientInfo, base64Decode) {
      if (!rawClientInfo) {
        throw createClientAuthError(clientInfoEmptyError);
      }
      try {
        const decodedClientInfo = base64Decode(rawClientInfo);
        return JSON.parse(decodedClientInfo);
      } catch (e) {
        throw createClientAuthError(clientInfoDecodingError);
      }
    }
    function buildClientInfoFromHomeAccountId(homeAccountId) {
      if (!homeAccountId) {
        throw createClientAuthError(clientInfoDecodingError);
      }
      const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
      return {
        uid: clientInfoParts[0],
        utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
      };
    }
    function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
      return !!tenantId && !!homeAccountId && tenantId === homeAccountId.split(".")[1];
    }
    function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
      if (idTokenClaims) {
        const { oid, sub, tid, name: name2, tfp, acr, preferred_username, upn, login_hint } = idTokenClaims;
        const tenantId2 = tid || tfp || acr || "";
        return {
          tenantId: tenantId2,
          localAccountId: oid || sub || "",
          name: name2,
          username: preferred_username || upn || "",
          loginHint: login_hint,
          isHomeTenant: tenantIdMatchesHomeTenant(tenantId2, homeAccountId)
        };
      } else {
        return {
          tenantId,
          localAccountId,
          username: "",
          isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId)
        };
      }
    }
    function updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {
      let updatedAccountInfo = baseAccountInfo;
      if (tenantProfile) {
        const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
        updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
      }
      if (idTokenClaims) {
        const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);
        updatedAccountInfo = {
          ...updatedAccountInfo,
          ...claimsSourcedTenantProfile,
          idTokenClaims,
          idToken: idTokenSecret
        };
        return updatedAccountInfo;
      }
      return updatedAccountInfo;
    }
    function getTenantIdFromIdTokenClaims(idTokenClaims) {
      if (idTokenClaims) {
        const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
        return tenantId || null;
      }
      return null;
    }
    var AccountEntity = class _AccountEntity {
      /**
       * Returns the AccountInfo interface for this account.
       */
      static getAccountInfo(accountEntity) {
        const tenantProfiles = accountEntity.tenantProfiles || [];
        if (tenantProfiles.length === 0 && accountEntity.realm && accountEntity.localAccountId) {
          tenantProfiles.push(buildTenantProfile(accountEntity.homeAccountId, accountEntity.localAccountId, accountEntity.realm));
        }
        return {
          homeAccountId: accountEntity.homeAccountId,
          environment: accountEntity.environment,
          tenantId: accountEntity.realm,
          username: accountEntity.username,
          localAccountId: accountEntity.localAccountId,
          loginHint: accountEntity.loginHint,
          name: accountEntity.name,
          nativeAccountId: accountEntity.nativeAccountId,
          authorityType: accountEntity.authorityType,
          // Deserialize tenant profiles array into a Map
          tenantProfiles: new Map(tenantProfiles.map((tenantProfile) => {
            return [tenantProfile.tenantId, tenantProfile];
          })),
          dataBoundary: accountEntity.dataBoundary
        };
      }
      /**
       * Returns true if the account entity is in single tenant format (outdated), false otherwise
       */
      isSingleTenant() {
        return !this.tenantProfiles;
      }
      /**
       * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
       * @param accountDetails
       */
      static createAccount(accountDetails, authority, base64Decode) {
        const account = new _AccountEntity();
        if (authority.authorityType === AuthorityType.Adfs) {
          account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
        } else if (authority.protocolMode === ProtocolMode.OIDC) {
          account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
        } else {
          account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
        }
        let clientInfo;
        if (accountDetails.clientInfo && base64Decode) {
          clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);
          if (clientInfo.xms_tdbr) {
            account.dataBoundary = clientInfo.xms_tdbr === "EU" ? "EU" : "None";
          }
        }
        account.clientInfo = accountDetails.clientInfo;
        account.homeAccountId = accountDetails.homeAccountId;
        account.nativeAccountId = accountDetails.nativeAccountId;
        const env = accountDetails.environment || authority && authority.getPreferredCache();
        if (!env) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        account.environment = env;
        account.realm = clientInfo?.utid || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || "";
        account.localAccountId = clientInfo?.uid || accountDetails.idTokenClaims?.oid || accountDetails.idTokenClaims?.sub || "";
        const preferredUsername = accountDetails.idTokenClaims?.preferred_username || accountDetails.idTokenClaims?.upn;
        const email = accountDetails.idTokenClaims?.emails ? accountDetails.idTokenClaims.emails[0] : null;
        account.username = preferredUsername || email || "";
        account.loginHint = accountDetails.idTokenClaims?.login_hint;
        account.name = accountDetails.idTokenClaims?.name || "";
        account.cloudGraphHostName = accountDetails.cloudGraphHostName;
        account.msGraphHost = accountDetails.msGraphHost;
        if (accountDetails.tenantProfiles) {
          account.tenantProfiles = accountDetails.tenantProfiles;
        } else {
          const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);
          account.tenantProfiles = [tenantProfile];
        }
        return account;
      }
      /**
       * Creates an AccountEntity object from AccountInfo
       * @param accountInfo
       * @param cloudGraphHostName
       * @param msGraphHost
       * @returns
       */
      static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
        const account = new _AccountEntity();
        account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = accountInfo.homeAccountId;
        account.localAccountId = accountInfo.localAccountId;
        account.nativeAccountId = accountInfo.nativeAccountId;
        account.realm = accountInfo.tenantId;
        account.environment = accountInfo.environment;
        account.username = accountInfo.username;
        account.name = accountInfo.name;
        account.loginHint = accountInfo.loginHint;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        const tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);
        if (tenantProfiles.length === 0 && accountInfo.tenantId && accountInfo.localAccountId) {
          tenantProfiles.push(buildTenantProfile(accountInfo.homeAccountId, accountInfo.localAccountId, accountInfo.tenantId, accountInfo.idTokenClaims));
        }
        account.tenantProfiles = tenantProfiles;
        account.dataBoundary = accountInfo.dataBoundary;
        return account;
      }
      /**
       * Generate HomeAccountId from server response
       * @param serverClientInfo
       * @param authType
       */
      static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {
        if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {
          if (serverClientInfo) {
            try {
              const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
              if (clientInfo.uid && clientInfo.utid) {
                return `${clientInfo.uid}.${clientInfo.utid}`;
              }
            } catch (e) {
            }
          }
          logger.warning("No client info in response");
        }
        return idTokenClaims?.sub || "";
      }
      /**
       * Validates an entity: checks for all expected params
       * @param entity
       */
      static isAccountEntity(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
      }
      /**
       * Helper function to determine whether 2 accountInfo objects represent the same account
       * @param accountA
       * @param accountB
       * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
       */
      static accountInfoIsEqual(accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
          return false;
        }
        let claimsMatch = true;
        if (compareClaims) {
          const accountAClaims = accountA.idTokenClaims || {};
          const accountBClaims = accountB.idTokenClaims || {};
          claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
        }
        return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.loginHint === accountB.loginHint && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
      }
    };
    var cacheQuotaExceeded = "cache_quota_exceeded";
    var cacheErrorUnknown = "cache_error_unknown";
    var CacheErrorCodes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      cacheErrorUnknown,
      cacheQuotaExceeded
    });
    var CacheErrorMessages = {
      [cacheQuotaExceeded]: "Exceeded cache storage capacity.",
      [cacheErrorUnknown]: "Unexpected error occurred when using cache storage."
    };
    var CacheError = class _CacheError extends AuthError {
      constructor(errorCode, errorMessage) {
        const message = errorMessage || (CacheErrorMessages[errorCode] ? CacheErrorMessages[errorCode] : CacheErrorMessages[cacheErrorUnknown]);
        super(`${errorCode}: ${message}`);
        Object.setPrototypeOf(this, _CacheError.prototype);
        this.name = "CacheError";
        this.errorCode = errorCode;
        this.errorMessage = message;
      }
    };
    function createCacheError(e) {
      if (!(e instanceof Error)) {
        return new CacheError(cacheErrorUnknown);
      }
      if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED" || e.message.includes("exceeded the quota")) {
        return new CacheError(cacheQuotaExceeded);
      } else {
        return new CacheError(e.name, e.message);
      }
    }
    var CacheManager = class {
      constructor(clientId, cryptoImpl, logger, performanceClient, staticAuthorityOptions) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl;
        this.commonLogger = logger.clone(name, version2);
        this.staticAuthorityOptions = staticAuthorityOptions;
        this.performanceClient = performanceClient;
      }
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter, correlationId) {
        return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter, correlationId), correlationId, accountFilter);
      }
      /**
       * Gets first tenanted AccountInfo object found based on provided filters
       */
      getAccountInfoFilteredBy(accountFilter, correlationId) {
        if (Object.keys(accountFilter).length === 0 || Object.values(accountFilter).every((value) => !value)) {
          this.commonLogger.warning("getAccountInfoFilteredBy: Account filter is empty or invalid, returning null");
          return null;
        }
        const allAccounts = this.getAllAccounts(accountFilter, correlationId);
        if (allAccounts.length > 1) {
          const sortedAccounts = allAccounts.sort((account) => {
            return account.idTokenClaims ? -1 : 1;
          });
          return sortedAccounts[0];
        } else if (allAccounts.length === 1) {
          return allAccounts[0];
        } else {
          return null;
        }
      }
      /**
       * Returns a single matching
       * @param accountFilter
       * @returns
       */
      getBaseAccountInfo(accountFilter, correlationId) {
        const accountEntities = this.getAccountsFilteredBy(accountFilter, correlationId);
        if (accountEntities.length > 0) {
          return AccountEntity.getAccountInfo(accountEntities[0]);
        } else {
          return null;
        }
      }
      /**
       * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
       * and builds the account info objects from the matching ID token's claims
       * @param cachedAccounts
       * @param accountFilter
       * @returns Array of AccountInfo objects that match account and tenant profile filters
       */
      buildTenantProfiles(cachedAccounts, correlationId, accountFilter) {
        return cachedAccounts.flatMap((accountEntity) => {
          return this.getTenantProfilesFromAccountEntity(accountEntity, correlationId, accountFilter?.tenantId, accountFilter);
        });
      }
      getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter) {
        let tenantedAccountInfo = null;
        let idTokenClaims;
        if (tenantProfileFilter) {
          if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
            return null;
          }
        }
        const idToken = this.getIdToken(accountInfo, correlationId, tokenKeys, tenantProfile.tenantId);
        if (idToken) {
          idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
          if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
            return null;
          }
        }
        tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken?.secret);
        return tenantedAccountInfo;
      }
      getTenantProfilesFromAccountEntity(accountEntity, correlationId, targetTenantId, tenantProfileFilter) {
        const accountInfo = AccountEntity.getAccountInfo(accountEntity);
        let searchTenantProfiles = accountInfo.tenantProfiles || /* @__PURE__ */ new Map();
        const tokenKeys = this.getTokenKeys();
        if (targetTenantId) {
          const tenantProfile = searchTenantProfiles.get(targetTenantId);
          if (tenantProfile) {
            searchTenantProfiles = /* @__PURE__ */ new Map([
              [targetTenantId, tenantProfile]
            ]);
          } else {
            return [];
          }
        }
        const matchingTenantProfiles = [];
        searchTenantProfiles.forEach((tenantProfile) => {
          const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter);
          if (tenantedAccountInfo) {
            matchingTenantProfiles.push(tenantedAccountInfo);
          }
        });
        return matchingTenantProfiles;
      }
      tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
        if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {
          return false;
        }
        if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {
          return false;
        }
        if (tenantProfileFilter.isHomeTenant !== void 0 && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {
          return false;
        }
        return true;
      }
      idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
        if (tenantProfileFilter) {
          if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {
            return false;
          }
          if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {
            return false;
          }
          if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {
            return false;
          }
          if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {
            return false;
          }
          if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
            return false;
          }
        }
        return true;
      }
      /**
       * saves a cache record
       * @param cacheRecord {CacheRecord}
       * @param correlationId {?string} correlation id
       * @param kmsi - Keep Me Signed In
       * @param apiId - API identifier for telemetry tracking
       * @param storeInCache {?StoreInCache}
       */
      async saveCacheRecord(cacheRecord, correlationId, kmsi, apiId, storeInCache) {
        if (!cacheRecord) {
          throw createClientAuthError(invalidCacheRecord);
        }
        try {
          if (!!cacheRecord.account) {
            await this.setAccount(cacheRecord.account, correlationId, kmsi, apiId);
          }
          if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {
            await this.setIdTokenCredential(cacheRecord.idToken, correlationId, kmsi);
          }
          if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {
            await this.saveAccessToken(cacheRecord.accessToken, correlationId, kmsi);
          }
          if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {
            await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId, kmsi);
          }
          if (!!cacheRecord.appMetadata) {
            this.setAppMetadata(cacheRecord.appMetadata, correlationId);
          }
        } catch (e) {
          this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createCacheError(e);
          }
        }
      }
      /**
       * saves access token credential
       * @param credential
       */
      async saveAccessToken(credential, correlationId, kmsi) {
        const accessTokenFilter = {
          clientId: credential.clientId,
          credentialType: credential.credentialType,
          environment: credential.environment,
          homeAccountId: credential.homeAccountId,
          realm: credential.realm,
          tokenType: credential.tokenType,
          requestedClaimsHash: credential.requestedClaimsHash
        };
        const tokenKeys = this.getTokenKeys();
        const currentScopes = ScopeSet.fromString(credential.target);
        tokenKeys.accessToken.forEach((key) => {
          if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {
            return;
          }
          const tokenEntity = this.getAccessTokenCredential(key, correlationId);
          if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
            const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
            if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
              this.removeAccessToken(key, correlationId);
            }
          }
        });
        await this.setAccessTokenCredential(credential, correlationId, kmsi);
      }
      /**
       * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
       * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
       * @param accountFilter - An object containing Account properties to filter by
       */
      getAccountsFilteredBy(accountFilter, correlationId) {
        const allAccountKeys = this.getAccountKeys();
        const matchingAccounts = [];
        allAccountKeys.forEach((cacheKey) => {
          const entity = this.getAccount(cacheKey, correlationId);
          if (!entity) {
            return;
          }
          if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
            return;
          }
          if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {
            return;
          }
          if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {
            return;
          }
          if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {
            return;
          }
          if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
            return;
          }
          if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {
            return;
          }
          const tenantProfileFilter = {
            localAccountId: accountFilter?.localAccountId,
            name: accountFilter?.name
          };
          const matchingTenantProfiles = entity.tenantProfiles?.filter((tenantProfile) => {
            return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
          });
          if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
            return;
          }
          matchingAccounts.push(entity);
        });
        return matchingAccounts;
      }
      /**
       * Returns whether or not the given credential entity matches the filter
       * @param entity
       * @param filter
       * @returns
       */
      credentialMatchesFilter(entity, filter) {
        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
          return false;
        }
        if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {
          return false;
        }
        if (typeof filter.homeAccountId === "string" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {
          return false;
        }
        if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
          return false;
        }
        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {
          return false;
        }
        if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {
          return false;
        }
        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {
          return false;
        }
        if (!!filter.target && !this.matchTarget(entity, filter.target)) {
          return false;
        }
        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {
          if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {
            return false;
          }
        }
        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
          if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {
            return false;
          }
          if (filter.tokenType === AuthenticationScheme.SSH) {
            if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
       * @param filter
       */
      getAppMetadataFilteredBy(filter) {
        const allCacheKeys = this.getKeys();
        const matchingAppMetadata = {};
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAppMetadata(cacheKey)) {
            return;
          }
          const entity = this.getAppMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
            return;
          }
          if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
            return;
          }
          matchingAppMetadata[cacheKey] = entity;
        });
        return matchingAppMetadata;
      }
      /**
       * retrieve authorityMetadata that contains a matching alias
       * @param filter
       */
      getAuthorityMetadataByAlias(host) {
        const allCacheKeys = this.getAuthorityMetadataKeys();
        let matchedEntity = null;
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {
            return;
          }
          const entity = this.getAuthorityMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (entity.aliases.indexOf(host) === -1) {
            return;
          }
          matchedEntity = entity;
        });
        return matchedEntity;
      }
      /**
       * Removes all accounts and related tokens from cache.
       */
      removeAllAccounts(correlationId) {
        const accounts = this.getAllAccounts({}, correlationId);
        accounts.forEach((account) => {
          this.removeAccount(account, correlationId);
        });
      }
      /**
       * Removes the account and related tokens for a given account key
       * @param account
       */
      removeAccount(account, correlationId) {
        this.removeAccountContext(account, correlationId);
        const accountKeys = this.getAccountKeys();
        const keyFilter = (key) => {
          return key.includes(account.homeAccountId) && key.includes(account.environment);
        };
        accountKeys.filter(keyFilter).forEach((key) => {
          this.removeItem(key, correlationId);
          this.performanceClient.incrementFields({ accountsRemoved: 1 }, correlationId);
        });
      }
      /**
       * Removes credentials associated with the provided account
       * @param account
       */
      removeAccountContext(account, correlationId) {
        const allTokenKeys = this.getTokenKeys();
        const keyFilter = (key) => {
          return key.includes(account.homeAccountId) && key.includes(account.environment);
        };
        allTokenKeys.idToken.filter(keyFilter).forEach((key) => {
          this.removeIdToken(key, correlationId);
        });
        allTokenKeys.accessToken.filter(keyFilter).forEach((key) => {
          this.removeAccessToken(key, correlationId);
        });
        allTokenKeys.refreshToken.filter(keyFilter).forEach((key) => {
          this.removeRefreshToken(key, correlationId);
        });
      }
      /**
       * Removes accessToken from the cache
       * @param key
       * @param correlationId
       */
      removeAccessToken(key, correlationId) {
        const credential = this.getAccessTokenCredential(key, correlationId);
        this.removeItem(key, correlationId);
        this.performanceClient.incrementFields({ accessTokensRemoved: 1 }, correlationId);
        if (!credential || credential.credentialType.toLowerCase() !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase() || credential.tokenType !== AuthenticationScheme.POP) {
          return;
        }
        const kid = credential.keyId;
        if (kid) {
          void this.cryptoImpl.removeTokenBindingKey(kid).catch(() => {
            this.commonLogger.error(`Failed to remove token binding key ${kid}`, correlationId);
            this.performanceClient?.incrementFields({ removeTokenBindingKeyFailure: 1 }, correlationId);
          });
        }
      }
      /**
       * Removes all app metadata objects from cache.
       */
      removeAppMetadata(correlationId) {
        const allCacheKeys = this.getKeys();
        allCacheKeys.forEach((cacheKey) => {
          if (this.isAppMetadata(cacheKey)) {
            this.removeItem(cacheKey, correlationId);
          }
        });
        return true;
      }
      /**
       * Retrieve IdTokenEntity from cache
       * @param account {AccountInfo}
       * @param tokenKeys {?TokenKeys}
       * @param targetRealm {?string}
       * @param performanceClient {?IPerformanceClient}
       * @param correlationId {?string}
       */
      getIdToken(account, correlationId, tokenKeys, targetRealm, performanceClient) {
        this.commonLogger.trace("CacheManager - getIdToken called");
        const idTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.clientId,
          realm: targetRealm
        };
        const idTokenMap = this.getIdTokensByFilter(idTokenFilter, correlationId, tokenKeys);
        const numIdTokens = idTokenMap.size;
        if (numIdTokens < 1) {
          this.commonLogger.info("CacheManager:getIdToken - No token found");
          return null;
        } else if (numIdTokens > 1) {
          let tokensToBeRemoved = idTokenMap;
          if (!targetRealm) {
            const homeIdTokenMap = /* @__PURE__ */ new Map();
            idTokenMap.forEach((idToken, key) => {
              if (idToken.realm === account.tenantId) {
                homeIdTokenMap.set(key, idToken);
              }
            });
            const numHomeIdTokens = homeIdTokenMap.size;
            if (numHomeIdTokens < 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");
              return idTokenMap.values().next().value;
            } else if (numHomeIdTokens === 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");
              return homeIdTokenMap.values().next().value;
            } else {
              tokensToBeRemoved = homeIdTokenMap;
            }
          }
          this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");
          tokensToBeRemoved.forEach((idToken, key) => {
            this.removeIdToken(key, correlationId);
          });
          if (performanceClient && correlationId) {
            performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
          }
          return null;
        }
        this.commonLogger.info("CacheManager:getIdToken - Returning ID token");
        return idTokenMap.values().next().value;
      }
      /**
       * Gets all idTokens matching the given filter
       * @param filter
       * @returns
       */
      getIdTokensByFilter(filter, correlationId, tokenKeys) {
        const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;
        const idTokens = /* @__PURE__ */ new Map();
        idTokenKeys.forEach((key) => {
          if (!this.idTokenKeyMatchesFilter(key, {
            clientId: this.clientId,
            ...filter
          })) {
            return;
          }
          const idToken = this.getIdTokenCredential(key, correlationId);
          if (idToken && this.credentialMatchesFilter(idToken, filter)) {
            idTokens.set(key, idToken);
          }
        });
        return idTokens;
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @returns
       */
      idTokenKeyMatchesFilter(inputKey, filter) {
        const key = inputKey.toLowerCase();
        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Removes idToken from the cache
       * @param key
       */
      removeIdToken(key, correlationId) {
        this.removeItem(key, correlationId);
      }
      /**
       * Removes refresh token from the cache
       * @param key
       */
      removeRefreshToken(key, correlationId) {
        this.removeItem(key, correlationId);
      }
      /**
       * Retrieve AccessTokenEntity from cache
       * @param account {AccountInfo}
       * @param request {BaseAuthRequest}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getAccessToken(account, request, tokenKeys, targetRealm) {
        const correlationId = request.correlationId;
        this.commonLogger.trace("CacheManager - getAccessToken called", correlationId);
        const scopes = ScopeSet.createSearchScopes(request.scopes);
        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
        const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        const accessTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType,
          clientId: this.clientId,
          realm: targetRealm || account.tenantId,
          target: scopes,
          tokenType: authScheme,
          keyId: request.sshKid,
          requestedClaimsHash: request.requestedClaimsHash
        };
        const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;
        const accessTokens = [];
        accessTokenKeys.forEach((key) => {
          if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {
            const accessToken = this.getAccessTokenCredential(key, correlationId);
            if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
              accessTokens.push(accessToken);
            }
          }
        });
        const numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          this.commonLogger.info("CacheManager:getAccessToken - No token found", correlationId);
          return null;
        } else if (numAccessTokens > 1) {
          this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them", correlationId);
          accessTokens.forEach((accessToken) => {
            this.removeAccessToken(this.generateCredentialKey(accessToken), correlationId);
          });
          this.performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
          return null;
        }
        this.commonLogger.info("CacheManager:getAccessToken - Returning access token", correlationId);
        return accessTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @param keyMustContainAllScopes
       * @returns
       */
      accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {
        const key = inputKey.toLowerCase();
        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {
          return false;
        }
        if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {
          return false;
        }
        if (filter.target) {
          const scopes = filter.target.asArray();
          for (let i = 0; i < scopes.length; i++) {
            if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {
              return false;
            } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {
              return true;
            }
          }
        }
        return true;
      }
      /**
       * Gets all access tokens matching the filter
       * @param filter
       * @returns
       */
      getAccessTokensByFilter(filter, correlationId) {
        const tokenKeys = this.getTokenKeys();
        const accessTokens = [];
        tokenKeys.accessToken.forEach((key) => {
          if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {
            return;
          }
          const accessToken = this.getAccessTokenCredential(key, correlationId);
          if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {
            accessTokens.push(accessToken);
          }
        });
        return accessTokens;
      }
      /**
       * Helper to retrieve the appropriate refresh token from cache
       * @param account {AccountInfo}
       * @param familyRT {boolean}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getRefreshToken(account, familyRT, correlationId, tokenKeys, performanceClient) {
        this.commonLogger.trace("CacheManager - getRefreshToken called");
        const id = familyRT ? THE_FAMILY_ID : void 0;
        const refreshTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.REFRESH_TOKEN,
          clientId: this.clientId,
          familyId: id
        };
        const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;
        const refreshTokens = [];
        refreshTokenKeys.forEach((key) => {
          if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {
            const refreshToken = this.getRefreshTokenCredential(key, correlationId);
            if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
              refreshTokens.push(refreshToken);
            }
          }
        });
        const numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
          this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
          return null;
        }
        if (numRefreshTokens > 1 && performanceClient && correlationId) {
          performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
        }
        this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
        return refreshTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       */
      refreshTokenKeyMatchesFilter(inputKey, filter) {
        const key = inputKey.toLowerCase();
        if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {
          return false;
        }
        if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Retrieve AppMetadataEntity from cache
       */
      readAppMetadataFromCache(environment) {
        const appMetadataFilter = {
          environment,
          clientId: this.clientId
        };
        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);
        const numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
          return null;
        } else if (numAppMetadata > 1) {
          throw createClientAuthError(multipleMatchingAppMetadata);
        }
        return appMetadataEntries[0];
      }
      /**
       * Return the family_id value associated  with FOCI
       * @param environment
       * @param clientId
       */
      isAppMetadataFOCI(environment) {
        const appMetadata = this.readAppMetadataFromCache(environment);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
      }
      /**
       * helper to match account ids
       * @param value
       * @param homeAccountId
       */
      matchHomeAccountId(entity, homeAccountId) {
        return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
      }
      /**
       * helper to match account ids
       * @param entity
       * @param localAccountId
       * @returns
       */
      matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
        return localAccountId === idTokenLocalAccountId;
      }
      matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
        return tenantProfile.localAccountId === localAccountId;
      }
      /**
       * helper to match names
       * @param entity
       * @param name
       * @returns true if the downcased name properties are present and match in the filter and the entity
       */
      matchName(claims, name2) {
        return !!(name2.toLowerCase() === claims.name?.toLowerCase());
      }
      /**
       * helper to match usernames
       * @param entity
       * @param username
       * @returns
       */
      matchUsername(cachedUsername, filterUsername) {
        return !!(cachedUsername && typeof cachedUsername === "string" && filterUsername?.toLowerCase() === cachedUsername.toLowerCase());
      }
      /**
       * helper to match assertion
       * @param value
       * @param oboAssertion
       */
      matchUserAssertionHash(entity, userAssertionHash) {
        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
      }
      /**
       * helper to match environment
       * @param value
       * @param environment
       */
      matchEnvironment(entity, environment) {
        if (this.staticAuthorityOptions) {
          const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);
          if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {
            return true;
          }
        }
        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
          return true;
        }
        return false;
      }
      /**
       * helper to match credential type
       * @param entity
       * @param credentialType
       */
      matchCredentialType(entity, credentialType) {
        return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
      }
      /**
       * helper to match client ids
       * @param entity
       * @param clientId
       */
      matchClientId(entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId);
      }
      /**
       * helper to match family ids
       * @param entity
       * @param familyId
       */
      matchFamilyId(entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId);
      }
      /**
       * helper to match realm
       * @param entity
       * @param realm
       */
      matchRealm(entity, realm) {
        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());
      }
      /**
       * helper to match nativeAccountId
       * @param entity
       * @param nativeAccountId
       * @returns boolean indicating the match result
       */
      matchNativeAccountId(entity, nativeAccountId) {
        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
      }
      /**
       * helper to match loginHint which can be either:
       * 1. login_hint ID token claim
       * 2. username in cached account object
       * 3. upn in ID token claims
       * @param entity
       * @param loginHint
       * @returns
       */
      matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
        if (tokenClaims.login_hint === loginHint) {
          return true;
        }
        if (tokenClaims.preferred_username === loginHint) {
          return true;
        }
        if (tokenClaims.upn === loginHint) {
          return true;
        }
        return false;
      }
      /**
       * Helper to match sid
       * @param entity
       * @param sid
       * @returns true if the sid claim is present and matches the filter
       */
      matchSid(idTokenClaims, sid) {
        return idTokenClaims.sid === sid;
      }
      matchAuthorityType(entity, authorityType) {
        return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());
      }
      /**
       * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
       * @param entity
       * @param target
       */
      matchTarget(entity, target) {
        const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        if (isNotAccessTokenCredential || !entity.target) {
          return false;
        }
        const entityScopeSet = ScopeSet.fromString(entity.target);
        return entityScopeSet.containsScopeSet(target);
      }
      /**
       * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
       * @param entity
       * @param tokenType
       */
      matchTokenType(entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType);
      }
      /**
       * Returns true if the credential's keyId matches the one in the request, false otherwise
       * @param entity
       * @param keyId
       */
      matchKeyId(entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId);
      }
      /**
       * returns if a given cache entity is of the type appmetadata
       * @param key
       */
      isAppMetadata(key) {
        return key.indexOf(APP_METADATA) !== -1;
      }
      /**
       * returns if a given cache entity is of the type authoritymetadata
       * @param key
       */
      isAuthorityMetadata(key) {
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
      }
      /**
       * returns cache key used for cloud instance metadata
       */
      generateAuthorityMetadataCacheKey(authority) {
        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
      }
      /**
       * Helper to convert serialized data to object
       * @param obj
       * @param json
       */
      static toObject(obj, json) {
        for (const propertyName in json) {
          obj[propertyName] = json[propertyName];
        }
        return obj;
      }
    };
    var DefaultStorageClass = class extends CacheManager {
      async setAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      setServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      getServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadataKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      setThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      getThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      removeItem() {
        throw createClientAuthError(methodNotImplemented);
      }
      getKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccountKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getTokenKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      generateCredentialKey() {
        throw createClientAuthError(methodNotImplemented);
      }
      generateAccountKey() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
    var StubPerformanceMeasurement = class {
      startMeasurement() {
        return;
      }
      endMeasurement() {
        return;
      }
      flushMeasurement() {
        return null;
      }
    };
    var StubPerformanceClient = class {
      generateId() {
        return "callback-id";
      }
      startMeasurement(measureName, correlationId) {
        return {
          end: () => null,
          discard: () => {
          },
          add: () => {
          },
          increment: () => {
          },
          event: {
            eventId: this.generateId(),
            status: PerformanceEventStatus.InProgress,
            authority: "",
            libraryName: "",
            libraryVersion: "",
            clientId: "",
            name: measureName,
            startTimeMs: Date.now(),
            correlationId: correlationId || ""
          },
          measurement: new StubPerformanceMeasurement()
        };
      }
      startPerformanceMeasurement() {
        return new StubPerformanceMeasurement();
      }
      calculateQueuedTime() {
        return 0;
      }
      addQueueMeasurement() {
        return;
      }
      setPreQueueTime() {
        return;
      }
      endMeasurement() {
        return null;
      }
      discardMeasurements() {
        return;
      }
      removePerformanceCallback() {
        return true;
      }
      addPerformanceCallback() {
        return "";
      }
      emitEvents() {
        return;
      }
      addFields() {
        return;
      }
      incrementFields() {
        return;
      }
      cacheEventByCorrelationId() {
        return;
      }
    };
    var DEFAULT_SYSTEM_OPTIONS = {
      tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
      preventCorsPreflight: false
    };
    var DEFAULT_LOGGER_IMPLEMENTATION = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: exports2.LogLevel.Info,
      correlationId: Constants.EMPTY_STRING
    };
    var DEFAULT_CACHE_OPTIONS = {
      claimsBasedCachingEnabled: false
    };
    var DEFAULT_NETWORK_IMPLEMENTATION = {
      async sendGetRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      },
      async sendPostRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
    var DEFAULT_LIBRARY_INFO = {
      sku: Constants.SKU,
      version: version2,
      cpu: Constants.EMPTY_STRING,
      os: Constants.EMPTY_STRING
    };
    var DEFAULT_CLIENT_CREDENTIALS = {
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: void 0
    };
    var DEFAULT_AZURE_CLOUD_OPTIONS = {
      azureCloudInstance: AzureCloudInstance.None,
      tenant: `${Constants.DEFAULT_COMMON_TENANT}`
    };
    var DEFAULT_TELEMETRY_OPTIONS = {
      application: {
        appName: "",
        appVersion: ""
      }
    };
    function buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials, libraryInfo, telemetry, serverTelemetryManager, persistencePlugin, serializableCache }) {
      const loggerOptions = {
        ...DEFAULT_LOGGER_IMPLEMENTATION,
        ...userLoggerOption
      };
      return {
        authOptions: buildAuthOptions(userAuthOptions),
        systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },
        loggerOptions,
        cacheOptions: { ...DEFAULT_CACHE_OPTIONS, ...userCacheOptions },
        storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions), new StubPerformanceClient()),
        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
        cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
        clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
        libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },
        serverTelemetryManager: serverTelemetryManager || null,
        persistencePlugin: persistencePlugin || null,
        serializableCache: serializableCache || null
      };
    }
    function buildAuthOptions(authOptions) {
      return {
        clientCapabilities: [],
        azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
        skipAuthorityMetadataCache: false,
        instanceAware: false,
        encodeExtraQueryParams: false,
        ...authOptions
      };
    }
    function isOidcProtocolMode(config) {
      return config.authOptions.authority.options.protocolMode === ProtocolMode.OIDC;
    }
    var CcsCredentialType = {
      HOME_ACCOUNT_ID: "home_account_id",
      UPN: "UPN"
    };
    function instrumentBrokerParams(parameters, correlationId, performanceClient) {
      if (!correlationId) {
        return;
      }
      const clientId = parameters.get(CLIENT_ID);
      if (clientId && parameters.has(BROKER_CLIENT_ID)) {
        performanceClient?.addFields({
          embeddedClientId: clientId,
          embeddedRedirectUri: parameters.get(REDIRECT_URI)
        }, correlationId);
      }
    }
    function addResponseType(parameters, responseType) {
      parameters.set(RESPONSE_TYPE, responseType);
    }
    function addResponseMode(parameters, responseMode) {
      parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);
    }
    function addNativeBroker(parameters) {
      parameters.set(NATIVE_BROKER, "1");
    }
    function addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
      if (addOidcScopes && !defaultScopes.includes("openid") && !scopes.includes("openid")) {
        defaultScopes.push("openid");
      }
      const requestScopes = addOidcScopes ? [...scopes || [], ...defaultScopes] : scopes || [];
      const scopeSet = new ScopeSet(requestScopes);
      parameters.set(SCOPE, scopeSet.printScopes());
    }
    function addClientId(parameters, clientId) {
      parameters.set(CLIENT_ID, clientId);
    }
    function addRedirectUri(parameters, redirectUri) {
      parameters.set(REDIRECT_URI, redirectUri);
    }
    function addPostLogoutRedirectUri(parameters, redirectUri) {
      parameters.set(POST_LOGOUT_URI, redirectUri);
    }
    function addIdTokenHint(parameters, idTokenHint) {
      parameters.set(ID_TOKEN_HINT, idTokenHint);
    }
    function addDomainHint(parameters, domainHint) {
      parameters.set(DOMAIN_HINT, domainHint);
    }
    function addLoginHint(parameters, loginHint) {
      parameters.set(LOGIN_HINT, loginHint);
    }
    function addCcsUpn(parameters, loginHint) {
      parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);
    }
    function addCcsOid(parameters, clientInfo) {
      parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);
    }
    function addSid(parameters, sid) {
      parameters.set(SID, sid);
    }
    function addClaims(parameters, claims, clientCapabilities) {
      const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);
      try {
        JSON.parse(mergedClaims);
      } catch (e) {
        throw createClientConfigurationError(invalidClaims);
      }
      parameters.set(CLAIMS, mergedClaims);
    }
    function addCorrelationId(parameters, correlationId) {
      parameters.set(CLIENT_REQUEST_ID, correlationId);
    }
    function addLibraryInfo(parameters, libraryInfo) {
      parameters.set(X_CLIENT_SKU, libraryInfo.sku);
      parameters.set(X_CLIENT_VER, libraryInfo.version);
      if (libraryInfo.os) {
        parameters.set(X_CLIENT_OS, libraryInfo.os);
      }
      if (libraryInfo.cpu) {
        parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
      }
    }
    function addApplicationTelemetry(parameters, appTelemetry) {
      if (appTelemetry?.appName) {
        parameters.set(X_APP_NAME, appTelemetry.appName);
      }
      if (appTelemetry?.appVersion) {
        parameters.set(X_APP_VER, appTelemetry.appVersion);
      }
    }
    function addPrompt(parameters, prompt) {
      parameters.set(PROMPT, prompt);
    }
    function addState(parameters, state) {
      if (state) {
        parameters.set(STATE, state);
      }
    }
    function addNonce(parameters, nonce) {
      parameters.set(NONCE, nonce);
    }
    function addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {
      if (codeChallenge && codeChallengeMethod) {
        parameters.set(CODE_CHALLENGE, codeChallenge);
        parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);
      } else {
        throw createClientConfigurationError(pkceParamsMissing);
      }
    }
    function addAuthorizationCode(parameters, code) {
      parameters.set(CODE, code);
    }
    function addDeviceCode(parameters, code) {
      parameters.set(DEVICE_CODE, code);
    }
    function addRefreshToken(parameters, refreshToken) {
      parameters.set(REFRESH_TOKEN, refreshToken);
    }
    function addCodeVerifier(parameters, codeVerifier) {
      parameters.set(CODE_VERIFIER, codeVerifier);
    }
    function addClientSecret(parameters, clientSecret) {
      parameters.set(CLIENT_SECRET, clientSecret);
    }
    function addClientAssertion(parameters, clientAssertion) {
      if (clientAssertion) {
        parameters.set(CLIENT_ASSERTION, clientAssertion);
      }
    }
    function addClientAssertionType(parameters, clientAssertionType) {
      if (clientAssertionType) {
        parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);
      }
    }
    function addOboAssertion(parameters, oboAssertion) {
      parameters.set(OBO_ASSERTION, oboAssertion);
    }
    function addRequestTokenUse(parameters, tokenUse) {
      parameters.set(REQUESTED_TOKEN_USE, tokenUse);
    }
    function addGrantType(parameters, grantType) {
      parameters.set(GRANT_TYPE, grantType);
    }
    function addClientInfo(parameters) {
      parameters.set(CLIENT_INFO$1, "1");
    }
    function addInstanceAware(parameters) {
      if (!parameters.has(INSTANCE_AWARE)) {
        parameters.set(INSTANCE_AWARE, "true");
      }
    }
    function addExtraQueryParameters(parameters, eQParams) {
      Object.entries(eQParams).forEach(([key, value]) => {
        if (!parameters.has(key) && value) {
          parameters.set(key, value);
        }
      });
    }
    function addClientCapabilitiesToClaims(claims, clientCapabilities) {
      let mergedClaims;
      if (!claims) {
        mergedClaims = {};
      } else {
        try {
          mergedClaims = JSON.parse(claims);
        } catch (e) {
          throw createClientConfigurationError(invalidClaims);
        }
      }
      if (clientCapabilities && clientCapabilities.length > 0) {
        if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
          mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
        }
        mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
          values: clientCapabilities
        };
      }
      return JSON.stringify(mergedClaims);
    }
    function addUsername(parameters, username) {
      parameters.set(PasswordGrantConstants.username, username);
    }
    function addPassword(parameters, password) {
      parameters.set(PasswordGrantConstants.password, password);
    }
    function addPopToken(parameters, cnfString) {
      if (cnfString) {
        parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
        parameters.set(REQ_CNF, cnfString);
      }
    }
    function addSshJwk(parameters, sshJwkString) {
      if (sshJwkString) {
        parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
        parameters.set(REQ_CNF, sshJwkString);
      }
    }
    function addServerTelemetry(parameters, serverTelemetryManager) {
      parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
      parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
    }
    function addThrottling(parameters) {
      parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
    }
    function addLogoutHint(parameters, logoutHint) {
      parameters.set(LOGOUT_HINT, logoutHint);
    }
    function addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {
      if (!parameters.has(BROKER_CLIENT_ID)) {
        parameters.set(BROKER_CLIENT_ID, brokerClientId);
      }
      if (!parameters.has(BROKER_REDIRECT_URI)) {
        parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);
      }
    }
    function addEARParameters(parameters, jwk) {
      parameters.set(EAR_JWK, encodeURIComponent(jwk));
      const jweCryptoB64Encoded = "eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0";
      parameters.set(EAR_JWE_CRYPTO, jweCryptoB64Encoded);
    }
    function addPostBodyParameters(parameters, bodyParameters) {
      Object.entries(bodyParameters).forEach(([key, value]) => {
        if (value) {
          parameters.set(key, value);
        }
      });
    }
    var RequestParameterBuilder = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      addApplicationTelemetry,
      addAuthorizationCode,
      addBrokerParameters,
      addCcsOid,
      addCcsUpn,
      addClaims,
      addClientAssertion,
      addClientAssertionType,
      addClientCapabilitiesToClaims,
      addClientId,
      addClientInfo,
      addClientSecret,
      addCodeChallengeParams,
      addCodeVerifier,
      addCorrelationId,
      addDeviceCode,
      addDomainHint,
      addEARParameters,
      addExtraQueryParameters,
      addGrantType,
      addIdTokenHint,
      addInstanceAware,
      addLibraryInfo,
      addLoginHint,
      addLogoutHint,
      addNativeBroker,
      addNonce,
      addOboAssertion,
      addPassword,
      addPopToken,
      addPostBodyParameters,
      addPostLogoutRedirectUri,
      addPrompt,
      addRedirectUri,
      addRefreshToken,
      addRequestTokenUse,
      addResponseMode,
      addResponseType,
      addScopes,
      addServerTelemetry,
      addSid,
      addSshJwk,
      addState,
      addThrottling,
      addUsername,
      instrumentBrokerParams
    });
    var ServerError = class _ServerError extends AuthError {
      constructor(errorCode, errorMessage, subError, errorNo, status) {
        super(errorCode, errorMessage, subError);
        this.name = "ServerError";
        this.errorNo = errorNo;
        this.status = status;
        Object.setPrototypeOf(this, _ServerError.prototype);
      }
    };
    function getRequestThumbprint(clientId, request, homeAccountId) {
      return {
        clientId,
        authority: request.authority,
        scopes: request.scopes,
        homeAccountIdentifier: homeAccountId,
        claims: request.claims,
        authenticationScheme: request.authenticationScheme,
        resourceRequestMethod: request.resourceRequestMethod,
        resourceRequestUri: request.resourceRequestUri,
        shrClaims: request.shrClaims,
        sshKid: request.sshKid,
        embeddedClientId: request.embeddedClientId || request.tokenBodyParameters?.clientId
      };
    }
    var ThrottlingUtils = class _ThrottlingUtils {
      /**
       * Prepares a RequestThumbprint to be stored as a key.
       * @param thumbprint
       */
      static generateThrottlingStorageKey(thumbprint) {
        return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
      }
      /**
       * Performs necessary throttling checks before a network request.
       * @param cacheManager
       * @param thumbprint
       */
      static preProcess(cacheManager, thumbprint, correlationId) {
        const key = _ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
        const value = cacheManager.getThrottlingCache(key);
        if (value) {
          if (value.throttleTime < Date.now()) {
            cacheManager.removeItem(key, correlationId);
            return;
          }
          throw new ServerError(value.errorCodes?.join(" ") || Constants.EMPTY_STRING, value.errorMessage, value.subError);
        }
      }
      /**
       * Performs necessary throttling checks after a network request.
       * @param cacheManager
       * @param thumbprint
       * @param response
       */
      static postProcess(cacheManager, thumbprint, response, correlationId) {
        if (_ThrottlingUtils.checkResponseStatus(response) || _ThrottlingUtils.checkResponseForRetryAfter(response)) {
          const thumbprintValue = {
            throttleTime: _ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
            error: response.body.error,
            errorCodes: response.body.error_codes,
            errorMessage: response.body.error_description,
            subError: response.body.suberror
          };
          cacheManager.setThrottlingCache(_ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue, correlationId);
        }
      }
      /**
       * Checks a NetworkResponse object's status codes against 429 or 5xx
       * @param response
       */
      static checkResponseStatus(response) {
        return response.status === 429 || response.status >= 500 && response.status < 600;
      }
      /**
       * Checks a NetworkResponse object's RetryAfter header
       * @param response
       */
      static checkResponseForRetryAfter(response) {
        if (response.headers) {
          return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
        }
        return false;
      }
      /**
       * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
       * @param throttleTime
       */
      static calculateThrottleTime(throttleTime) {
        const time = throttleTime <= 0 ? 0 : throttleTime;
        const currentSeconds = Date.now() / 1e3;
        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
      }
      static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {
        const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);
        const key = this.generateThrottlingStorageKey(thumbprint);
        cacheManager.removeItem(key, request.correlationId);
      }
    };
    var NetworkError = class _NetworkError extends AuthError {
      constructor(error, httpStatus, responseHeaders) {
        super(error.errorCode, error.errorMessage, error.subError);
        Object.setPrototypeOf(this, _NetworkError.prototype);
        this.name = "NetworkError";
        this.error = error;
        this.httpStatus = httpStatus;
        this.responseHeaders = responseHeaders;
      }
    };
    function createNetworkError(error, httpStatus, responseHeaders, additionalError) {
      error.errorMessage = `${error.errorMessage}, additionalErrorInfo: error.name:${additionalError?.name}, error.message:${additionalError?.message}`;
      return new NetworkError(error, httpStatus, responseHeaders);
    }
    var BaseClient = class {
      constructor(configuration, performanceClient) {
        this.config = buildClientConfiguration(configuration);
        this.logger = new Logger(this.config.loggerOptions, name, version2);
        this.cryptoUtils = this.config.cryptoInterface;
        this.cacheManager = this.config.storageInterface;
        this.networkClient = this.config.networkInterface;
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        this.authority = this.config.authOptions.authority;
        this.performanceClient = performanceClient;
      }
      /**
       * Creates default headers for requests to token endpoint
       */
      createTokenRequestHeaders(ccsCred) {
        const headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
              break;
          }
        }
        return headers;
      }
      /**
       * Http post to token endpoint
       * @param tokenEndpoint
       * @param queryString
       * @param headers
       * @param thumbprint
       */
      async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {
        if (queuedEvent) {
          this.performanceClient?.addQueueMeasurement(queuedEvent, correlationId);
        }
        const response = await this.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers }, correlationId);
        if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
          this.config.serverTelemetryManager.clearTelemetryCache();
        }
        return response;
      }
      /**
       * Wraps sendPostRequestAsync with necessary preflight and postflight logic
       * @param thumbprint - Request thumbprint for throttling
       * @param tokenEndpoint - Endpoint to make the POST to
       * @param options - Body and Headers to include on the POST request
       * @param correlationId - CorrelationId for telemetry
       */
      async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {
        ThrottlingUtils.preProcess(this.cacheManager, thumbprint, correlationId);
        let response;
        try {
          response = await invokeAsync(this.networkClient.sendPostRequestAsync.bind(this.networkClient), PerformanceEvents.NetworkClientSendPostRequestAsync, this.logger, this.performanceClient, correlationId)(tokenEndpoint, options);
          const responseHeaders = response.headers || {};
          this.performanceClient?.addFields({
            refreshTokenSize: response.body.refresh_token?.length || 0,
            httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
            requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || ""
          }, correlationId);
        } catch (e) {
          if (e instanceof NetworkError) {
            const responseHeaders = e.responseHeaders;
            if (responseHeaders) {
              this.performanceClient?.addFields({
                httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
                requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || "",
                contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] || void 0,
                contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] || void 0,
                httpStatus: e.httpStatus
              }, correlationId);
            }
            throw e.error;
          }
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createClientAuthError(networkError);
          }
        }
        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response, correlationId);
        return response;
      }
      /**
       * Updates the authority object of the client. Endpoint discovery must be completed.
       * @param updatedAuthority
       */
      async updateAuthority(cloudInstanceHostname, correlationId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);
        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
        const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);
        this.authority = cloudInstanceAuthority;
      }
      /**
       * Creates query string for the /token request
       * @param request
       */
      createTokenQueryParameters(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenQueryParameters) {
          addExtraQueryParameters(parameters, request.tokenQueryParameters);
        }
        addCorrelationId(parameters, request.correlationId);
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
    var noTokensFound = "no_tokens_found";
    var nativeAccountUnavailable = "native_account_unavailable";
    var refreshTokenExpired = "refresh_token_expired";
    var uxNotAllowed = "ux_not_allowed";
    var interactionRequired = "interaction_required";
    var consentRequired = "consent_required";
    var loginRequired = "login_required";
    var badToken = "bad_token";
    var interruptedUser = "interrupted_user";
    var InteractionRequiredAuthErrorCodes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      badToken,
      consentRequired,
      interactionRequired,
      interruptedUser,
      loginRequired,
      nativeAccountUnavailable,
      noTokensFound,
      refreshTokenExpired,
      uxNotAllowed
    });
    var InteractionRequiredServerErrorMessage = [
      interactionRequired,
      consentRequired,
      loginRequired,
      badToken,
      uxNotAllowed,
      interruptedUser
    ];
    var InteractionRequiredAuthSubErrorMessage = [
      "message_only",
      "additional_action",
      "basic_action",
      "user_password_expired",
      "consent_required",
      "bad_token",
      "interrupted_user"
    ];
    var InteractionRequiredAuthErrorMessages = {
      [noTokensFound]: "No refresh token found in the cache. Please sign-in.",
      [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
      [refreshTokenExpired]: "Refresh token has expired.",
      [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve.",
      [uxNotAllowed]: "`canShowUI` flag in Edge was set to false. User interaction required on web page. Please invoke an interactive API to resolve.",
      [interruptedUser]: "The user could not be authenticated due to an interrupted state. Please invoke an interactive API to resolve."
    };
    var InteractionRequiredAuthErrorMessage = {
      noTokensFoundError: {
        code: noTokensFound,
        desc: InteractionRequiredAuthErrorMessages[noTokensFound]
      },
      native_account_unavailable: {
        code: nativeAccountUnavailable,
        desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable]
      },
      bad_token: {
        code: badToken,
        desc: InteractionRequiredAuthErrorMessages[badToken]
      },
      interrupted_user: {
        code: interruptedUser,
        desc: InteractionRequiredAuthErrorMessages[interruptedUser]
      }
    };
    var InteractionRequiredAuthError = class _InteractionRequiredAuthError extends AuthError {
      constructor(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims, errorNo) {
        super(errorCode, errorMessage, subError);
        Object.setPrototypeOf(this, _InteractionRequiredAuthError.prototype);
        this.timestamp = timestamp || Constants.EMPTY_STRING;
        this.traceId = traceId || Constants.EMPTY_STRING;
        this.correlationId = correlationId || Constants.EMPTY_STRING;
        this.claims = claims || Constants.EMPTY_STRING;
        this.name = "InteractionRequiredAuthError";
        this.errorNo = errorNo;
      }
    };
    function isInteractionRequiredError(errorCode, errorString, subError) {
      const isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
      const isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
      const isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some((irErrorCode) => {
        return errorString.indexOf(irErrorCode) > -1;
      });
      return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
    }
    function createInteractionRequiredAuthError(errorCode) {
      return new InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);
    }
    var ProtocolUtils = class _ProtocolUtils {
      /**
       * Appends user state with random guid, or returns random guid.
       * @param userState
       * @param randomGuid
       */
      static setRequestState(cryptoObj, userState, meta) {
        const libraryState = _ProtocolUtils.generateLibraryState(cryptoObj, meta);
        return userState ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;
      }
      /**
       * Generates the state value used by the common library.
       * @param randomGuid
       * @param cryptoObj
       */
      static generateLibraryState(cryptoObj, meta) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        const stateObj = {
          id: cryptoObj.createNewGuid()
        };
        if (meta) {
          stateObj.meta = meta;
        }
        const stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString);
      }
      /**
       * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
       * @param state
       * @param cryptoObj
       */
      static parseRequestState(cryptoObj, state) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        if (!state) {
          throw createClientAuthError(invalidState);
        }
        try {
          const splitState = state.split(Constants.RESOURCE_DELIM);
          const libraryState = splitState[0];
          const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
          const libraryStateString = cryptoObj.base64Decode(libraryState);
          const libraryStateObj = JSON.parse(libraryStateString);
          return {
            userRequestState: userState || Constants.EMPTY_STRING,
            libraryState: libraryStateObj
          };
        } catch (e) {
          throw createClientAuthError(invalidState);
        }
      }
    };
    var KeyLocation = {
      SW: "sw"
    };
    var PopTokenGenerator = class {
      constructor(cryptoUtils, performanceClient) {
        this.cryptoUtils = cryptoUtils;
        this.performanceClient = performanceClient;
      }
      /**
       * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
       * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
       * @param request
       * @returns
       */
      async generateCnf(request, logger) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
        const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger, this.performanceClient, request.correlationId)(request);
        const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
        return {
          kid: reqCnf.kid,
          reqCnfString
        };
      }
      /**
       * Generates key_id for a SHR token request
       * @param request
       * @returns
       */
      async generateKid(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
        const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);
        return {
          kid: kidThumbprint,
          xms_ksl: KeyLocation.SW
        };
      }
      /**
       * Signs the POP access_token with the local generated key-pair
       * @param accessToken
       * @param request
       * @returns
       */
      async signPopToken(accessToken, keyId, request) {
        return this.signPayload(accessToken, keyId, request);
      }
      /**
       * Utility function to generate the signed JWT for an access_token
       * @param payload
       * @param kid
       * @param request
       * @param claims
       * @returns
       */
      async signPayload(payload, keyId, request, claims) {
        const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions } = request;
        const resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
        const resourceUrlComponents = resourceUrlString?.getUrlComponents();
        return this.cryptoUtils.signJwt({
          at: payload,
          ts: nowSeconds(),
          m: resourceRequestMethod?.toUpperCase(),
          u: resourceUrlComponents?.HostNameAndPort,
          nonce: shrNonce || this.cryptoUtils.createNewGuid(),
          p: resourceUrlComponents?.AbsolutePath,
          q: resourceUrlComponents?.QueryString ? [[], resourceUrlComponents.QueryString] : void 0,
          client_claims: shrClaims || void 0,
          ...claims
        }, keyId, shrOptions, request.correlationId);
      }
    };
    var TokenCacheContext = class {
      constructor(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged;
      }
      /**
       * boolean which indicates the changes in cache
       */
      get cacheHasChanged() {
        return this.hasChanged;
      }
      /**
       * function to retrieve the token cache
       */
      get tokenCache() {
        return this.cache;
      }
    };
    var ResponseHandler = class _ResponseHandler {
      constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin;
        this.performanceClient = performanceClient;
      }
      /**
       * Function which validates server authorization token response.
       * @param serverResponse
       * @param refreshAccessToken
       */
      validateTokenResponse(serverResponse, refreshAccessToken) {
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          const errString = `Error(s): ${serverResponse.error_codes || Constants.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants.NOT_AVAILABLE}`;
          const serverErrorNo = serverResponse.error_codes?.length ? serverResponse.error_codes[0] : void 0;
          const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);
          if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.
${serverError}`);
            return;
          } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.
${serverError}`);
            return;
          }
          if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
            throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING, serverErrorNo);
          }
          throw serverError;
        }
      }
      /**
       * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
       * @param serverTokenResponse
       * @param authority
       */
      async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, apiId, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
        let idTokenClaims;
        if (serverTokenResponse.id_token) {
          idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);
          if (authCodePayload && authCodePayload.nonce) {
            if (idTokenClaims.nonce !== authCodePayload.nonce) {
              throw createClientAuthError(nonceMismatch);
            }
          }
          if (request.maxAge || request.maxAge === 0) {
            const authTime = idTokenClaims.auth_time;
            if (!authTime) {
              throw createClientAuthError(authTimeNotFound);
            }
            checkMaxAge(authTime, request.maxAge);
          }
        }
        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
        let requestStateObj;
        if (!!authCodePayload && !!authCodePayload.state) {
          requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
        }
        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || void 0;
        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);
        let cacheContext;
        try {
          if (this.persistencePlugin && this.serializableCache) {
            this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
            cacheContext = new TokenCacheContext(this.serializableCache, true);
            await this.persistencePlugin.beforeCacheAccess(cacheContext);
          }
          if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
            const cachedAccounts = this.cacheStorage.getAllAccounts({
              homeAccountId: cacheRecord.account.homeAccountId,
              environment: cacheRecord.account.environment
            }, request.correlationId);
            if (cachedAccounts.length < 1) {
              this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
              this.performanceClient?.addFields({
                acntLoggedOut: true
              }, request.correlationId);
              return await _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, void 0, serverRequestId);
            }
          }
          await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, isKmsi(idTokenClaims || {}), apiId, request.storeInCache);
        } finally {
          if (this.persistencePlugin && this.serializableCache && cacheContext) {
            this.logger.verbose("Persistence enabled, calling afterCacheAccess");
            await this.persistencePlugin.afterCacheAccess(cacheContext);
          }
        }
        return _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);
      }
      /**
       * Generates CacheRecord
       * @param serverTokenResponse
       * @param idTokenObj
       * @param authority
       */
      generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {
        const env = authority.getPreferredCache();
        if (!env) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
        let cachedIdToken;
        let cachedAccount;
        if (serverTokenResponse.id_token && !!idTokenClaims) {
          cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");
          cachedAccount = buildAccountToCache(
            this.cacheStorage,
            authority,
            this.homeAccountIdentifier,
            this.cryptoObj.base64Decode,
            request.correlationId,
            idTokenClaims,
            serverTokenResponse.client_info,
            env,
            claimsTenantId,
            authCodePayload,
            void 0,
            // nativeAccountId
            this.logger
          );
        }
        let cachedAccessToken = null;
        if (serverTokenResponse.access_token) {
          const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
          const expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
          const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
          const refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
          const tokenExpirationSeconds = reqTimestamp + expiresIn;
          const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
          const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
          cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
        }
        let cachedRefreshToken = null;
        if (serverTokenResponse.refresh_token) {
          let rtExpiresOn;
          if (serverTokenResponse.refresh_token_expires_in) {
            const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in === "string" ? parseInt(serverTokenResponse.refresh_token_expires_in, 10) : serverTokenResponse.refresh_token_expires_in;
            rtExpiresOn = reqTimestamp + rtExpiresIn;
            this.performanceClient?.addFields({
              ntwkRtExpiresOnSeconds: rtExpiresOn
            }, request.correlationId);
          }
          cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);
        }
        let cachedAppMetadata = null;
        if (serverTokenResponse.foci) {
          cachedAppMetadata = {
            clientId: this.clientId,
            environment: env,
            familyId: serverTokenResponse.foci
          };
        }
        return {
          account: cachedAccount,
          idToken: cachedIdToken,
          accessToken: cachedAccessToken,
          refreshToken: cachedRefreshToken,
          appMetadata: cachedAppMetadata
        };
      }
      /**
       * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
       *
       * Optionally takes a state string that is set as-is in the response.
       *
       * @param cacheRecord
       * @param idTokenObj
       * @param fromTokenCache
       * @param stateString
       */
      static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {
        let accessToken = Constants.EMPTY_STRING;
        let responseScopes = [];
        let expiresOn = null;
        let extExpiresOn;
        let refreshOn;
        let familyId = Constants.EMPTY_STRING;
        if (cacheRecord.accessToken) {
          if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP && !request.popKid) {
            const popTokenGenerator = new PopTokenGenerator(cryptoObj);
            const { secret, keyId } = cacheRecord.accessToken;
            if (!keyId) {
              throw createClientAuthError(keyIdMissing);
            }
            accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);
          } else {
            accessToken = cacheRecord.accessToken.secret;
          }
          responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
          expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);
          extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
          if (cacheRecord.accessToken.refreshOn) {
            refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);
          }
        }
        if (cacheRecord.appMetadata) {
          familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : "";
        }
        const uid = idTokenClaims?.oid || idTokenClaims?.sub || "";
        const tid = idTokenClaims?.tid || "";
        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {
          cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;
        }
        const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(
          AccountEntity.getAccountInfo(cacheRecord.account),
          void 0,
          // tenantProfile optional
          idTokenClaims,
          cacheRecord.idToken?.secret
        ) : null;
        return {
          authority: authority.canonicalAuthority,
          uniqueId: uid,
          tenantId: tid,
          scopes: responseScopes,
          account: accountInfo,
          idToken: cacheRecord?.idToken?.secret || "",
          idTokenClaims: idTokenClaims || {},
          accessToken,
          fromCache: fromTokenCache,
          expiresOn,
          extExpiresOn,
          refreshOn,
          correlationId: request.correlationId,
          requestId: requestId || Constants.EMPTY_STRING,
          familyId,
          tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,
          state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
          cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,
          msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,
          code: serverTokenResponse?.spa_code,
          fromNativeBroker: false
        };
      }
    };
    function buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode, correlationId, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger) {
      logger?.verbose("setCachedAccount called");
      const accountKeys = cacheStorage.getAccountKeys();
      const baseAccountKey = accountKeys.find((accountKey) => {
        return accountKey.startsWith(homeAccountId);
      });
      let cachedAccount = null;
      if (baseAccountKey) {
        cachedAccount = cacheStorage.getAccount(baseAccountKey, correlationId);
      }
      const baseAccount = cachedAccount || AccountEntity.createAccount({
        homeAccountId,
        idTokenClaims,
        clientInfo,
        environment,
        cloudGraphHostName: authCodePayload?.cloud_graph_host_name,
        msGraphHost: authCodePayload?.msgraph_host,
        nativeAccountId
      }, authority, base64Decode);
      const tenantProfiles = baseAccount.tenantProfiles || [];
      const tenantId = claimsTenantId || baseAccount.realm;
      if (tenantId && !tenantProfiles.find((tenantProfile) => {
        return tenantProfile.tenantId === tenantId;
      })) {
        const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);
        tenantProfiles.push(newTenantProfile);
      }
      baseAccount.tenantProfiles = tenantProfiles;
      return baseAccount;
    }
    async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
      if (typeof clientAssertion === "string") {
        return clientAssertion;
      } else {
        const config = {
          clientId,
          tokenEndpoint
        };
        return clientAssertion(config);
      }
    }
    var ClientAssertionUtils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getClientAssertion
    });
    var AuthorizationCodeClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
        this.includeRedirectUri = true;
        this.oidcDefaultScopes = this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;
      }
      /**
       * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
       * authorization_code_grant
       * @param request
       * @param apiId - API identifier for telemetry tracking
       */
      async acquireToken(request, apiId, authCodePayload) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);
        if (!request.code) {
          throw createClientAuthError(requestCannotBeMade);
        }
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, apiId, authCodePayload, void 0, void 0, void 0, requestId);
      }
      /**
       * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param authorityUri
       */
      getLogoutUri(logoutRequest) {
        if (!logoutRequest) {
          throw createClientConfigurationError(logoutRequestEmpty);
        }
        const queryString = this.createLogoutUrlQueryString(logoutRequest);
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
      }
      /**
       * Executes POST request to token endpoint
       * @param authority
       * @param request
       */
      async executeTokenRequest(authority, request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
        let ccsCredential = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCredential = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        }
        const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request
       */
      async createTokenRequestBody(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
        if (!this.includeRedirectUri) {
          if (!request.redirectUri) {
            throw createClientConfigurationError(redirectUriEmpty);
          }
        } else {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);
        addAuthorizationCode(parameters, request.code);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        if (request.codeVerifier) {
          addCodeVerifier(parameters, request.codeVerifier);
        }
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);
        addClientInfo(parameters);
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        let ccsCred = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCred = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        } else {
          ccsCred = request.ccsCredential;
        }
        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, ccsCred.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {
          addExtraQueryParameters(parameters, {
            [RETURN_SPA_CODE]: "1"
          });
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
      /**
       * This API validates the `EndSessionRequest` and creates a URL
       * @param request
       */
      createLogoutUrlQueryString(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.postLogoutRedirectUri) {
          addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);
        }
        if (request.correlationId) {
          addCorrelationId(parameters, request.correlationId);
        }
        if (request.idTokenHint) {
          addIdTokenHint(parameters, request.idTokenHint);
        }
        if (request.state) {
          addState(parameters, request.state);
        }
        if (request.logoutHint) {
          addLogoutHint(parameters, request.logoutHint);
        }
        if (request.extraQueryParameters) {
          addExtraQueryParameters(parameters, request.extraQueryParameters);
        }
        if (this.config.authOptions.instanceAware) {
          addInstanceAware(parameters);
        }
        return mapToQueryString(parameters, this.config.authOptions.encodeExtraQueryParams, request.extraQueryParameters);
      }
    };
    var DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300;
    var RefreshTokenClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      async acquireToken(request, apiId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, apiId, void 0, void 0, true, request.forceCache, requestId);
      }
      /**
       * Gets cached refresh token and attaches to request, then calls acquireToken API
       * @param request
       */
      async acquireTokenByRefreshToken(request, apiId) {
        if (!request) {
          throw createClientConfigurationError(tokenRequestEmpty);
        }
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
        if (isFOCI) {
          try {
            return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true, apiId);
          } catch (e) {
            const noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === noTokensFound;
            const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
            if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
              return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false, apiId);
            } else {
              throw e;
            }
          }
        }
        return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false, apiId);
      }
      /**
       * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
       * @param request
       */
      async acquireTokenWithCachedRefreshToken(request, foci, apiId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
        const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, request.correlationId, void 0, this.performanceClient);
        if (!refreshToken) {
          throw createInteractionRequiredAuthError(noTokensFound);
        }
        if (refreshToken.expiresOn) {
          const offset = request.refreshTokenExpirationOffsetSeconds || DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS;
          this.performanceClient?.addFields({
            cacheRtExpiresOnSeconds: Number(refreshToken.expiresOn),
            rtOffsetSeconds: offset
          }, request.correlationId);
          if (isTokenExpired(refreshToken.expiresOn, offset)) {
            throw createInteractionRequiredAuthError(refreshTokenExpired);
          }
        }
        const refreshTokenRequest = {
          ...request,
          refreshToken: refreshToken.secret,
          authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
          ccsCredential: {
            credential: request.account.homeAccountId,
            type: CcsCredentialType.HOME_ACCOUNT_ID
          }
        };
        try {
          return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest, apiId);
        } catch (e) {
          if (e instanceof InteractionRequiredAuthError) {
            if (e.subError === badToken) {
              this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");
              const badRefreshTokenKey = this.cacheManager.generateCredentialKey(refreshToken);
              this.cacheManager.removeRefreshToken(badRefreshTokenKey, request.correlationId);
            }
          }
          throw e;
        }
      }
      /**
       * Constructs the network message and makes a NW call to the underlying secure token service
       * @param request
       * @param authority
       */
      async executeTokenRequest(request, authority) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
        const headers = this.createTokenRequestHeaders(request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);
      }
      /**
       * Helper function to create the token request body
       * @param request
       */
      async createTokenRequestBody(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
        if (request.redirectUri) {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(parameters, request.scopes, true, this.config.authOptions.authority.options.OIDCOptions?.defaultScopes);
        addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);
        addClientInfo(parameters);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        addRefreshToken(parameters, request.refreshToken);
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
          switch (request.ccsCredential.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, request.ccsCredential.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
    var SilentFlowClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      /**
       * Retrieves token from cache or throws an error if it must be refreshed.
       * @param request
       */
      async acquireCachedToken(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);
        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
        if (request.forceRefresh || !this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {
          this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        }
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const requestTenantId = request.account.tenantId || getTenantFromAuthorityString(request.authority);
        const tokenKeys = this.cacheManager.getTokenKeys();
        const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId);
        if (!cachedAccessToken) {
          this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (wasClockTurnedBack(cachedAccessToken.cachedAt) || isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
          this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn, 0)) {
          lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
        }
        const environment = request.authority || this.authority.getPreferredCache();
        const cacheRecord = {
          account: this.cacheManager.getAccount(this.cacheManager.generateAccountKey(request.account), request.correlationId),
          accessToken: cachedAccessToken,
          idToken: this.cacheManager.getIdToken(request.account, request.correlationId, tokenKeys, requestTenantId, this.performanceClient),
          refreshToken: null,
          appMetadata: this.cacheManager.readAppMetadataFromCache(environment)
        };
        this.setCacheOutcome(lastCacheOutcome, request.correlationId);
        if (this.config.serverTelemetryManager) {
          this.config.serverTelemetryManager.incrementCacheHits();
        }
        return [
          await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request),
          lastCacheOutcome
        ];
      }
      setCacheOutcome(cacheOutcome, correlationId) {
        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);
        this.performanceClient?.addFields({
          cacheOutcome
        }, correlationId);
        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
          this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
        }
      }
      /**
       * Helper function to build response object from the CacheRecord
       * @param cacheRecord
       */
      async generateResultFromCacheRecord(cacheRecord, request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);
        let idTokenClaims;
        if (cacheRecord.idToken) {
          idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);
        }
        if (request.maxAge || request.maxAge === 0) {
          const authTime = idTokenClaims?.auth_time;
          if (!authTime) {
            throw createClientAuthError(authTimeNotFound);
          }
          checkMaxAge(authTime, request.maxAge);
        }
        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);
      }
    };
    var StubbedNetworkModule = {
      sendGetRequestAsync: () => {
        return Promise.reject(createClientAuthError(methodNotImplemented));
      },
      sendPostRequestAsync: () => {
        return Promise.reject(createClientAuthError(methodNotImplemented));
      }
    };
    function getStandardAuthorizeRequestParameters(authOptions, request, logger, performanceClient) {
      const correlationId = request.correlationId;
      const parameters = /* @__PURE__ */ new Map();
      addClientId(parameters, request.embeddedClientId || request.extraQueryParameters?.[CLIENT_ID] || authOptions.clientId);
      const requestScopes = [
        ...request.scopes || [],
        ...request.extraScopesToConsent || []
      ];
      addScopes(parameters, requestScopes, true, authOptions.authority.options.OIDCOptions?.defaultScopes);
      addRedirectUri(parameters, request.redirectUri);
      addCorrelationId(parameters, correlationId);
      addResponseMode(parameters, request.responseMode);
      addClientInfo(parameters);
      if (request.prompt) {
        addPrompt(parameters, request.prompt);
        performanceClient?.addFields({ prompt: request.prompt }, correlationId);
      }
      if (request.domainHint) {
        addDomainHint(parameters, request.domainHint);
        performanceClient?.addFields({ domainHintFromRequest: true }, correlationId);
      }
      if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
        if (request.sid && request.prompt === PromptValue.NONE) {
          logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
          addSid(parameters, request.sid);
          performanceClient?.addFields({ sidFromRequest: true }, correlationId);
        } else if (request.account) {
          const accountSid = extractAccountSid(request.account);
          let accountLoginHintClaim = extractLoginHint(request.account);
          if (accountLoginHintClaim && request.domainHint) {
            logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);
            accountLoginHintClaim = null;
          }
          if (accountLoginHintClaim) {
            logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
            addLoginHint(parameters, accountLoginHintClaim);
            performanceClient?.addFields({ loginHintFromClaim: true }, correlationId);
            try {
              const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
              addCcsOid(parameters, clientInfo);
            } catch (e) {
              logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
            }
          } else if (accountSid && request.prompt === PromptValue.NONE) {
            logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
            addSid(parameters, accountSid);
            performanceClient?.addFields({ sidFromClaim: true }, correlationId);
            try {
              const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
              addCcsOid(parameters, clientInfo);
            } catch (e) {
              logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
            }
          } else if (request.loginHint) {
            logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
            addLoginHint(parameters, request.loginHint);
            addCcsUpn(parameters, request.loginHint);
            performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
          } else if (request.account.username) {
            logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
            addLoginHint(parameters, request.account.username);
            performanceClient?.addFields({ loginHintFromUpn: true }, correlationId);
            try {
              const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
              addCcsOid(parameters, clientInfo);
            } catch (e) {
              logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
            }
          }
        } else if (request.loginHint) {
          logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
          addLoginHint(parameters, request.loginHint);
          addCcsUpn(parameters, request.loginHint);
          performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
        }
      } else {
        logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
      }
      if (request.nonce) {
        addNonce(parameters, request.nonce);
      }
      if (request.state) {
        addState(parameters, request.state);
      }
      if (request.claims || authOptions.clientCapabilities && authOptions.clientCapabilities.length > 0) {
        addClaims(parameters, request.claims, authOptions.clientCapabilities);
      }
      if (request.embeddedClientId) {
        addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);
      }
      if (authOptions.instanceAware && (!request.extraQueryParameters || !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {
        addInstanceAware(parameters);
      }
      return parameters;
    }
    function getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {
      const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);
      return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);
    }
    function getAuthorizationCodePayload(serverParams, cachedState) {
      validateAuthorizationResponse(serverParams, cachedState);
      if (!serverParams.code) {
        throw createClientAuthError(authorizationCodeMissingFromServerResponse);
      }
      return serverParams;
    }
    function validateAuthorizationResponse(serverResponse, requestState) {
      if (!serverResponse.state || !requestState) {
        throw serverResponse.state ? createClientAuthError(stateNotFound, "Cached State") : createClientAuthError(stateNotFound, "Server State");
      }
      let decodedServerResponseState;
      let decodedRequestState;
      try {
        decodedServerResponseState = decodeURIComponent(serverResponse.state);
      } catch (e) {
        throw createClientAuthError(invalidState, serverResponse.state);
      }
      try {
        decodedRequestState = decodeURIComponent(requestState);
      } catch (e) {
        throw createClientAuthError(invalidState, serverResponse.state);
      }
      if (decodedServerResponseState !== decodedRequestState) {
        throw createClientAuthError(stateMismatch);
      }
      if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
        const serverErrorNo = parseServerErrorNo(serverResponse);
        if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
          throw new InteractionRequiredAuthError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || "", serverResponse.trace_id || "", serverResponse.correlation_id || "", serverResponse.claims || "", serverErrorNo);
        }
        throw new ServerError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverErrorNo);
      }
    }
    function parseServerErrorNo(serverResponse) {
      const errorCodePrefix = "code=";
      const errorCodePrefixIndex = serverResponse.error_uri?.lastIndexOf(errorCodePrefix);
      return errorCodePrefixIndex && errorCodePrefixIndex >= 0 ? serverResponse.error_uri?.substring(errorCodePrefixIndex + errorCodePrefix.length) : void 0;
    }
    function extractAccountSid(account) {
      return account.idTokenClaims?.sid || null;
    }
    function extractLoginHint(account) {
      return account.loginHint || account.idTokenClaims?.login_hint || null;
    }
    var Authorize = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getAuthorizationCodePayload,
      getAuthorizeUrl,
      getStandardAuthorizeRequestParameters,
      validateAuthorizationResponse
    });
    var AuthenticationHeaderParser = class {
      constructor(headers) {
        this.headers = headers;
      }
      /**
       * This method parses the SHR nonce value out of either the Authentication-Info or WWW-Authenticate authentication headers.
       * @returns
       */
      getShrNonce() {
        const authenticationInfo = this.headers[HeaderNames.AuthenticationInfo];
        if (authenticationInfo) {
          const authenticationInfoChallenges = this.parseChallenges(authenticationInfo);
          if (authenticationInfoChallenges.nextnonce) {
            return authenticationInfoChallenges.nextnonce;
          }
          throw createClientConfigurationError(invalidAuthenticationHeader);
        }
        const wwwAuthenticate = this.headers[HeaderNames.WWWAuthenticate];
        if (wwwAuthenticate) {
          const wwwAuthenticateChallenges = this.parseChallenges(wwwAuthenticate);
          if (wwwAuthenticateChallenges.nonce) {
            return wwwAuthenticateChallenges.nonce;
          }
          throw createClientConfigurationError(invalidAuthenticationHeader);
        }
        throw createClientConfigurationError(missingNonceAuthenticationHeader);
      }
      /**
       * Parses an HTTP header's challenge set into a key/value map.
       * @param header
       * @returns
       */
      parseChallenges(header) {
        const schemeSeparator = header.indexOf(" ");
        const challenges = header.substr(schemeSeparator + 1).split(",");
        const challengeMap = {};
        challenges.forEach((challenge) => {
          const [key, value] = challenge.split("=");
          challengeMap[key] = unescape(value.replace(/['"]+/g, Constants.EMPTY_STRING));
        });
        return challengeMap;
      }
    };
    function tagToString(tag) {
      if (tag === 0) {
        return "UNTAG";
      }
      const tagSymbolSpace = "abcdefghijklmnopqrstuvwxyz0123456789****************************";
      let tagBuffer = "*****";
      const chars = [
        tagSymbolSpace[tag >> 24 & 63],
        tagSymbolSpace[tag >> 18 & 63],
        tagSymbolSpace[tag >> 12 & 63],
        tagSymbolSpace[tag >> 6 & 63],
        tagSymbolSpace[tag >> 0 & 63]
      ];
      tagBuffer = chars.join("");
      return tagBuffer;
    }
    var PlatformBrokerError = class _PlatformBrokerError extends AuthError {
      constructor(errorStatus, errorContext, errorCode, errorTag) {
        const tagString = tagToString(errorTag);
        const enhancedErrorContext = errorContext ? `${errorContext} (Error Code: ${errorCode}, Tag: ${tagString})` : `(Error Code: ${errorCode}, Tag: ${tagString})`;
        super(errorStatus, enhancedErrorContext);
        this.name = "PlatformBrokerError";
        this.statusCode = errorCode;
        this.tag = tagString;
        Object.setPrototypeOf(this, _PlatformBrokerError.prototype);
      }
    };
    var skuGroupSeparator = ",";
    var skuValueSeparator = "|";
    function makeExtraSkuString(params) {
      const { skus, libraryName, libraryVersion, extensionName, extensionVersion } = params;
      const skuMap = /* @__PURE__ */ new Map([
        [0, [libraryName, libraryVersion]],
        [2, [extensionName, extensionVersion]]
      ]);
      let skuArr = [];
      if (skus?.length) {
        skuArr = skus.split(skuGroupSeparator);
        if (skuArr.length < 4) {
          return skus;
        }
      } else {
        skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
      }
      skuMap.forEach((value, key) => {
        if (value.length === 2 && value[0]?.length && value[1]?.length) {
          setSku({
            skuArr,
            index: key,
            skuName: value[0],
            skuVersion: value[1]
          });
        }
      });
      return skuArr.join(skuGroupSeparator);
    }
    function setSku(params) {
      const { skuArr, index, skuName, skuVersion } = params;
      if (index >= skuArr.length) {
        return;
      }
      skuArr[index] = [skuName, skuVersion].join(skuValueSeparator);
    }
    var ServerTelemetryManager = class _ServerTelemetryManager {
      constructor(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
      }
      /**
       * API to add MSER Telemetry to request
       */
      generateCurrentRequestHeaderValue() {
        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
        const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
        const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
        if (nativeBrokerErrorCode?.length) {
          platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
        }
        const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const regionDiscoveryFields = this.getRegionDiscoveryFields();
        const requestWithRegionDiscoveryFields = [
          request,
          regionDiscoveryFields
        ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          requestWithRegionDiscoveryFields,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to add MSER Telemetry for the last failed request
       */
      generateLastRequestHeaderValue() {
        const lastRequests = this.getLastRequests();
        const maxErrors = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errorCount = lastRequests.errors.length;
        const overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          lastRequests.cacheHits,
          failedRequests,
          errors,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to cache token failures for MSER data capture
       * @param error
       */
      cacheFailedRequest(error) {
        const lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
          lastRequests.failedRequests.shift();
          lastRequests.failedRequests.shift();
          lastRequests.errors.shift();
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (error instanceof Error && !!error && error.toString()) {
          if (error instanceof AuthError) {
            if (error.subError) {
              lastRequests.errors.push(error.subError);
            } else if (error.errorCode) {
              lastRequests.errors.push(error.errorCode);
            } else {
              lastRequests.errors.push(error.toString());
            }
          } else {
            lastRequests.errors.push(error.toString());
          }
        } else {
          lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
        }
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
        return;
      }
      /**
       * Update server telemetry cache entry by incrementing cache hit counter
       */
      incrementCacheHits() {
        const lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
        return lastRequests.cacheHits;
      }
      /**
       * Get the server telemetry entity from cache or initialize a new one
       */
      getLastRequests() {
        const initialValue = {
          failedRequests: [],
          errors: [],
          cacheHits: 0
        };
        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue;
      }
      /**
       * Remove server telemetry cache entry
       */
      clearTelemetryCache() {
        const lastRequests = this.getLastRequests();
        const numErrorsFlushed = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
          this.cacheManager.removeItem(this.telemetryCacheKey, this.correlationId);
        } else {
          const serverTelemEntity = {
            failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
            errors: lastRequests.errors.slice(numErrorsFlushed),
            cacheHits: 0
          };
          this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity, this.correlationId);
        }
      }
      /**
       * Returns the maximum number of errors that can be flushed to the server in the next network request
       * @param serverTelemetryEntity
       */
      static maxErrorsToSend(serverTelemetryEntity) {
        let i;
        let maxErrors = 0;
        let dataSize = 0;
        const errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
          const apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
          const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
          const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
          dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
          if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
            maxErrors += 1;
          } else {
            break;
          }
        }
        return maxErrors;
      }
      /**
       * Get the region discovery fields
       *
       * @returns string
       */
      getRegionDiscoveryFields() {
        const regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
        return regionDiscoveryFields.join(",");
      }
      /**
       * Update the region discovery metadata
       *
       * @param regionDiscoveryMetadata
       * @returns void
       */
      updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
      }
      /**
       * Set cache outcome
       */
      setCacheOutcome(cacheOutcome) {
        this.cacheOutcome = cacheOutcome;
      }
      setNativeBrokerErrorCode(errorCode) {
        const lastRequests = this.getLastRequests();
        lastRequests.nativeBrokerErrorCode = errorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
      }
      getNativeBrokerErrorCode() {
        return this.getLastRequests().nativeBrokerErrorCode;
      }
      clearNativeBrokerErrorCode() {
        const lastRequests = this.getLastRequests();
        delete lastRequests.nativeBrokerErrorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
      }
      static makeExtraSkuString(params) {
        return makeExtraSkuString(params);
      }
    };
    exports2.AADAuthorityConstants = AADAuthorityConstants;
    exports2.AADServerParamKeys = AADServerParamKeys;
    exports2.AccountEntity = AccountEntity;
    exports2.AuthError = AuthError;
    exports2.AuthErrorCodes = AuthErrorCodes;
    exports2.AuthErrorMessage = AuthErrorMessage;
    exports2.AuthToken = AuthToken;
    exports2.AuthenticationHeaderParser = AuthenticationHeaderParser;
    exports2.AuthenticationScheme = AuthenticationScheme;
    exports2.Authority = Authority;
    exports2.AuthorityFactory = AuthorityFactory;
    exports2.AuthorityType = AuthorityType;
    exports2.AuthorizationCodeClient = AuthorizationCodeClient;
    exports2.Authorize = Authorize;
    exports2.AzureCloudInstance = AzureCloudInstance;
    exports2.BaseClient = BaseClient;
    exports2.CacheAccountType = CacheAccountType;
    exports2.CacheError = CacheError;
    exports2.CacheErrorCodes = CacheErrorCodes;
    exports2.CacheHelpers = CacheHelpers;
    exports2.CacheManager = CacheManager;
    exports2.CacheOutcome = CacheOutcome;
    exports2.CacheType = CacheType;
    exports2.CcsCredentialType = CcsCredentialType;
    exports2.ClaimsRequestKeys = ClaimsRequestKeys;
    exports2.ClientAssertionUtils = ClientAssertionUtils;
    exports2.ClientAuthError = ClientAuthError;
    exports2.ClientAuthErrorCodes = ClientAuthErrorCodes;
    exports2.ClientAuthErrorMessage = ClientAuthErrorMessage;
    exports2.ClientConfigurationError = ClientConfigurationError;
    exports2.ClientConfigurationErrorCodes = ClientConfigurationErrorCodes;
    exports2.ClientConfigurationErrorMessage = ClientConfigurationErrorMessage;
    exports2.CodeChallengeMethodValues = CodeChallengeMethodValues;
    exports2.Constants = Constants;
    exports2.CredentialType = CredentialType;
    exports2.DEFAULT_CRYPTO_IMPLEMENTATION = DEFAULT_CRYPTO_IMPLEMENTATION;
    exports2.DEFAULT_SYSTEM_OPTIONS = DEFAULT_SYSTEM_OPTIONS;
    exports2.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = DEFAULT_TOKEN_RENEWAL_OFFSET_SEC;
    exports2.DefaultStorageClass = DefaultStorageClass;
    exports2.EncodingTypes = EncodingTypes;
    exports2.Errors = Errors;
    exports2.GrantType = GrantType;
    exports2.HeaderNames = HeaderNames;
    exports2.HttpMethod = HttpMethod;
    exports2.HttpStatus = HttpStatus;
    exports2.IntFields = IntFields;
    exports2.InteractionRequiredAuthError = InteractionRequiredAuthError;
    exports2.InteractionRequiredAuthErrorCodes = InteractionRequiredAuthErrorCodes;
    exports2.InteractionRequiredAuthErrorMessage = InteractionRequiredAuthErrorMessage;
    exports2.JsonWebTokenTypes = JsonWebTokenTypes;
    exports2.Logger = Logger;
    exports2.NetworkError = NetworkError;
    exports2.OAuthResponseType = OAuthResponseType;
    exports2.OIDC_DEFAULT_SCOPES = OIDC_DEFAULT_SCOPES;
    exports2.ONE_DAY_IN_MS = ONE_DAY_IN_MS;
    exports2.PasswordGrantConstants = PasswordGrantConstants;
    exports2.PerformanceEventAbbreviations = PerformanceEventAbbreviations;
    exports2.PerformanceEventStatus = PerformanceEventStatus;
    exports2.PerformanceEvents = PerformanceEvents;
    exports2.PersistentCacheKeys = PersistentCacheKeys;
    exports2.PlatformBrokerError = PlatformBrokerError;
    exports2.PopTokenGenerator = PopTokenGenerator;
    exports2.PromptValue = PromptValue;
    exports2.ProtocolMode = ProtocolMode;
    exports2.ProtocolUtils = ProtocolUtils;
    exports2.RefreshTokenClient = RefreshTokenClient;
    exports2.RequestParameterBuilder = RequestParameterBuilder;
    exports2.ResponseHandler = ResponseHandler;
    exports2.ResponseMode = ResponseMode;
    exports2.ScopeSet = ScopeSet;
    exports2.ServerError = ServerError;
    exports2.ServerResponseType = ServerResponseType;
    exports2.ServerTelemetryManager = ServerTelemetryManager;
    exports2.SilentFlowClient = SilentFlowClient;
    exports2.StringUtils = StringUtils;
    exports2.StubPerformanceClient = StubPerformanceClient;
    exports2.StubPerformanceMeasurement = StubPerformanceMeasurement;
    exports2.StubbedNetworkModule = StubbedNetworkModule;
    exports2.THE_FAMILY_ID = THE_FAMILY_ID;
    exports2.ThrottlingConstants = ThrottlingConstants;
    exports2.ThrottlingUtils = ThrottlingUtils;
    exports2.TimeUtils = TimeUtils;
    exports2.TokenCacheContext = TokenCacheContext;
    exports2.UrlString = UrlString;
    exports2.UrlUtils = UrlUtils;
    exports2.buildAccountToCache = buildAccountToCache;
    exports2.buildClientInfo = buildClientInfo;
    exports2.buildClientInfoFromHomeAccountId = buildClientInfoFromHomeAccountId;
    exports2.buildStaticAuthorityOptions = buildStaticAuthorityOptions;
    exports2.buildTenantProfile = buildTenantProfile;
    exports2.createAuthError = createAuthError;
    exports2.createCacheError = createCacheError;
    exports2.createClientAuthError = createClientAuthError;
    exports2.createClientConfigurationError = createClientConfigurationError;
    exports2.createInteractionRequiredAuthError = createInteractionRequiredAuthError;
    exports2.createNetworkError = createNetworkError;
    exports2.formatAuthorityUri = formatAuthorityUri;
    exports2.getClientAssertion = getClientAssertion;
    exports2.getRequestThumbprint = getRequestThumbprint;
    exports2.getTenantIdFromIdTokenClaims = getTenantIdFromIdTokenClaims;
    exports2.invoke = invoke;
    exports2.invokeAsync = invokeAsync;
    exports2.tenantIdMatchesHomeTenant = tenantIdMatchesHomeTenant;
    exports2.updateAccountTenantProfileData = updateAccountTenantProfileData;
    exports2.version = version2;
  }
});

// node_modules/@azure/msal-common/lib/index-browser.cjs
var require_index_browser = __commonJS({
  "node_modules/@azure/msal-common/lib/index-browser.cjs"(exports2) {
    "use strict";
    var indexNode = require_index_node_BtzY9XyU();
    var missingKidError = "missing_kid_error";
    var missingAlgError = "missing_alg_error";
    var JoseHeaderErrorMessages = {
      [missingKidError]: "The JOSE Header for the requested JWT, JWS or JWK object requires a keyId to be configured as the 'kid' header claim. No 'kid' value was provided.",
      [missingAlgError]: "The JOSE Header for the requested JWT, JWS or JWK object requires an algorithm to be specified as the 'alg' header claim. No 'alg' value was provided."
    };
    var JoseHeaderError = class _JoseHeaderError extends indexNode.AuthError {
      constructor(errorCode, errorMessage) {
        super(errorCode, errorMessage);
        this.name = "JoseHeaderError";
        Object.setPrototypeOf(this, _JoseHeaderError.prototype);
      }
    };
    function createJoseHeaderError(code) {
      return new JoseHeaderError(code, JoseHeaderErrorMessages[code]);
    }
    var JoseHeader = class _JoseHeader {
      constructor(options) {
        this.typ = options.typ;
        this.alg = options.alg;
        this.kid = options.kid;
      }
      /**
       * Builds SignedHttpRequest formatted JOSE Header from the
       * JOSE Header options provided or previously set on the object and returns
       * the stringified header object.
       * Throws if keyId or algorithm aren't provided since they are required for Access Token Binding.
       * @param shrHeaderOptions
       * @returns
       */
      static getShrHeaderString(shrHeaderOptions) {
        if (!shrHeaderOptions.kid) {
          throw createJoseHeaderError(missingKidError);
        }
        if (!shrHeaderOptions.alg) {
          throw createJoseHeaderError(missingAlgError);
        }
        const shrHeader = new _JoseHeader({
          // Access Token PoP headers must have type pop, but the type header can be overriden for special cases
          typ: shrHeaderOptions.typ || indexNode.JsonWebTokenTypes.Pop,
          kid: shrHeaderOptions.kid,
          alg: shrHeaderOptions.alg
        });
        return JSON.stringify(shrHeader);
      }
    };
    function startContext(event, abbreviations, stack) {
      if (!stack) {
        return;
      }
      stack.push({
        name: abbreviations.get(event.name) || event.name
      });
    }
    function endContext(event, abbreviations, stack, error) {
      if (!stack?.length) {
        return;
      }
      const peek = (stack2) => {
        return stack2.length ? stack2[stack2.length - 1] : void 0;
      };
      const abbrEventName = abbreviations.get(event.name) || event.name;
      const top = peek(stack);
      if (top?.name !== abbrEventName) {
        return;
      }
      const current = stack?.pop();
      if (!current) {
        return;
      }
      const errorCode = error instanceof indexNode.AuthError ? error.errorCode : error instanceof Error ? error.name : void 0;
      const subErr = error instanceof indexNode.AuthError ? error.subError : void 0;
      if (errorCode && current.childErr !== errorCode) {
        current.err = errorCode;
        if (subErr) {
          current.subErr = subErr;
        }
      }
      delete current.name;
      delete current.childErr;
      const context = {
        ...current,
        dur: event.durationMs
      };
      if (!event.success) {
        context.fail = 1;
      }
      const parent = peek(stack);
      if (!parent) {
        return { [abbrEventName]: context };
      }
      if (errorCode) {
        parent.childErr = errorCode;
      }
      let childName;
      if (!parent[abbrEventName]) {
        childName = abbrEventName;
      } else {
        const siblings = Object.keys(parent).filter((key) => key.startsWith(abbrEventName)).length;
        childName = `${abbrEventName}_${siblings + 1}`;
      }
      parent[childName] = context;
      return parent;
    }
    function addError(error, logger, event, stackMaxSize = 5) {
      if (!(error instanceof Error)) {
        logger.trace("PerformanceClient.addErrorStack: Input error is not instance of Error", event.correlationId);
        return;
      } else if (error instanceof indexNode.AuthError) {
        event.errorCode = error.errorCode;
        event.subErrorCode = error.subError;
        if (error instanceof indexNode.ServerError || error instanceof indexNode.InteractionRequiredAuthError) {
          event.serverErrorNo = error.errorNo;
        }
        return;
      } else if (error instanceof indexNode.CacheError) {
        event.errorCode = error.errorCode;
        return;
      } else if (event.errorStack?.length) {
        logger.trace("PerformanceClient.addErrorStack: Stack already exist", event.correlationId);
        return;
      } else if (!error.stack?.length) {
        logger.trace("PerformanceClient.addErrorStack: Input stack is empty", event.correlationId);
        return;
      }
      if (error.stack) {
        event.errorStack = compactStack(error.stack, stackMaxSize);
      }
      event.errorName = error.name;
    }
    function compactStack(stack, stackMaxSize) {
      if (stackMaxSize < 0) {
        return [];
      }
      const stackArr = stack.split("\n") || [];
      const res = [];
      const firstLine = stackArr[0];
      if (firstLine.startsWith("TypeError: Cannot read property") || firstLine.startsWith("TypeError: Cannot read properties of") || firstLine.startsWith("TypeError: Cannot set property") || firstLine.startsWith("TypeError: Cannot set properties of") || firstLine.endsWith("is not a function")) {
        res.push(compactStackLine(firstLine));
      } else if (firstLine.startsWith("SyntaxError") || firstLine.startsWith("TypeError")) {
        res.push(compactStackLine(
          // Example: SyntaxError: Unexpected token 'e', "test" is not valid JSON -> SyntaxError: Unexpected token <redacted>, <redacted> is not valid JSON
          firstLine.replace(/['].*[']|["].*["]/g, "<redacted>")
        ));
      }
      for (let ix = 1; ix < stackArr.length; ix++) {
        if (res.length >= stackMaxSize) {
          break;
        }
        const line = stackArr[ix];
        res.push(compactStackLine(line));
      }
      return res;
    }
    function compactStackLine(line) {
      const filePathIx = line.lastIndexOf(" ") + 1;
      if (filePathIx < 1) {
        return line;
      }
      const filePath = line.substring(filePathIx);
      let fileNameIx = filePath.lastIndexOf("/");
      fileNameIx = fileNameIx < 0 ? filePath.lastIndexOf("\\") : fileNameIx;
      if (fileNameIx >= 0) {
        return (line.substring(0, filePathIx) + "(" + filePath.substring(fileNameIx + 1) + (filePath.charAt(filePath.length - 1) === ")" ? "" : ")")).trimStart();
      }
      return line.trimStart();
    }
    function getAccountType(account) {
      const idTokenClaims = account?.idTokenClaims;
      if (idTokenClaims?.tfp || idTokenClaims?.acr) {
        return "B2C";
      }
      if (!idTokenClaims?.tid) {
        return void 0;
      } else if (idTokenClaims?.tid === "9188040d-6c67-4c5b-b112-36a304b66dad") {
        return "MSA";
      }
      return "AAD";
    }
    var PerformanceClient = class {
      /**
       * Creates an instance of PerformanceClient,
       * an abstract class containing core performance telemetry logic.
       *
       * @constructor
       * @param {string} clientId Client ID of the application
       * @param {string} authority Authority used by the application
       * @param {Logger} logger Logger used by the application
       * @param {string} libraryName Name of the library
       * @param {string} libraryVersion Version of the library
       * @param {ApplicationTelemetry} applicationTelemetry application name and version
       * @param {Set<String>} intFields integer fields to be truncated
       * @param {Map<string, string>} abbreviations event name abbreviations
       */
      constructor(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry, intFields, abbreviations) {
        this.authority = authority;
        this.libraryName = libraryName;
        this.libraryVersion = libraryVersion;
        this.applicationTelemetry = applicationTelemetry;
        this.clientId = clientId;
        this.logger = logger;
        this.callbacks = /* @__PURE__ */ new Map();
        this.eventsByCorrelationId = /* @__PURE__ */ new Map();
        this.eventStack = /* @__PURE__ */ new Map();
        this.queueMeasurements = /* @__PURE__ */ new Map();
        this.preQueueTimeByCorrelationId = /* @__PURE__ */ new Map();
        this.intFields = intFields || /* @__PURE__ */ new Set();
        for (const item of indexNode.IntFields) {
          this.intFields.add(item);
        }
        this.abbreviations = abbreviations || /* @__PURE__ */ new Map();
        for (const [key, value] of indexNode.PerformanceEventAbbreviations) {
          this.abbreviations.set(key, value);
        }
      }
      /**
       * Starts and returns an platform-specific implementation of IPerformanceMeasurement.
       * Note: this function can be changed to abstract at the next major version bump.
       *
       * @param {string} measureName
       * @param {string} correlationId
       * @returns {IPerformanceMeasurement}
       * @deprecated This method will be removed in the next major version
       */
      startPerformanceMeasurement(measureName, correlationId) {
        return {};
      }
      /**
       * Gets map of pre-queue times by correlation Id
       *
       * @param {PerformanceEvents} eventName
       * @param {string} correlationId
       * @returns {number}
       */
      getPreQueueTime(eventName, correlationId) {
        const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);
        if (!preQueueEvent) {
          this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`);
          return;
        } else if (preQueueEvent.name !== eventName) {
          this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`);
          return;
        }
        return preQueueEvent.time;
      }
      /**
       * Calculates the difference between current time and time when function was queued.
       * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.
       *
       * @param {number} preQueueTime
       * @param {number} currentTime
       * @returns {number}
       */
      calculateQueuedTime(preQueueTime, currentTime) {
        if (preQueueTime < 1) {
          this.logger.trace(`PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`);
          return 0;
        }
        if (currentTime < 1) {
          this.logger.trace(`PerformanceClient: currentTime should be a positive integer and not ${currentTime}`);
          return 0;
        }
        if (currentTime < preQueueTime) {
          this.logger.trace("PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved");
          return 0;
        }
        return currentTime - preQueueTime;
      }
      /**
       * Adds queue measurement time to QueueMeasurements array for given correlation ID.
       *
       * @param {PerformanceEvents} eventName
       * @param {?string} correlationId
       * @param {?number} queueTime
       * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements
       * @returns
       */
      addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {
        if (!correlationId) {
          this.logger.trace(`PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`);
          return;
        }
        if (queueTime === 0) {
          this.logger.trace(`PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`);
        } else if (!queueTime) {
          this.logger.trace(`PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`);
          return;
        }
        const queueMeasurement = {
          eventName,
          // Always default queue time to 0 for manually completed (improperly instrumented)
          queueTime: manuallyCompleted ? 0 : queueTime,
          manuallyCompleted
        };
        const existingMeasurements = this.queueMeasurements.get(correlationId);
        if (existingMeasurements) {
          existingMeasurements.push(queueMeasurement);
          this.queueMeasurements.set(correlationId, existingMeasurements);
        } else {
          this.logger.trace(`PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`);
          const measurementArray = [queueMeasurement];
          this.queueMeasurements.set(correlationId, measurementArray);
        }
        this.preQueueTimeByCorrelationId.delete(correlationId);
      }
      /**
       * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.
       *
       * @param {PerformanceEvents} measureName
       * @param {?string} [correlationId]
       * @returns {InProgressPerformanceEvent}
       */
      startMeasurement(measureName, correlationId) {
        const eventCorrelationId = correlationId || this.generateId();
        if (!correlationId) {
          this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);
        }
        this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);
        const inProgressEvent = {
          eventId: this.generateId(),
          status: indexNode.PerformanceEventStatus.InProgress,
          authority: this.authority,
          libraryName: this.libraryName,
          libraryVersion: this.libraryVersion,
          clientId: this.clientId,
          name: measureName,
          startTimeMs: Date.now(),
          correlationId: eventCorrelationId,
          appName: this.applicationTelemetry?.appName,
          appVersion: this.applicationTelemetry?.appVersion
        };
        this.cacheEventByCorrelationId(inProgressEvent);
        startContext(inProgressEvent, this.abbreviations, this.eventStack.get(eventCorrelationId));
        return {
          end: (event, error, account) => {
            return this.endMeasurement({
              // Initial set of event properties
              ...inProgressEvent,
              // Properties set when event ends
              ...event
            }, error, account);
          },
          discard: () => {
            return this.discardMeasurements(inProgressEvent.correlationId);
          },
          add: (fields) => {
            return this.addFields(fields, inProgressEvent.correlationId);
          },
          increment: (fields) => {
            return this.incrementFields(fields, inProgressEvent.correlationId);
          },
          event: inProgressEvent,
          measurement: new indexNode.StubPerformanceMeasurement()
        };
      }
      /**
       * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,
       * as consumers should instead use the function returned by startMeasurement.
       * Adds a new field named as "[event name]DurationMs" for sub-measurements, completes and emits an event
       * otherwise.
       *
       * @param {PerformanceEvent} event
       * @param {unknown} error
       * @param {AccountInfo?} account
       * @returns {(PerformanceEvent | null)}
       */
      endMeasurement(event, error, account) {
        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);
        if (!rootEvent) {
          this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);
          return null;
        }
        const isRoot = event.eventId === rootEvent.eventId;
        let queueInfo = {
          totalQueueTime: 0,
          totalQueueCount: 0,
          manuallyCompletedCount: 0
        };
        event.durationMs = Math.round(event.durationMs || this.getDurationMs(event.startTimeMs));
        const context = JSON.stringify(endContext(event, this.abbreviations, this.eventStack.get(rootEvent.correlationId), error));
        if (isRoot) {
          queueInfo = this.getQueueInfo(event.correlationId);
          this.discardMeasurements(rootEvent.correlationId);
        } else {
          rootEvent.incompleteSubMeasurements?.delete(event.eventId);
        }
        this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${event.durationMs} ms`, event.correlationId);
        if (error) {
          addError(error, this.logger, rootEvent);
        }
        if (!isRoot) {
          rootEvent[event.name + "DurationMs"] = Math.floor(event.durationMs);
          return { ...rootEvent };
        }
        if (isRoot && !error && (rootEvent.errorCode || rootEvent.subErrorCode)) {
          this.logger.trace(`PerformanceClient: Remove error and sub-error codes for root event ${event.name} as intermediate error was successfully handled`, event.correlationId);
          rootEvent.errorCode = void 0;
          rootEvent.subErrorCode = void 0;
        }
        let finalEvent = { ...rootEvent, ...event };
        let incompleteSubsCount = 0;
        finalEvent.incompleteSubMeasurements?.forEach((subMeasurement) => {
          this.logger.trace(`PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`, finalEvent.correlationId);
          incompleteSubsCount++;
        });
        finalEvent.incompleteSubMeasurements = void 0;
        finalEvent = {
          ...finalEvent,
          queuedTimeMs: queueInfo.totalQueueTime,
          queuedCount: queueInfo.totalQueueCount,
          queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,
          status: indexNode.PerformanceEventStatus.Completed,
          incompleteSubsCount,
          context
        };
        if (account) {
          finalEvent.accountType = getAccountType(account);
          finalEvent.dataBoundary = account.dataBoundary;
        }
        this.truncateIntegralFields(finalEvent);
        this.emitEvents([finalEvent], event.correlationId);
        return finalEvent;
      }
      /**
       * Saves extra information to be emitted when the measurements are flushed
       * @param fields
       * @param correlationId
       */
      addFields(fields, correlationId) {
        this.logger.trace("PerformanceClient: Updating static fields");
        const event = this.eventsByCorrelationId.get(correlationId);
        if (event) {
          this.eventsByCorrelationId.set(correlationId, {
            ...event,
            ...fields
          });
        } else {
          this.logger.trace("PerformanceClient: Event not found for", correlationId);
        }
      }
      /**
       * Increment counters to be emitted when the measurements are flushed
       * @param fields {string[]}
       * @param correlationId {string} correlation identifier
       */
      incrementFields(fields, correlationId) {
        this.logger.trace("PerformanceClient: Updating counters");
        const event = this.eventsByCorrelationId.get(correlationId);
        if (event) {
          for (const counter in fields) {
            if (!event.hasOwnProperty(counter)) {
              event[counter] = 0;
            } else if (isNaN(Number(event[counter]))) {
              return;
            }
            event[counter] += fields[counter];
          }
        } else {
          this.logger.trace("PerformanceClient: Event not found for", correlationId);
        }
      }
      /**
       * Upserts event into event cache.
       * First key is the correlation id, second key is the event id.
       * Allows for events to be grouped by correlation id,
       * and to easily allow for properties on them to be updated.
       *
       * @private
       * @param {PerformanceEvent} event
       */
      cacheEventByCorrelationId(event) {
        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);
        if (rootEvent) {
          this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);
          rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || /* @__PURE__ */ new Map();
          rootEvent.incompleteSubMeasurements.set(event.eventId, {
            name: event.name,
            startTimeMs: event.startTimeMs
          });
        } else {
          this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);
          this.eventsByCorrelationId.set(event.correlationId, { ...event });
          this.eventStack.set(event.correlationId, []);
        }
      }
      getQueueInfo(correlationId) {
        const queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);
        if (!queueMeasurementForCorrelationId) {
          this.logger.trace(`PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`);
        }
        let totalQueueTime = 0;
        let totalQueueCount = 0;
        let manuallyCompletedCount = 0;
        queueMeasurementForCorrelationId?.forEach((measurement) => {
          totalQueueTime += measurement.queueTime;
          totalQueueCount++;
          manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;
        });
        return {
          totalQueueTime,
          totalQueueCount,
          manuallyCompletedCount
        };
      }
      /**
       * Removes measurements and aux data for a given correlation id.
       *
       * @param {string} correlationId
       */
      discardMeasurements(correlationId) {
        this.logger.trace("PerformanceClient: Performance measurements discarded", correlationId);
        this.eventsByCorrelationId.delete(correlationId);
        this.logger.trace("PerformanceClient: QueueMeasurements discarded", correlationId);
        this.queueMeasurements.delete(correlationId);
        this.logger.trace("PerformanceClient: Pre-queue times discarded", correlationId);
        this.preQueueTimeByCorrelationId.delete(correlationId);
        this.logger.trace("PerformanceClient: Event stack discarded", correlationId);
        this.eventStack.delete(correlationId);
      }
      /**
       * Registers a callback function to receive performance events.
       *
       * @param {PerformanceCallbackFunction} callback
       * @returns {string}
       */
      addPerformanceCallback(callback) {
        for (const [id, cb] of this.callbacks) {
          if (cb.toString() === callback.toString()) {
            this.logger.warning(`PerformanceClient: Performance callback is already registered with id: ${id}`);
            return id;
          }
        }
        const callbackId = this.generateId();
        this.callbacks.set(callbackId, callback);
        this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);
        return callbackId;
      }
      /**
       * Removes a callback registered with addPerformanceCallback.
       *
       * @param {string} callbackId
       * @returns {boolean}
       */
      removePerformanceCallback(callbackId) {
        const result = this.callbacks.delete(callbackId);
        if (result) {
          this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);
        } else {
          this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);
        }
        return result;
      }
      /**
       * Emits events to all registered callbacks.
       *
       * @param {PerformanceEvent[]} events
       * @param {?string} [correlationId]
       */
      emitEvents(events, correlationId) {
        this.logger.verbose("PerformanceClient: Emitting performance events", correlationId);
        this.callbacks.forEach((callback, callbackId) => {
          this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);
          callback.apply(null, [events]);
        });
      }
      /**
       * Enforce truncation of integral fields in performance event.
       * @param {PerformanceEvent} event performance event to update.
       */
      truncateIntegralFields(event) {
        this.intFields.forEach((key) => {
          if (key in event && typeof event[key] === "number") {
            event[key] = Math.floor(event[key]);
          }
        });
      }
      /**
       * Returns event duration in milliseconds
       * @param startTimeMs {number}
       * @returns {number}
       */
      getDurationMs(startTimeMs) {
        const durationMs = Date.now() - startTimeMs;
        return durationMs < 0 ? durationMs : 0;
      }
    };
    exports2.AADAuthorityConstants = indexNode.AADAuthorityConstants;
    exports2.AADServerParamKeys = indexNode.AADServerParamKeys;
    exports2.AccountEntity = indexNode.AccountEntity;
    exports2.AuthError = indexNode.AuthError;
    exports2.AuthErrorCodes = indexNode.AuthErrorCodes;
    exports2.AuthErrorMessage = indexNode.AuthErrorMessage;
    exports2.AuthToken = indexNode.AuthToken;
    exports2.AuthenticationHeaderParser = indexNode.AuthenticationHeaderParser;
    exports2.AuthenticationScheme = indexNode.AuthenticationScheme;
    exports2.Authority = indexNode.Authority;
    exports2.AuthorityFactory = indexNode.AuthorityFactory;
    exports2.AuthorityType = indexNode.AuthorityType;
    exports2.AuthorizationCodeClient = indexNode.AuthorizationCodeClient;
    exports2.AuthorizeProtocol = indexNode.Authorize;
    exports2.AzureCloudInstance = indexNode.AzureCloudInstance;
    exports2.BaseClient = indexNode.BaseClient;
    exports2.CacheAccountType = indexNode.CacheAccountType;
    exports2.CacheError = indexNode.CacheError;
    exports2.CacheErrorCodes = indexNode.CacheErrorCodes;
    exports2.CacheHelpers = indexNode.CacheHelpers;
    exports2.CacheManager = indexNode.CacheManager;
    exports2.CacheOutcome = indexNode.CacheOutcome;
    exports2.CacheType = indexNode.CacheType;
    exports2.CcsCredentialType = indexNode.CcsCredentialType;
    exports2.ClaimsRequestKeys = indexNode.ClaimsRequestKeys;
    exports2.ClientAuthError = indexNode.ClientAuthError;
    exports2.ClientAuthErrorCodes = indexNode.ClientAuthErrorCodes;
    exports2.ClientAuthErrorMessage = indexNode.ClientAuthErrorMessage;
    exports2.ClientConfigurationError = indexNode.ClientConfigurationError;
    exports2.ClientConfigurationErrorCodes = indexNode.ClientConfigurationErrorCodes;
    exports2.ClientConfigurationErrorMessage = indexNode.ClientConfigurationErrorMessage;
    exports2.CodeChallengeMethodValues = indexNode.CodeChallengeMethodValues;
    exports2.Constants = indexNode.Constants;
    exports2.CredentialType = indexNode.CredentialType;
    exports2.DEFAULT_CRYPTO_IMPLEMENTATION = indexNode.DEFAULT_CRYPTO_IMPLEMENTATION;
    exports2.DEFAULT_SYSTEM_OPTIONS = indexNode.DEFAULT_SYSTEM_OPTIONS;
    exports2.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = indexNode.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC;
    exports2.DefaultStorageClass = indexNode.DefaultStorageClass;
    exports2.EncodingTypes = indexNode.EncodingTypes;
    exports2.Errors = indexNode.Errors;
    exports2.GrantType = indexNode.GrantType;
    exports2.HeaderNames = indexNode.HeaderNames;
    exports2.HttpMethod = indexNode.HttpMethod;
    exports2.HttpStatus = indexNode.HttpStatus;
    exports2.IntFields = indexNode.IntFields;
    exports2.InteractionRequiredAuthError = indexNode.InteractionRequiredAuthError;
    exports2.InteractionRequiredAuthErrorCodes = indexNode.InteractionRequiredAuthErrorCodes;
    exports2.InteractionRequiredAuthErrorMessage = indexNode.InteractionRequiredAuthErrorMessage;
    exports2.JsonWebTokenTypes = indexNode.JsonWebTokenTypes;
    Object.defineProperty(exports2, "LogLevel", {
      enumerable: true,
      get: function() {
        return indexNode.LogLevel;
      }
    });
    exports2.Logger = indexNode.Logger;
    exports2.NetworkError = indexNode.NetworkError;
    exports2.OAuthResponseType = indexNode.OAuthResponseType;
    exports2.OIDC_DEFAULT_SCOPES = indexNode.OIDC_DEFAULT_SCOPES;
    exports2.ONE_DAY_IN_MS = indexNode.ONE_DAY_IN_MS;
    exports2.PasswordGrantConstants = indexNode.PasswordGrantConstants;
    exports2.PerformanceEventStatus = indexNode.PerformanceEventStatus;
    exports2.PerformanceEvents = indexNode.PerformanceEvents;
    exports2.PersistentCacheKeys = indexNode.PersistentCacheKeys;
    exports2.PlatformBrokerError = indexNode.PlatformBrokerError;
    exports2.PopTokenGenerator = indexNode.PopTokenGenerator;
    exports2.PromptValue = indexNode.PromptValue;
    exports2.ProtocolMode = indexNode.ProtocolMode;
    exports2.ProtocolUtils = indexNode.ProtocolUtils;
    exports2.RefreshTokenClient = indexNode.RefreshTokenClient;
    exports2.RequestParameterBuilder = indexNode.RequestParameterBuilder;
    exports2.ResponseHandler = indexNode.ResponseHandler;
    exports2.ResponseMode = indexNode.ResponseMode;
    exports2.ScopeSet = indexNode.ScopeSet;
    exports2.ServerError = indexNode.ServerError;
    exports2.ServerResponseType = indexNode.ServerResponseType;
    exports2.ServerTelemetryManager = indexNode.ServerTelemetryManager;
    exports2.SilentFlowClient = indexNode.SilentFlowClient;
    exports2.StringUtils = indexNode.StringUtils;
    exports2.StubPerformanceClient = indexNode.StubPerformanceClient;
    exports2.StubbedNetworkModule = indexNode.StubbedNetworkModule;
    exports2.THE_FAMILY_ID = indexNode.THE_FAMILY_ID;
    exports2.ThrottlingConstants = indexNode.ThrottlingConstants;
    exports2.ThrottlingUtils = indexNode.ThrottlingUtils;
    exports2.TimeUtils = indexNode.TimeUtils;
    exports2.UrlString = indexNode.UrlString;
    exports2.UrlUtils = indexNode.UrlUtils;
    exports2.buildAccountToCache = indexNode.buildAccountToCache;
    exports2.buildClientInfo = indexNode.buildClientInfo;
    exports2.buildClientInfoFromHomeAccountId = indexNode.buildClientInfoFromHomeAccountId;
    exports2.buildStaticAuthorityOptions = indexNode.buildStaticAuthorityOptions;
    exports2.buildTenantProfile = indexNode.buildTenantProfile;
    exports2.createAuthError = indexNode.createAuthError;
    exports2.createCacheError = indexNode.createCacheError;
    exports2.createClientAuthError = indexNode.createClientAuthError;
    exports2.createClientConfigurationError = indexNode.createClientConfigurationError;
    exports2.createInteractionRequiredAuthError = indexNode.createInteractionRequiredAuthError;
    exports2.createNetworkError = indexNode.createNetworkError;
    exports2.formatAuthorityUri = indexNode.formatAuthorityUri;
    exports2.getRequestThumbprint = indexNode.getRequestThumbprint;
    exports2.getTenantIdFromIdTokenClaims = indexNode.getTenantIdFromIdTokenClaims;
    exports2.invoke = indexNode.invoke;
    exports2.invokeAsync = indexNode.invokeAsync;
    exports2.tenantIdMatchesHomeTenant = indexNode.tenantIdMatchesHomeTenant;
    exports2.updateAccountTenantProfileData = indexNode.updateAccountTenantProfileData;
    exports2.version = indexNode.version;
    exports2.JoseHeader = JoseHeader;
    exports2.PerformanceClient = PerformanceClient;
  }
});

// node_modules/@azure/msal-common/lib/index.cjs
var require_lib2 = __commonJS({
  "node_modules/@azure/msal-common/lib/index.cjs"(exports2) {
    "use strict";
    var indexNode = require_index_node_BtzY9XyU();
    var indexBrowser = require_index_browser();
    exports2.AADAuthorityConstants = indexNode.AADAuthorityConstants;
    exports2.AADServerParamKeys = indexNode.AADServerParamKeys;
    exports2.AccountEntity = indexNode.AccountEntity;
    exports2.AuthError = indexNode.AuthError;
    exports2.AuthErrorCodes = indexNode.AuthErrorCodes;
    exports2.AuthErrorMessage = indexNode.AuthErrorMessage;
    exports2.AuthToken = indexNode.AuthToken;
    exports2.AuthenticationHeaderParser = indexNode.AuthenticationHeaderParser;
    exports2.AuthenticationScheme = indexNode.AuthenticationScheme;
    exports2.Authority = indexNode.Authority;
    exports2.AuthorityFactory = indexNode.AuthorityFactory;
    exports2.AuthorityType = indexNode.AuthorityType;
    exports2.AuthorizationCodeClient = indexNode.AuthorizationCodeClient;
    exports2.AuthorizeProtocol = indexNode.Authorize;
    exports2.AzureCloudInstance = indexNode.AzureCloudInstance;
    exports2.BaseClient = indexNode.BaseClient;
    exports2.CacheAccountType = indexNode.CacheAccountType;
    exports2.CacheError = indexNode.CacheError;
    exports2.CacheErrorCodes = indexNode.CacheErrorCodes;
    exports2.CacheHelpers = indexNode.CacheHelpers;
    exports2.CacheManager = indexNode.CacheManager;
    exports2.CacheOutcome = indexNode.CacheOutcome;
    exports2.CacheType = indexNode.CacheType;
    exports2.CcsCredentialType = indexNode.CcsCredentialType;
    exports2.ClaimsRequestKeys = indexNode.ClaimsRequestKeys;
    exports2.ClientAssertionUtils = indexNode.ClientAssertionUtils;
    exports2.ClientAuthError = indexNode.ClientAuthError;
    exports2.ClientAuthErrorCodes = indexNode.ClientAuthErrorCodes;
    exports2.ClientAuthErrorMessage = indexNode.ClientAuthErrorMessage;
    exports2.ClientConfigurationError = indexNode.ClientConfigurationError;
    exports2.ClientConfigurationErrorCodes = indexNode.ClientConfigurationErrorCodes;
    exports2.ClientConfigurationErrorMessage = indexNode.ClientConfigurationErrorMessage;
    exports2.CodeChallengeMethodValues = indexNode.CodeChallengeMethodValues;
    exports2.Constants = indexNode.Constants;
    exports2.CredentialType = indexNode.CredentialType;
    exports2.DEFAULT_CRYPTO_IMPLEMENTATION = indexNode.DEFAULT_CRYPTO_IMPLEMENTATION;
    exports2.DEFAULT_SYSTEM_OPTIONS = indexNode.DEFAULT_SYSTEM_OPTIONS;
    exports2.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = indexNode.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC;
    exports2.DefaultStorageClass = indexNode.DefaultStorageClass;
    exports2.EncodingTypes = indexNode.EncodingTypes;
    exports2.Errors = indexNode.Errors;
    exports2.GrantType = indexNode.GrantType;
    exports2.HeaderNames = indexNode.HeaderNames;
    exports2.HttpMethod = indexNode.HttpMethod;
    exports2.HttpStatus = indexNode.HttpStatus;
    exports2.IntFields = indexNode.IntFields;
    exports2.InteractionRequiredAuthError = indexNode.InteractionRequiredAuthError;
    exports2.InteractionRequiredAuthErrorCodes = indexNode.InteractionRequiredAuthErrorCodes;
    exports2.InteractionRequiredAuthErrorMessage = indexNode.InteractionRequiredAuthErrorMessage;
    exports2.JsonWebTokenTypes = indexNode.JsonWebTokenTypes;
    Object.defineProperty(exports2, "LogLevel", {
      enumerable: true,
      get: function() {
        return indexNode.LogLevel;
      }
    });
    exports2.Logger = indexNode.Logger;
    exports2.NetworkError = indexNode.NetworkError;
    exports2.OAuthResponseType = indexNode.OAuthResponseType;
    exports2.OIDC_DEFAULT_SCOPES = indexNode.OIDC_DEFAULT_SCOPES;
    exports2.ONE_DAY_IN_MS = indexNode.ONE_DAY_IN_MS;
    exports2.PasswordGrantConstants = indexNode.PasswordGrantConstants;
    exports2.PerformanceEventStatus = indexNode.PerformanceEventStatus;
    exports2.PerformanceEvents = indexNode.PerformanceEvents;
    exports2.PersistentCacheKeys = indexNode.PersistentCacheKeys;
    exports2.PlatformBrokerError = indexNode.PlatformBrokerError;
    exports2.PopTokenGenerator = indexNode.PopTokenGenerator;
    exports2.PromptValue = indexNode.PromptValue;
    exports2.ProtocolMode = indexNode.ProtocolMode;
    exports2.ProtocolUtils = indexNode.ProtocolUtils;
    exports2.RefreshTokenClient = indexNode.RefreshTokenClient;
    exports2.RequestParameterBuilder = indexNode.RequestParameterBuilder;
    exports2.ResponseHandler = indexNode.ResponseHandler;
    exports2.ResponseMode = indexNode.ResponseMode;
    exports2.ScopeSet = indexNode.ScopeSet;
    exports2.ServerError = indexNode.ServerError;
    exports2.ServerResponseType = indexNode.ServerResponseType;
    exports2.ServerTelemetryManager = indexNode.ServerTelemetryManager;
    exports2.SilentFlowClient = indexNode.SilentFlowClient;
    exports2.StringUtils = indexNode.StringUtils;
    exports2.StubPerformanceClient = indexNode.StubPerformanceClient;
    exports2.StubbedNetworkModule = indexNode.StubbedNetworkModule;
    exports2.THE_FAMILY_ID = indexNode.THE_FAMILY_ID;
    exports2.ThrottlingConstants = indexNode.ThrottlingConstants;
    exports2.ThrottlingUtils = indexNode.ThrottlingUtils;
    exports2.TimeUtils = indexNode.TimeUtils;
    exports2.TokenCacheContext = indexNode.TokenCacheContext;
    exports2.UrlString = indexNode.UrlString;
    exports2.UrlUtils = indexNode.UrlUtils;
    exports2.buildAccountToCache = indexNode.buildAccountToCache;
    exports2.buildClientInfo = indexNode.buildClientInfo;
    exports2.buildClientInfoFromHomeAccountId = indexNode.buildClientInfoFromHomeAccountId;
    exports2.buildStaticAuthorityOptions = indexNode.buildStaticAuthorityOptions;
    exports2.buildTenantProfile = indexNode.buildTenantProfile;
    exports2.createAuthError = indexNode.createAuthError;
    exports2.createCacheError = indexNode.createCacheError;
    exports2.createClientAuthError = indexNode.createClientAuthError;
    exports2.createClientConfigurationError = indexNode.createClientConfigurationError;
    exports2.createInteractionRequiredAuthError = indexNode.createInteractionRequiredAuthError;
    exports2.createNetworkError = indexNode.createNetworkError;
    exports2.formatAuthorityUri = indexNode.formatAuthorityUri;
    exports2.getClientAssertion = indexNode.getClientAssertion;
    exports2.getRequestThumbprint = indexNode.getRequestThumbprint;
    exports2.getTenantIdFromIdTokenClaims = indexNode.getTenantIdFromIdTokenClaims;
    exports2.invoke = indexNode.invoke;
    exports2.invokeAsync = indexNode.invokeAsync;
    exports2.tenantIdMatchesHomeTenant = indexNode.tenantIdMatchesHomeTenant;
    exports2.updateAccountTenantProfileData = indexNode.updateAccountTenantProfileData;
    exports2.version = indexNode.version;
    exports2.JoseHeader = indexBrowser.JoseHeader;
    exports2.PerformanceClient = indexBrowser.PerformanceClient;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports2, module2) {
    var Buffer3 = require_safe_buffer().Buffer;
    var Stream = require("stream");
    var util = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer3.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer3.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer3.concat([this.buffer, Buffer3.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer3.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer3.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer3.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer3.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer3.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer3.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer3.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports2, module2) {
    var Buffer3 = require_safe_buffer().Buffer;
    var crypto5 = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto5.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer3.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer3.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer3.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer3.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto5.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    var bufferEqual;
    var timingSafeEqual = "timingSafeEqual" in crypto5 ? function timingSafeEqual2(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return crypto5.timingSafeEqual(a, b);
    } : function timingSafeEqual2(a, b) {
      if (!bufferEqual) {
        bufferEqual = require_buffer_equal_constant_time();
      }
      return bufferEqual(a, b);
    };
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return timingSafeEqual(Buffer3.from(signature), Buffer3.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto5.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto5.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto5.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto5.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto5.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto5.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto5.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto5.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports2, module2) {
    var Buffer3 = require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer3.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    var Buffer3 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    function base64url(string, encoding) {
      return Buffer3.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret;
      secret = secret == null ? opts.privateKey : secret;
      secret = secret == null ? opts.key : secret;
      if (/^hs/i.test(opts.header.alg) === true && secret == null) {
        throw new TypeError("secret must be a string or buffer or a KeyObject");
      }
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    var Buffer3 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer3.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer3.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret;
      secretOrKey = secretOrKey == null ? opts.publicKey : secretOrKey;
      secretOrKey = secretOrKey == null ? opts.key : secretOrKey;
      if (/^hs/i.test(opts.algorithm) === true && secretOrKey == null) {
        throw new TypeError("secret must be a string or buffer or a KeyObject");
      }
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports2) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    var jws = require_jws();
    module2.exports = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    var ms = require_ms();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants2();
    var debug = require_debug2();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      if (typeof a === "number" && typeof b === "number") {
        return a === b ? 0 : a < b ? -1 : 1;
      }
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.major < other.major) {
          return -1;
        }
        if (this.major > other.major) {
          return 1;
        }
        if (this.minor < other.minor) {
          return -1;
        }
        if (this.minor > other.minor) {
          return 1;
        }
        if (this.patch < other.patch) {
          return -1;
        }
        if (this.patch > other.patch) {
          return 1;
        }
        return 0;
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse2;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var valid = (version2, options) => {
      const v = parse2(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var clean = (version2, options) => {
      const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var diff = (version1, version2) => {
      const v12 = parse2(version1, null, true);
      const v2 = parse2(version2, null, true);
      const comparison = v12.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v12 : v2;
      const lowVersion = v1Higher ? v2 : v12;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v12.major !== v2.major) {
        return prefix + "major";
      }
      if (v12.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v12.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse2(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug2();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      comp = comp.replace(re[t.BUILD], "");
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug2();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants2();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports2, module2) {
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module2.exports = function(algorithm, key) {
      if (!algorithm || !key)
        return;
      const keyType = key.asymmetricKeyType;
      if (!keyType)
        return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject, createSecretKey, createPublicKey } = require("crypto");
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
          try {
            secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports2, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports2, module2) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports2, module2) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var { KeyObject, createSecretKey, createPrivateKey } = require("crypto");
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate2(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate2(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate2(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
          secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
          return failure(error);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports2, module2) {
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/@azure/msal-node/lib/msal-node.cjs
var require_msal_node = __commonJS({
  "node_modules/@azure/msal-node/lib/msal-node.cjs"(exports2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var uuid = (init_esm_node(), __toCommonJS(esm_node_exports));
    var crypto5 = require("crypto");
    var msalCommon = require_lib2();
    var jwt = require_jsonwebtoken();
    var fs6 = require("fs");
    var path2 = require("path");
    var Serializer = class {
      /**
       * serialize the JSON blob
       * @param data - JSON blob cache
       */
      static serializeJSONBlob(data) {
        return JSON.stringify(data);
      }
      /**
       * Serialize Accounts
       * @param accCache - cache of accounts
       */
      static serializeAccounts(accCache) {
        const accounts = {};
        Object.keys(accCache).map(function(key) {
          const accountEntity = accCache[key];
          accounts[key] = {
            home_account_id: accountEntity.homeAccountId,
            environment: accountEntity.environment,
            realm: accountEntity.realm,
            local_account_id: accountEntity.localAccountId,
            username: accountEntity.username,
            authority_type: accountEntity.authorityType,
            name: accountEntity.name,
            client_info: accountEntity.clientInfo,
            last_modification_time: accountEntity.lastModificationTime,
            last_modification_app: accountEntity.lastModificationApp,
            tenantProfiles: accountEntity.tenantProfiles?.map((tenantProfile) => {
              return JSON.stringify(tenantProfile);
            })
          };
        });
        return accounts;
      }
      /**
       * Serialize IdTokens
       * @param idTCache - cache of ID tokens
       */
      static serializeIdTokens(idTCache) {
        const idTokens = {};
        Object.keys(idTCache).map(function(key) {
          const idTEntity = idTCache[key];
          idTokens[key] = {
            home_account_id: idTEntity.homeAccountId,
            environment: idTEntity.environment,
            credential_type: idTEntity.credentialType,
            client_id: idTEntity.clientId,
            secret: idTEntity.secret,
            realm: idTEntity.realm
          };
        });
        return idTokens;
      }
      /**
       * Serializes AccessTokens
       * @param atCache - cache of access tokens
       */
      static serializeAccessTokens(atCache) {
        const accessTokens = {};
        Object.keys(atCache).map(function(key) {
          const atEntity = atCache[key];
          accessTokens[key] = {
            home_account_id: atEntity.homeAccountId,
            environment: atEntity.environment,
            credential_type: atEntity.credentialType,
            client_id: atEntity.clientId,
            secret: atEntity.secret,
            realm: atEntity.realm,
            target: atEntity.target,
            cached_at: atEntity.cachedAt,
            expires_on: atEntity.expiresOn,
            extended_expires_on: atEntity.extendedExpiresOn,
            refresh_on: atEntity.refreshOn,
            key_id: atEntity.keyId,
            token_type: atEntity.tokenType,
            requestedClaims: atEntity.requestedClaims,
            requestedClaimsHash: atEntity.requestedClaimsHash,
            userAssertionHash: atEntity.userAssertionHash
          };
        });
        return accessTokens;
      }
      /**
       * Serialize refreshTokens
       * @param rtCache - cache of refresh tokens
       */
      static serializeRefreshTokens(rtCache) {
        const refreshTokens = {};
        Object.keys(rtCache).map(function(key) {
          const rtEntity = rtCache[key];
          refreshTokens[key] = {
            home_account_id: rtEntity.homeAccountId,
            environment: rtEntity.environment,
            credential_type: rtEntity.credentialType,
            client_id: rtEntity.clientId,
            secret: rtEntity.secret,
            family_id: rtEntity.familyId,
            target: rtEntity.target,
            realm: rtEntity.realm
          };
        });
        return refreshTokens;
      }
      /**
       * Serialize amdtCache
       * @param amdtCache - cache of app metadata
       */
      static serializeAppMetadata(amdtCache) {
        const appMetadata = {};
        Object.keys(amdtCache).map(function(key) {
          const amdtEntity = amdtCache[key];
          appMetadata[key] = {
            client_id: amdtEntity.clientId,
            environment: amdtEntity.environment,
            family_id: amdtEntity.familyId
          };
        });
        return appMetadata;
      }
      /**
       * Serialize the cache
       * @param inMemCache - itemised cache read from the JSON
       */
      static serializeAllCache(inMemCache) {
        return {
          Account: this.serializeAccounts(inMemCache.accounts),
          IdToken: this.serializeIdTokens(inMemCache.idTokens),
          AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
          RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
          AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)
        };
      }
    };
    var Constants$1 = {
      LIBRARY_NAME: "MSAL.JS",
      SKU: "msal.js.common",
      // default authority
      DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
      DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
      DEFAULT_COMMON_TENANT: "common",
      // ADFS String
      ADFS: "adfs",
      DSTS: "dstsv2",
      // Default AAD Instance Discovery Endpoint
      AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
      // CIAM URL
      CIAM_AUTH_URL: ".ciamlogin.com",
      AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
      // Resource delimiter - used for certain cache entries
      RESOURCE_DELIM: "|",
      // Placeholder for non-existent account ids/objects
      NO_ACCOUNT: "NO_ACCOUNT",
      // Claims
      CLAIMS: "claims",
      // Consumer UTID
      CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
      // Default scopes
      OPENID_SCOPE: "openid",
      PROFILE_SCOPE: "profile",
      OFFLINE_ACCESS_SCOPE: "offline_access",
      EMAIL_SCOPE: "email",
      CODE_GRANT_TYPE: "authorization_code",
      RT_GRANT_TYPE: "refresh_token",
      S256_CODE_CHALLENGE_METHOD: "S256",
      URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
      AUTHORIZATION_PENDING: "authorization_pending",
      NOT_DEFINED: "not_defined",
      EMPTY_STRING: "",
      NOT_APPLICABLE: "N/A",
      NOT_AVAILABLE: "Not Available",
      FORWARD_SLASH: "/",
      IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
      IMDS_VERSION: "2020-06-01",
      IMDS_TIMEOUT: 2e3,
      AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
      REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
      KNOWN_PUBLIC_CLOUDS: [
        "login.microsoftonline.com",
        "login.windows.net",
        "login.microsoft.com",
        "sts.windows.net"
      ],
      SHR_NONCE_VALIDITY: 240,
      INVALID_INSTANCE: "invalid_instance"
    };
    var HttpStatus = {
      SUCCESS: 200,
      SUCCESS_RANGE_START: 200,
      SUCCESS_RANGE_END: 299,
      REDIRECT: 302,
      CLIENT_ERROR: 400,
      CLIENT_ERROR_RANGE_START: 400,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      NOT_FOUND: 404,
      REQUEST_TIMEOUT: 408,
      GONE: 410,
      TOO_MANY_REQUESTS: 429,
      CLIENT_ERROR_RANGE_END: 499,
      SERVER_ERROR: 500,
      SERVER_ERROR_RANGE_START: 500,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      SERVER_ERROR_RANGE_END: 599,
      MULTI_SIDED_ERROR: 600
    };
    var OIDC_DEFAULT_SCOPES = [
      Constants$1.OPENID_SCOPE,
      Constants$1.PROFILE_SCOPE,
      Constants$1.OFFLINE_ACCESS_SCOPE
    ];
    var OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants$1.EMAIL_SCOPE];
    var HeaderNames = {
      CONTENT_TYPE: "Content-Type",
      CONTENT_LENGTH: "Content-Length",
      RETRY_AFTER: "Retry-After",
      CCS_HEADER: "X-AnchorMailbox",
      WWWAuthenticate: "WWW-Authenticate",
      AuthenticationInfo: "Authentication-Info",
      X_MS_REQUEST_ID: "x-ms-request-id",
      X_MS_HTTP_VERSION: "x-ms-httpver"
    };
    var AADAuthorityConstants = {
      COMMON: "common",
      ORGANIZATIONS: "organizations",
      CONSUMERS: "consumers"
    };
    var ClaimsRequestKeys = {
      ACCESS_TOKEN: "access_token",
      XMS_CC: "xms_cc"
    };
    var PromptValue = {
      LOGIN: "login",
      SELECT_ACCOUNT: "select_account",
      CONSENT: "consent",
      NONE: "none",
      CREATE: "create",
      NO_SESSION: "no_session"
    };
    var CodeChallengeMethodValues = {
      PLAIN: "plain",
      S256: "S256"
    };
    var OAuthResponseType = {
      CODE: "code",
      IDTOKEN_TOKEN: "id_token token"
    };
    var ResponseMode = {
      QUERY: "query",
      FRAGMENT: "fragment",
      FORM_POST: "form_post"
    };
    var GrantType = {
      AUTHORIZATION_CODE_GRANT: "authorization_code",
      CLIENT_CREDENTIALS_GRANT: "client_credentials",
      RESOURCE_OWNER_PASSWORD_GRANT: "password",
      REFRESH_TOKEN_GRANT: "refresh_token",
      DEVICE_CODE_GRANT: "device_code",
      JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer"
    };
    var CacheAccountType = {
      MSSTS_ACCOUNT_TYPE: "MSSTS",
      ADFS_ACCOUNT_TYPE: "ADFS",
      GENERIC_ACCOUNT_TYPE: "Generic"
      // NTLM, Kerberos, FBA, Basic etc
    };
    var Separators = {
      CACHE_KEY_SEPARATOR: "-",
      CLIENT_INFO_SEPARATOR: "."
    };
    var CredentialType = {
      ID_TOKEN: "IdToken",
      ACCESS_TOKEN: "AccessToken",
      ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",
      REFRESH_TOKEN: "RefreshToken"
    };
    var APP_METADATA = "appmetadata";
    var CLIENT_INFO = "client_info";
    var THE_FAMILY_ID = "1";
    var AUTHORITY_METADATA_CONSTANTS = {
      CACHE_KEY: "authority-metadata",
      REFRESH_TIME_SECONDS: 3600 * 24
      // 24 Hours
    };
    var AuthorityMetadataSource = {
      CONFIG: "config",
      CACHE: "cache",
      NETWORK: "network",
      HARDCODED_VALUES: "hardcoded_values"
    };
    var SERVER_TELEM_CONSTANTS = {
      SCHEMA_VERSION: 5,
      MAX_LAST_HEADER_BYTES: 330,
      MAX_CACHED_ERRORS: 50,
      CACHE_KEY: "server-telemetry",
      CATEGORY_SEPARATOR: "|",
      VALUE_SEPARATOR: ",",
      OVERFLOW_TRUE: "1",
      OVERFLOW_FALSE: "0",
      UNKNOWN_ERROR: "unknown_error"
    };
    var AuthenticationScheme = {
      BEARER: "Bearer",
      POP: "pop",
      SSH: "ssh-cert"
    };
    var ThrottlingConstants = {
      // Default time to throttle RequestThumbprint in seconds
      DEFAULT_THROTTLE_TIME_SECONDS: 60,
      // Default maximum time to throttle in seconds, overrides what the server sends back
      DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
      // Prefix for storing throttling entries
      THROTTLING_PREFIX: "throttling",
      // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
      X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
    };
    var Errors = {
      INVALID_GRANT_ERROR: "invalid_grant",
      CLIENT_MISMATCH_ERROR: "client_mismatch"
    };
    var PasswordGrantConstants = {
      username: "username",
      password: "password"
    };
    var RegionDiscoverySources = {
      FAILED_AUTO_DETECTION: "1",
      INTERNAL_CACHE: "2",
      ENVIRONMENT_VARIABLE: "3",
      IMDS: "4"
    };
    var RegionDiscoveryOutcomes = {
      CONFIGURED_NO_AUTO_DETECTION: "2",
      AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",
      AUTO_DETECTION_REQUESTED_FAILED: "5"
    };
    var CacheOutcome = {
      // When a token is found in the cache or the cache is not supposed to be hit when making the request
      NOT_APPLICABLE: "0",
      // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
      FORCE_REFRESH_OR_CLAIMS: "1",
      // When the token request goes to the identity provider because no cached access token exists
      NO_CACHED_ACCESS_TOKEN: "2",
      // When the token request goes to the identity provider because cached access token expired
      CACHED_ACCESS_TOKEN_EXPIRED: "3",
      // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
      PROACTIVELY_REFRESHED: "4"
    };
    var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
    var EncodingTypes = {
      BASE64: "base64",
      HEX: "hex",
      UTF8: "utf-8"
    };
    var unexpectedError = "unexpected_error";
    var postRequestFailed = "post_request_failed";
    var AuthErrorCodes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      postRequestFailed,
      unexpectedError
    });
    var AuthErrorMessages = {
      [unexpectedError]: "Unexpected error in authentication.",
      [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
    };
    var AuthErrorMessage = {
      unexpectedError: {
        code: unexpectedError,
        desc: AuthErrorMessages[unexpectedError]
      },
      postRequestFailed: {
        code: postRequestFailed,
        desc: AuthErrorMessages[postRequestFailed]
      }
    };
    var AuthError = class _AuthError extends Error {
      constructor(errorCode, errorMessage, suberror) {
        const errorString = errorMessage ? `${errorCode}: ${errorMessage}` : errorCode;
        super(errorString);
        Object.setPrototypeOf(this, _AuthError.prototype);
        this.errorCode = errorCode || Constants$1.EMPTY_STRING;
        this.errorMessage = errorMessage || Constants$1.EMPTY_STRING;
        this.subError = suberror || Constants$1.EMPTY_STRING;
        this.name = "AuthError";
      }
      setCorrelationId(correlationId) {
        this.correlationId = correlationId;
      }
    };
    function createAuthError(code, additionalMessage) {
      return new AuthError(code, additionalMessage ? `${AuthErrorMessages[code]} ${additionalMessage}` : AuthErrorMessages[code]);
    }
    var clientInfoDecodingError = "client_info_decoding_error";
    var clientInfoEmptyError = "client_info_empty_error";
    var tokenParsingError = "token_parsing_error";
    var nullOrEmptyToken = "null_or_empty_token";
    var endpointResolutionError = "endpoints_resolution_error";
    var networkError = "network_error";
    var openIdConfigError = "openid_config_error";
    var hashNotDeserialized = "hash_not_deserialized";
    var invalidState = "invalid_state";
    var stateMismatch = "state_mismatch";
    var stateNotFound = "state_not_found";
    var nonceMismatch = "nonce_mismatch";
    var authTimeNotFound = "auth_time_not_found";
    var maxAgeTranspired = "max_age_transpired";
    var multipleMatchingTokens = "multiple_matching_tokens";
    var multipleMatchingAccounts = "multiple_matching_accounts";
    var multipleMatchingAppMetadata = "multiple_matching_appMetadata";
    var requestCannotBeMade = "request_cannot_be_made";
    var cannotRemoveEmptyScope = "cannot_remove_empty_scope";
    var cannotAppendScopeSet = "cannot_append_scopeset";
    var emptyInputScopeSet = "empty_input_scopeset";
    var deviceCodePollingCancelled = "device_code_polling_cancelled";
    var deviceCodeExpired = "device_code_expired";
    var deviceCodeUnknownError = "device_code_unknown_error";
    var noAccountInSilentRequest = "no_account_in_silent_request";
    var invalidCacheRecord = "invalid_cache_record";
    var invalidCacheEnvironment = "invalid_cache_environment";
    var noAccountFound = "no_account_found";
    var noCryptoObject = "no_crypto_object";
    var unexpectedCredentialType = "unexpected_credential_type";
    var invalidAssertion = "invalid_assertion";
    var invalidClientCredential = "invalid_client_credential";
    var tokenRefreshRequired = "token_refresh_required";
    var userTimeoutReached = "user_timeout_reached";
    var tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";
    var authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";
    var bindingKeyNotRemoved = "binding_key_not_removed";
    var endSessionEndpointNotSupported = "end_session_endpoint_not_supported";
    var keyIdMissing = "key_id_missing";
    var noNetworkConnectivity = "no_network_connectivity";
    var userCanceled = "user_canceled";
    var missingTenantIdError = "missing_tenant_id_error";
    var methodNotImplemented = "method_not_implemented";
    var nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";
    var platformBrokerError = "platform_broker_error";
    var ClientAuthErrorCodes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      authTimeNotFound,
      authorizationCodeMissingFromServerResponse,
      bindingKeyNotRemoved,
      cannotAppendScopeSet,
      cannotRemoveEmptyScope,
      clientInfoDecodingError,
      clientInfoEmptyError,
      deviceCodeExpired,
      deviceCodePollingCancelled,
      deviceCodeUnknownError,
      emptyInputScopeSet,
      endSessionEndpointNotSupported,
      endpointResolutionError,
      hashNotDeserialized,
      invalidAssertion,
      invalidCacheEnvironment,
      invalidCacheRecord,
      invalidClientCredential,
      invalidState,
      keyIdMissing,
      maxAgeTranspired,
      methodNotImplemented,
      missingTenantIdError,
      multipleMatchingAccounts,
      multipleMatchingAppMetadata,
      multipleMatchingTokens,
      nestedAppAuthBridgeDisabled,
      networkError,
      noAccountFound,
      noAccountInSilentRequest,
      noCryptoObject,
      noNetworkConnectivity,
      nonceMismatch,
      nullOrEmptyToken,
      openIdConfigError,
      platformBrokerError,
      requestCannotBeMade,
      stateMismatch,
      stateNotFound,
      tokenClaimsCnfRequiredForSignedJwt,
      tokenParsingError,
      tokenRefreshRequired,
      unexpectedCredentialType,
      userCanceled,
      userTimeoutReached
    });
    var ClientAuthErrorMessages = {
      [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",
      [clientInfoEmptyError]: "The client info was empty",
      [tokenParsingError]: "Token cannot be parsed",
      [nullOrEmptyToken]: "The token is null or empty",
      [endpointResolutionError]: "Endpoints cannot be resolved",
      [networkError]: "Network request failed",
      [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",
      [hashNotDeserialized]: "The hash parameters could not be deserialized",
      [invalidState]: "State was not the expected format",
      [stateMismatch]: "State mismatch error",
      [stateNotFound]: "State not found",
      [nonceMismatch]: "Nonce mismatch error",
      [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable. auth_time is an optional claim and is not enabled by default - it must be enabled. See https://aka.ms/msaljs/optional-claims for more information.",
      [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",
      [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account.",
      [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",
      [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",
      [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",
      [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",
      [cannotAppendScopeSet]: "Cannot append ScopeSet",
      [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",
      [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",
      [deviceCodeExpired]: "Device code is expired.",
      [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",
      [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",
      [invalidCacheRecord]: "Cache record object was null or undefined.",
      [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",
      [noAccountFound]: "No account found in cache for given key.",
      [noCryptoObject]: "No crypto object detected.",
      [unexpectedCredentialType]: "Unexpected credential type.",
      [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",
      [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",
      [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",
      [userTimeoutReached]: "User defined timeout for device code polling reached",
      [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",
      [authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",
      [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
      [endSessionEndpointNotSupported]: "The provided authority does not support logout",
      [keyIdMissing]: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
      [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",
      [userCanceled]: "User cancelled the flow.",
      [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",
      [methodNotImplemented]: "This method has not been implemented",
      [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled",
      [platformBrokerError]: "An error occurred in the native broker. See the platformBrokerError property for details."
    };
    var ClientAuthErrorMessage = {
      clientInfoDecodingError: {
        code: clientInfoDecodingError,
        desc: ClientAuthErrorMessages[clientInfoDecodingError]
      },
      clientInfoEmptyError: {
        code: clientInfoEmptyError,
        desc: ClientAuthErrorMessages[clientInfoEmptyError]
      },
      tokenParsingError: {
        code: tokenParsingError,
        desc: ClientAuthErrorMessages[tokenParsingError]
      },
      nullOrEmptyToken: {
        code: nullOrEmptyToken,
        desc: ClientAuthErrorMessages[nullOrEmptyToken]
      },
      endpointResolutionError: {
        code: endpointResolutionError,
        desc: ClientAuthErrorMessages[endpointResolutionError]
      },
      networkError: {
        code: networkError,
        desc: ClientAuthErrorMessages[networkError]
      },
      unableToGetOpenidConfigError: {
        code: openIdConfigError,
        desc: ClientAuthErrorMessages[openIdConfigError]
      },
      hashNotDeserialized: {
        code: hashNotDeserialized,
        desc: ClientAuthErrorMessages[hashNotDeserialized]
      },
      invalidStateError: {
        code: invalidState,
        desc: ClientAuthErrorMessages[invalidState]
      },
      stateMismatchError: {
        code: stateMismatch,
        desc: ClientAuthErrorMessages[stateMismatch]
      },
      stateNotFoundError: {
        code: stateNotFound,
        desc: ClientAuthErrorMessages[stateNotFound]
      },
      nonceMismatchError: {
        code: nonceMismatch,
        desc: ClientAuthErrorMessages[nonceMismatch]
      },
      authTimeNotFoundError: {
        code: authTimeNotFound,
        desc: ClientAuthErrorMessages[authTimeNotFound]
      },
      maxAgeTranspired: {
        code: maxAgeTranspired,
        desc: ClientAuthErrorMessages[maxAgeTranspired]
      },
      multipleMatchingTokens: {
        code: multipleMatchingTokens,
        desc: ClientAuthErrorMessages[multipleMatchingTokens]
      },
      multipleMatchingAccounts: {
        code: multipleMatchingAccounts,
        desc: ClientAuthErrorMessages[multipleMatchingAccounts]
      },
      multipleMatchingAppMetadata: {
        code: multipleMatchingAppMetadata,
        desc: ClientAuthErrorMessages[multipleMatchingAppMetadata]
      },
      tokenRequestCannotBeMade: {
        code: requestCannotBeMade,
        desc: ClientAuthErrorMessages[requestCannotBeMade]
      },
      removeEmptyScopeError: {
        code: cannotRemoveEmptyScope,
        desc: ClientAuthErrorMessages[cannotRemoveEmptyScope]
      },
      appendScopeSetError: {
        code: cannotAppendScopeSet,
        desc: ClientAuthErrorMessages[cannotAppendScopeSet]
      },
      emptyInputScopeSetError: {
        code: emptyInputScopeSet,
        desc: ClientAuthErrorMessages[emptyInputScopeSet]
      },
      DeviceCodePollingCancelled: {
        code: deviceCodePollingCancelled,
        desc: ClientAuthErrorMessages[deviceCodePollingCancelled]
      },
      DeviceCodeExpired: {
        code: deviceCodeExpired,
        desc: ClientAuthErrorMessages[deviceCodeExpired]
      },
      DeviceCodeUnknownError: {
        code: deviceCodeUnknownError,
        desc: ClientAuthErrorMessages[deviceCodeUnknownError]
      },
      NoAccountInSilentRequest: {
        code: noAccountInSilentRequest,
        desc: ClientAuthErrorMessages[noAccountInSilentRequest]
      },
      invalidCacheRecord: {
        code: invalidCacheRecord,
        desc: ClientAuthErrorMessages[invalidCacheRecord]
      },
      invalidCacheEnvironment: {
        code: invalidCacheEnvironment,
        desc: ClientAuthErrorMessages[invalidCacheEnvironment]
      },
      noAccountFound: {
        code: noAccountFound,
        desc: ClientAuthErrorMessages[noAccountFound]
      },
      noCryptoObj: {
        code: noCryptoObject,
        desc: ClientAuthErrorMessages[noCryptoObject]
      },
      unexpectedCredentialType: {
        code: unexpectedCredentialType,
        desc: ClientAuthErrorMessages[unexpectedCredentialType]
      },
      invalidAssertion: {
        code: invalidAssertion,
        desc: ClientAuthErrorMessages[invalidAssertion]
      },
      invalidClientCredential: {
        code: invalidClientCredential,
        desc: ClientAuthErrorMessages[invalidClientCredential]
      },
      tokenRefreshRequired: {
        code: tokenRefreshRequired,
        desc: ClientAuthErrorMessages[tokenRefreshRequired]
      },
      userTimeoutReached: {
        code: userTimeoutReached,
        desc: ClientAuthErrorMessages[userTimeoutReached]
      },
      tokenClaimsRequired: {
        code: tokenClaimsCnfRequiredForSignedJwt,
        desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt]
      },
      noAuthorizationCodeFromServer: {
        code: authorizationCodeMissingFromServerResponse,
        desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse]
      },
      bindingKeyNotRemovedError: {
        code: bindingKeyNotRemoved,
        desc: ClientAuthErrorMessages[bindingKeyNotRemoved]
      },
      logoutNotSupported: {
        code: endSessionEndpointNotSupported,
        desc: ClientAuthErrorMessages[endSessionEndpointNotSupported]
      },
      keyIdMissing: {
        code: keyIdMissing,
        desc: ClientAuthErrorMessages[keyIdMissing]
      },
      noNetworkConnectivity: {
        code: noNetworkConnectivity,
        desc: ClientAuthErrorMessages[noNetworkConnectivity]
      },
      userCanceledError: {
        code: userCanceled,
        desc: ClientAuthErrorMessages[userCanceled]
      },
      missingTenantIdError: {
        code: missingTenantIdError,
        desc: ClientAuthErrorMessages[missingTenantIdError]
      },
      nestedAppAuthBridgeDisabled: {
        code: nestedAppAuthBridgeDisabled,
        desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled]
      },
      platformBrokerError: {
        code: platformBrokerError,
        desc: ClientAuthErrorMessages[platformBrokerError]
      }
    };
    var ClientAuthError = class _ClientAuthError extends AuthError {
      constructor(errorCode, additionalMessage) {
        super(errorCode, additionalMessage ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}` : ClientAuthErrorMessages[errorCode]);
        this.name = "ClientAuthError";
        Object.setPrototypeOf(this, _ClientAuthError.prototype);
      }
    };
    function createClientAuthError(errorCode, additionalMessage) {
      return new ClientAuthError(errorCode, additionalMessage);
    }
    var DEFAULT_CRYPTO_IMPLEMENTATION = {
      createNewGuid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Decode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64Encode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      base64UrlEncode: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      encodeKid: () => {
        throw createClientAuthError(methodNotImplemented);
      },
      async getPublicKeyThumbprint() {
        throw createClientAuthError(methodNotImplemented);
      },
      async removeTokenBindingKey() {
        throw createClientAuthError(methodNotImplemented);
      },
      async clearKeystore() {
        throw createClientAuthError(methodNotImplemented);
      },
      async signJwt() {
        throw createClientAuthError(methodNotImplemented);
      },
      async hashString() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
    exports2.LogLevel = void 0;
    (function(LogLevel) {
      LogLevel[LogLevel["Error"] = 0] = "Error";
      LogLevel[LogLevel["Warning"] = 1] = "Warning";
      LogLevel[LogLevel["Info"] = 2] = "Info";
      LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
      LogLevel[LogLevel["Trace"] = 4] = "Trace";
    })(exports2.LogLevel || (exports2.LogLevel = {}));
    var Logger = class _Logger {
      constructor(loggerOptions, packageName, packageVersion) {
        this.level = exports2.LogLevel.Info;
        const defaultLoggerCallback = () => {
          return;
        };
        const setLoggerOptions = loggerOptions || _Logger.createDefaultLoggerOptions();
        this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback;
        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
        this.level = typeof setLoggerOptions.logLevel === "number" ? setLoggerOptions.logLevel : exports2.LogLevel.Info;
        this.correlationId = setLoggerOptions.correlationId || Constants$1.EMPTY_STRING;
        this.packageName = packageName || Constants$1.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants$1.EMPTY_STRING;
      }
      static createDefaultLoggerOptions() {
        return {
          loggerCallback: () => {
          },
          piiLoggingEnabled: false,
          logLevel: exports2.LogLevel.Info
        };
      }
      /**
       * Create new Logger with existing configurations.
       */
      clone(packageName, packageVersion, correlationId) {
        return new _Logger({
          loggerCallback: this.localCallback,
          piiLoggingEnabled: this.piiLoggingEnabled,
          logLevel: this.level,
          correlationId: correlationId || this.correlationId
        }, packageName, packageVersion);
      }
      /**
       * Log message with required options.
       */
      logMessage(logMessage, options) {
        if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
          return;
        }
        const timestamp = (/* @__PURE__ */ new Date()).toUTCString();
        const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ""}]`;
        const log2 = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${exports2.LogLevel[options.logLevel]} - ${logMessage}`;
        this.executeCallback(options.logLevel, log2, options.containsPii || false);
      }
      /**
       * Execute callback with message.
       */
      executeCallback(level, message, containsPii) {
        if (this.localCallback) {
          this.localCallback(level, message, containsPii);
        }
      }
      /**
       * Logs error messages.
       */
      error(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Error,
          containsPii: false,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Logs error messages with PII.
       */
      errorPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Error,
          containsPii: true,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages.
       */
      warning(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Warning,
          containsPii: false,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Logs warning messages with PII.
       */
      warningPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Warning,
          containsPii: true,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Logs info messages.
       */
      info(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Info,
          containsPii: false,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Logs info messages with PII.
       */
      infoPii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Info,
          containsPii: true,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages.
       */
      verbose(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Verbose,
          containsPii: false,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Logs verbose messages with PII.
       */
      verbosePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Verbose,
          containsPii: true,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages.
       */
      trace(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Trace,
          containsPii: false,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Logs trace messages with PII.
       */
      tracePii(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Trace,
          containsPii: true,
          correlationId: correlationId || Constants$1.EMPTY_STRING
        });
      }
      /**
       * Returns whether PII Logging is enabled or not.
       */
      isPiiLoggingEnabled() {
        return this.piiLoggingEnabled || false;
      }
    };
    var name$1 = "@azure/msal-common";
    var version$1 = "15.15.0";
    var AzureCloudInstance = {
      // AzureCloudInstance is not specified.
      None: "none",
      // Microsoft Azure public cloud
      AzurePublic: "https://login.microsoftonline.com",
      // Microsoft PPE
      AzurePpe: "https://login.windows-ppe.net",
      // Microsoft Chinese national/regional cloud
      AzureChina: "https://login.chinacloudapi.cn",
      // Microsoft German national/regional cloud ("Black Forest")
      AzureGermany: "https://login.microsoftonline.de",
      // US Government cloud
      AzureUsGovernment: "https://login.microsoftonline.us"
    };
    var redirectUriEmpty = "redirect_uri_empty";
    var claimsRequestParsingError = "claims_request_parsing_error";
    var authorityUriInsecure = "authority_uri_insecure";
    var urlParseError = "url_parse_error";
    var urlEmptyError = "empty_url_error";
    var emptyInputScopesError = "empty_input_scopes_error";
    var invalidClaims = "invalid_claims";
    var tokenRequestEmpty = "token_request_empty";
    var logoutRequestEmpty = "logout_request_empty";
    var invalidCodeChallengeMethod = "invalid_code_challenge_method";
    var pkceParamsMissing = "pkce_params_missing";
    var invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";
    var invalidAuthorityMetadata = "invalid_authority_metadata";
    var untrustedAuthority = "untrusted_authority";
    var missingSshJwk = "missing_ssh_jwk";
    var missingSshKid = "missing_ssh_kid";
    var missingNonceAuthenticationHeader = "missing_nonce_authentication_header";
    var invalidAuthenticationHeader = "invalid_authentication_header";
    var cannotSetOIDCOptions = "cannot_set_OIDCOptions";
    var cannotAllowPlatformBroker = "cannot_allow_platform_broker";
    var authorityMismatch = "authority_mismatch";
    var invalidRequestMethodForEAR = "invalid_request_method_for_EAR";
    var invalidAuthorizePostBodyParameters = "invalid_authorize_post_body_parameters";
    var invalidPlatformBrokerConfiguration = "invalid_platform_broker_configuration";
    var ClientConfigurationErrorCodes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      authorityMismatch,
      authorityUriInsecure,
      cannotAllowPlatformBroker,
      cannotSetOIDCOptions,
      claimsRequestParsingError,
      emptyInputScopesError,
      invalidAuthenticationHeader,
      invalidAuthorityMetadata,
      invalidAuthorizePostBodyParameters,
      invalidClaims,
      invalidCloudDiscoveryMetadata,
      invalidCodeChallengeMethod,
      invalidPlatformBrokerConfiguration,
      invalidRequestMethodForEAR,
      logoutRequestEmpty,
      missingNonceAuthenticationHeader,
      missingSshJwk,
      missingSshKid,
      pkceParamsMissing,
      redirectUriEmpty,
      tokenRequestEmpty,
      untrustedAuthority,
      urlEmptyError,
      urlParseError
    });
    var ClientConfigurationErrorMessages = {
      [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",
      [claimsRequestParsingError]: "Could not parse the given claims request object.",
      [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
      [urlParseError]: "URL could not be parsed into appropriate segments.",
      [urlEmptyError]: "URL was empty or null.",
      [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
      [invalidClaims]: "Given claims parameter must be a stringified JSON object.",
      [tokenRequestEmpty]: "Token request was empty and not found in cache.",
      [logoutRequestEmpty]: "The logout request was null or undefined.",
      [invalidCodeChallengeMethod]: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
      [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
      [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
      [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
      [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
      [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
      [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
      [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
      [invalidAuthenticationHeader]: "Invalid authentication header provided",
      [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",
      [cannotAllowPlatformBroker]: "Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.",
      [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority.",
      [invalidAuthorizePostBodyParameters]: "Invalid authorize post body parameters provided. If you are using authorizePostBodyParameters, the request method must be POST. Please check the request method and parameters.",
      [invalidRequestMethodForEAR]: "Invalid request method for EAR protocol mode. The request method cannot be GET when using EAR protocol mode. Please change the request method to POST.",
      [invalidPlatformBrokerConfiguration]: "Invalid platform broker configuration. `allowPlatformBrokerWithDOM` can only be enabled when `allowPlatformBroker` is enabled."
    };
    var ClientConfigurationErrorMessage = {
      redirectUriNotSet: {
        code: redirectUriEmpty,
        desc: ClientConfigurationErrorMessages[redirectUriEmpty]
      },
      claimsRequestParsingError: {
        code: claimsRequestParsingError,
        desc: ClientConfigurationErrorMessages[claimsRequestParsingError]
      },
      authorityUriInsecure: {
        code: authorityUriInsecure,
        desc: ClientConfigurationErrorMessages[authorityUriInsecure]
      },
      urlParseError: {
        code: urlParseError,
        desc: ClientConfigurationErrorMessages[urlParseError]
      },
      urlEmptyError: {
        code: urlEmptyError,
        desc: ClientConfigurationErrorMessages[urlEmptyError]
      },
      emptyScopesError: {
        code: emptyInputScopesError,
        desc: ClientConfigurationErrorMessages[emptyInputScopesError]
      },
      invalidClaimsRequest: {
        code: invalidClaims,
        desc: ClientConfigurationErrorMessages[invalidClaims]
      },
      tokenRequestEmptyError: {
        code: tokenRequestEmpty,
        desc: ClientConfigurationErrorMessages[tokenRequestEmpty]
      },
      logoutRequestEmptyError: {
        code: logoutRequestEmpty,
        desc: ClientConfigurationErrorMessages[logoutRequestEmpty]
      },
      invalidCodeChallengeMethod: {
        code: invalidCodeChallengeMethod,
        desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod]
      },
      invalidCodeChallengeParams: {
        code: pkceParamsMissing,
        desc: ClientConfigurationErrorMessages[pkceParamsMissing]
      },
      invalidCloudDiscoveryMetadata: {
        code: invalidCloudDiscoveryMetadata,
        desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata]
      },
      invalidAuthorityMetadata: {
        code: invalidAuthorityMetadata,
        desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata]
      },
      untrustedAuthority: {
        code: untrustedAuthority,
        desc: ClientConfigurationErrorMessages[untrustedAuthority]
      },
      missingSshJwk: {
        code: missingSshJwk,
        desc: ClientConfigurationErrorMessages[missingSshJwk]
      },
      missingSshKid: {
        code: missingSshKid,
        desc: ClientConfigurationErrorMessages[missingSshKid]
      },
      missingNonceAuthenticationHeader: {
        code: missingNonceAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader]
      },
      invalidAuthenticationHeader: {
        code: invalidAuthenticationHeader,
        desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader]
      },
      cannotSetOIDCOptions: {
        code: cannotSetOIDCOptions,
        desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions]
      },
      cannotAllowPlatformBroker: {
        code: cannotAllowPlatformBroker,
        desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker]
      },
      authorityMismatch: {
        code: authorityMismatch,
        desc: ClientConfigurationErrorMessages[authorityMismatch]
      },
      invalidAuthorizePostBodyParameters: {
        code: invalidAuthorizePostBodyParameters,
        desc: ClientConfigurationErrorMessages[invalidAuthorizePostBodyParameters]
      },
      invalidRequestMethodForEAR: {
        code: invalidRequestMethodForEAR,
        desc: ClientConfigurationErrorMessages[invalidRequestMethodForEAR]
      },
      invalidPlatformBrokerConfiguration: {
        code: invalidPlatformBrokerConfiguration,
        desc: ClientConfigurationErrorMessages[invalidPlatformBrokerConfiguration]
      }
    };
    var ClientConfigurationError = class _ClientConfigurationError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ClientConfigurationErrorMessages[errorCode]);
        this.name = "ClientConfigurationError";
        Object.setPrototypeOf(this, _ClientConfigurationError.prototype);
      }
    };
    function createClientConfigurationError(errorCode) {
      return new ClientConfigurationError(errorCode);
    }
    var StringUtils = class {
      /**
       * Check if stringified object is empty
       * @param strObj
       */
      static isEmptyObj(strObj) {
        if (strObj) {
          try {
            const obj = JSON.parse(strObj);
            return Object.keys(obj).length === 0;
          } catch (e) {
          }
        }
        return true;
      }
      static startsWith(str, search) {
        return str.indexOf(search) === 0;
      }
      static endsWith(str, search) {
        return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
      }
      /**
       * Parses string into an object.
       *
       * @param query
       */
      static queryStringToObject(query) {
        const obj = {};
        const params = query.split("&");
        const decode = (s) => decodeURIComponent(s.replace(/\+/g, " "));
        params.forEach((pair) => {
          if (pair.trim()) {
            const [key, value] = pair.split(/=(.+)/g, 2);
            if (key && value) {
              obj[decode(key)] = decode(value);
            }
          }
        });
        return obj;
      }
      /**
       * Trims entries in an array.
       *
       * @param arr
       */
      static trimArrayEntries(arr) {
        return arr.map((entry) => entry.trim());
      }
      /**
       * Removes empty strings from array
       * @param arr
       */
      static removeEmptyStringsFromArray(arr) {
        return arr.filter((entry) => {
          return !!entry;
        });
      }
      /**
       * Attempts to parse a string into JSON
       * @param str
       */
      static jsonParseHelper(str) {
        try {
          return JSON.parse(str);
        } catch (e) {
          return null;
        }
      }
      /**
       * Tests if a given string matches a given pattern, with support for wildcards and queries.
       * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
       * @param input String to match against
       */
      static matchPattern(pattern, input) {
        const regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
        return regex.test(input);
      }
    };
    var ScopeSet = class _ScopeSet {
      constructor(inputScopes) {
        const scopeArr = inputScopes ? StringUtils.trimArrayEntries([...inputScopes]) : [];
        const filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        if (!filteredInput || !filteredInput.length) {
          throw createClientConfigurationError(emptyInputScopesError);
        }
        this.scopes = /* @__PURE__ */ new Set();
        filteredInput.forEach((scope) => this.scopes.add(scope));
      }
      /**
       * Factory method to create ScopeSet from space-delimited string
       * @param inputScopeString
       * @param appClientId
       * @param scopesRequired
       */
      static fromString(inputScopeString) {
        const scopeString = inputScopeString || Constants$1.EMPTY_STRING;
        const inputScopes = scopeString.split(" ");
        return new _ScopeSet(inputScopes);
      }
      /**
       * Creates the set of scopes to search for in cache lookups
       * @param inputScopeString
       * @returns
       */
      static createSearchScopes(inputScopeString) {
        const scopesToUse = inputScopeString && inputScopeString.length > 0 ? inputScopeString : [...OIDC_DEFAULT_SCOPES];
        const scopeSet = new _ScopeSet(scopesToUse);
        if (!scopeSet.containsOnlyOIDCScopes()) {
          scopeSet.removeOIDCScopes();
        } else {
          scopeSet.removeScope(Constants$1.OFFLINE_ACCESS_SCOPE);
        }
        return scopeSet;
      }
      /**
       * Check if a given scope is present in this set of scopes.
       * @param scope
       */
      containsScope(scope) {
        const lowerCaseScopes = this.printScopesLowerCase().split(" ");
        const lowerCaseScopesSet = new _ScopeSet(lowerCaseScopes);
        return scope ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
      }
      /**
       * Check if a set of scopes is present in this set of scopes.
       * @param scopeSet
       */
      containsScopeSet(scopeSet) {
        if (!scopeSet || scopeSet.scopes.size <= 0) {
          return false;
        }
        return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every((scope) => this.containsScope(scope));
      }
      /**
       * Check if set of scopes contains only the defaults
       */
      containsOnlyOIDCScopes() {
        let defaultScopeCount = 0;
        OIDC_SCOPES.forEach((defaultScope) => {
          if (this.containsScope(defaultScope)) {
            defaultScopeCount += 1;
          }
        });
        return this.scopes.size === defaultScopeCount;
      }
      /**
       * Appends single scope if passed
       * @param newScope
       */
      appendScope(newScope) {
        if (newScope) {
          this.scopes.add(newScope.trim());
        }
      }
      /**
       * Appends multiple scopes if passed
       * @param newScopes
       */
      appendScopes(newScopes) {
        try {
          newScopes.forEach((newScope) => this.appendScope(newScope));
        } catch (e) {
          throw createClientAuthError(cannotAppendScopeSet);
        }
      }
      /**
       * Removes element from set of scopes.
       * @param scope
       */
      removeScope(scope) {
        if (!scope) {
          throw createClientAuthError(cannotRemoveEmptyScope);
        }
        this.scopes.delete(scope.trim());
      }
      /**
       * Removes default scopes from set of scopes
       * Primarily used to prevent cache misses if the default scopes are not returned from the server
       */
      removeOIDCScopes() {
        OIDC_SCOPES.forEach((defaultScope) => {
          this.scopes.delete(defaultScope);
        });
      }
      /**
       * Combines an array of scopes with the current set of scopes.
       * @param otherScopes
       */
      unionScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        const unionScopes = /* @__PURE__ */ new Set();
        otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
        return unionScopes;
      }
      /**
       * Check if scopes intersect between this set and another.
       * @param otherScopes
       */
      intersectingScopeSets(otherScopes) {
        if (!otherScopes) {
          throw createClientAuthError(emptyInputScopeSet);
        }
        if (!otherScopes.containsOnlyOIDCScopes()) {
          otherScopes.removeOIDCScopes();
        }
        const unionScopes = this.unionScopeSets(otherScopes);
        const sizeOtherScopes = otherScopes.getScopeCount();
        const sizeThisScopes = this.getScopeCount();
        const sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
      }
      /**
       * Returns size of set of scopes.
       */
      getScopeCount() {
        return this.scopes.size;
      }
      /**
       * Returns the scopes as an array of string values
       */
      asArray() {
        const array = [];
        this.scopes.forEach((val) => array.push(val));
        return array;
      }
      /**
       * Prints scopes into a space-delimited string
       */
      printScopes() {
        if (this.scopes) {
          const scopeArr = this.asArray();
          return scopeArr.join(" ");
        }
        return Constants$1.EMPTY_STRING;
      }
      /**
       * Prints scopes into a space-delimited lower-case string (used for caching)
       */
      printScopesLowerCase() {
        return this.printScopes().toLowerCase();
      }
    };
    function buildClientInfo(rawClientInfo, base64Decode) {
      if (!rawClientInfo) {
        throw createClientAuthError(clientInfoEmptyError);
      }
      try {
        const decodedClientInfo = base64Decode(rawClientInfo);
        return JSON.parse(decodedClientInfo);
      } catch (e) {
        throw createClientAuthError(clientInfoDecodingError);
      }
    }
    function buildClientInfoFromHomeAccountId(homeAccountId) {
      if (!homeAccountId) {
        throw createClientAuthError(clientInfoDecodingError);
      }
      const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
      return {
        uid: clientInfoParts[0],
        utid: clientInfoParts.length < 2 ? Constants$1.EMPTY_STRING : clientInfoParts[1]
      };
    }
    function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
      return !!tenantId && !!homeAccountId && tenantId === homeAccountId.split(".")[1];
    }
    function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
      if (idTokenClaims) {
        const { oid, sub, tid, name: name2, tfp, acr, preferred_username, upn, login_hint } = idTokenClaims;
        const tenantId2 = tid || tfp || acr || "";
        return {
          tenantId: tenantId2,
          localAccountId: oid || sub || "",
          name: name2,
          username: preferred_username || upn || "",
          loginHint: login_hint,
          isHomeTenant: tenantIdMatchesHomeTenant(tenantId2, homeAccountId)
        };
      } else {
        return {
          tenantId,
          localAccountId,
          username: "",
          isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId)
        };
      }
    }
    function updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {
      let updatedAccountInfo = baseAccountInfo;
      if (tenantProfile) {
        const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
        updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
      }
      if (idTokenClaims) {
        const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);
        updatedAccountInfo = {
          ...updatedAccountInfo,
          ...claimsSourcedTenantProfile,
          idTokenClaims,
          idToken: idTokenSecret
        };
        return updatedAccountInfo;
      }
      return updatedAccountInfo;
    }
    var AuthorityType = {
      Default: 0,
      Adfs: 1,
      Dsts: 2,
      Ciam: 3
    };
    function getTenantIdFromIdTokenClaims(idTokenClaims) {
      if (idTokenClaims) {
        const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
        return tenantId || null;
      }
      return null;
    }
    var ProtocolMode = {
      /**
       * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features
       */
      AAD: "AAD",
      /**
       * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.
       * Support is limited for this mode.
       */
      OIDC: "OIDC",
      /**
       * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features
       */
      EAR: "EAR"
    };
    var AccountEntity = class _AccountEntity {
      /**
       * Returns the AccountInfo interface for this account.
       */
      static getAccountInfo(accountEntity) {
        const tenantProfiles = accountEntity.tenantProfiles || [];
        if (tenantProfiles.length === 0 && accountEntity.realm && accountEntity.localAccountId) {
          tenantProfiles.push(buildTenantProfile(accountEntity.homeAccountId, accountEntity.localAccountId, accountEntity.realm));
        }
        return {
          homeAccountId: accountEntity.homeAccountId,
          environment: accountEntity.environment,
          tenantId: accountEntity.realm,
          username: accountEntity.username,
          localAccountId: accountEntity.localAccountId,
          loginHint: accountEntity.loginHint,
          name: accountEntity.name,
          nativeAccountId: accountEntity.nativeAccountId,
          authorityType: accountEntity.authorityType,
          // Deserialize tenant profiles array into a Map
          tenantProfiles: new Map(tenantProfiles.map((tenantProfile) => {
            return [tenantProfile.tenantId, tenantProfile];
          })),
          dataBoundary: accountEntity.dataBoundary
        };
      }
      /**
       * Returns true if the account entity is in single tenant format (outdated), false otherwise
       */
      isSingleTenant() {
        return !this.tenantProfiles;
      }
      /**
       * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
       * @param accountDetails
       */
      static createAccount(accountDetails, authority, base64Decode) {
        const account = new _AccountEntity();
        if (authority.authorityType === AuthorityType.Adfs) {
          account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
        } else if (authority.protocolMode === ProtocolMode.OIDC) {
          account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
        } else {
          account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
        }
        let clientInfo;
        if (accountDetails.clientInfo && base64Decode) {
          clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);
          if (clientInfo.xms_tdbr) {
            account.dataBoundary = clientInfo.xms_tdbr === "EU" ? "EU" : "None";
          }
        }
        account.clientInfo = accountDetails.clientInfo;
        account.homeAccountId = accountDetails.homeAccountId;
        account.nativeAccountId = accountDetails.nativeAccountId;
        const env = accountDetails.environment || authority && authority.getPreferredCache();
        if (!env) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        account.environment = env;
        account.realm = clientInfo?.utid || getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) || "";
        account.localAccountId = clientInfo?.uid || accountDetails.idTokenClaims?.oid || accountDetails.idTokenClaims?.sub || "";
        const preferredUsername = accountDetails.idTokenClaims?.preferred_username || accountDetails.idTokenClaims?.upn;
        const email = accountDetails.idTokenClaims?.emails ? accountDetails.idTokenClaims.emails[0] : null;
        account.username = preferredUsername || email || "";
        account.loginHint = accountDetails.idTokenClaims?.login_hint;
        account.name = accountDetails.idTokenClaims?.name || "";
        account.cloudGraphHostName = accountDetails.cloudGraphHostName;
        account.msGraphHost = accountDetails.msGraphHost;
        if (accountDetails.tenantProfiles) {
          account.tenantProfiles = accountDetails.tenantProfiles;
        } else {
          const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);
          account.tenantProfiles = [tenantProfile];
        }
        return account;
      }
      /**
       * Creates an AccountEntity object from AccountInfo
       * @param accountInfo
       * @param cloudGraphHostName
       * @param msGraphHost
       * @returns
       */
      static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
        const account = new _AccountEntity();
        account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = accountInfo.homeAccountId;
        account.localAccountId = accountInfo.localAccountId;
        account.nativeAccountId = accountInfo.nativeAccountId;
        account.realm = accountInfo.tenantId;
        account.environment = accountInfo.environment;
        account.username = accountInfo.username;
        account.name = accountInfo.name;
        account.loginHint = accountInfo.loginHint;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        const tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);
        if (tenantProfiles.length === 0 && accountInfo.tenantId && accountInfo.localAccountId) {
          tenantProfiles.push(buildTenantProfile(accountInfo.homeAccountId, accountInfo.localAccountId, accountInfo.tenantId, accountInfo.idTokenClaims));
        }
        account.tenantProfiles = tenantProfiles;
        account.dataBoundary = accountInfo.dataBoundary;
        return account;
      }
      /**
       * Generate HomeAccountId from server response
       * @param serverClientInfo
       * @param authType
       */
      static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {
        if (!(authType === AuthorityType.Adfs || authType === AuthorityType.Dsts)) {
          if (serverClientInfo) {
            try {
              const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
              if (clientInfo.uid && clientInfo.utid) {
                return `${clientInfo.uid}.${clientInfo.utid}`;
              }
            } catch (e) {
            }
          }
          logger.warning("No client info in response");
        }
        return idTokenClaims?.sub || "";
      }
      /**
       * Validates an entity: checks for all expected params
       * @param entity
       */
      static isAccountEntity(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
      }
      /**
       * Helper function to determine whether 2 accountInfo objects represent the same account
       * @param accountA
       * @param accountB
       * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
       */
      static accountInfoIsEqual(accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
          return false;
        }
        let claimsMatch = true;
        if (compareClaims) {
          const accountAClaims = accountA.idTokenClaims || {};
          const accountBClaims = accountB.idTokenClaims || {};
          claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
        }
        return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.loginHint === accountB.loginHint && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
      }
    };
    function extractTokenClaims(encodedToken, base64Decode) {
      const jswPayload = getJWSPayload(encodedToken);
      try {
        const base64Decoded = base64Decode(jswPayload);
        return JSON.parse(base64Decoded);
      } catch (err) {
        throw createClientAuthError(tokenParsingError);
      }
    }
    function isKmsi(idTokenClaims) {
      if (!idTokenClaims.signin_state) {
        return false;
      }
      const kmsiClaims = ["kmsi", "dvc_dmjd"];
      const kmsi = idTokenClaims.signin_state.some((value) => kmsiClaims.includes(value.trim().toLowerCase()));
      return kmsi;
    }
    function getJWSPayload(authToken) {
      if (!authToken) {
        throw createClientAuthError(nullOrEmptyToken);
      }
      const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
      const matches = tokenPartsRegex.exec(authToken);
      if (!matches || matches.length < 4) {
        throw createClientAuthError(tokenParsingError);
      }
      return matches[2];
    }
    function checkMaxAge(authTime, maxAge) {
      const fiveMinuteSkew = 3e5;
      if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
        throw createClientAuthError(maxAgeTranspired);
      }
    }
    function stripLeadingHashOrQuery(responseString) {
      if (responseString.startsWith("#/")) {
        return responseString.substring(2);
      } else if (responseString.startsWith("#") || responseString.startsWith("?")) {
        return responseString.substring(1);
      }
      return responseString;
    }
    function getDeserializedResponse(responseString) {
      if (!responseString || responseString.indexOf("=") < 0) {
        return null;
      }
      try {
        const normalizedResponse = stripLeadingHashOrQuery(responseString);
        const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
        if (deserializedHash.code || deserializedHash.ear_jwe || deserializedHash.error || deserializedHash.error_description || deserializedHash.state) {
          return deserializedHash;
        }
      } catch (e) {
        throw createClientAuthError(hashNotDeserialized);
      }
      return null;
    }
    function mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {
      const queryParameterArray = new Array();
      parameters.forEach((value, key) => {
        if (!encodeExtraParams && extraQueryParameters && key in extraQueryParameters) {
          queryParameterArray.push(`${key}=${value}`);
        } else {
          queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);
        }
      });
      return queryParameterArray.join("&");
    }
    var UrlString = class _UrlString {
      get urlString() {
        return this._urlString;
      }
      constructor(url) {
        this._urlString = url;
        if (!this._urlString) {
          throw createClientConfigurationError(urlEmptyError);
        }
        if (!url.includes("#")) {
          this._urlString = _UrlString.canonicalizeUri(url);
        }
      }
      /**
       * Ensure urls are lower case and end with a / character.
       * @param url
       */
      static canonicalizeUri(url) {
        if (url) {
          let lowerCaseUrl = url.toLowerCase();
          if (StringUtils.endsWith(lowerCaseUrl, "?")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -1);
          } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -2);
          }
          if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
            lowerCaseUrl += "/";
          }
          return lowerCaseUrl;
        }
        return url;
      }
      /**
       * Throws if urlString passed is not a valid authority URI string.
       */
      validateAsUri() {
        let components;
        try {
          components = this.getUrlComponents();
        } catch (e) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.HostNameAndPort || !components.PathSegments) {
          throw createClientConfigurationError(urlParseError);
        }
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
          throw createClientConfigurationError(authorityUriInsecure);
        }
      }
      /**
       * Given a url and a query string return the url with provided query string appended
       * @param url
       * @param queryString
       */
      static appendQueryString(url, queryString) {
        if (!queryString) {
          return url;
        }
        return url.indexOf("?") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;
      }
      /**
       * Returns a url with the hash removed
       * @param url
       */
      static removeHashFromUrl(url) {
        return _UrlString.canonicalizeUri(url.split("#")[0]);
      }
      /**
       * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
       * @param href The url
       * @param tenantId The tenant id to replace
       */
      replaceTenantPath(tenantId) {
        const urlObject = this.getUrlComponents();
        const pathArray = urlObject.PathSegments;
        if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {
          pathArray[0] = tenantId;
        }
        return _UrlString.constructAuthorityUriFromObject(urlObject);
      }
      /**
       * Parses out the components from a url string.
       * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
       */
      getUrlComponents() {
        const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        const match = this.urlString.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        const urlComponents = {
          Protocol: match[1],
          HostNameAndPort: match[4],
          AbsolutePath: match[5],
          QueryString: match[7]
        };
        let pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter((val) => val && val.length > 0);
        urlComponents.PathSegments = pathSegments;
        if (urlComponents.QueryString && urlComponents.QueryString.endsWith("/")) {
          urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
        }
        return urlComponents;
      }
      static getDomainFromUrl(url) {
        const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
        const match = url.match(regEx);
        if (!match) {
          throw createClientConfigurationError(urlParseError);
        }
        return match[2];
      }
      static getAbsoluteUrl(relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants$1.FORWARD_SLASH) {
          const url = new _UrlString(baseUrl);
          const baseComponents = url.getUrlComponents();
          return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
        }
        return relativeUrl;
      }
      static constructAuthorityUriFromObject(urlObject) {
        return new _UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
      }
      /**
       * Check if the hash of the URL string contains known properties
       * @deprecated This API will be removed in a future version
       */
      static hashContainsKnownProperties(response) {
        return !!getDeserializedResponse(response);
      }
    };
    var rawMetdataJSON = {
      endpointMetadata: {
        "login.microsoftonline.com": {
          token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout"
        },
        "login.chinacloudapi.cn": {
          token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
          authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout"
        },
        "login.microsoftonline.us": {
          token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
          authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout"
        },
        "login.sovcloud-identity.fr": {
          token_endpoint: "https://login.sovcloud-identity.fr/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.sovcloud-identity.fr/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.sovcloud-identity.fr/{tenantid}/v2.0",
          authorization_endpoint: "https://login.sovcloud-identity.fr/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.sovcloud-identity.fr/{tenantid}/oauth2/v2.0/logout"
        },
        "login.sovcloud-identity.de": {
          token_endpoint: "https://login.sovcloud-identity.de/{tenantid}/oauth2/v2.0/token",
          jwks_uri: "https://login.sovcloud-identity.de/{tenantid}/discovery/v2.0/keys",
          issuer: "https://login.sovcloud-identity.de/{tenantid}/v2.0",
          authorization_endpoint: "https://login.sovcloud-identity.de/{tenantid}/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.sovcloud-identity.de/{tenantid}/oauth2/v2.0/logout"
        },
        "login.sovcloud-identity.sg": {
          token_endpoint: "https://login.sovcloud-identity.sg/common/oauth2/v2.0/token",
          jwks_uri: "https://login.sovcloud-identity.sg/common/discovery/v2.0/keys",
          issuer: "https://login.sovcloud-identity.sg/{tenantid}/v2.0",
          authorization_endpoint: "https://login.sovcloud-identity.sg/common/oauth2/v2.0/authorize",
          end_session_endpoint: "https://login.sovcloud-identity.sg/common/oauth2/v2.0/logout"
        }
      },
      instanceDiscoveryMetadata: {
        metadata: [
          {
            preferred_network: "login.microsoftonline.com",
            preferred_cache: "login.windows.net",
            aliases: [
              "login.microsoftonline.com",
              "login.windows.net",
              "login.microsoft.com",
              "sts.windows.net"
            ]
          },
          {
            preferred_network: "login.partner.microsoftonline.cn",
            preferred_cache: "login.partner.microsoftonline.cn",
            aliases: [
              "login.partner.microsoftonline.cn",
              "login.chinacloudapi.cn"
            ]
          },
          {
            preferred_network: "login.microsoftonline.de",
            preferred_cache: "login.microsoftonline.de",
            aliases: ["login.microsoftonline.de"]
          },
          {
            preferred_network: "login.microsoftonline.us",
            preferred_cache: "login.microsoftonline.us",
            aliases: [
              "login.microsoftonline.us",
              "login.usgovcloudapi.net"
            ]
          },
          {
            preferred_network: "login-us.microsoftonline.com",
            preferred_cache: "login-us.microsoftonline.com",
            aliases: ["login-us.microsoftonline.com"]
          },
          {
            preferred_network: "login.sovcloud-identity.fr",
            preferred_cache: "login.sovcloud-identity.fr",
            aliases: ["login.sovcloud-identity.fr"]
          },
          {
            preferred_network: "login.sovcloud-identity.de",
            preferred_cache: "login.sovcloud-identity.de",
            aliases: ["login.sovcloud-identity.de"]
          },
          {
            preferred_network: "login.sovcloud-identity.sg",
            preferred_cache: "login.sovcloud-identity.sg",
            aliases: ["login.sovcloud-identity.sg"]
          }
        ]
      }
    };
    var EndpointMetadata = rawMetdataJSON.endpointMetadata;
    var InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
    var InstanceDiscoveryMetadataAliases = /* @__PURE__ */ new Set();
    InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
      metadataEntry.aliases.forEach((alias) => {
        InstanceDiscoveryMetadataAliases.add(alias);
      });
    });
    function getAliasesFromStaticSources(staticAuthorityOptions, logger) {
      let staticAliases;
      const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
      if (canonicalAuthority) {
        const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
        staticAliases = getAliasesFromMetadata(authorityHost, staticAuthorityOptions.cloudDiscoveryMetadata?.metadata, AuthorityMetadataSource.CONFIG, logger) || getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger) || staticAuthorityOptions.knownAuthorities;
      }
      return staticAliases || [];
    }
    function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source, logger) {
      logger?.trace(`getAliasesFromMetadata called with source: ${source}`);
      if (authorityHost && cloudDiscoveryMetadata) {
        const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);
        if (metadata) {
          logger?.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source}, returning aliases`);
          return metadata.aliases;
        } else {
          logger?.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source}`);
        }
      }
      return null;
    }
    function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
      const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);
      return metadata;
    }
    function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
      for (let i = 0; i < response.length; i++) {
        const metadata = response[i];
        if (metadata.aliases.includes(authorityHost)) {
          return metadata;
        }
      }
      return null;
    }
    var cacheQuotaExceeded = "cache_quota_exceeded";
    var cacheErrorUnknown = "cache_error_unknown";
    var CacheErrorMessages = {
      [cacheQuotaExceeded]: "Exceeded cache storage capacity.",
      [cacheErrorUnknown]: "Unexpected error occurred when using cache storage."
    };
    var CacheError = class _CacheError extends AuthError {
      constructor(errorCode, errorMessage) {
        const message = errorMessage || (CacheErrorMessages[errorCode] ? CacheErrorMessages[errorCode] : CacheErrorMessages[cacheErrorUnknown]);
        super(`${errorCode}: ${message}`);
        Object.setPrototypeOf(this, _CacheError.prototype);
        this.name = "CacheError";
        this.errorCode = errorCode;
        this.errorMessage = message;
      }
    };
    function createCacheError(e) {
      if (!(e instanceof Error)) {
        return new CacheError(cacheErrorUnknown);
      }
      if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED" || e.message.includes("exceeded the quota")) {
        return new CacheError(cacheQuotaExceeded);
      } else {
        return new CacheError(e.name, e.message);
      }
    }
    var CacheManager = class {
      constructor(clientId, cryptoImpl, logger, performanceClient, staticAuthorityOptions) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl;
        this.commonLogger = logger.clone(name$1, version$1);
        this.staticAuthorityOptions = staticAuthorityOptions;
        this.performanceClient = performanceClient;
      }
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter, correlationId) {
        return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter, correlationId), correlationId, accountFilter);
      }
      /**
       * Gets first tenanted AccountInfo object found based on provided filters
       */
      getAccountInfoFilteredBy(accountFilter, correlationId) {
        if (Object.keys(accountFilter).length === 0 || Object.values(accountFilter).every((value) => !value)) {
          this.commonLogger.warning("getAccountInfoFilteredBy: Account filter is empty or invalid, returning null");
          return null;
        }
        const allAccounts = this.getAllAccounts(accountFilter, correlationId);
        if (allAccounts.length > 1) {
          const sortedAccounts = allAccounts.sort((account) => {
            return account.idTokenClaims ? -1 : 1;
          });
          return sortedAccounts[0];
        } else if (allAccounts.length === 1) {
          return allAccounts[0];
        } else {
          return null;
        }
      }
      /**
       * Returns a single matching
       * @param accountFilter
       * @returns
       */
      getBaseAccountInfo(accountFilter, correlationId) {
        const accountEntities = this.getAccountsFilteredBy(accountFilter, correlationId);
        if (accountEntities.length > 0) {
          return AccountEntity.getAccountInfo(accountEntities[0]);
        } else {
          return null;
        }
      }
      /**
       * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
       * and builds the account info objects from the matching ID token's claims
       * @param cachedAccounts
       * @param accountFilter
       * @returns Array of AccountInfo objects that match account and tenant profile filters
       */
      buildTenantProfiles(cachedAccounts, correlationId, accountFilter) {
        return cachedAccounts.flatMap((accountEntity) => {
          return this.getTenantProfilesFromAccountEntity(accountEntity, correlationId, accountFilter?.tenantId, accountFilter);
        });
      }
      getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter) {
        let tenantedAccountInfo = null;
        let idTokenClaims;
        if (tenantProfileFilter) {
          if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
            return null;
          }
        }
        const idToken = this.getIdToken(accountInfo, correlationId, tokenKeys, tenantProfile.tenantId);
        if (idToken) {
          idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
          if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
            return null;
          }
        }
        tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken?.secret);
        return tenantedAccountInfo;
      }
      getTenantProfilesFromAccountEntity(accountEntity, correlationId, targetTenantId, tenantProfileFilter) {
        const accountInfo = AccountEntity.getAccountInfo(accountEntity);
        let searchTenantProfiles = accountInfo.tenantProfiles || /* @__PURE__ */ new Map();
        const tokenKeys = this.getTokenKeys();
        if (targetTenantId) {
          const tenantProfile = searchTenantProfiles.get(targetTenantId);
          if (tenantProfile) {
            searchTenantProfiles = /* @__PURE__ */ new Map([
              [targetTenantId, tenantProfile]
            ]);
          } else {
            return [];
          }
        }
        const matchingTenantProfiles = [];
        searchTenantProfiles.forEach((tenantProfile) => {
          const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter);
          if (tenantedAccountInfo) {
            matchingTenantProfiles.push(tenantedAccountInfo);
          }
        });
        return matchingTenantProfiles;
      }
      tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
        if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {
          return false;
        }
        if (!!tenantProfileFilter.name && !(tenantProfile.name === tenantProfileFilter.name)) {
          return false;
        }
        if (tenantProfileFilter.isHomeTenant !== void 0 && !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {
          return false;
        }
        return true;
      }
      idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
        if (tenantProfileFilter) {
          if (!!tenantProfileFilter.localAccountId && !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {
            return false;
          }
          if (!!tenantProfileFilter.loginHint && !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {
            return false;
          }
          if (!!tenantProfileFilter.username && !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {
            return false;
          }
          if (!!tenantProfileFilter.name && !this.matchName(idTokenClaims, tenantProfileFilter.name)) {
            return false;
          }
          if (!!tenantProfileFilter.sid && !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
            return false;
          }
        }
        return true;
      }
      /**
       * saves a cache record
       * @param cacheRecord {CacheRecord}
       * @param correlationId {?string} correlation id
       * @param kmsi - Keep Me Signed In
       * @param apiId - API identifier for telemetry tracking
       * @param storeInCache {?StoreInCache}
       */
      async saveCacheRecord(cacheRecord, correlationId, kmsi, apiId, storeInCache) {
        if (!cacheRecord) {
          throw createClientAuthError(invalidCacheRecord);
        }
        try {
          if (!!cacheRecord.account) {
            await this.setAccount(cacheRecord.account, correlationId, kmsi, apiId);
          }
          if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {
            await this.setIdTokenCredential(cacheRecord.idToken, correlationId, kmsi);
          }
          if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {
            await this.saveAccessToken(cacheRecord.accessToken, correlationId, kmsi);
          }
          if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {
            await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId, kmsi);
          }
          if (!!cacheRecord.appMetadata) {
            this.setAppMetadata(cacheRecord.appMetadata, correlationId);
          }
        } catch (e) {
          this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createCacheError(e);
          }
        }
      }
      /**
       * saves access token credential
       * @param credential
       */
      async saveAccessToken(credential, correlationId, kmsi) {
        const accessTokenFilter = {
          clientId: credential.clientId,
          credentialType: credential.credentialType,
          environment: credential.environment,
          homeAccountId: credential.homeAccountId,
          realm: credential.realm,
          tokenType: credential.tokenType,
          requestedClaimsHash: credential.requestedClaimsHash
        };
        const tokenKeys = this.getTokenKeys();
        const currentScopes = ScopeSet.fromString(credential.target);
        tokenKeys.accessToken.forEach((key) => {
          if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {
            return;
          }
          const tokenEntity = this.getAccessTokenCredential(key, correlationId);
          if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
            const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
            if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
              this.removeAccessToken(key, correlationId);
            }
          }
        });
        await this.setAccessTokenCredential(credential, correlationId, kmsi);
      }
      /**
       * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
       * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
       * @param accountFilter - An object containing Account properties to filter by
       */
      getAccountsFilteredBy(accountFilter, correlationId) {
        const allAccountKeys = this.getAccountKeys();
        const matchingAccounts = [];
        allAccountKeys.forEach((cacheKey) => {
          const entity = this.getAccount(cacheKey, correlationId);
          if (!entity) {
            return;
          }
          if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
            return;
          }
          if (!!accountFilter.username && !this.matchUsername(entity.username, accountFilter.username)) {
            return;
          }
          if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {
            return;
          }
          if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {
            return;
          }
          if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
            return;
          }
          if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {
            return;
          }
          const tenantProfileFilter = {
            localAccountId: accountFilter?.localAccountId,
            name: accountFilter?.name
          };
          const matchingTenantProfiles = entity.tenantProfiles?.filter((tenantProfile) => {
            return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
          });
          if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
            return;
          }
          matchingAccounts.push(entity);
        });
        return matchingAccounts;
      }
      /**
       * Returns whether or not the given credential entity matches the filter
       * @param entity
       * @param filter
       * @returns
       */
      credentialMatchesFilter(entity, filter) {
        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
          return false;
        }
        if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {
          return false;
        }
        if (typeof filter.homeAccountId === "string" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {
          return false;
        }
        if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
          return false;
        }
        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {
          return false;
        }
        if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {
          return false;
        }
        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {
          return false;
        }
        if (!!filter.target && !this.matchTarget(entity, filter.target)) {
          return false;
        }
        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {
          if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {
            return false;
          }
        }
        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
          if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {
            return false;
          }
          if (filter.tokenType === AuthenticationScheme.SSH) {
            if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
       * @param filter
       */
      getAppMetadataFilteredBy(filter) {
        const allCacheKeys = this.getKeys();
        const matchingAppMetadata = {};
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAppMetadata(cacheKey)) {
            return;
          }
          const entity = this.getAppMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
            return;
          }
          if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
            return;
          }
          matchingAppMetadata[cacheKey] = entity;
        });
        return matchingAppMetadata;
      }
      /**
       * retrieve authorityMetadata that contains a matching alias
       * @param filter
       */
      getAuthorityMetadataByAlias(host) {
        const allCacheKeys = this.getAuthorityMetadataKeys();
        let matchedEntity = null;
        allCacheKeys.forEach((cacheKey) => {
          if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {
            return;
          }
          const entity = this.getAuthorityMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (entity.aliases.indexOf(host) === -1) {
            return;
          }
          matchedEntity = entity;
        });
        return matchedEntity;
      }
      /**
       * Removes all accounts and related tokens from cache.
       */
      removeAllAccounts(correlationId) {
        const accounts = this.getAllAccounts({}, correlationId);
        accounts.forEach((account) => {
          this.removeAccount(account, correlationId);
        });
      }
      /**
       * Removes the account and related tokens for a given account key
       * @param account
       */
      removeAccount(account, correlationId) {
        this.removeAccountContext(account, correlationId);
        const accountKeys = this.getAccountKeys();
        const keyFilter = (key) => {
          return key.includes(account.homeAccountId) && key.includes(account.environment);
        };
        accountKeys.filter(keyFilter).forEach((key) => {
          this.removeItem(key, correlationId);
          this.performanceClient.incrementFields({ accountsRemoved: 1 }, correlationId);
        });
      }
      /**
       * Removes credentials associated with the provided account
       * @param account
       */
      removeAccountContext(account, correlationId) {
        const allTokenKeys = this.getTokenKeys();
        const keyFilter = (key) => {
          return key.includes(account.homeAccountId) && key.includes(account.environment);
        };
        allTokenKeys.idToken.filter(keyFilter).forEach((key) => {
          this.removeIdToken(key, correlationId);
        });
        allTokenKeys.accessToken.filter(keyFilter).forEach((key) => {
          this.removeAccessToken(key, correlationId);
        });
        allTokenKeys.refreshToken.filter(keyFilter).forEach((key) => {
          this.removeRefreshToken(key, correlationId);
        });
      }
      /**
       * Removes accessToken from the cache
       * @param key
       * @param correlationId
       */
      removeAccessToken(key, correlationId) {
        const credential = this.getAccessTokenCredential(key, correlationId);
        this.removeItem(key, correlationId);
        this.performanceClient.incrementFields({ accessTokensRemoved: 1 }, correlationId);
        if (!credential || credential.credentialType.toLowerCase() !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase() || credential.tokenType !== AuthenticationScheme.POP) {
          return;
        }
        const kid = credential.keyId;
        if (kid) {
          void this.cryptoImpl.removeTokenBindingKey(kid).catch(() => {
            this.commonLogger.error(`Failed to remove token binding key ${kid}`, correlationId);
            this.performanceClient?.incrementFields({ removeTokenBindingKeyFailure: 1 }, correlationId);
          });
        }
      }
      /**
       * Removes all app metadata objects from cache.
       */
      removeAppMetadata(correlationId) {
        const allCacheKeys = this.getKeys();
        allCacheKeys.forEach((cacheKey) => {
          if (this.isAppMetadata(cacheKey)) {
            this.removeItem(cacheKey, correlationId);
          }
        });
        return true;
      }
      /**
       * Retrieve IdTokenEntity from cache
       * @param account {AccountInfo}
       * @param tokenKeys {?TokenKeys}
       * @param targetRealm {?string}
       * @param performanceClient {?IPerformanceClient}
       * @param correlationId {?string}
       */
      getIdToken(account, correlationId, tokenKeys, targetRealm, performanceClient) {
        this.commonLogger.trace("CacheManager - getIdToken called");
        const idTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.clientId,
          realm: targetRealm
        };
        const idTokenMap = this.getIdTokensByFilter(idTokenFilter, correlationId, tokenKeys);
        const numIdTokens = idTokenMap.size;
        if (numIdTokens < 1) {
          this.commonLogger.info("CacheManager:getIdToken - No token found");
          return null;
        } else if (numIdTokens > 1) {
          let tokensToBeRemoved = idTokenMap;
          if (!targetRealm) {
            const homeIdTokenMap = /* @__PURE__ */ new Map();
            idTokenMap.forEach((idToken, key) => {
              if (idToken.realm === account.tenantId) {
                homeIdTokenMap.set(key, idToken);
              }
            });
            const numHomeIdTokens = homeIdTokenMap.size;
            if (numHomeIdTokens < 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");
              return idTokenMap.values().next().value;
            } else if (numHomeIdTokens === 1) {
              this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");
              return homeIdTokenMap.values().next().value;
            } else {
              tokensToBeRemoved = homeIdTokenMap;
            }
          }
          this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");
          tokensToBeRemoved.forEach((idToken, key) => {
            this.removeIdToken(key, correlationId);
          });
          if (performanceClient && correlationId) {
            performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
          }
          return null;
        }
        this.commonLogger.info("CacheManager:getIdToken - Returning ID token");
        return idTokenMap.values().next().value;
      }
      /**
       * Gets all idTokens matching the given filter
       * @param filter
       * @returns
       */
      getIdTokensByFilter(filter, correlationId, tokenKeys) {
        const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;
        const idTokens = /* @__PURE__ */ new Map();
        idTokenKeys.forEach((key) => {
          if (!this.idTokenKeyMatchesFilter(key, {
            clientId: this.clientId,
            ...filter
          })) {
            return;
          }
          const idToken = this.getIdTokenCredential(key, correlationId);
          if (idToken && this.credentialMatchesFilter(idToken, filter)) {
            idTokens.set(key, idToken);
          }
        });
        return idTokens;
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @returns
       */
      idTokenKeyMatchesFilter(inputKey, filter) {
        const key = inputKey.toLowerCase();
        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Removes idToken from the cache
       * @param key
       */
      removeIdToken(key, correlationId) {
        this.removeItem(key, correlationId);
      }
      /**
       * Removes refresh token from the cache
       * @param key
       */
      removeRefreshToken(key, correlationId) {
        this.removeItem(key, correlationId);
      }
      /**
       * Retrieve AccessTokenEntity from cache
       * @param account {AccountInfo}
       * @param request {BaseAuthRequest}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getAccessToken(account, request, tokenKeys, targetRealm) {
        const correlationId = request.correlationId;
        this.commonLogger.trace("CacheManager - getAccessToken called", correlationId);
        const scopes = ScopeSet.createSearchScopes(request.scopes);
        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
        const credentialType = authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        const accessTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType,
          clientId: this.clientId,
          realm: targetRealm || account.tenantId,
          target: scopes,
          tokenType: authScheme,
          keyId: request.sshKid,
          requestedClaimsHash: request.requestedClaimsHash
        };
        const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;
        const accessTokens = [];
        accessTokenKeys.forEach((key) => {
          if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {
            const accessToken = this.getAccessTokenCredential(key, correlationId);
            if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
              accessTokens.push(accessToken);
            }
          }
        });
        const numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          this.commonLogger.info("CacheManager:getAccessToken - No token found", correlationId);
          return null;
        } else if (numAccessTokens > 1) {
          this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them", correlationId);
          accessTokens.forEach((accessToken) => {
            this.removeAccessToken(this.generateCredentialKey(accessToken), correlationId);
          });
          this.performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
          return null;
        }
        this.commonLogger.info("CacheManager:getAccessToken - Returning access token", correlationId);
        return accessTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       * @param keyMustContainAllScopes
       * @returns
       */
      accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {
        const key = inputKey.toLowerCase();
        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {
          return false;
        }
        if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {
          return false;
        }
        if (filter.target) {
          const scopes = filter.target.asArray();
          for (let i = 0; i < scopes.length; i++) {
            if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {
              return false;
            } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {
              return true;
            }
          }
        }
        return true;
      }
      /**
       * Gets all access tokens matching the filter
       * @param filter
       * @returns
       */
      getAccessTokensByFilter(filter, correlationId) {
        const tokenKeys = this.getTokenKeys();
        const accessTokens = [];
        tokenKeys.accessToken.forEach((key) => {
          if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {
            return;
          }
          const accessToken = this.getAccessTokenCredential(key, correlationId);
          if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {
            accessTokens.push(accessToken);
          }
        });
        return accessTokens;
      }
      /**
       * Helper to retrieve the appropriate refresh token from cache
       * @param account {AccountInfo}
       * @param familyRT {boolean}
       * @param correlationId {?string}
       * @param tokenKeys {?TokenKeys}
       * @param performanceClient {?IPerformanceClient}
       */
      getRefreshToken(account, familyRT, correlationId, tokenKeys, performanceClient) {
        this.commonLogger.trace("CacheManager - getRefreshToken called");
        const id = familyRT ? THE_FAMILY_ID : void 0;
        const refreshTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: CredentialType.REFRESH_TOKEN,
          clientId: this.clientId,
          familyId: id
        };
        const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;
        const refreshTokens = [];
        refreshTokenKeys.forEach((key) => {
          if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {
            const refreshToken = this.getRefreshTokenCredential(key, correlationId);
            if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
              refreshTokens.push(refreshToken);
            }
          }
        });
        const numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
          this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
          return null;
        }
        if (numRefreshTokens > 1 && performanceClient && correlationId) {
          performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
        }
        this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
        return refreshTokens[0];
      }
      /**
       * Validate the cache key against filter before retrieving and parsing cache value
       * @param key
       * @param filter
       */
      refreshTokenKeyMatchesFilter(inputKey, filter) {
        const key = inputKey.toLowerCase();
        if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {
          return false;
        }
        if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
          return false;
        }
        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
          return false;
        }
        return true;
      }
      /**
       * Retrieve AppMetadataEntity from cache
       */
      readAppMetadataFromCache(environment) {
        const appMetadataFilter = {
          environment,
          clientId: this.clientId
        };
        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);
        const numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
          return null;
        } else if (numAppMetadata > 1) {
          throw createClientAuthError(multipleMatchingAppMetadata);
        }
        return appMetadataEntries[0];
      }
      /**
       * Return the family_id value associated  with FOCI
       * @param environment
       * @param clientId
       */
      isAppMetadataFOCI(environment) {
        const appMetadata = this.readAppMetadataFromCache(environment);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
      }
      /**
       * helper to match account ids
       * @param value
       * @param homeAccountId
       */
      matchHomeAccountId(entity, homeAccountId) {
        return !!(typeof entity.homeAccountId === "string" && homeAccountId === entity.homeAccountId);
      }
      /**
       * helper to match account ids
       * @param entity
       * @param localAccountId
       * @returns
       */
      matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
        return localAccountId === idTokenLocalAccountId;
      }
      matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
        return tenantProfile.localAccountId === localAccountId;
      }
      /**
       * helper to match names
       * @param entity
       * @param name
       * @returns true if the downcased name properties are present and match in the filter and the entity
       */
      matchName(claims, name2) {
        return !!(name2.toLowerCase() === claims.name?.toLowerCase());
      }
      /**
       * helper to match usernames
       * @param entity
       * @param username
       * @returns
       */
      matchUsername(cachedUsername, filterUsername) {
        return !!(cachedUsername && typeof cachedUsername === "string" && filterUsername?.toLowerCase() === cachedUsername.toLowerCase());
      }
      /**
       * helper to match assertion
       * @param value
       * @param oboAssertion
       */
      matchUserAssertionHash(entity, userAssertionHash) {
        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
      }
      /**
       * helper to match environment
       * @param value
       * @param environment
       */
      matchEnvironment(entity, environment) {
        if (this.staticAuthorityOptions) {
          const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);
          if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {
            return true;
          }
        }
        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
          return true;
        }
        return false;
      }
      /**
       * helper to match credential type
       * @param entity
       * @param credentialType
       */
      matchCredentialType(entity, credentialType) {
        return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
      }
      /**
       * helper to match client ids
       * @param entity
       * @param clientId
       */
      matchClientId(entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId);
      }
      /**
       * helper to match family ids
       * @param entity
       * @param familyId
       */
      matchFamilyId(entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId);
      }
      /**
       * helper to match realm
       * @param entity
       * @param realm
       */
      matchRealm(entity, realm) {
        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());
      }
      /**
       * helper to match nativeAccountId
       * @param entity
       * @param nativeAccountId
       * @returns boolean indicating the match result
       */
      matchNativeAccountId(entity, nativeAccountId) {
        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
      }
      /**
       * helper to match loginHint which can be either:
       * 1. login_hint ID token claim
       * 2. username in cached account object
       * 3. upn in ID token claims
       * @param entity
       * @param loginHint
       * @returns
       */
      matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
        if (tokenClaims.login_hint === loginHint) {
          return true;
        }
        if (tokenClaims.preferred_username === loginHint) {
          return true;
        }
        if (tokenClaims.upn === loginHint) {
          return true;
        }
        return false;
      }
      /**
       * Helper to match sid
       * @param entity
       * @param sid
       * @returns true if the sid claim is present and matches the filter
       */
      matchSid(idTokenClaims, sid) {
        return idTokenClaims.sid === sid;
      }
      matchAuthorityType(entity, authorityType) {
        return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());
      }
      /**
       * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
       * @param entity
       * @param target
       */
      matchTarget(entity, target) {
        const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        if (isNotAccessTokenCredential || !entity.target) {
          return false;
        }
        const entityScopeSet = ScopeSet.fromString(entity.target);
        return entityScopeSet.containsScopeSet(target);
      }
      /**
       * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
       * @param entity
       * @param tokenType
       */
      matchTokenType(entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType);
      }
      /**
       * Returns true if the credential's keyId matches the one in the request, false otherwise
       * @param entity
       * @param keyId
       */
      matchKeyId(entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId);
      }
      /**
       * returns if a given cache entity is of the type appmetadata
       * @param key
       */
      isAppMetadata(key) {
        return key.indexOf(APP_METADATA) !== -1;
      }
      /**
       * returns if a given cache entity is of the type authoritymetadata
       * @param key
       */
      isAuthorityMetadata(key) {
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
      }
      /**
       * returns cache key used for cloud instance metadata
       */
      generateAuthorityMetadataCacheKey(authority) {
        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
      }
      /**
       * Helper to convert serialized data to object
       * @param obj
       * @param json
       */
      static toObject(obj, json) {
        for (const propertyName in json) {
          obj[propertyName] = json[propertyName];
        }
        return obj;
      }
    };
    var DefaultStorageClass = class extends CacheManager {
      async setAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccount() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getIdTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccessTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      async setRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      getRefreshTokenCredential() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAppMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      setServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      getServerTelemetry() {
        throw createClientAuthError(methodNotImplemented);
      }
      setAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadata() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAuthorityMetadataKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      setThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      getThrottlingCache() {
        throw createClientAuthError(methodNotImplemented);
      }
      removeItem() {
        throw createClientAuthError(methodNotImplemented);
      }
      getKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getAccountKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      getTokenKeys() {
        throw createClientAuthError(methodNotImplemented);
      }
      generateCredentialKey() {
        throw createClientAuthError(methodNotImplemented);
      }
      generateAccountKey() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
    var PerformanceEvents = {
      /**
       * acquireTokenByCode API (msal-browser and msal-node).
       * Used to acquire tokens by trading an authorization code against the token endpoint.
       */
      AcquireTokenByCode: "acquireTokenByCode",
      /**
       * acquireTokenByRefreshToken API (msal-browser and msal-node).
       * Used to renew an access token using a refresh token against the token endpoint.
       */
      AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",
      /**
       * acquireTokenSilent API (msal-browser and msal-node).
       * Used to silently acquire a new access token (from the cache or the network).
       */
      AcquireTokenSilent: "acquireTokenSilent",
      /**
       * acquireTokenSilentAsync (msal-browser).
       * Internal API for acquireTokenSilent.
       */
      AcquireTokenSilentAsync: "acquireTokenSilentAsync",
      /**
       * acquireTokenPopup (msal-browser).
       * Used to acquire a new access token interactively through pop ups
       */
      AcquireTokenPopup: "acquireTokenPopup",
      /**
       * acquireTokenPreRedirect (msal-browser).
       * First part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenPreRedirect: "acquireTokenPreRedirect",
      /**
       * acquireTokenRedirect (msal-browser).
       * Second part of the redirect flow.
       * Used to acquire a new access token interactively through redirects.
       */
      AcquireTokenRedirect: "acquireTokenRedirect",
      /**
       * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
       * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
       */
      CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",
      /**
       * signJwt API in CryptoOpts class (msal-browser).
       * Used to signed a pop token.
       */
      CryptoOptsSignJwt: "cryptoOptsSignJwt",
      /**
       * acquireToken API in the SilentCacheClient class (msal-browser).
       * Used to read access tokens from the cache.
       */
      SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",
      /**
       * acquireToken API in the SilentIframeClient class (msal-browser).
       * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
       */
      SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",
      AwaitConcurrentIframe: "awaitConcurrentIframe",
      /**
       * acquireToken API in SilentRereshClient (msal-browser).
       * Used to acquire a new set of tokens from the token endpoint using a refresh token.
       */
      SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",
      /**
       * ssoSilent API (msal-browser).
       * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
       */
      SsoSilent: "ssoSilent",
      /**
       * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
       * Used to load authority metadata for a request.
       */
      StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",
      /**
       * acquireToken APIs in msal-browser.
       * Used to make an /authorize endpoint call with native brokering enabled.
       */
      FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",
      /**
       * acquireToken API in NativeInteractionClient class (msal-browser).
       * Used to acquire a token from Native component when native brokering is enabled.
       */
      NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",
      /**
       * Time spent creating default headers for requests to token endpoint
       */
      BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",
      /**
       * Time spent sending/waiting for the response of a request to the token endpoint
       */
      NetworkClientSendPostRequestAsync: "networkClientSendPostRequestAsync",
      RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",
      AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",
      /**
       * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
       */
      BrokerHandhshake: "brokerHandshake",
      /**
       * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
       */
      AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",
      /**
       * Time taken for token acquisition by broker
       */
      AcquireTokenByBroker: "acquireTokenByBroker",
      /**
       * Time spent on the network for refresh token acquisition
       */
      RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",
      /**
       * Time taken for acquiring refresh token , records RT size
       */
      RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",
      /**
       * Time taken for acquiring cached refresh token
       */
      RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",
      /**
       * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",
      /**
       * Helper function to create token request body in RefreshTokenClient (msal-common).
       */
      RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",
      /**
       * acquireTokenFromCache (msal-browser).
       * Internal API for acquiring token from cache
       */
      AcquireTokenFromCache: "acquireTokenFromCache",
      SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",
      SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",
      /**
       * acquireTokenBySilentIframe (msal-browser).
       * Internal API for acquiring token by silent Iframe
       */
      AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",
      /**
       * Internal API for initializing base request in BaseInteractionClient (msal-browser)
       */
      InitializeBaseRequest: "initializeBaseRequest",
      /**
       * Internal API for initializing silent request in SilentCacheClient (msal-browser)
       */
      InitializeSilentRequest: "initializeSilentRequest",
      InitializeClientApplication: "initializeClientApplication",
      InitializeCache: "initializeCache",
      /**
       * Helper function in SilentIframeClient class (msal-browser).
       */
      SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",
      /**
       * SilentHandler
       */
      SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",
      SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",
      SilentHandlerLoadFrame: "silentHandlerLoadFrame",
      SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",
      /**
       * Helper functions in StandardInteractionClient class (msal-browser)
       */
      StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",
      StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",
      StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",
      /**
       * getAuthCodeUrl API (msal-browser and msal-node).
       */
      GetAuthCodeUrl: "getAuthCodeUrl",
      GetStandardParams: "getStandardParams",
      /**
       * Functions from InteractionHandler (msal-browser)
       */
      HandleCodeResponseFromServer: "handleCodeResponseFromServer",
      HandleCodeResponse: "handleCodeResponse",
      HandleResponseEar: "handleResponseEar",
      HandleResponsePlatformBroker: "handleResponsePlatformBroker",
      HandleResponseCode: "handleResponseCode",
      UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",
      /**
       * APIs in Authorization Code Client (msal-common)
       */
      AuthClientAcquireToken: "authClientAcquireToken",
      AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",
      AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",
      /**
       * Generate functions in PopTokenGenerator (msal-common)
       */
      PopTokenGenerateCnf: "popTokenGenerateCnf",
      PopTokenGenerateKid: "popTokenGenerateKid",
      /**
       * handleServerTokenResponse API in ResponseHandler (msal-common)
       */
      HandleServerTokenResponse: "handleServerTokenResponse",
      DeserializeResponse: "deserializeResponse",
      /**
       * Authority functions
       */
      AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",
      AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",
      AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",
      AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",
      AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",
      AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",
      AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",
      AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",
      /**
       * Region Discovery functions
       */
      RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",
      RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",
      RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",
      AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",
      GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",
      GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",
      HandleRedirectPromiseMeasurement: "handleRedirectPromise",
      HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",
      UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",
      UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",
      NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",
      NativeGenerateAuthResult: "nativeGenerateAuthResult",
      RemoveHiddenIframe: "removeHiddenIframe",
      /**
       * Cache operations
       */
      ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",
      CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",
      ImportExistingCache: "importExistingCache",
      SetUserData: "setUserData",
      LocalStorageUpdated: "localStorageUpdated",
      /**
       * Crypto Operations
       */
      GeneratePkceCodes: "generatePkceCodes",
      GenerateCodeVerifier: "generateCodeVerifier",
      GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",
      Sha256Digest: "sha256Digest",
      GetRandomValues: "getRandomValues",
      GenerateHKDF: "generateHKDF",
      GenerateBaseKey: "generateBaseKey",
      Base64Decode: "base64Decode",
      UrlEncodeArr: "urlEncodeArr",
      Encrypt: "encrypt",
      Decrypt: "decrypt",
      GenerateEarKey: "generateEarKey",
      DecryptEarResponse: "decryptEarResponse",
      LoadExternalTokens: "LoadExternalTokens",
      LoadAccount: "loadAccount",
      LoadIdToken: "loadIdToken",
      LoadAccessToken: "loadAccessToken",
      LoadRefreshToken: "loadRefreshToken",
      /**
       * SSO capability verification call (msal-browser).
       * Fire-and-forget SSO verification call made after interactive authentication completes.
       */
      SsoCapable: "ssoCapable"
    };
    var PerformanceEventStatus = {
      InProgress: 1
    };
    var StubPerformanceMeasurement = class {
      startMeasurement() {
        return;
      }
      endMeasurement() {
        return;
      }
      flushMeasurement() {
        return null;
      }
    };
    var StubPerformanceClient = class {
      generateId() {
        return "callback-id";
      }
      startMeasurement(measureName, correlationId) {
        return {
          end: () => null,
          discard: () => {
          },
          add: () => {
          },
          increment: () => {
          },
          event: {
            eventId: this.generateId(),
            status: PerformanceEventStatus.InProgress,
            authority: "",
            libraryName: "",
            libraryVersion: "",
            clientId: "",
            name: measureName,
            startTimeMs: Date.now(),
            correlationId: correlationId || ""
          },
          measurement: new StubPerformanceMeasurement()
        };
      }
      startPerformanceMeasurement() {
        return new StubPerformanceMeasurement();
      }
      calculateQueuedTime() {
        return 0;
      }
      addQueueMeasurement() {
        return;
      }
      setPreQueueTime() {
        return;
      }
      endMeasurement() {
        return null;
      }
      discardMeasurements() {
        return;
      }
      removePerformanceCallback() {
        return true;
      }
      addPerformanceCallback() {
        return "";
      }
      emitEvents() {
        return;
      }
      addFields() {
        return;
      }
      incrementFields() {
        return;
      }
      cacheEventByCorrelationId() {
        return;
      }
    };
    var DEFAULT_SYSTEM_OPTIONS$1 = {
      tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
      preventCorsPreflight: false
    };
    var DEFAULT_LOGGER_IMPLEMENTATION = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: exports2.LogLevel.Info,
      correlationId: Constants$1.EMPTY_STRING
    };
    var DEFAULT_CACHE_OPTIONS$1 = {
      claimsBasedCachingEnabled: false
    };
    var DEFAULT_NETWORK_IMPLEMENTATION = {
      async sendGetRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      },
      async sendPostRequestAsync() {
        throw createClientAuthError(methodNotImplemented);
      }
    };
    var DEFAULT_LIBRARY_INFO = {
      sku: Constants$1.SKU,
      version: version$1,
      cpu: Constants$1.EMPTY_STRING,
      os: Constants$1.EMPTY_STRING
    };
    var DEFAULT_CLIENT_CREDENTIALS = {
      clientSecret: Constants$1.EMPTY_STRING,
      clientAssertion: void 0
    };
    var DEFAULT_AZURE_CLOUD_OPTIONS = {
      azureCloudInstance: AzureCloudInstance.None,
      tenant: `${Constants$1.DEFAULT_COMMON_TENANT}`
    };
    var DEFAULT_TELEMETRY_OPTIONS$1 = {
      application: {
        appName: "",
        appVersion: ""
      }
    };
    function buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials, libraryInfo, telemetry, serverTelemetryManager, persistencePlugin, serializableCache }) {
      const loggerOptions = {
        ...DEFAULT_LOGGER_IMPLEMENTATION,
        ...userLoggerOption
      };
      return {
        authOptions: buildAuthOptions(userAuthOptions),
        systemOptions: { ...DEFAULT_SYSTEM_OPTIONS$1, ...userSystemOptions },
        loggerOptions,
        cacheOptions: { ...DEFAULT_CACHE_OPTIONS$1, ...userCacheOptions },
        storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions), new StubPerformanceClient()),
        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
        cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
        clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
        libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS$1, ...telemetry },
        serverTelemetryManager: serverTelemetryManager || null,
        persistencePlugin: persistencePlugin || null,
        serializableCache: serializableCache || null
      };
    }
    function buildAuthOptions(authOptions) {
      return {
        clientCapabilities: [],
        azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
        skipAuthorityMetadataCache: false,
        instanceAware: false,
        encodeExtraQueryParams: false,
        ...authOptions
      };
    }
    function isOidcProtocolMode(config) {
      return config.authOptions.authority.options.protocolMode === ProtocolMode.OIDC;
    }
    var CcsCredentialType = {
      HOME_ACCOUNT_ID: "home_account_id",
      UPN: "UPN"
    };
    var CLIENT_ID = "client_id";
    var REDIRECT_URI = "redirect_uri";
    var RESPONSE_TYPE = "response_type";
    var RESPONSE_MODE = "response_mode";
    var GRANT_TYPE = "grant_type";
    var CLAIMS = "claims";
    var SCOPE = "scope";
    var REFRESH_TOKEN = "refresh_token";
    var STATE = "state";
    var NONCE = "nonce";
    var PROMPT = "prompt";
    var CODE = "code";
    var CODE_CHALLENGE = "code_challenge";
    var CODE_CHALLENGE_METHOD = "code_challenge_method";
    var CODE_VERIFIER = "code_verifier";
    var CLIENT_REQUEST_ID = "client-request-id";
    var X_CLIENT_SKU = "x-client-SKU";
    var X_CLIENT_VER = "x-client-VER";
    var X_CLIENT_OS = "x-client-OS";
    var X_CLIENT_CPU = "x-client-CPU";
    var X_CLIENT_CURR_TELEM = "x-client-current-telemetry";
    var X_CLIENT_LAST_TELEM = "x-client-last-telemetry";
    var X_MS_LIB_CAPABILITY = "x-ms-lib-capability";
    var X_APP_NAME = "x-app-name";
    var X_APP_VER = "x-app-ver";
    var POST_LOGOUT_URI = "post_logout_redirect_uri";
    var ID_TOKEN_HINT = "id_token_hint";
    var DEVICE_CODE = "device_code";
    var CLIENT_SECRET = "client_secret";
    var CLIENT_ASSERTION = "client_assertion";
    var CLIENT_ASSERTION_TYPE = "client_assertion_type";
    var TOKEN_TYPE = "token_type";
    var REQ_CNF = "req_cnf";
    var OBO_ASSERTION = "assertion";
    var REQUESTED_TOKEN_USE = "requested_token_use";
    var ON_BEHALF_OF = "on_behalf_of";
    var RETURN_SPA_CODE = "return_spa_code";
    var LOGOUT_HINT = "logout_hint";
    var SID = "sid";
    var LOGIN_HINT = "login_hint";
    var DOMAIN_HINT = "domain_hint";
    var X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";
    var BROKER_CLIENT_ID = "brk_client_id";
    var BROKER_REDIRECT_URI = "brk_redirect_uri";
    var INSTANCE_AWARE = "instance_aware";
    function instrumentBrokerParams(parameters, correlationId, performanceClient) {
      if (!correlationId) {
        return;
      }
      const clientId = parameters.get(CLIENT_ID);
      if (clientId && parameters.has(BROKER_CLIENT_ID)) {
        performanceClient?.addFields({
          embeddedClientId: clientId,
          embeddedRedirectUri: parameters.get(REDIRECT_URI)
        }, correlationId);
      }
    }
    function addResponseType(parameters, responseType) {
      parameters.set(RESPONSE_TYPE, responseType);
    }
    function addResponseMode(parameters, responseMode) {
      parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);
    }
    function addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
      if (addOidcScopes && !defaultScopes.includes("openid") && !scopes.includes("openid")) {
        defaultScopes.push("openid");
      }
      const requestScopes = addOidcScopes ? [...scopes || [], ...defaultScopes] : scopes || [];
      const scopeSet = new ScopeSet(requestScopes);
      parameters.set(SCOPE, scopeSet.printScopes());
    }
    function addClientId(parameters, clientId) {
      parameters.set(CLIENT_ID, clientId);
    }
    function addRedirectUri(parameters, redirectUri) {
      parameters.set(REDIRECT_URI, redirectUri);
    }
    function addPostLogoutRedirectUri(parameters, redirectUri) {
      parameters.set(POST_LOGOUT_URI, redirectUri);
    }
    function addIdTokenHint(parameters, idTokenHint) {
      parameters.set(ID_TOKEN_HINT, idTokenHint);
    }
    function addDomainHint(parameters, domainHint) {
      parameters.set(DOMAIN_HINT, domainHint);
    }
    function addLoginHint(parameters, loginHint) {
      parameters.set(LOGIN_HINT, loginHint);
    }
    function addCcsUpn(parameters, loginHint) {
      parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);
    }
    function addCcsOid(parameters, clientInfo) {
      parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);
    }
    function addSid(parameters, sid) {
      parameters.set(SID, sid);
    }
    function addClaims(parameters, claims, clientCapabilities) {
      const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);
      try {
        JSON.parse(mergedClaims);
      } catch (e) {
        throw createClientConfigurationError(invalidClaims);
      }
      parameters.set(CLAIMS, mergedClaims);
    }
    function addCorrelationId(parameters, correlationId) {
      parameters.set(CLIENT_REQUEST_ID, correlationId);
    }
    function addLibraryInfo(parameters, libraryInfo) {
      parameters.set(X_CLIENT_SKU, libraryInfo.sku);
      parameters.set(X_CLIENT_VER, libraryInfo.version);
      if (libraryInfo.os) {
        parameters.set(X_CLIENT_OS, libraryInfo.os);
      }
      if (libraryInfo.cpu) {
        parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
      }
    }
    function addApplicationTelemetry(parameters, appTelemetry) {
      if (appTelemetry?.appName) {
        parameters.set(X_APP_NAME, appTelemetry.appName);
      }
      if (appTelemetry?.appVersion) {
        parameters.set(X_APP_VER, appTelemetry.appVersion);
      }
    }
    function addPrompt(parameters, prompt) {
      parameters.set(PROMPT, prompt);
    }
    function addState(parameters, state) {
      if (state) {
        parameters.set(STATE, state);
      }
    }
    function addNonce(parameters, nonce) {
      parameters.set(NONCE, nonce);
    }
    function addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {
      if (codeChallenge && codeChallengeMethod) {
        parameters.set(CODE_CHALLENGE, codeChallenge);
        parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);
      } else {
        throw createClientConfigurationError(pkceParamsMissing);
      }
    }
    function addAuthorizationCode(parameters, code) {
      parameters.set(CODE, code);
    }
    function addDeviceCode(parameters, code) {
      parameters.set(DEVICE_CODE, code);
    }
    function addRefreshToken(parameters, refreshToken) {
      parameters.set(REFRESH_TOKEN, refreshToken);
    }
    function addCodeVerifier(parameters, codeVerifier) {
      parameters.set(CODE_VERIFIER, codeVerifier);
    }
    function addClientSecret(parameters, clientSecret) {
      parameters.set(CLIENT_SECRET, clientSecret);
    }
    function addClientAssertion(parameters, clientAssertion) {
      if (clientAssertion) {
        parameters.set(CLIENT_ASSERTION, clientAssertion);
      }
    }
    function addClientAssertionType(parameters, clientAssertionType) {
      if (clientAssertionType) {
        parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);
      }
    }
    function addOboAssertion(parameters, oboAssertion) {
      parameters.set(OBO_ASSERTION, oboAssertion);
    }
    function addRequestTokenUse(parameters, tokenUse) {
      parameters.set(REQUESTED_TOKEN_USE, tokenUse);
    }
    function addGrantType(parameters, grantType) {
      parameters.set(GRANT_TYPE, grantType);
    }
    function addClientInfo(parameters) {
      parameters.set(CLIENT_INFO, "1");
    }
    function addInstanceAware(parameters) {
      if (!parameters.has(INSTANCE_AWARE)) {
        parameters.set(INSTANCE_AWARE, "true");
      }
    }
    function addExtraQueryParameters(parameters, eQParams) {
      Object.entries(eQParams).forEach(([key, value]) => {
        if (!parameters.has(key) && value) {
          parameters.set(key, value);
        }
      });
    }
    function addClientCapabilitiesToClaims(claims, clientCapabilities) {
      let mergedClaims;
      if (!claims) {
        mergedClaims = {};
      } else {
        try {
          mergedClaims = JSON.parse(claims);
        } catch (e) {
          throw createClientConfigurationError(invalidClaims);
        }
      }
      if (clientCapabilities && clientCapabilities.length > 0) {
        if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
          mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
        }
        mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
          values: clientCapabilities
        };
      }
      return JSON.stringify(mergedClaims);
    }
    function addUsername(parameters, username) {
      parameters.set(PasswordGrantConstants.username, username);
    }
    function addPassword(parameters, password) {
      parameters.set(PasswordGrantConstants.password, password);
    }
    function addPopToken(parameters, cnfString) {
      if (cnfString) {
        parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
        parameters.set(REQ_CNF, cnfString);
      }
    }
    function addSshJwk(parameters, sshJwkString) {
      if (sshJwkString) {
        parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
        parameters.set(REQ_CNF, sshJwkString);
      }
    }
    function addServerTelemetry(parameters, serverTelemetryManager) {
      parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
      parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
    }
    function addThrottling(parameters) {
      parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
    }
    function addLogoutHint(parameters, logoutHint) {
      parameters.set(LOGOUT_HINT, logoutHint);
    }
    function addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {
      if (!parameters.has(BROKER_CLIENT_ID)) {
        parameters.set(BROKER_CLIENT_ID, brokerClientId);
      }
      if (!parameters.has(BROKER_REDIRECT_URI)) {
        parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);
      }
    }
    function isOpenIdConfigResponse(response) {
      return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
    }
    function isCloudInstanceDiscoveryResponse(response) {
      return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
    }
    function isCloudInstanceDiscoveryErrorResponse(response) {
      return response.hasOwnProperty("error") && response.hasOwnProperty("error_description");
    }
    var invoke = (callback, eventName, logger, telemetryClient, correlationId) => {
      return (...args) => {
        logger.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        try {
          const result = callback(...args);
          inProgressEvent?.end({
            success: true
          });
          logger.trace(`Returning result from ${eventName}`);
          return result;
        } catch (e) {
          logger.trace(`Error occurred in ${eventName}`);
          try {
            logger.trace(JSON.stringify(e));
          } catch (e2) {
            logger.trace("Unable to print error message.");
          }
          inProgressEvent?.end({
            success: false
          }, e);
          throw e;
        }
      };
    };
    var invokeAsync = (callback, eventName, logger, telemetryClient, correlationId) => {
      return (...args) => {
        logger.trace(`Executing function ${eventName}`);
        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
        if (correlationId) {
          const eventCount = eventName + "CallCount";
          telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
        }
        telemetryClient?.setPreQueueTime(eventName, correlationId);
        return callback(...args).then((response) => {
          logger.trace(`Returning result from ${eventName}`);
          inProgressEvent?.end({
            success: true
          });
          return response;
        }).catch((e) => {
          logger.trace(`Error occurred in ${eventName}`);
          try {
            logger.trace(JSON.stringify(e));
          } catch (e2) {
            logger.trace("Unable to print error message.");
          }
          inProgressEvent?.end({
            success: false
          }, e);
          throw e;
        });
      };
    };
    var RegionDiscovery = class _RegionDiscovery {
      constructor(networkInterface, logger, performanceClient, correlationId) {
        this.networkInterface = networkInterface;
        this.logger = logger;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
      }
      /**
       * Detect the region from the application's environment.
       *
       * @returns Promise<string | null>
       */
      async detectRegion(environmentRegion, regionDiscoveryMetadata) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
        let autodetectedRegionName = environmentRegion;
        if (!autodetectedRegionName) {
          const options = _RegionDiscovery.IMDS_OPTIONS;
          try {
            const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants$1.IMDS_VERSION, options);
            if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {
              autodetectedRegionName = localIMDSVersionResponse.body;
              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
            }
            if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {
              const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);
              if (!currentIMDSVersion) {
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                return null;
              }
              const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);
              if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {
                autodetectedRegionName = currentIMDSVersionResponse.body;
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
              }
            }
          } catch (e) {
            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
            return null;
          }
        } else {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
        }
        if (!autodetectedRegionName) {
          regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
        }
        return autodetectedRegionName || null;
      }
      /**
       * Make the call to the IMDS endpoint
       *
       * @param imdsEndpointUrl
       * @returns Promise<NetworkResponse<string>>
       */
      async getRegionFromIMDS(version3, options) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
        return this.networkInterface.sendGetRequestAsync(`${Constants$1.IMDS_ENDPOINT}?api-version=${version3}&format=text`, options, Constants$1.IMDS_TIMEOUT);
      }
      /**
       * Get the most recent version of the IMDS endpoint available
       *
       * @returns Promise<string | null>
       */
      async getCurrentVersion(options) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(`${Constants$1.IMDS_ENDPOINT}?format=json`, options);
          if (response.status === HttpStatus.BAD_REQUEST && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
            return response.body["newest-versions"][0];
          }
          return null;
        } catch (e) {
          return null;
        }
      }
    };
    RegionDiscovery.IMDS_OPTIONS = {
      headers: {
        Metadata: "true"
      }
    };
    function nowSeconds() {
      return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    }
    function toDateFromSeconds(seconds) {
      if (seconds) {
        return new Date(Number(seconds) * 1e3);
      }
      return /* @__PURE__ */ new Date();
    }
    function isTokenExpired(expiresOn, offset) {
      const expirationSec = Number(expiresOn) || 0;
      const offsetCurrentTimeSec = nowSeconds() + offset;
      return offsetCurrentTimeSec > expirationSec;
    }
    function wasClockTurnedBack(cachedAt) {
      const cachedAtSec = Number(cachedAt);
      return cachedAtSec > nowSeconds();
    }
    function delay(t, value) {
      return new Promise((resolve) => setTimeout(() => resolve(value), t));
    }
    function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
      const idTokenEntity = {
        credentialType: CredentialType.ID_TOKEN,
        homeAccountId,
        environment,
        clientId,
        secret: idToken,
        realm: tenantId,
        lastUpdatedAt: Date.now().toString()
        // Set the last updated time to now
      };
      return idTokenEntity;
    }
    function createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
      const atEntity = {
        homeAccountId,
        credentialType: CredentialType.ACCESS_TOKEN,
        secret: accessToken,
        cachedAt: nowSeconds().toString(),
        expiresOn: expiresOn.toString(),
        extendedExpiresOn: extExpiresOn.toString(),
        environment,
        clientId,
        realm: tenantId,
        target: scopes,
        tokenType: tokenType || AuthenticationScheme.BEARER,
        lastUpdatedAt: Date.now().toString()
        // Set the last updated time to now
      };
      if (userAssertionHash) {
        atEntity.userAssertionHash = userAssertionHash;
      }
      if (refreshOn) {
        atEntity.refreshOn = refreshOn.toString();
      }
      if (requestedClaims) {
        atEntity.requestedClaims = requestedClaims;
        atEntity.requestedClaimsHash = requestedClaimsHash;
      }
      if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {
        atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        switch (atEntity.tokenType) {
          case AuthenticationScheme.POP:
            const tokenClaims = extractTokenClaims(accessToken, base64Decode);
            if (!tokenClaims?.cnf?.kid) {
              throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
            }
            atEntity.keyId = tokenClaims.cnf.kid;
            break;
          case AuthenticationScheme.SSH:
            atEntity.keyId = keyId;
        }
      }
      return atEntity;
    }
    function createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {
      const rtEntity = {
        credentialType: CredentialType.REFRESH_TOKEN,
        homeAccountId,
        environment,
        clientId,
        secret: refreshToken,
        lastUpdatedAt: Date.now().toString()
      };
      if (userAssertionHash) {
        rtEntity.userAssertionHash = userAssertionHash;
      }
      if (familyId) {
        rtEntity.familyId = familyId;
      }
      if (expiresOn) {
        rtEntity.expiresOn = expiresOn.toString();
      }
      return rtEntity;
    }
    function isCredentialEntity(entity) {
      return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret");
    }
    function isAccessTokenEntity(entity) {
      if (!entity) {
        return false;
      }
      return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
    }
    function isIdTokenEntity(entity) {
      if (!entity) {
        return false;
      }
      return isCredentialEntity(entity) && entity.hasOwnProperty("realm") && entity["credentialType"] === CredentialType.ID_TOKEN;
    }
    function isRefreshTokenEntity(entity) {
      if (!entity) {
        return false;
      }
      return isCredentialEntity(entity) && entity["credentialType"] === CredentialType.REFRESH_TOKEN;
    }
    function isServerTelemetryEntity(key, entity) {
      const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
      let validateEntity = true;
      if (entity) {
        validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
      }
      return validateKey && validateEntity;
    }
    function isThrottlingEntity(key, entity) {
      let validateKey = false;
      if (key) {
        validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
      }
      let validateEntity = true;
      if (entity) {
        validateEntity = entity.hasOwnProperty("throttleTime");
      }
      return validateKey && validateEntity;
    }
    function generateAppMetadataKey({ environment, clientId }) {
      const appMetaDataKeyArray = [
        APP_METADATA,
        environment,
        clientId
      ];
      return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
    }
    function isAppMetadataEntity(key, entity) {
      if (!entity) {
        return false;
      }
      return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
    }
    function isAuthorityMetadataEntity(key, entity) {
      if (!entity) {
        return false;
      }
      return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
    }
    function generateAuthorityMetadataExpiresAt() {
      return nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
    }
    function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
      authorityMetadata.authorization_endpoint = updatedValues.authorization_endpoint;
      authorityMetadata.token_endpoint = updatedValues.token_endpoint;
      authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
      authorityMetadata.issuer = updatedValues.issuer;
      authorityMetadata.endpointsFromNetwork = fromNetwork;
      authorityMetadata.jwks_uri = updatedValues.jwks_uri;
    }
    function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
      authorityMetadata.aliases = updatedValues.aliases;
      authorityMetadata.preferred_cache = updatedValues.preferred_cache;
      authorityMetadata.preferred_network = updatedValues.preferred_network;
      authorityMetadata.aliasesFromNetwork = fromNetwork;
    }
    function isAuthorityMetadataExpired(metadata) {
      return metadata.expiresAt <= nowSeconds();
    }
    var Authority = class _Authority {
      constructor(authority, networkInterface, cacheManager, authorityOptions, logger, correlationId, performanceClient, managedIdentity) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscoveryMetadata = {
          region_used: void 0,
          region_source: void 0,
          region_outcome: void 0
        };
        this.logger = logger;
        this.performanceClient = performanceClient;
        this.correlationId = correlationId;
        this.managedIdentity = managedIdentity || false;
        this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);
      }
      /**
       * Get {@link AuthorityType}
       * @param authorityUri {@link IUri}
       * @private
       */
      getAuthorityType(authorityUri) {
        if (authorityUri.HostNameAndPort.endsWith(Constants$1.CIAM_AUTH_URL)) {
          return AuthorityType.Ciam;
        }
        const pathSegments = authorityUri.PathSegments;
        if (pathSegments.length) {
          switch (pathSegments[0].toLowerCase()) {
            case Constants$1.ADFS:
              return AuthorityType.Adfs;
            case Constants$1.DSTS:
              return AuthorityType.Dsts;
          }
        }
        return AuthorityType.Default;
      }
      // See above for AuthorityType
      get authorityType() {
        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
      }
      /**
       * ProtocolMode enum representing the way endpoints are constructed.
       */
      get protocolMode() {
        return this.authorityOptions.protocolMode;
      }
      /**
       * Returns authorityOptions which can be used to reinstantiate a new authority instance
       */
      get options() {
        return this.authorityOptions;
      }
      /**
       * A URL that is the authority set by the developer
       */
      get canonicalAuthority() {
        return this._canonicalAuthority.urlString;
      }
      /**
       * Sets canonical authority.
       */
      set canonicalAuthority(url) {
        this._canonicalAuthority = new UrlString(url);
        this._canonicalAuthority.validateAsUri();
        this._canonicalAuthorityUrlComponents = null;
      }
      /**
       * Get authority components.
       */
      get canonicalAuthorityUrlComponents() {
        if (!this._canonicalAuthorityUrlComponents) {
          this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
        }
        return this._canonicalAuthorityUrlComponents;
      }
      /**
       * Get hostname and port i.e. login.microsoftonline.com
       */
      get hostnameAndPort() {
        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
      }
      /**
       * Get tenant for authority.
       */
      get tenant() {
        return this.canonicalAuthorityUrlComponents.PathSegments[0];
      }
      /**
       * OAuth /authorize endpoint for requests
       */
      get authorizationEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.authorization_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth /token endpoint for requests
       */
      get tokenEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      get deviceCodeEndpoint() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth logout endpoint for requests
       */
      get endSessionEndpoint() {
        if (this.discoveryComplete()) {
          if (!this.metadata.end_session_endpoint) {
            throw createClientAuthError(endSessionEndpointNotSupported);
          }
          return this.replacePath(this.metadata.end_session_endpoint);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * OAuth issuer for requests
       */
      get selfSignedJwtAudience() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.issuer);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Jwks_uri for token signing keys
       */
      get jwksUri() {
        if (this.discoveryComplete()) {
          return this.replacePath(this.metadata.jwks_uri);
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
       * @param authorityUri {@link IUri}
       * @private
       */
      canReplaceTenant(authorityUri) {
        return authorityUri.PathSegments.length === 1 && !_Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) && this.getAuthorityType(authorityUri) === AuthorityType.Default && this.protocolMode !== ProtocolMode.OIDC;
      }
      /**
       * Replaces tenant in url path with current tenant. Defaults to common.
       * @param urlString
       */
      replaceTenant(urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
      }
      /**
       * Replaces path such as tenant or policy with the current tenant or policy.
       * @param urlString
       */
      replacePath(urlString) {
        let endpoint = urlString;
        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach((currentPart, index) => {
          let cachedPart = cachedAuthorityParts[index];
          if (index === 0 && this.canReplaceTenant(cachedAuthorityUrlComponents)) {
            const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
            if (cachedPart !== tenantId) {
              this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
              cachedPart = tenantId;
            }
          }
          if (currentPart !== cachedPart) {
            endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
          }
        });
        return this.replaceTenant(endpoint);
      }
      /**
       * The default open id configuration endpoint for any canonical authority.
       */
      get defaultOpenIdConfigurationEndpoint() {
        const canonicalAuthorityHost = this.hostnameAndPort;
        if (this.canonicalAuthority.endsWith("v2.0/") || this.authorityType === AuthorityType.Adfs || this.protocolMode === ProtocolMode.OIDC && !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost)) {
          return `${this.canonicalAuthority}.well-known/openid-configuration`;
        }
        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
      }
      /**
       * Boolean that returns whether or not tenant discovery has been completed.
       */
      discoveryComplete() {
        return !!this.metadata;
      }
      /**
       * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
       * and the /authorize, /token and logout endpoints.
       */
      async resolveEndpointsAsync() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
        const metadataEntity = this.getCurrentMetadataEntity();
        const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
        const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
          source: endpointSource
        });
        this.performanceClient?.addFields({
          cloudDiscoverySource,
          authorityEndpointSource: endpointSource
        }, this.correlationId);
      }
      /**
       * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
       * from the configured canonical authority
       * @returns
       */
      getCurrentMetadataEntity() {
        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
        if (!metadataEntity) {
          metadataEntity = {
            aliases: [],
            preferred_cache: this.hostnameAndPort,
            preferred_network: this.hostnameAndPort,
            canonical_authority: this.canonicalAuthority,
            authorization_endpoint: "",
            token_endpoint: "",
            end_session_endpoint: "",
            issuer: "",
            aliasesFromNetwork: false,
            endpointsFromNetwork: false,
            expiresAt: generateAuthorityMetadataExpiresAt(),
            jwks_uri: ""
          };
        }
        return metadataEntity;
      }
      /**
       * Updates cached metadata based on metadata source and sets the instance's metadata
       * property to the same value
       * @param metadataEntity
       * @param cloudDiscoverySource
       * @param endpointMetadataResult
       */
      updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE) {
          metadataEntity.expiresAt = generateAuthorityMetadataExpiresAt();
          metadataEntity.canonical_authority = this.canonicalAuthority;
        }
        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
        this.metadata = metadataEntity;
      }
      /**
       * Update AuthorityMetadataEntity with new endpoints and return where the information came from
       * @param metadataEntity
       */
      async updateEndpointMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
        const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
        if (localMetadata) {
          if (localMetadata.source === AuthorityMetadataSource.HARDCODED_VALUES) {
            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
              if (localMetadata.metadata) {
                const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);
                updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
                metadataEntity.canonical_authority = this.canonicalAuthority;
              }
            }
          }
          return localMetadata.source;
        }
        let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
            metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);
          }
          updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        } else {
          throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
        }
      }
      /**
       * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
       * response if the source is hardcoded metadata
       * @param metadataEntity
       * @returns
       */
      updateEndpointMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get endpoint metadata from authority configuration");
        const configMetadata = this.getEndpointMetadataFromConfig();
        if (configMetadata) {
          this.logger.verbose("Found endpoint metadata in authority configuration");
          updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
          return {
            source: AuthorityMetadataSource.CONFIG
          };
        }
        this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");
        if (this.authorityOptions.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
          if (hardcodedMetadata) {
            updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
            return {
              source: AuthorityMetadataSource.HARDCODED_VALUES,
              metadata: hardcodedMetadata
            };
          } else {
            this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");
          }
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found endpoint metadata in the cache.");
          return { source: AuthorityMetadataSource.CACHE };
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Compares the number of url components after the domain to determine if the cached
       * authority metadata can be used for the requested authority. Protects against same domain different
       * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
       * @param metadataEntity
       */
      isAuthoritySameType(metadataEntity) {
        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
      }
      /**
       * Parse authorityMetadata config option
       */
      getEndpointMetadataFromConfig() {
        if (this.authorityOptions.authorityMetadata) {
          try {
            return JSON.parse(this.authorityOptions.authorityMetadata);
          } catch (e) {
            throw createClientConfigurationError(invalidAuthorityMetadata);
          }
        }
        return null;
      }
      /**
       * Gets OAuth endpoints from the given OpenID configuration endpoint.
       *
       * @param hasHardcodedMetadata boolean
       */
      async getEndpointMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
        const options = {};
        const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);
        try {
          const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);
          const isValidResponse = isOpenIdConfigResponse(response.body);
          if (isValidResponse) {
            return response.body;
          } else {
            this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);
            return null;
          }
        } catch (e) {
          this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
          return null;
        }
      }
      /**
       * Get OAuth endpoints for common authorities.
       */
      getEndpointMetadataFromHardcodedValues() {
        if (this.hostnameAndPort in EndpointMetadata) {
          return EndpointMetadata[this.hostnameAndPort];
        }
        return null;
      }
      /**
       * Update the retrieved metadata with regional information.
       * User selected Azure region will be used if configured.
       */
      async updateMetadataWithRegionalInformation(metadata) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
        const userConfiguredAzureRegion = this.authorityOptions.azureRegionConfiguration?.azureRegion;
        if (userConfiguredAzureRegion) {
          if (userConfiguredAzureRegion !== Constants$1.AZURE_REGION_AUTO_DISCOVER_FLAG) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
            this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
            return _Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
          }
          const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)(this.authorityOptions.azureRegionConfiguration?.environmentRegion, this.regionDiscoveryMetadata);
          if (autodetectedRegionName) {
            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
            this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
            return _Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
          }
          this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
        }
        return metadata;
      }
      /**
       * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
       * and returns where the information was retrieved from
       * @param metadataEntity
       * @returns AuthorityMetadataSource
       */
      async updateCloudDiscoveryMetadata(metadataEntity) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
        const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
        if (localMetadataSource) {
          return localMetadataSource;
        }
        const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
        if (metadata) {
          updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
          return AuthorityMetadataSource.NETWORK;
        }
        throw createClientConfigurationError(untrustedAuthority);
      }
      updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
        this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");
        this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities || Constants$1.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants$1.NOT_APPLICABLE}`);
        this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants$1.NOT_APPLICABLE}`);
        const metadata = this.getCloudDiscoveryMetadataFromConfig();
        if (metadata) {
          this.logger.verbose("Found cloud discovery metadata in authority configuration");
          updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
          return AuthorityMetadataSource.CONFIG;
        }
        this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");
        if (this.options.skipAuthorityMetadataCache) {
          this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");
        } else {
          const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);
          if (hardcodedMetadata) {
            this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
            updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
            return AuthorityMetadataSource.HARDCODED_VALUES;
          }
          this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");
        }
        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {
          this.logger.verbose("Found cloud discovery metadata in the cache.");
          return AuthorityMetadataSource.CACHE;
        } else if (metadataEntityExpired) {
          this.logger.verbose("The metadata entity is expired.");
        }
        return null;
      }
      /**
       * Parse cloudDiscoveryMetadata config or check knownAuthorities
       */
      getCloudDiscoveryMetadataFromConfig() {
        if (this.authorityType === AuthorityType.Ciam) {
          this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        if (this.authorityOptions.cloudDiscoveryMetadata) {
          this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
          try {
            this.logger.verbose("Attempting to parse the cloud discovery metadata.");
            const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
            const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
            this.logger.verbose("Parsed the cloud discovery metadata.");
            if (metadata) {
              this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
              return metadata;
            } else {
              this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
            }
          } catch (e) {
            this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
            throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
          }
        }
        if (this.isInKnownAuthorities()) {
          this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
          return _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return null;
      }
      /**
       * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
       *
       * @param hasHardcodedMetadata boolean
       */
      async getCloudDiscoveryMetadataFromNetwork() {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
        const instanceDiscoveryEndpoint = `${Constants$1.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
        const options = {};
        let match = null;
        try {
          const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);
          let typedResponseBody;
          let metadata;
          if (isCloudInstanceDiscoveryResponse(response.body)) {
            typedResponseBody = response.body;
            metadata = typedResponseBody.metadata;
            this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);
          } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
            this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);
            typedResponseBody = response.body;
            if (typedResponseBody.error === Constants$1.INVALID_INSTANCE) {
              this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
              return null;
            }
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);
            this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);
            this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
            metadata = [];
          } else {
            this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
            return null;
          }
          this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
          match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
        } catch (error) {
          if (error instanceof AuthError) {
            this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.
Error: ${error.errorCode}
Error Description: ${error.errorMessage}`);
          } else {
            const typedError = error;
            this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.
Error: ${typedError.name}
Error Description: ${typedError.message}`);
          }
          return null;
        }
        if (!match) {
          this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
          this.logger.verbose("Creating custom Authority for custom domain scenario.");
          match = _Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return match;
      }
      /**
       * Helper function to determine if this host is included in the knownAuthorities config option
       */
      isInKnownAuthorities() {
        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {
          return authority && UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;
        });
        return matches.length > 0;
      }
      /**
       * helper function to populate the authority based on azureCloudOptions
       * @param authorityString
       * @param azureCloudOptions
       */
      static generateAuthority(authorityString, azureCloudOptions) {
        let authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
          const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants$1.DEFAULT_COMMON_TENANT;
          authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
      }
      /**
       * Creates cloud discovery metadata object from a given host
       * @param host
       */
      static createCloudDiscoveryMetadataFromHost(host) {
        return {
          preferred_network: host,
          preferred_cache: host,
          aliases: [host]
        };
      }
      /**
       * helper function to generate environment from authority object
       */
      getPreferredCache() {
        if (this.managedIdentity) {
          return Constants$1.DEFAULT_AUTHORITY_HOST;
        } else if (this.discoveryComplete()) {
          return this.metadata.preferred_cache;
        } else {
          throw createClientAuthError(endpointResolutionError);
        }
      }
      /**
       * Returns whether or not the provided host is an alias of this authority instance
       * @param host
       */
      isAlias(host) {
        return this.metadata.aliases.indexOf(host) > -1;
      }
      /**
       * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
       * @param host
       */
      isAliasOfKnownMicrosoftAuthority(host) {
        return InstanceDiscoveryMetadataAliases.has(host);
      }
      /**
       * Checks whether the provided host is that of a public cloud authority
       *
       * @param authority string
       * @returns bool
       */
      static isPublicCloudAuthority(host) {
        return Constants$1.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
      }
      /**
       * Rebuild the authority string with the region
       *
       * @param host string
       * @param region string
       */
      static buildRegionalAuthorityString(host, region, queryString) {
        const authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        const authorityUrlParts = authorityUrlInstance.getUrlComponents();
        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
          hostNameAndPort = `${region}.${Constants$1.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
        }
        const url = UrlString.constructAuthorityUriFromObject({
          ...authorityUrlInstance.getUrlComponents(),
          HostNameAndPort: hostNameAndPort
        }).urlString;
        if (queryString)
          return `${url}?${queryString}`;
        return url;
      }
      /**
       * Replace the endpoints in the metadata object with their regional equivalents.
       *
       * @param metadata OpenIdConfigResponse
       * @param azureRegion string
       */
      static replaceWithRegionalInformation(metadata, azureRegion) {
        const regionalMetadata = { ...metadata };
        regionalMetadata.authorization_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);
        regionalMetadata.token_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);
        if (regionalMetadata.end_session_endpoint) {
          regionalMetadata.end_session_endpoint = _Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);
        }
        return regionalMetadata;
      }
      /**
       * Transform CIAM_AUTHORIY as per the below rules:
       * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
       *
       * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
       * `ciamlogin.com` can also change in the future and we should accommodate the same
       *
       * @param authority
       */
      static transformCIAMAuthority(authority) {
        let ciamAuthority = authority;
        const authorityUrl = new UrlString(authority);
        const authorityUrlComponents = authorityUrl.getUrlComponents();
        if (authorityUrlComponents.PathSegments.length === 0 && authorityUrlComponents.HostNameAndPort.endsWith(Constants$1.CIAM_AUTH_URL)) {
          const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
          ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants$1.AAD_TENANT_DOMAIN_SUFFIX}`;
        }
        return ciamAuthority;
      }
    };
    Authority.reservedTenantDomains = /* @__PURE__ */ new Set([
      "{tenant}",
      "{tenantid}",
      AADAuthorityConstants.COMMON,
      AADAuthorityConstants.CONSUMERS,
      AADAuthorityConstants.ORGANIZATIONS
    ]);
    function getTenantFromAuthorityString(authority) {
      const authorityUrl = new UrlString(authority);
      const authorityUrlComponents = authorityUrl.getUrlComponents();
      const tenantId = authorityUrlComponents.PathSegments.slice(-1)[0]?.toLowerCase();
      switch (tenantId) {
        case AADAuthorityConstants.COMMON:
        case AADAuthorityConstants.ORGANIZATIONS:
        case AADAuthorityConstants.CONSUMERS:
          return void 0;
        default:
          return tenantId;
      }
    }
    function formatAuthorityUri(authorityUri) {
      return authorityUri.endsWith(Constants$1.FORWARD_SLASH) ? authorityUri : `${authorityUri}${Constants$1.FORWARD_SLASH}`;
    }
    function buildStaticAuthorityOptions(authOptions) {
      const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
      let cloudDiscoveryMetadata = void 0;
      if (rawCloudDiscoveryMetadata) {
        try {
          cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
        } catch (e) {
          throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
        }
      }
      return {
        canonicalAuthority: authOptions.authority ? formatAuthorityUri(authOptions.authority) : void 0,
        knownAuthorities: authOptions.knownAuthorities,
        cloudDiscoveryMetadata
      };
    }
    async function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient) {
      performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
      const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
      const acquireTokenAuthority = new Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient);
      try {
        await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger, performanceClient, correlationId)();
        return acquireTokenAuthority;
      } catch (e) {
        throw createClientAuthError(endpointResolutionError);
      }
    }
    var ServerError = class _ServerError extends AuthError {
      constructor(errorCode, errorMessage, subError, errorNo, status) {
        super(errorCode, errorMessage, subError);
        this.name = "ServerError";
        this.errorNo = errorNo;
        this.status = status;
        Object.setPrototypeOf(this, _ServerError.prototype);
      }
    };
    function getRequestThumbprint(clientId, request, homeAccountId) {
      return {
        clientId,
        authority: request.authority,
        scopes: request.scopes,
        homeAccountIdentifier: homeAccountId,
        claims: request.claims,
        authenticationScheme: request.authenticationScheme,
        resourceRequestMethod: request.resourceRequestMethod,
        resourceRequestUri: request.resourceRequestUri,
        shrClaims: request.shrClaims,
        sshKid: request.sshKid,
        embeddedClientId: request.embeddedClientId || request.tokenBodyParameters?.clientId
      };
    }
    var ThrottlingUtils = class _ThrottlingUtils {
      /**
       * Prepares a RequestThumbprint to be stored as a key.
       * @param thumbprint
       */
      static generateThrottlingStorageKey(thumbprint) {
        return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
      }
      /**
       * Performs necessary throttling checks before a network request.
       * @param cacheManager
       * @param thumbprint
       */
      static preProcess(cacheManager, thumbprint, correlationId) {
        const key = _ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
        const value = cacheManager.getThrottlingCache(key);
        if (value) {
          if (value.throttleTime < Date.now()) {
            cacheManager.removeItem(key, correlationId);
            return;
          }
          throw new ServerError(value.errorCodes?.join(" ") || Constants$1.EMPTY_STRING, value.errorMessage, value.subError);
        }
      }
      /**
       * Performs necessary throttling checks after a network request.
       * @param cacheManager
       * @param thumbprint
       * @param response
       */
      static postProcess(cacheManager, thumbprint, response, correlationId) {
        if (_ThrottlingUtils.checkResponseStatus(response) || _ThrottlingUtils.checkResponseForRetryAfter(response)) {
          const thumbprintValue = {
            throttleTime: _ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
            error: response.body.error,
            errorCodes: response.body.error_codes,
            errorMessage: response.body.error_description,
            subError: response.body.suberror
          };
          cacheManager.setThrottlingCache(_ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue, correlationId);
        }
      }
      /**
       * Checks a NetworkResponse object's status codes against 429 or 5xx
       * @param response
       */
      static checkResponseStatus(response) {
        return response.status === 429 || response.status >= 500 && response.status < 600;
      }
      /**
       * Checks a NetworkResponse object's RetryAfter header
       * @param response
       */
      static checkResponseForRetryAfter(response) {
        if (response.headers) {
          return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
        }
        return false;
      }
      /**
       * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
       * @param throttleTime
       */
      static calculateThrottleTime(throttleTime) {
        const time = throttleTime <= 0 ? 0 : throttleTime;
        const currentSeconds = Date.now() / 1e3;
        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
      }
      static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {
        const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);
        const key = this.generateThrottlingStorageKey(thumbprint);
        cacheManager.removeItem(key, request.correlationId);
      }
    };
    var NetworkError = class _NetworkError extends AuthError {
      constructor(error, httpStatus, responseHeaders) {
        super(error.errorCode, error.errorMessage, error.subError);
        Object.setPrototypeOf(this, _NetworkError.prototype);
        this.name = "NetworkError";
        this.error = error;
        this.httpStatus = httpStatus;
        this.responseHeaders = responseHeaders;
      }
    };
    var BaseClient = class {
      constructor(configuration, performanceClient) {
        this.config = buildClientConfiguration(configuration);
        this.logger = new Logger(this.config.loggerOptions, name$1, version$1);
        this.cryptoUtils = this.config.cryptoInterface;
        this.cacheManager = this.config.storageInterface;
        this.networkClient = this.config.networkInterface;
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        this.authority = this.config.authOptions.authority;
        this.performanceClient = performanceClient;
      }
      /**
       * Creates default headers for requests to token endpoint
       */
      createTokenRequestHeaders(ccsCred) {
        const headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants$1.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
              break;
          }
        }
        return headers;
      }
      /**
       * Http post to token endpoint
       * @param tokenEndpoint
       * @param queryString
       * @param headers
       * @param thumbprint
       */
      async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {
        if (queuedEvent) {
          this.performanceClient?.addQueueMeasurement(queuedEvent, correlationId);
        }
        const response = await this.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers }, correlationId);
        if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
          this.config.serverTelemetryManager.clearTelemetryCache();
        }
        return response;
      }
      /**
       * Wraps sendPostRequestAsync with necessary preflight and postflight logic
       * @param thumbprint - Request thumbprint for throttling
       * @param tokenEndpoint - Endpoint to make the POST to
       * @param options - Body and Headers to include on the POST request
       * @param correlationId - CorrelationId for telemetry
       */
      async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {
        ThrottlingUtils.preProcess(this.cacheManager, thumbprint, correlationId);
        let response;
        try {
          response = await invokeAsync(this.networkClient.sendPostRequestAsync.bind(this.networkClient), PerformanceEvents.NetworkClientSendPostRequestAsync, this.logger, this.performanceClient, correlationId)(tokenEndpoint, options);
          const responseHeaders = response.headers || {};
          this.performanceClient?.addFields({
            refreshTokenSize: response.body.refresh_token?.length || 0,
            httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
            requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || ""
          }, correlationId);
        } catch (e) {
          if (e instanceof NetworkError) {
            const responseHeaders = e.responseHeaders;
            if (responseHeaders) {
              this.performanceClient?.addFields({
                httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
                requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || "",
                contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] || void 0,
                contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] || void 0,
                httpStatus: e.httpStatus
              }, correlationId);
            }
            throw e.error;
          }
          if (e instanceof AuthError) {
            throw e;
          } else {
            throw createClientAuthError(networkError);
          }
        }
        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response, correlationId);
        return response;
      }
      /**
       * Updates the authority object of the client. Endpoint discovery must be completed.
       * @param updatedAuthority
       */
      async updateAuthority(cloudInstanceHostname, correlationId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);
        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
        const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);
        this.authority = cloudInstanceAuthority;
      }
      /**
       * Creates query string for the /token request
       * @param request
       */
      createTokenQueryParameters(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenQueryParameters) {
          addExtraQueryParameters(parameters, request.tokenQueryParameters);
        }
        addCorrelationId(parameters, request.correlationId);
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
    var noTokensFound = "no_tokens_found";
    var nativeAccountUnavailable = "native_account_unavailable";
    var refreshTokenExpired = "refresh_token_expired";
    var uxNotAllowed = "ux_not_allowed";
    var interactionRequired = "interaction_required";
    var consentRequired = "consent_required";
    var loginRequired = "login_required";
    var badToken = "bad_token";
    var interruptedUser = "interrupted_user";
    var InteractionRequiredAuthErrorCodes = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      badToken,
      consentRequired,
      interactionRequired,
      interruptedUser,
      loginRequired,
      nativeAccountUnavailable,
      noTokensFound,
      refreshTokenExpired,
      uxNotAllowed
    });
    var InteractionRequiredServerErrorMessage = [
      interactionRequired,
      consentRequired,
      loginRequired,
      badToken,
      uxNotAllowed,
      interruptedUser
    ];
    var InteractionRequiredAuthSubErrorMessage = [
      "message_only",
      "additional_action",
      "basic_action",
      "user_password_expired",
      "consent_required",
      "bad_token",
      "interrupted_user"
    ];
    var InteractionRequiredAuthErrorMessages = {
      [noTokensFound]: "No refresh token found in the cache. Please sign-in.",
      [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
      [refreshTokenExpired]: "Refresh token has expired.",
      [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve.",
      [uxNotAllowed]: "`canShowUI` flag in Edge was set to false. User interaction required on web page. Please invoke an interactive API to resolve.",
      [interruptedUser]: "The user could not be authenticated due to an interrupted state. Please invoke an interactive API to resolve."
    };
    var InteractionRequiredAuthErrorMessage = {
      noTokensFoundError: {
        code: noTokensFound,
        desc: InteractionRequiredAuthErrorMessages[noTokensFound]
      },
      native_account_unavailable: {
        code: nativeAccountUnavailable,
        desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable]
      },
      bad_token: {
        code: badToken,
        desc: InteractionRequiredAuthErrorMessages[badToken]
      },
      interrupted_user: {
        code: interruptedUser,
        desc: InteractionRequiredAuthErrorMessages[interruptedUser]
      }
    };
    var InteractionRequiredAuthError = class _InteractionRequiredAuthError extends AuthError {
      constructor(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims, errorNo) {
        super(errorCode, errorMessage, subError);
        Object.setPrototypeOf(this, _InteractionRequiredAuthError.prototype);
        this.timestamp = timestamp || Constants$1.EMPTY_STRING;
        this.traceId = traceId || Constants$1.EMPTY_STRING;
        this.correlationId = correlationId || Constants$1.EMPTY_STRING;
        this.claims = claims || Constants$1.EMPTY_STRING;
        this.name = "InteractionRequiredAuthError";
        this.errorNo = errorNo;
      }
    };
    function isInteractionRequiredError(errorCode, errorString, subError) {
      const isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
      const isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
      const isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some((irErrorCode) => {
        return errorString.indexOf(irErrorCode) > -1;
      });
      return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
    }
    function createInteractionRequiredAuthError(errorCode) {
      return new InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);
    }
    var ProtocolUtils = class _ProtocolUtils {
      /**
       * Appends user state with random guid, or returns random guid.
       * @param userState
       * @param randomGuid
       */
      static setRequestState(cryptoObj, userState, meta) {
        const libraryState = _ProtocolUtils.generateLibraryState(cryptoObj, meta);
        return userState ? `${libraryState}${Constants$1.RESOURCE_DELIM}${userState}` : libraryState;
      }
      /**
       * Generates the state value used by the common library.
       * @param randomGuid
       * @param cryptoObj
       */
      static generateLibraryState(cryptoObj, meta) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        const stateObj = {
          id: cryptoObj.createNewGuid()
        };
        if (meta) {
          stateObj.meta = meta;
        }
        const stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString);
      }
      /**
       * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
       * @param state
       * @param cryptoObj
       */
      static parseRequestState(cryptoObj, state) {
        if (!cryptoObj) {
          throw createClientAuthError(noCryptoObject);
        }
        if (!state) {
          throw createClientAuthError(invalidState);
        }
        try {
          const splitState = state.split(Constants$1.RESOURCE_DELIM);
          const libraryState = splitState[0];
          const userState = splitState.length > 1 ? splitState.slice(1).join(Constants$1.RESOURCE_DELIM) : Constants$1.EMPTY_STRING;
          const libraryStateString = cryptoObj.base64Decode(libraryState);
          const libraryStateObj = JSON.parse(libraryStateString);
          return {
            userRequestState: userState || Constants$1.EMPTY_STRING,
            libraryState: libraryStateObj
          };
        } catch (e) {
          throw createClientAuthError(invalidState);
        }
      }
    };
    var KeyLocation = {
      SW: "sw"
    };
    var PopTokenGenerator = class {
      constructor(cryptoUtils, performanceClient) {
        this.cryptoUtils = cryptoUtils;
        this.performanceClient = performanceClient;
      }
      /**
       * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
       * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
       * @param request
       * @returns
       */
      async generateCnf(request, logger) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
        const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger, this.performanceClient, request.correlationId)(request);
        const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
        return {
          kid: reqCnf.kid,
          reqCnfString
        };
      }
      /**
       * Generates key_id for a SHR token request
       * @param request
       * @returns
       */
      async generateKid(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
        const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);
        return {
          kid: kidThumbprint,
          xms_ksl: KeyLocation.SW
        };
      }
      /**
       * Signs the POP access_token with the local generated key-pair
       * @param accessToken
       * @param request
       * @returns
       */
      async signPopToken(accessToken, keyId, request) {
        return this.signPayload(accessToken, keyId, request);
      }
      /**
       * Utility function to generate the signed JWT for an access_token
       * @param payload
       * @param kid
       * @param request
       * @param claims
       * @returns
       */
      async signPayload(payload, keyId, request, claims) {
        const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions } = request;
        const resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
        const resourceUrlComponents = resourceUrlString?.getUrlComponents();
        return this.cryptoUtils.signJwt({
          at: payload,
          ts: nowSeconds(),
          m: resourceRequestMethod?.toUpperCase(),
          u: resourceUrlComponents?.HostNameAndPort,
          nonce: shrNonce || this.cryptoUtils.createNewGuid(),
          p: resourceUrlComponents?.AbsolutePath,
          q: resourceUrlComponents?.QueryString ? [[], resourceUrlComponents.QueryString] : void 0,
          client_claims: shrClaims || void 0,
          ...claims
        }, keyId, shrOptions, request.correlationId);
      }
    };
    var TokenCacheContext = class {
      constructor(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged;
      }
      /**
       * boolean which indicates the changes in cache
       */
      get cacheHasChanged() {
        return this.hasChanged;
      }
      /**
       * function to retrieve the token cache
       */
      get tokenCache() {
        return this.cache;
      }
    };
    var ResponseHandler = class _ResponseHandler {
      constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin;
        this.performanceClient = performanceClient;
      }
      /**
       * Function which validates server authorization token response.
       * @param serverResponse
       * @param refreshAccessToken
       */
      validateTokenResponse(serverResponse, refreshAccessToken) {
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          const errString = `Error(s): ${serverResponse.error_codes || Constants$1.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants$1.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants$1.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants$1.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants$1.NOT_AVAILABLE}`;
          const serverErrorNo = serverResponse.error_codes?.length ? serverResponse.error_codes[0] : void 0;
          const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);
          if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.
${serverError}`);
            return;
          } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {
            this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.
${serverError}`);
            return;
          }
          if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
            throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants$1.EMPTY_STRING, serverResponse.trace_id || Constants$1.EMPTY_STRING, serverResponse.correlation_id || Constants$1.EMPTY_STRING, serverResponse.claims || Constants$1.EMPTY_STRING, serverErrorNo);
          }
          throw serverError;
        }
      }
      /**
       * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
       * @param serverTokenResponse
       * @param authority
       */
      async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, apiId, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
        let idTokenClaims;
        if (serverTokenResponse.id_token) {
          idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants$1.EMPTY_STRING, this.cryptoObj.base64Decode);
          if (authCodePayload && authCodePayload.nonce) {
            if (idTokenClaims.nonce !== authCodePayload.nonce) {
              throw createClientAuthError(nonceMismatch);
            }
          }
          if (request.maxAge || request.maxAge === 0) {
            const authTime = idTokenClaims.auth_time;
            if (!authTime) {
              throw createClientAuthError(authTimeNotFound);
            }
            checkMaxAge(authTime, request.maxAge);
          }
        }
        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants$1.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
        let requestStateObj;
        if (!!authCodePayload && !!authCodePayload.state) {
          requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
        }
        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || void 0;
        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);
        let cacheContext;
        try {
          if (this.persistencePlugin && this.serializableCache) {
            this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
            cacheContext = new TokenCacheContext(this.serializableCache, true);
            await this.persistencePlugin.beforeCacheAccess(cacheContext);
          }
          if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
            const cachedAccounts = this.cacheStorage.getAllAccounts({
              homeAccountId: cacheRecord.account.homeAccountId,
              environment: cacheRecord.account.environment
            }, request.correlationId);
            if (cachedAccounts.length < 1) {
              this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
              this.performanceClient?.addFields({
                acntLoggedOut: true
              }, request.correlationId);
              return await _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, void 0, serverRequestId);
            }
          }
          await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, isKmsi(idTokenClaims || {}), apiId, request.storeInCache);
        } finally {
          if (this.persistencePlugin && this.serializableCache && cacheContext) {
            this.logger.verbose("Persistence enabled, calling afterCacheAccess");
            await this.persistencePlugin.afterCacheAccess(cacheContext);
          }
        }
        return _ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);
      }
      /**
       * Generates CacheRecord
       * @param serverTokenResponse
       * @param idTokenObj
       * @param authority
       */
      generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {
        const env = authority.getPreferredCache();
        if (!env) {
          throw createClientAuthError(invalidCacheEnvironment);
        }
        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
        let cachedIdToken;
        let cachedAccount;
        if (serverTokenResponse.id_token && !!idTokenClaims) {
          cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");
          cachedAccount = buildAccountToCache(
            this.cacheStorage,
            authority,
            this.homeAccountIdentifier,
            this.cryptoObj.base64Decode,
            request.correlationId,
            idTokenClaims,
            serverTokenResponse.client_info,
            env,
            claimsTenantId,
            authCodePayload,
            void 0,
            // nativeAccountId
            this.logger
          );
        }
        let cachedAccessToken = null;
        if (serverTokenResponse.access_token) {
          const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
          const expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
          const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
          const refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
          const tokenExpirationSeconds = reqTimestamp + expiresIn;
          const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
          const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
          cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
        }
        let cachedRefreshToken = null;
        if (serverTokenResponse.refresh_token) {
          let rtExpiresOn;
          if (serverTokenResponse.refresh_token_expires_in) {
            const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in === "string" ? parseInt(serverTokenResponse.refresh_token_expires_in, 10) : serverTokenResponse.refresh_token_expires_in;
            rtExpiresOn = reqTimestamp + rtExpiresIn;
            this.performanceClient?.addFields({
              ntwkRtExpiresOnSeconds: rtExpiresOn
            }, request.correlationId);
          }
          cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);
        }
        let cachedAppMetadata = null;
        if (serverTokenResponse.foci) {
          cachedAppMetadata = {
            clientId: this.clientId,
            environment: env,
            familyId: serverTokenResponse.foci
          };
        }
        return {
          account: cachedAccount,
          idToken: cachedIdToken,
          accessToken: cachedAccessToken,
          refreshToken: cachedRefreshToken,
          appMetadata: cachedAppMetadata
        };
      }
      /**
       * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
       *
       * Optionally takes a state string that is set as-is in the response.
       *
       * @param cacheRecord
       * @param idTokenObj
       * @param fromTokenCache
       * @param stateString
       */
      static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {
        let accessToken = Constants$1.EMPTY_STRING;
        let responseScopes = [];
        let expiresOn = null;
        let extExpiresOn;
        let refreshOn;
        let familyId = Constants$1.EMPTY_STRING;
        if (cacheRecord.accessToken) {
          if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP && !request.popKid) {
            const popTokenGenerator = new PopTokenGenerator(cryptoObj);
            const { secret, keyId } = cacheRecord.accessToken;
            if (!keyId) {
              throw createClientAuthError(keyIdMissing);
            }
            accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);
          } else {
            accessToken = cacheRecord.accessToken.secret;
          }
          responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
          expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);
          extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
          if (cacheRecord.accessToken.refreshOn) {
            refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);
          }
        }
        if (cacheRecord.appMetadata) {
          familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : "";
        }
        const uid = idTokenClaims?.oid || idTokenClaims?.sub || "";
        const tid = idTokenClaims?.tid || "";
        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {
          cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;
        }
        const accountInfo = cacheRecord.account ? updateAccountTenantProfileData(
          AccountEntity.getAccountInfo(cacheRecord.account),
          void 0,
          // tenantProfile optional
          idTokenClaims,
          cacheRecord.idToken?.secret
        ) : null;
        return {
          authority: authority.canonicalAuthority,
          uniqueId: uid,
          tenantId: tid,
          scopes: responseScopes,
          account: accountInfo,
          idToken: cacheRecord?.idToken?.secret || "",
          idTokenClaims: idTokenClaims || {},
          accessToken,
          fromCache: fromTokenCache,
          expiresOn,
          extExpiresOn,
          refreshOn,
          correlationId: request.correlationId,
          requestId: requestId || Constants$1.EMPTY_STRING,
          familyId,
          tokenType: cacheRecord.accessToken?.tokenType || Constants$1.EMPTY_STRING,
          state: requestState ? requestState.userRequestState : Constants$1.EMPTY_STRING,
          cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants$1.EMPTY_STRING,
          msGraphHost: cacheRecord.account?.msGraphHost || Constants$1.EMPTY_STRING,
          code: serverTokenResponse?.spa_code,
          fromNativeBroker: false
        };
      }
    };
    function buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode, correlationId, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger) {
      logger?.verbose("setCachedAccount called");
      const accountKeys = cacheStorage.getAccountKeys();
      const baseAccountKey = accountKeys.find((accountKey) => {
        return accountKey.startsWith(homeAccountId);
      });
      let cachedAccount = null;
      if (baseAccountKey) {
        cachedAccount = cacheStorage.getAccount(baseAccountKey, correlationId);
      }
      const baseAccount = cachedAccount || AccountEntity.createAccount({
        homeAccountId,
        idTokenClaims,
        clientInfo,
        environment,
        cloudGraphHostName: authCodePayload?.cloud_graph_host_name,
        msGraphHost: authCodePayload?.msgraph_host,
        nativeAccountId
      }, authority, base64Decode);
      const tenantProfiles = baseAccount.tenantProfiles || [];
      const tenantId = claimsTenantId || baseAccount.realm;
      if (tenantId && !tenantProfiles.find((tenantProfile) => {
        return tenantProfile.tenantId === tenantId;
      })) {
        const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);
        tenantProfiles.push(newTenantProfile);
      }
      baseAccount.tenantProfiles = tenantProfiles;
      return baseAccount;
    }
    async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
      if (typeof clientAssertion === "string") {
        return clientAssertion;
      } else {
        const config = {
          clientId,
          tokenEndpoint
        };
        return clientAssertion(config);
      }
    }
    var AuthorizationCodeClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
        this.includeRedirectUri = true;
        this.oidcDefaultScopes = this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;
      }
      /**
       * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
       * authorization_code_grant
       * @param request
       * @param apiId - API identifier for telemetry tracking
       */
      async acquireToken(request, apiId, authCodePayload) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);
        if (!request.code) {
          throw createClientAuthError(requestCannotBeMade);
        }
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, apiId, authCodePayload, void 0, void 0, void 0, requestId);
      }
      /**
       * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param authorityUri
       */
      getLogoutUri(logoutRequest) {
        if (!logoutRequest) {
          throw createClientConfigurationError(logoutRequestEmpty);
        }
        const queryString = this.createLogoutUrlQueryString(logoutRequest);
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
      }
      /**
       * Executes POST request to token endpoint
       * @param authority
       * @param request
       */
      async executeTokenRequest(authority, request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
        let ccsCredential = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCredential = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        }
        const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request
       */
      async createTokenRequestBody(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
        if (!this.includeRedirectUri) {
          if (!request.redirectUri) {
            throw createClientConfigurationError(redirectUriEmpty);
          }
        } else {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);
        addAuthorizationCode(parameters, request.code);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        if (request.codeVerifier) {
          addCodeVerifier(parameters, request.codeVerifier);
        }
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);
        addClientInfo(parameters);
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        let ccsCred = void 0;
        if (request.clientInfo) {
          try {
            const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
            ccsCred = {
              credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
              type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          } catch (e) {
            this.logger.verbose("Could not parse client info for CCS Header: " + e);
          }
        } else {
          ccsCred = request.ccsCredential;
        }
        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, ccsCred.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {
          addExtraQueryParameters(parameters, {
            [RETURN_SPA_CODE]: "1"
          });
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
      /**
       * This API validates the `EndSessionRequest` and creates a URL
       * @param request
       */
      createLogoutUrlQueryString(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.postLogoutRedirectUri) {
          addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);
        }
        if (request.correlationId) {
          addCorrelationId(parameters, request.correlationId);
        }
        if (request.idTokenHint) {
          addIdTokenHint(parameters, request.idTokenHint);
        }
        if (request.state) {
          addState(parameters, request.state);
        }
        if (request.logoutHint) {
          addLogoutHint(parameters, request.logoutHint);
        }
        if (request.extraQueryParameters) {
          addExtraQueryParameters(parameters, request.extraQueryParameters);
        }
        if (this.config.authOptions.instanceAware) {
          addInstanceAware(parameters);
        }
        return mapToQueryString(parameters, this.config.authOptions.encodeExtraQueryParams, request.extraQueryParameters);
      }
    };
    var DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300;
    var RefreshTokenClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      async acquireToken(request, apiId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
        const reqTimestamp = nowSeconds();
        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);
        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, apiId, void 0, void 0, true, request.forceCache, requestId);
      }
      /**
       * Gets cached refresh token and attaches to request, then calls acquireToken API
       * @param request
       */
      async acquireTokenByRefreshToken(request, apiId) {
        if (!request) {
          throw createClientConfigurationError(tokenRequestEmpty);
        }
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
        if (isFOCI) {
          try {
            return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true, apiId);
          } catch (e) {
            const noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === noTokensFound;
            const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
            if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
              return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false, apiId);
            } else {
              throw e;
            }
          }
        }
        return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false, apiId);
      }
      /**
       * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
       * @param request
       */
      async acquireTokenWithCachedRefreshToken(request, foci, apiId) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
        const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, request.correlationId, void 0, this.performanceClient);
        if (!refreshToken) {
          throw createInteractionRequiredAuthError(noTokensFound);
        }
        if (refreshToken.expiresOn) {
          const offset = request.refreshTokenExpirationOffsetSeconds || DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS;
          this.performanceClient?.addFields({
            cacheRtExpiresOnSeconds: Number(refreshToken.expiresOn),
            rtOffsetSeconds: offset
          }, request.correlationId);
          if (isTokenExpired(refreshToken.expiresOn, offset)) {
            throw createInteractionRequiredAuthError(refreshTokenExpired);
          }
        }
        const refreshTokenRequest = {
          ...request,
          refreshToken: refreshToken.secret,
          authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
          ccsCredential: {
            credential: request.account.homeAccountId,
            type: CcsCredentialType.HOME_ACCOUNT_ID
          }
        };
        try {
          return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest, apiId);
        } catch (e) {
          if (e instanceof InteractionRequiredAuthError) {
            if (e.subError === badToken) {
              this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");
              const badRefreshTokenKey = this.cacheManager.generateCredentialKey(refreshToken);
              this.cacheManager.removeRefreshToken(badRefreshTokenKey, request.correlationId);
            }
          }
          throw e;
        }
      }
      /**
       * Constructs the network message and makes a NW call to the underlying secure token service
       * @param request
       * @param authority
       */
      async executeTokenRequest(request, authority) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
        const headers = this.createTokenRequestHeaders(request.ccsCredential);
        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);
      }
      /**
       * Helper function to create the token request body
       * @param request
       */
      async createTokenRequestBody(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);
        if (request.redirectUri) {
          addRedirectUri(parameters, request.redirectUri);
        }
        addScopes(parameters, request.scopes, true, this.config.authOptions.authority.options.OIDCOptions?.defaultScopes);
        addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);
        addClientInfo(parameters);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        addRefreshToken(parameters, request.refreshToken);
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          const clientAssertion = this.config.clientCredentials.clientAssertion;
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        if (request.authenticationScheme === AuthenticationScheme.POP) {
          const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
          let reqCnfData;
          if (!request.popKid) {
            const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
            reqCnfData = generatedReqCnfData.reqCnfString;
          } else {
            reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
          }
          addPopToken(parameters, reqCnfData);
        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {
          if (request.sshJwk) {
            addSshJwk(parameters, request.sshJwk);
          } else {
            throw createClientConfigurationError(missingSshJwk);
          }
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
          switch (request.ccsCredential.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
                addCcsOid(parameters, clientInfo);
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case CcsCredentialType.UPN:
              addCcsUpn(parameters, request.ccsCredential.credential);
              break;
          }
        }
        if (request.embeddedClientId) {
          addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
        }
        if (request.tokenBodyParameters) {
          addExtraQueryParameters(parameters, request.tokenBodyParameters);
        }
        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
        return mapToQueryString(parameters);
      }
    };
    var SilentFlowClient = class extends BaseClient {
      constructor(configuration, performanceClient) {
        super(configuration, performanceClient);
      }
      /**
       * Retrieves token from cache or throws an error if it must be refreshed.
       * @param request
       */
      async acquireCachedToken(request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);
        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
        if (request.forceRefresh || !this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {
          this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        }
        if (!request.account) {
          throw createClientAuthError(noAccountInSilentRequest);
        }
        const requestTenantId = request.account.tenantId || getTenantFromAuthorityString(request.authority);
        const tokenKeys = this.cacheManager.getTokenKeys();
        const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId);
        if (!cachedAccessToken) {
          this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (wasClockTurnedBack(cachedAccessToken.cachedAt) || isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
          this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);
          throw createClientAuthError(tokenRefreshRequired);
        } else if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn, 0)) {
          lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
        }
        const environment = request.authority || this.authority.getPreferredCache();
        const cacheRecord = {
          account: this.cacheManager.getAccount(this.cacheManager.generateAccountKey(request.account), request.correlationId),
          accessToken: cachedAccessToken,
          idToken: this.cacheManager.getIdToken(request.account, request.correlationId, tokenKeys, requestTenantId, this.performanceClient),
          refreshToken: null,
          appMetadata: this.cacheManager.readAppMetadataFromCache(environment)
        };
        this.setCacheOutcome(lastCacheOutcome, request.correlationId);
        if (this.config.serverTelemetryManager) {
          this.config.serverTelemetryManager.incrementCacheHits();
        }
        return [
          await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request),
          lastCacheOutcome
        ];
      }
      setCacheOutcome(cacheOutcome, correlationId) {
        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);
        this.performanceClient?.addFields({
          cacheOutcome
        }, correlationId);
        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
          this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
        }
      }
      /**
       * Helper function to build response object from the CacheRecord
       * @param cacheRecord
       */
      async generateResultFromCacheRecord(cacheRecord, request) {
        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);
        let idTokenClaims;
        if (cacheRecord.idToken) {
          idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);
        }
        if (request.maxAge || request.maxAge === 0) {
          const authTime = idTokenClaims?.auth_time;
          if (!authTime) {
            throw createClientAuthError(authTimeNotFound);
          }
          checkMaxAge(authTime, request.maxAge);
        }
        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);
      }
    };
    function getStandardAuthorizeRequestParameters(authOptions, request, logger, performanceClient) {
      const correlationId = request.correlationId;
      const parameters = /* @__PURE__ */ new Map();
      addClientId(parameters, request.embeddedClientId || request.extraQueryParameters?.[CLIENT_ID] || authOptions.clientId);
      const requestScopes = [
        ...request.scopes || [],
        ...request.extraScopesToConsent || []
      ];
      addScopes(parameters, requestScopes, true, authOptions.authority.options.OIDCOptions?.defaultScopes);
      addRedirectUri(parameters, request.redirectUri);
      addCorrelationId(parameters, correlationId);
      addResponseMode(parameters, request.responseMode);
      addClientInfo(parameters);
      if (request.prompt) {
        addPrompt(parameters, request.prompt);
      }
      if (request.domainHint) {
        addDomainHint(parameters, request.domainHint);
      }
      if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
        if (request.sid && request.prompt === PromptValue.NONE) {
          logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
          addSid(parameters, request.sid);
        } else if (request.account) {
          const accountSid = extractAccountSid(request.account);
          let accountLoginHintClaim = extractLoginHint(request.account);
          if (accountLoginHintClaim && request.domainHint) {
            logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);
            accountLoginHintClaim = null;
          }
          if (accountLoginHintClaim) {
            logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
            addLoginHint(parameters, accountLoginHintClaim);
            try {
              const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
              addCcsOid(parameters, clientInfo);
            } catch (e) {
              logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
            }
          } else if (accountSid && request.prompt === PromptValue.NONE) {
            logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
            addSid(parameters, accountSid);
            try {
              const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
              addCcsOid(parameters, clientInfo);
            } catch (e) {
              logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
            }
          } else if (request.loginHint) {
            logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
            addLoginHint(parameters, request.loginHint);
            addCcsUpn(parameters, request.loginHint);
          } else if (request.account.username) {
            logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
            addLoginHint(parameters, request.account.username);
            try {
              const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
              addCcsOid(parameters, clientInfo);
            } catch (e) {
              logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
            }
          }
        } else if (request.loginHint) {
          logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
          addLoginHint(parameters, request.loginHint);
          addCcsUpn(parameters, request.loginHint);
        }
      } else {
        logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
      }
      if (request.nonce) {
        addNonce(parameters, request.nonce);
      }
      if (request.state) {
        addState(parameters, request.state);
      }
      if (request.claims || authOptions.clientCapabilities && authOptions.clientCapabilities.length > 0) {
        addClaims(parameters, request.claims, authOptions.clientCapabilities);
      }
      if (request.embeddedClientId) {
        addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);
      }
      if (authOptions.instanceAware && (!request.extraQueryParameters || !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {
        addInstanceAware(parameters);
      }
      return parameters;
    }
    function getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {
      const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);
      return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);
    }
    function extractAccountSid(account) {
      return account.idTokenClaims?.sid || null;
    }
    function extractLoginHint(account) {
      return account.loginHint || account.idTokenClaims?.login_hint || null;
    }
    var skuGroupSeparator = ",";
    var skuValueSeparator = "|";
    function makeExtraSkuString(params) {
      const { skus, libraryName, libraryVersion, extensionName, extensionVersion } = params;
      const skuMap = /* @__PURE__ */ new Map([
        [0, [libraryName, libraryVersion]],
        [2, [extensionName, extensionVersion]]
      ]);
      let skuArr = [];
      if (skus?.length) {
        skuArr = skus.split(skuGroupSeparator);
        if (skuArr.length < 4) {
          return skus;
        }
      } else {
        skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
      }
      skuMap.forEach((value, key) => {
        if (value.length === 2 && value[0]?.length && value[1]?.length) {
          setSku({
            skuArr,
            index: key,
            skuName: value[0],
            skuVersion: value[1]
          });
        }
      });
      return skuArr.join(skuGroupSeparator);
    }
    function setSku(params) {
      const { skuArr, index, skuName, skuVersion } = params;
      if (index >= skuArr.length) {
        return;
      }
      skuArr[index] = [skuName, skuVersion].join(skuValueSeparator);
    }
    var ServerTelemetryManager = class _ServerTelemetryManager {
      constructor(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants$1.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants$1.EMPTY_STRING;
        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
      }
      /**
       * API to add MSER Telemetry to request
       */
      generateCurrentRequestHeaderValue() {
        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
        const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
        const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
        if (nativeBrokerErrorCode?.length) {
          platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
        }
        const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const regionDiscoveryFields = this.getRegionDiscoveryFields();
        const requestWithRegionDiscoveryFields = [
          request,
          regionDiscoveryFields
        ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          requestWithRegionDiscoveryFields,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to add MSER Telemetry for the last failed request
       */
      generateLastRequestHeaderValue() {
        const lastRequests = this.getLastRequests();
        const maxErrors = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        const errorCount = lastRequests.errors.length;
        const overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [
          SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
          lastRequests.cacheHits,
          failedRequests,
          errors,
          platformFields
        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      }
      /**
       * API to cache token failures for MSER data capture
       * @param error
       */
      cacheFailedRequest(error) {
        const lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
          lastRequests.failedRequests.shift();
          lastRequests.failedRequests.shift();
          lastRequests.errors.shift();
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (error instanceof Error && !!error && error.toString()) {
          if (error instanceof AuthError) {
            if (error.subError) {
              lastRequests.errors.push(error.subError);
            } else if (error.errorCode) {
              lastRequests.errors.push(error.errorCode);
            } else {
              lastRequests.errors.push(error.toString());
            }
          } else {
            lastRequests.errors.push(error.toString());
          }
        } else {
          lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
        }
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
        return;
      }
      /**
       * Update server telemetry cache entry by incrementing cache hit counter
       */
      incrementCacheHits() {
        const lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
        return lastRequests.cacheHits;
      }
      /**
       * Get the server telemetry entity from cache or initialize a new one
       */
      getLastRequests() {
        const initialValue = {
          failedRequests: [],
          errors: [],
          cacheHits: 0
        };
        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue;
      }
      /**
       * Remove server telemetry cache entry
       */
      clearTelemetryCache() {
        const lastRequests = this.getLastRequests();
        const numErrorsFlushed = _ServerTelemetryManager.maxErrorsToSend(lastRequests);
        const errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
          this.cacheManager.removeItem(this.telemetryCacheKey, this.correlationId);
        } else {
          const serverTelemEntity = {
            failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
            errors: lastRequests.errors.slice(numErrorsFlushed),
            cacheHits: 0
          };
          this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity, this.correlationId);
        }
      }
      /**
       * Returns the maximum number of errors that can be flushed to the server in the next network request
       * @param serverTelemetryEntity
       */
      static maxErrorsToSend(serverTelemetryEntity) {
        let i;
        let maxErrors = 0;
        let dataSize = 0;
        const errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
          const apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants$1.EMPTY_STRING;
          const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants$1.EMPTY_STRING;
          const errorCode = serverTelemetryEntity.errors[i] || Constants$1.EMPTY_STRING;
          dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
          if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
            maxErrors += 1;
          } else {
            break;
          }
        }
        return maxErrors;
      }
      /**
       * Get the region discovery fields
       *
       * @returns string
       */
      getRegionDiscoveryFields() {
        const regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || Constants$1.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionSource || Constants$1.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionOutcome || Constants$1.EMPTY_STRING);
        return regionDiscoveryFields.join(",");
      }
      /**
       * Update the region discovery metadata
       *
       * @param regionDiscoveryMetadata
       * @returns void
       */
      updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
      }
      /**
       * Set cache outcome
       */
      setCacheOutcome(cacheOutcome) {
        this.cacheOutcome = cacheOutcome;
      }
      setNativeBrokerErrorCode(errorCode) {
        const lastRequests = this.getLastRequests();
        lastRequests.nativeBrokerErrorCode = errorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
      }
      getNativeBrokerErrorCode() {
        return this.getLastRequests().nativeBrokerErrorCode;
      }
      clearNativeBrokerErrorCode() {
        const lastRequests = this.getLastRequests();
        delete lastRequests.nativeBrokerErrorCode;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
      }
      static makeExtraSkuString(params) {
        return makeExtraSkuString(params);
      }
    };
    var Deserializer = class {
      /**
       * Parse the JSON blob in memory and deserialize the content
       * @param cachedJson - JSON blob cache
       */
      static deserializeJSONBlob(jsonFile) {
        const deserializedCache = !jsonFile ? {} : JSON.parse(jsonFile);
        return deserializedCache;
      }
      /**
       * Deserializes accounts to AccountEntity objects
       * @param accounts - accounts of type SerializedAccountEntity
       */
      static deserializeAccounts(accounts) {
        const accountObjects = {};
        if (accounts) {
          Object.keys(accounts).map(function(key) {
            const serializedAcc = accounts[key];
            const mappedAcc = {
              homeAccountId: serializedAcc.home_account_id,
              environment: serializedAcc.environment,
              realm: serializedAcc.realm,
              localAccountId: serializedAcc.local_account_id,
              username: serializedAcc.username,
              authorityType: serializedAcc.authority_type,
              name: serializedAcc.name,
              clientInfo: serializedAcc.client_info,
              lastModificationTime: serializedAcc.last_modification_time,
              lastModificationApp: serializedAcc.last_modification_app,
              tenantProfiles: serializedAcc.tenantProfiles?.map((serializedTenantProfile) => {
                return JSON.parse(serializedTenantProfile);
              }),
              lastUpdatedAt: Date.now().toString()
            };
            const account = new AccountEntity();
            CacheManager.toObject(account, mappedAcc);
            accountObjects[key] = account;
          });
        }
        return accountObjects;
      }
      /**
       * Deserializes id tokens to IdTokenEntity objects
       * @param idTokens - credentials of type SerializedIdTokenEntity
       */
      static deserializeIdTokens(idTokens) {
        const idObjects = {};
        if (idTokens) {
          Object.keys(idTokens).map(function(key) {
            const serializedIdT = idTokens[key];
            const idToken = {
              homeAccountId: serializedIdT.home_account_id,
              environment: serializedIdT.environment,
              credentialType: serializedIdT.credential_type,
              clientId: serializedIdT.client_id,
              secret: serializedIdT.secret,
              realm: serializedIdT.realm,
              lastUpdatedAt: Date.now().toString()
            };
            idObjects[key] = idToken;
          });
        }
        return idObjects;
      }
      /**
       * Deserializes access tokens to AccessTokenEntity objects
       * @param accessTokens - access tokens of type SerializedAccessTokenEntity
       */
      static deserializeAccessTokens(accessTokens) {
        const atObjects = {};
        if (accessTokens) {
          Object.keys(accessTokens).map(function(key) {
            const serializedAT = accessTokens[key];
            const accessToken = {
              homeAccountId: serializedAT.home_account_id,
              environment: serializedAT.environment,
              credentialType: serializedAT.credential_type,
              clientId: serializedAT.client_id,
              secret: serializedAT.secret,
              realm: serializedAT.realm,
              target: serializedAT.target,
              cachedAt: serializedAT.cached_at,
              expiresOn: serializedAT.expires_on,
              extendedExpiresOn: serializedAT.extended_expires_on,
              refreshOn: serializedAT.refresh_on,
              keyId: serializedAT.key_id,
              tokenType: serializedAT.token_type,
              requestedClaims: serializedAT.requestedClaims,
              requestedClaimsHash: serializedAT.requestedClaimsHash,
              userAssertionHash: serializedAT.userAssertionHash,
              lastUpdatedAt: Date.now().toString()
            };
            atObjects[key] = accessToken;
          });
        }
        return atObjects;
      }
      /**
       * Deserializes refresh tokens to RefreshTokenEntity objects
       * @param refreshTokens - refresh tokens of type SerializedRefreshTokenEntity
       */
      static deserializeRefreshTokens(refreshTokens) {
        const rtObjects = {};
        if (refreshTokens) {
          Object.keys(refreshTokens).map(function(key) {
            const serializedRT = refreshTokens[key];
            const refreshToken = {
              homeAccountId: serializedRT.home_account_id,
              environment: serializedRT.environment,
              credentialType: serializedRT.credential_type,
              clientId: serializedRT.client_id,
              secret: serializedRT.secret,
              familyId: serializedRT.family_id,
              target: serializedRT.target,
              realm: serializedRT.realm,
              lastUpdatedAt: Date.now().toString()
            };
            rtObjects[key] = refreshToken;
          });
        }
        return rtObjects;
      }
      /**
       * Deserializes appMetadata to AppMetaData objects
       * @param appMetadata - app metadata of type SerializedAppMetadataEntity
       */
      static deserializeAppMetadata(appMetadata) {
        const appMetadataObjects = {};
        if (appMetadata) {
          Object.keys(appMetadata).map(function(key) {
            const serializedAmdt = appMetadata[key];
            appMetadataObjects[key] = {
              clientId: serializedAmdt.client_id,
              environment: serializedAmdt.environment,
              familyId: serializedAmdt.family_id
            };
          });
        }
        return appMetadataObjects;
      }
      /**
       * Deserialize an inMemory Cache
       * @param jsonCache - JSON blob cache
       */
      static deserializeAllCache(jsonCache) {
        return {
          accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
          idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
          accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},
          refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},
          appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}
        };
      }
    };
    var internals = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      Deserializer,
      Serializer
    });
    var DEFAULT_MANAGED_IDENTITY_ID = "system_assigned_managed_identity";
    var MANAGED_IDENTITY_DEFAULT_TENANT = "managed_identity";
    var DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY = `https://login.microsoftonline.com/${MANAGED_IDENTITY_DEFAULT_TENANT}/`;
    var ManagedIdentityHeaders = {
      AUTHORIZATION_HEADER_NAME: "Authorization",
      METADATA_HEADER_NAME: "Metadata",
      APP_SERVICE_SECRET_HEADER_NAME: "X-IDENTITY-HEADER",
      ML_AND_SF_SECRET_HEADER_NAME: "secret"
    };
    var ManagedIdentityQueryParameters = {
      API_VERSION: "api-version",
      RESOURCE: "resource",
      SHA256_TOKEN_TO_REFRESH: "token_sha256_to_refresh",
      XMS_CC: "xms_cc"
    };
    var ManagedIdentityEnvironmentVariableNames = {
      AZURE_POD_IDENTITY_AUTHORITY_HOST: "AZURE_POD_IDENTITY_AUTHORITY_HOST",
      DEFAULT_IDENTITY_CLIENT_ID: "DEFAULT_IDENTITY_CLIENT_ID",
      IDENTITY_ENDPOINT: "IDENTITY_ENDPOINT",
      IDENTITY_HEADER: "IDENTITY_HEADER",
      IDENTITY_SERVER_THUMBPRINT: "IDENTITY_SERVER_THUMBPRINT",
      IMDS_ENDPOINT: "IMDS_ENDPOINT",
      MSI_ENDPOINT: "MSI_ENDPOINT",
      MSI_SECRET: "MSI_SECRET"
    };
    var ManagedIdentitySourceNames = {
      APP_SERVICE: "AppService",
      AZURE_ARC: "AzureArc",
      CLOUD_SHELL: "CloudShell",
      DEFAULT_TO_IMDS: "DefaultToImds",
      IMDS: "Imds",
      MACHINE_LEARNING: "MachineLearning",
      SERVICE_FABRIC: "ServiceFabric"
    };
    var ManagedIdentityIdType = {
      SYSTEM_ASSIGNED: "system-assigned",
      USER_ASSIGNED_CLIENT_ID: "user-assigned-client-id",
      USER_ASSIGNED_RESOURCE_ID: "user-assigned-resource-id",
      USER_ASSIGNED_OBJECT_ID: "user-assigned-object-id"
    };
    var HttpMethod = {
      GET: "get",
      POST: "post"
    };
    var ProxyStatus = {
      SUCCESS_RANGE_START: HttpStatus.SUCCESS_RANGE_START,
      SUCCESS_RANGE_END: HttpStatus.SUCCESS_RANGE_END,
      SERVER_ERROR: HttpStatus.SERVER_ERROR
    };
    var REGION_ENVIRONMENT_VARIABLE = "REGION_NAME";
    var MSAL_FORCE_REGION = "MSAL_FORCE_REGION";
    var RANDOM_OCTET_SIZE = 32;
    var Hash = {
      SHA256: "sha256"
    };
    var CharSet = {
      CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
    };
    var CACHE = {
      KEY_SEPARATOR: "-"
    };
    var Constants = {
      MSAL_SKU: "msal.js.node",
      JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
      AUTHORIZATION_PENDING: "authorization_pending",
      HTTP_PROTOCOL: "http://",
      LOCALHOST: "localhost"
    };
    var ApiId = {
      acquireTokenSilent: 62,
      acquireTokenByUsernamePassword: 371,
      acquireTokenByDeviceCode: 671,
      acquireTokenByClientCredential: 771,
      acquireTokenByOBO: 772,
      acquireTokenWithManagedIdentity: 773,
      acquireTokenByCode: 871,
      acquireTokenByRefreshToken: 872
    };
    var JwtConstants = {
      RSA_256: "RS256",
      PSS_256: "PS256",
      X5T_256: "x5t#S256",
      X5T: "x5t",
      X5C: "x5c",
      AUDIENCE: "aud",
      EXPIRATION_TIME: "exp",
      ISSUER: "iss",
      SUBJECT: "sub",
      NOT_BEFORE: "nbf",
      JWT_ID: "jti"
    };
    var LOOPBACK_SERVER_CONSTANTS = {
      INTERVAL_MS: 100,
      TIMEOUT_MS: 5e3
    };
    var AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES = 4096;
    var NetworkUtils = class {
      static getNetworkResponse(headers, body, statusCode) {
        return {
          headers,
          body,
          status: statusCode
        };
      }
      /*
       * Utility function that converts a URL object into an ordinary options object as expected by the
       * http.request and https.request APIs.
       * https://github.com/nodejs/node/blob/main/lib/internal/url.js#L1090
       */
      static urlToHttpOptions(url) {
        const options = {
          protocol: url.protocol,
          hostname: url.hostname && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
          hash: url.hash,
          search: url.search,
          pathname: url.pathname,
          path: `${url.pathname || ""}${url.search || ""}`,
          href: url.href
        };
        if (url.port !== "") {
          options.port = Number(url.port);
        }
        if (url.username || url.password) {
          options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;
        }
        return options;
      }
    };
    var name = "@azure/msal-node";
    var version2 = "3.8.8";
    var HttpClient = class {
      constructor(proxyUrl, customAgentOptions, loggerOptions) {
        this.networkRequestViaProxy = (httpMethod, destinationUrlString, options, timeout) => {
          const destinationUrl = new URL(destinationUrlString);
          const proxyUrl2 = new URL(this.proxyUrl);
          const headers = options?.headers || {};
          const tunnelRequestOptions = {
            host: proxyUrl2.hostname,
            port: proxyUrl2.port,
            method: "CONNECT",
            path: destinationUrl.hostname,
            headers
          };
          if (this.customAgentOptions && Object.keys(this.customAgentOptions).length) {
            tunnelRequestOptions.agent = new http.Agent(this.customAgentOptions);
          }
          let postRequestStringContent = "";
          if (httpMethod === HttpMethod.POST) {
            const body = options?.body || "";
            postRequestStringContent = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${body.length}\r
\r
${body}`;
          } else {
            if (timeout) {
              tunnelRequestOptions.timeout = timeout;
            }
          }
          const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r
Host: ${destinationUrl.host}\r
Connection: close\r
` + postRequestStringContent + "\r\n";
          return new Promise((resolve, reject) => {
            const request = http.request(tunnelRequestOptions);
            if (timeout) {
              request.on("timeout", () => {
                this.logUrlWithPiiAwareness(`Request timeout after ${timeout}ms for URL`, destinationUrlString);
                request.destroy();
                reject(new Error(`Request time out after ${timeout}ms`));
              });
            }
            request.end();
            request.on("connect", (response, socket) => {
              const proxyStatusCode = response?.statusCode || ProxyStatus.SERVER_ERROR;
              if (proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START || proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END) {
                request.destroy();
                socket.destroy();
                reject(new Error(`Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${response?.statusMessage || "Unknown"}`));
              }
              socket.write(outgoingRequestString);
              const data = [];
              socket.on("data", (chunk) => {
                data.push(chunk);
              });
              socket.on("end", () => {
                const dataString = Buffer.concat([...data]).toString();
                const dataStringArray = dataString.split("\r\n");
                const httpStatusCode = parseInt(dataStringArray[0].split(" ")[1]);
                const statusMessage = dataStringArray[0].split(" ").slice(2).join(" ");
                const body = dataStringArray[dataStringArray.length - 1];
                const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
                const entries = /* @__PURE__ */ new Map();
                headersArray.forEach((header) => {
                  const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
                  const headerKey = headerKeyValue[0];
                  let headerValue = headerKeyValue[1];
                  try {
                    const object = JSON.parse(headerValue);
                    if (object && typeof object === "object") {
                      headerValue = object;
                    }
                  } catch (e) {
                  }
                  entries.set(headerKey, headerValue);
                });
                const headers2 = Object.fromEntries(entries);
                const parsedHeaders = headers2;
                const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, this.parseBody(httpStatusCode, statusMessage, parsedHeaders, body), httpStatusCode);
                if (this.shouldDestroyRequest(httpStatusCode, networkResponse)) {
                  request.destroy();
                }
                resolve(networkResponse);
              });
              socket.on("error", (chunk) => {
                request.destroy();
                socket.destroy();
                reject(new Error(chunk.toString()));
              });
            });
            request.on("error", (chunk) => {
              this.logger.error(`HttpClient - Proxy request error: ${chunk.toString()}`, "");
              this.logUrlWithPiiAwareness("Destination URL", destinationUrlString);
              this.logUrlWithPiiAwareness("Proxy URL", this.proxyUrl);
              this.logger.error(`HttpClient - Method: ${httpMethod}`, "");
              this.logger.errorPii(`HttpClient - Headers: ${JSON.stringify(headers)}`, "");
              request.destroy();
              reject(new Error(chunk.toString()));
            });
          });
        };
        this.networkRequestViaHttps = (httpMethod, urlString, options, timeout) => {
          const isPostRequest = httpMethod === HttpMethod.POST;
          const body = options?.body || "";
          const url = new URL(urlString);
          const headers = options?.headers || {};
          const customOptions = {
            method: httpMethod,
            headers,
            ...NetworkUtils.urlToHttpOptions(url)
          };
          if (this.customAgentOptions && Object.keys(this.customAgentOptions).length) {
            customOptions.agent = new https.Agent(this.customAgentOptions);
          }
          if (isPostRequest) {
            customOptions.headers = {
              ...customOptions.headers,
              "Content-Length": body.length
            };
          } else {
            if (timeout) {
              customOptions.timeout = timeout;
            }
          }
          return new Promise((resolve, reject) => {
            let request;
            if (customOptions.protocol === "http:") {
              request = http.request(customOptions);
            } else {
              request = https.request(customOptions);
            }
            if (isPostRequest) {
              request.write(body);
            }
            if (timeout) {
              request.on("timeout", () => {
                this.logUrlWithPiiAwareness(`HTTPS request timeout after ${timeout}ms for URL`, urlString);
                request.destroy();
                reject(new Error(`Request time out after ${timeout}ms`));
              });
            }
            request.end();
            request.on("response", (response) => {
              const headers2 = response.headers;
              const statusCode = response.statusCode;
              const statusMessage = response.statusMessage;
              const data = [];
              response.on("data", (chunk) => {
                data.push(chunk);
              });
              response.on("end", () => {
                const body2 = Buffer.concat([...data]).toString();
                const parsedHeaders = headers2;
                const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, this.parseBody(statusCode, statusMessage, parsedHeaders, body2), statusCode);
                if (this.shouldDestroyRequest(statusCode, networkResponse)) {
                  request.destroy();
                }
                resolve(networkResponse);
              });
            });
            request.on("error", (chunk) => {
              this.logger.error(`HttpClient - HTTPS request error: ${chunk.toString()}`, "");
              this.logUrlWithPiiAwareness("URL", urlString);
              this.logger.error(`HttpClient - Method: ${httpMethod}`, "");
              this.logger.errorPii(`HttpClient - Headers: ${JSON.stringify(headers)}`, "");
              request.destroy();
              reject(new Error(chunk.toString()));
            });
          });
        };
        this.parseBody = (statusCode, statusMessage, headers, body) => {
          let parsedBody;
          try {
            parsedBody = JSON.parse(body);
          } catch (error) {
            let errorType;
            let errorDescriptionHelper;
            if (statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START && statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END) {
              errorType = "client_error";
              errorDescriptionHelper = "A client";
            } else if (statusCode >= HttpStatus.SERVER_ERROR_RANGE_START && statusCode <= HttpStatus.SERVER_ERROR_RANGE_END) {
              errorType = "server_error";
              errorDescriptionHelper = "A server";
            } else {
              errorType = "unknown_error";
              errorDescriptionHelper = "An unknown";
            }
            parsedBody = {
              error: errorType,
              error_description: `${errorDescriptionHelper} error occured.
Http status code: ${statusCode}
Http status message: ${statusMessage || "Unknown"}
Headers: ${JSON.stringify(headers)}`
            };
          }
          return parsedBody;
        };
        this.logUrlWithPiiAwareness = (label, urlString) => {
          if (this.isPiiEnabled) {
            this.logger.errorPii(`HttpClient - ${label}: ${urlString}`, "");
          } else {
            let urlHelper;
            try {
              const url = new URL(urlString);
              urlHelper = `${url.protocol}//${url.host}${url.pathname}`;
            } catch {
              urlHelper = urlString.split("?")[0] || "unknown";
            }
            this.logger.error(`HttpClient - ${label}: ${urlHelper} [Enable PII logging to see additional details]`, "");
          }
        };
        this.shouldDestroyRequest = (statusCode, networkResponse) => {
          return (statusCode < HttpStatus.SUCCESS_RANGE_START || statusCode > HttpStatus.SUCCESS_RANGE_END) && // do not destroy the request for the device code flow
          !(networkResponse.body && typeof networkResponse.body === "object" && "error" in networkResponse.body && networkResponse.body.error === Constants.AUTHORIZATION_PENDING);
        };
        this.proxyUrl = proxyUrl || "";
        this.customAgentOptions = customAgentOptions || {};
        this.logger = new Logger(loggerOptions || {}, name, version2);
        this.isPiiEnabled = this.logger.isPiiLoggingEnabled();
      }
      /**
       * Http Get request
       * @param url
       * @param options
       */
      async sendGetRequestAsync(url, options, timeout) {
        if (this.proxyUrl) {
          return this.networkRequestViaProxy(HttpMethod.GET, url, options, timeout);
        } else {
          return this.networkRequestViaHttps(HttpMethod.GET, url, options, timeout);
        }
      }
      /**
       * Http Post request
       * @param url
       * @param options
       */
      async sendPostRequestAsync(url, options) {
        if (this.proxyUrl) {
          return this.networkRequestViaProxy(HttpMethod.POST, url, options);
        } else {
          return this.networkRequestViaHttps(HttpMethod.POST, url, options);
        }
      }
    };
    var invalidFileExtension = "invalid_file_extension";
    var invalidFilePath = "invalid_file_path";
    var invalidManagedIdentityIdType = "invalid_managed_identity_id_type";
    var invalidSecret = "invalid_secret";
    var missingId = "missing_client_id";
    var networkUnavailable = "network_unavailable";
    var platformNotSupported = "platform_not_supported";
    var unableToCreateAzureArc = "unable_to_create_azure_arc";
    var unableToCreateCloudShell = "unable_to_create_cloud_shell";
    var unableToCreateSource = "unable_to_create_source";
    var unableToReadSecretFile = "unable_to_read_secret_file";
    var userAssignedNotAvailableAtRuntime = "user_assigned_not_available_at_runtime";
    var wwwAuthenticateHeaderMissing = "www_authenticate_header_missing";
    var wwwAuthenticateHeaderUnsupportedFormat = "www_authenticate_header_unsupported_format";
    var MsiEnvironmentVariableUrlMalformedErrorCodes = {
      [ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]: "azure_pod_identity_authority_host_url_malformed",
      [ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT]: "identity_endpoint_url_malformed",
      [ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT]: "imds_endpoint_url_malformed",
      [ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT]: "msi_endpoint_url_malformed"
    };
    var ManagedIdentityErrorMessages = {
      [invalidFileExtension]: "The file path in the WWW-Authenticate header does not contain a .key file.",
      [invalidFilePath]: "The file path in the WWW-Authenticate header is not in a valid Windows or Linux Format.",
      [invalidManagedIdentityIdType]: "More than one ManagedIdentityIdType was provided.",
      [invalidSecret]: "The secret in the file on the file path in the WWW-Authenticate header is greater than 4096 bytes.",
      [platformNotSupported]: "The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.",
      [missingId]: "A ManagedIdentityId id was not provided.",
      [MsiEnvironmentVariableUrlMalformedErrorCodes.AZURE_POD_IDENTITY_AUTHORITY_HOST]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.IDENTITY_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.IMDS_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' environment variable is malformed.`,
      [MsiEnvironmentVariableUrlMalformedErrorCodes.MSI_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' environment variable is malformed.`,
      [networkUnavailable]: "Authentication unavailable. The request to the managed identity endpoint timed out.",
      [unableToCreateAzureArc]: "Azure Arc Managed Identities can only be system assigned.",
      [unableToCreateCloudShell]: "Cloud Shell Managed Identities can only be system assigned.",
      [unableToCreateSource]: "Unable to create a Managed Identity source based on environment variables.",
      [unableToReadSecretFile]: "Unable to read the secret file.",
      [userAssignedNotAvailableAtRuntime]: "Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.",
      [wwwAuthenticateHeaderMissing]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is missing.",
      [wwwAuthenticateHeaderUnsupportedFormat]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is in an unsupported format."
    };
    var ManagedIdentityError = class _ManagedIdentityError extends AuthError {
      constructor(errorCode) {
        super(errorCode, ManagedIdentityErrorMessages[errorCode]);
        this.name = "ManagedIdentityError";
        Object.setPrototypeOf(this, _ManagedIdentityError.prototype);
      }
    };
    function createManagedIdentityError(errorCode) {
      return new ManagedIdentityError(errorCode);
    }
    var ManagedIdentityId = class {
      get id() {
        return this._id;
      }
      set id(value) {
        this._id = value;
      }
      get idType() {
        return this._idType;
      }
      set idType(value) {
        this._idType = value;
      }
      constructor(managedIdentityIdParams) {
        const userAssignedClientId = managedIdentityIdParams?.userAssignedClientId;
        const userAssignedResourceId = managedIdentityIdParams?.userAssignedResourceId;
        const userAssignedObjectId = managedIdentityIdParams?.userAssignedObjectId;
        if (userAssignedClientId) {
          if (userAssignedResourceId || userAssignedObjectId) {
            throw createManagedIdentityError(invalidManagedIdentityIdType);
          }
          this.id = userAssignedClientId;
          this.idType = ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID;
        } else if (userAssignedResourceId) {
          if (userAssignedClientId || userAssignedObjectId) {
            throw createManagedIdentityError(invalidManagedIdentityIdType);
          }
          this.id = userAssignedResourceId;
          this.idType = ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID;
        } else if (userAssignedObjectId) {
          if (userAssignedClientId || userAssignedResourceId) {
            throw createManagedIdentityError(invalidManagedIdentityIdType);
          }
          this.id = userAssignedObjectId;
          this.idType = ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID;
        } else {
          this.id = DEFAULT_MANAGED_IDENTITY_ID;
          this.idType = ManagedIdentityIdType.SYSTEM_ASSIGNED;
        }
      }
    };
    var NodeAuthErrorMessage = {
      invalidLoopbackAddressType: {
        code: "invalid_loopback_server_address_type",
        desc: "Loopback server address is not type string. This is unexpected."
      },
      unableToLoadRedirectUri: {
        code: "unable_to_load_redirectUrl",
        desc: "Loopback server callback was invoked without a url. This is unexpected."
      },
      noAuthCodeInResponse: {
        code: "no_auth_code_in_response",
        desc: "No auth code found in the server response. Please check your network trace to determine what happened."
      },
      noLoopbackServerExists: {
        code: "no_loopback_server_exists",
        desc: "No loopback server exists yet."
      },
      loopbackServerAlreadyExists: {
        code: "loopback_server_already_exists",
        desc: "Loopback server already exists. Cannot create another."
      },
      loopbackServerTimeout: {
        code: "loopback_server_timeout",
        desc: "Timed out waiting for auth code listener to be registered."
      },
      stateNotFoundError: {
        code: "state_not_found",
        desc: "State not found. Please verify that the request originated from msal."
      },
      thumbprintMissing: {
        code: "thumbprint_missing_from_client_certificate",
        desc: "Client certificate does not contain a SHA-1 or SHA-256 thumbprint."
      },
      redirectUriNotSupported: {
        code: "redirect_uri_not_supported",
        desc: "RedirectUri is not supported in this scenario. Please remove redirectUri from the request."
      }
    };
    var NodeAuthError = class _NodeAuthError extends AuthError {
      constructor(errorCode, errorMessage) {
        super(errorCode, errorMessage);
        this.name = "NodeAuthError";
      }
      /**
       * Creates an error thrown if loopback server address is of type string.
       */
      static createInvalidLoopbackAddressTypeError() {
        return new _NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server is unable to get a url.
       */
      static createUnableToLoadRedirectUrlError() {
        return new _NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
      }
      /**
       * Creates an error thrown if the server response does not contain an auth code.
       */
      static createNoAuthCodeInResponseError() {
        return new _NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server has not been spun up yet.
       */
      static createNoLoopbackServerExistsError() {
        return new _NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
      }
      /**
       * Creates an error thrown if a loopback server already exists when attempting to create another one.
       */
      static createLoopbackServerAlreadyExistsError() {
        return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
      }
      /**
       * Creates an error thrown if the loopback server times out registering the auth code listener.
       */
      static createLoopbackServerTimeoutError() {
        return new _NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
      }
      /**
       * Creates an error thrown when the state is not present.
       */
      static createStateNotFoundError() {
        return new _NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);
      }
      /**
       * Creates an error thrown when client certificate was provided, but neither the SHA-1 or SHA-256 thumbprints were provided
       */
      static createThumbprintMissingError() {
        return new _NodeAuthError(NodeAuthErrorMessage.thumbprintMissing.code, NodeAuthErrorMessage.thumbprintMissing.desc);
      }
      /**
       * Creates an error thrown when redirectUri is provided in an unsupported scenario
       */
      static createRedirectUriNotSupportedError() {
        return new _NodeAuthError(NodeAuthErrorMessage.redirectUriNotSupported.code, NodeAuthErrorMessage.redirectUriNotSupported.desc);
      }
    };
    var DEFAULT_AUTH_OPTIONS = {
      clientId: Constants$1.EMPTY_STRING,
      authority: Constants$1.DEFAULT_AUTHORITY,
      clientSecret: Constants$1.EMPTY_STRING,
      clientAssertion: Constants$1.EMPTY_STRING,
      clientCertificate: {
        thumbprint: Constants$1.EMPTY_STRING,
        thumbprintSha256: Constants$1.EMPTY_STRING,
        privateKey: Constants$1.EMPTY_STRING,
        x5c: Constants$1.EMPTY_STRING
      },
      knownAuthorities: [],
      cloudDiscoveryMetadata: Constants$1.EMPTY_STRING,
      authorityMetadata: Constants$1.EMPTY_STRING,
      clientCapabilities: [],
      protocolMode: ProtocolMode.AAD,
      azureCloudOptions: {
        azureCloudInstance: AzureCloudInstance.None,
        tenant: Constants$1.EMPTY_STRING
      },
      skipAuthorityMetadataCache: false,
      encodeExtraQueryParams: false
    };
    var DEFAULT_CACHE_OPTIONS = {
      claimsBasedCachingEnabled: false
    };
    var DEFAULT_LOGGER_OPTIONS = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: exports2.LogLevel.Info
    };
    var DEFAULT_SYSTEM_OPTIONS = {
      loggerOptions: DEFAULT_LOGGER_OPTIONS,
      networkClient: new HttpClient(),
      proxyUrl: Constants$1.EMPTY_STRING,
      customAgentOptions: {},
      disableInternalRetries: false
    };
    var DEFAULT_TELEMETRY_OPTIONS = {
      application: {
        appName: Constants$1.EMPTY_STRING,
        appVersion: Constants$1.EMPTY_STRING
      }
    };
    function buildAppConfiguration({ auth, broker, cache, system, telemetry }) {
      const systemOptions = {
        ...DEFAULT_SYSTEM_OPTIONS,
        networkClient: new HttpClient(system?.proxyUrl, system?.customAgentOptions),
        loggerOptions: system?.loggerOptions || DEFAULT_LOGGER_OPTIONS,
        disableInternalRetries: system?.disableInternalRetries || false
      };
      if (!!auth.clientCertificate && !!!auth.clientCertificate.thumbprint && !!!auth.clientCertificate.thumbprintSha256) {
        throw NodeAuthError.createStateNotFoundError();
      }
      return {
        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },
        broker: { ...broker },
        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },
        system: { ...systemOptions, ...system },
        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry }
      };
    }
    function buildManagedIdentityConfiguration({ clientCapabilities, managedIdentityIdParams, system }) {
      const managedIdentityId = new ManagedIdentityId(managedIdentityIdParams);
      const loggerOptions = system?.loggerOptions || DEFAULT_LOGGER_OPTIONS;
      let networkClient;
      if (system?.networkClient) {
        networkClient = system.networkClient;
      } else {
        networkClient = new HttpClient(system?.proxyUrl, system?.customAgentOptions);
      }
      return {
        clientCapabilities: clientCapabilities || [],
        managedIdentityId,
        system: {
          loggerOptions,
          networkClient
        },
        disableInternalRetries: system?.disableInternalRetries || false
      };
    }
    var GuidGenerator = class {
      /**
       *
       * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.
       * uuidv4 generates guids from cryprtographically-string random
       */
      generateGuid() {
        return uuid.v4();
      }
      /**
       * verifies if a string is  GUID
       * @param guid
       */
      isGuid(guid) {
        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return regexGuid.test(guid);
      }
    };
    var EncodingUtils = class _EncodingUtils {
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param str text
       */
      static base64Encode(str, encoding) {
        return Buffer.from(str, encoding).toString(EncodingTypes.BASE64);
      }
      /**
       * encode a URL
       * @param str
       */
      static base64EncodeUrl(str, encoding) {
        return _EncodingUtils.base64Encode(str, encoding).replace(/=/g, Constants$1.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
      }
      /**
       * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
       * 'base64': Base64 encoding.
       *
       * @param base64Str Base64 encoded text
       */
      static base64Decode(base64Str) {
        return Buffer.from(base64Str, EncodingTypes.BASE64).toString("utf8");
      }
      /**
       * @param base64Str Base64 encoded Url
       */
      static base64DecodeUrl(base64Str) {
        let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");
        while (str.length % 4) {
          str += "=";
        }
        return _EncodingUtils.base64Decode(str);
      }
    };
    var HashUtils = class {
      /**
       * generate 'SHA256' hash
       * @param buffer
       */
      sha256(buffer) {
        return crypto5.createHash(Hash.SHA256).update(buffer).digest();
      }
    };
    var PkceGenerator = class {
      constructor() {
        this.hashUtils = new HashUtils();
      }
      /**
       * generates the codeVerfier and the challenge from the codeVerfier
       * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2
       */
      async generatePkceCodes() {
        const verifier = this.generateCodeVerifier();
        const challenge = this.generateCodeChallengeFromVerifier(verifier);
        return { verifier, challenge };
      }
      /**
       * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1
       */
      generateCodeVerifier() {
        const charArr = [];
        const maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;
        while (charArr.length <= RANDOM_OCTET_SIZE) {
          const byte = crypto5.randomBytes(1)[0];
          if (byte >= maxNumber) {
            continue;
          }
          const index = byte % CharSet.CV_CHARSET.length;
          charArr.push(CharSet.CV_CHARSET[index]);
        }
        const verifier = charArr.join(Constants$1.EMPTY_STRING);
        return EncodingUtils.base64EncodeUrl(verifier);
      }
      /**
       * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2
       * @param codeVerifier
       */
      generateCodeChallengeFromVerifier(codeVerifier) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString(EncodingTypes.BASE64), EncodingTypes.BASE64);
      }
    };
    var CryptoProvider = class {
      constructor() {
        this.pkceGenerator = new PkceGenerator();
        this.guidGenerator = new GuidGenerator();
        this.hashUtils = new HashUtils();
      }
      /**
       * base64 URL safe encoded string
       */
      base64UrlEncode() {
        throw new Error("Method not implemented.");
      }
      /**
       * Stringifies and base64Url encodes input public key
       * @param inputKid - public key id
       * @returns Base64Url encoded public key
       */
      encodeKid() {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a new random GUID - used to populate state and nonce.
       * @returns string (GUID)
       */
      createNewGuid() {
        return this.guidGenerator.generateGuid();
      }
      /**
       * Encodes input string to base64.
       * @param input - string to be encoded
       */
      base64Encode(input) {
        return EncodingUtils.base64Encode(input);
      }
      /**
       * Decodes input string from base64.
       * @param input - string to be decoded
       */
      base64Decode(input) {
        return EncodingUtils.base64Decode(input);
      }
      /**
       * Generates PKCE codes used in Authorization Code Flow.
       */
      generatePkceCodes() {
        return this.pkceGenerator.generatePkceCodes();
      }
      /**
       * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node
       */
      getPublicKeyThumbprint() {
        throw new Error("Method not implemented.");
      }
      /**
       * Removes cryptographic keypair from key store matching the keyId passed in
       * @param kid - public key id
       */
      removeTokenBindingKey() {
        throw new Error("Method not implemented.");
      }
      /**
       * Removes all cryptographic keys from Keystore
       */
      clearKeystore() {
        throw new Error("Method not implemented.");
      }
      /**
       * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node
       */
      signJwt() {
        throw new Error("Method not implemented.");
      }
      /**
       * Returns the SHA-256 hash of an input string
       */
      async hashString(plainText) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString(EncodingTypes.BASE64), EncodingTypes.BASE64);
      }
    };
    function generateCredentialKey(credential) {
      const familyId = credential.credentialType === CredentialType.REFRESH_TOKEN && credential.familyId || credential.clientId;
      const scheme = credential.tokenType && credential.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? credential.tokenType.toLowerCase() : "";
      const credentialKey = [
        credential.homeAccountId,
        credential.environment,
        credential.credentialType,
        familyId,
        credential.realm || "",
        credential.target || "",
        credential.requestedClaimsHash || "",
        scheme
      ];
      return credentialKey.join(CACHE.KEY_SEPARATOR).toLowerCase();
    }
    function generateAccountKey(account) {
      const homeTenantId = account.homeAccountId.split(".")[1];
      const accountKey = [
        account.homeAccountId,
        account.environment,
        homeTenantId || account.tenantId || ""
      ];
      return accountKey.join(CACHE.KEY_SEPARATOR).toLowerCase();
    }
    var NodeStorage = class extends CacheManager {
      constructor(logger, clientId, cryptoImpl, staticAuthorityOptions) {
        super(clientId, cryptoImpl, logger, new msalCommon.StubPerformanceClient(), staticAuthorityOptions);
        this.cache = {};
        this.changeEmitters = [];
        this.logger = logger;
      }
      /**
       * Queue up callbacks
       * @param func - a callback function for cache change indication
       */
      registerChangeEmitter(func) {
        this.changeEmitters.push(func);
      }
      /**
       * Invoke the callback when cache changes
       */
      emitChange() {
        this.changeEmitters.forEach((func) => func.call(null));
      }
      /**
       * Converts cacheKVStore to InMemoryCache
       * @param cache - key value store
       */
      cacheToInMemoryCache(cache) {
        const inMemoryCache = {
          accounts: {},
          idTokens: {},
          accessTokens: {},
          refreshTokens: {},
          appMetadata: {}
        };
        for (const key in cache) {
          const value = cache[key];
          if (typeof value !== "object") {
            continue;
          }
          if (value instanceof AccountEntity) {
            inMemoryCache.accounts[key] = value;
          } else if (isIdTokenEntity(value)) {
            inMemoryCache.idTokens[key] = value;
          } else if (isAccessTokenEntity(value)) {
            inMemoryCache.accessTokens[key] = value;
          } else if (isRefreshTokenEntity(value)) {
            inMemoryCache.refreshTokens[key] = value;
          } else if (isAppMetadataEntity(key, value)) {
            inMemoryCache.appMetadata[key] = value;
          } else {
            continue;
          }
        }
        return inMemoryCache;
      }
      /**
       * converts inMemoryCache to CacheKVStore
       * @param inMemoryCache - kvstore map for inmemory
       */
      inMemoryCacheToCache(inMemoryCache) {
        let cache = this.getCache();
        cache = {
          ...cache,
          ...inMemoryCache.accounts,
          ...inMemoryCache.idTokens,
          ...inMemoryCache.accessTokens,
          ...inMemoryCache.refreshTokens,
          ...inMemoryCache.appMetadata
        };
        return cache;
      }
      /**
       * gets the current in memory cache for the client
       */
      getInMemoryCache() {
        this.logger.trace("Getting in-memory cache");
        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
        return inMemoryCache;
      }
      /**
       * sets the current in memory cache for the client
       * @param inMemoryCache - key value map in memory
       */
      setInMemoryCache(inMemoryCache) {
        this.logger.trace("Setting in-memory cache");
        const cache = this.inMemoryCacheToCache(inMemoryCache);
        this.setCache(cache);
        this.emitChange();
      }
      /**
       * get the current cache key-value store
       */
      getCache() {
        this.logger.trace("Getting cache key-value store");
        return this.cache;
      }
      /**
       * sets the current cache (key value store)
       * @param cacheMap - key value map
       */
      setCache(cache) {
        this.logger.trace("Setting cache key value store");
        this.cache = cache;
        this.emitChange();
      }
      /**
       * Gets cache item with given key.
       * @param key - lookup key for the cache entry
       */
      getItem(key) {
        this.logger.tracePii(`Item key: ${key}`);
        const cache = this.getCache();
        return cache[key];
      }
      /**
       * Gets cache item with given key-value
       * @param key - lookup key for the cache entry
       * @param value - value of the cache entry
       */
      setItem(key, value) {
        this.logger.tracePii(`Item key: ${key}`);
        const cache = this.getCache();
        cache[key] = value;
        this.setCache(cache);
      }
      generateCredentialKey(credential) {
        return generateCredentialKey(credential);
      }
      generateAccountKey(account) {
        return generateAccountKey(account);
      }
      getAccountKeys() {
        const inMemoryCache = this.getInMemoryCache();
        const accountKeys = Object.keys(inMemoryCache.accounts);
        return accountKeys;
      }
      getTokenKeys() {
        const inMemoryCache = this.getInMemoryCache();
        const tokenKeys = {
          idToken: Object.keys(inMemoryCache.idTokens),
          accessToken: Object.keys(inMemoryCache.accessTokens),
          refreshToken: Object.keys(inMemoryCache.refreshTokens)
        };
        return tokenKeys;
      }
      /**
       * Reads account from cache, builds it into an account entity and returns it.
       * @param accountKey - lookup key to fetch cache type AccountEntity
       * @returns
       */
      getAccount(accountKey) {
        const cachedAccount = this.getItem(accountKey);
        return cachedAccount ? Object.assign(new AccountEntity(), this.getItem(accountKey)) : null;
      }
      /**
       * set account entity
       * @param account - cache value to be set of type AccountEntity
       */
      async setAccount(account) {
        const accountKey = this.generateAccountKey(AccountEntity.getAccountInfo(account));
        this.setItem(accountKey, account);
      }
      /**
       * fetch the idToken credential
       * @param idTokenKey - lookup key to fetch cache type IdTokenEntity
       */
      getIdTokenCredential(idTokenKey) {
        const idToken = this.getItem(idTokenKey);
        if (isIdTokenEntity(idToken)) {
          return idToken;
        }
        return null;
      }
      /**
       * set idToken credential
       * @param idToken - cache value to be set of type IdTokenEntity
       */
      async setIdTokenCredential(idToken) {
        const idTokenKey = this.generateCredentialKey(idToken);
        this.setItem(idTokenKey, idToken);
      }
      /**
       * fetch the accessToken credential
       * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity
       */
      getAccessTokenCredential(accessTokenKey) {
        const accessToken = this.getItem(accessTokenKey);
        if (isAccessTokenEntity(accessToken)) {
          return accessToken;
        }
        return null;
      }
      /**
       * set accessToken credential
       * @param accessToken -  cache value to be set of type AccessTokenEntity
       */
      async setAccessTokenCredential(accessToken) {
        const accessTokenKey = this.generateCredentialKey(accessToken);
        this.setItem(accessTokenKey, accessToken);
      }
      /**
       * fetch the refreshToken credential
       * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity
       */
      getRefreshTokenCredential(refreshTokenKey) {
        const refreshToken = this.getItem(refreshTokenKey);
        if (isRefreshTokenEntity(refreshToken)) {
          return refreshToken;
        }
        return null;
      }
      /**
       * set refreshToken credential
       * @param refreshToken - cache value to be set of type RefreshTokenEntity
       */
      async setRefreshTokenCredential(refreshToken) {
        const refreshTokenKey = this.generateCredentialKey(refreshToken);
        this.setItem(refreshTokenKey, refreshToken);
      }
      /**
       * fetch appMetadata entity from the platform cache
       * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity
       */
      getAppMetadata(appMetadataKey) {
        const appMetadata = this.getItem(appMetadataKey);
        if (isAppMetadataEntity(appMetadataKey, appMetadata)) {
          return appMetadata;
        }
        return null;
      }
      /**
       * set appMetadata entity to the platform cache
       * @param appMetadata - cache value to be set of type AppMetadataEntity
       */
      setAppMetadata(appMetadata) {
        const appMetadataKey = generateAppMetadataKey(appMetadata);
        this.setItem(appMetadataKey, appMetadata);
      }
      /**
       * fetch server telemetry entity from the platform cache
       * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity
       */
      getServerTelemetry(serverTelemetrykey) {
        const serverTelemetryEntity = this.getItem(serverTelemetrykey);
        if (serverTelemetryEntity && isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
          return serverTelemetryEntity;
        }
        return null;
      }
      /**
       * set server telemetry entity to the platform cache
       * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity
       * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity
       */
      setServerTelemetry(serverTelemetryKey, serverTelemetry) {
        this.setItem(serverTelemetryKey, serverTelemetry);
      }
      /**
       * fetch authority metadata entity from the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       */
      getAuthorityMetadata(key) {
        const authorityMetadataEntity = this.getItem(key);
        if (authorityMetadataEntity && isAuthorityMetadataEntity(key, authorityMetadataEntity)) {
          return authorityMetadataEntity;
        }
        return null;
      }
      /**
       * Get all authority metadata keys
       */
      getAuthorityMetadataKeys() {
        return this.getKeys().filter((key) => {
          return this.isAuthorityMetadata(key);
        });
      }
      /**
       * set authority metadata entity to the platform cache
       * @param key - lookup key to fetch cache type AuthorityMetadataEntity
       * @param metadata - cache value to be set of type AuthorityMetadataEntity
       */
      setAuthorityMetadata(key, metadata) {
        this.setItem(key, metadata);
      }
      /**
       * fetch throttling entity from the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       */
      getThrottlingCache(throttlingCacheKey) {
        const throttlingCache = this.getItem(throttlingCacheKey);
        if (throttlingCache && isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
          return throttlingCache;
        }
        return null;
      }
      /**
       * set throttling entity to the platform cache
       * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
       * @param throttlingCache - cache value to be set of type ThrottlingEntity
       */
      setThrottlingCache(throttlingCacheKey, throttlingCache) {
        this.setItem(throttlingCacheKey, throttlingCache);
      }
      /**
       * Removes the cache item from memory with the given key.
       * @param key - lookup key to remove a cache entity
       * @param inMemory - key value map of the cache
       */
      removeItem(key) {
        this.logger.tracePii(`Item key: ${key}`);
        let result = false;
        const cache = this.getCache();
        if (!!cache[key]) {
          delete cache[key];
          result = true;
        }
        if (result) {
          this.setCache(cache);
          this.emitChange();
        }
        return result;
      }
      /**
       * Remove account entity from the platform cache if it's outdated
       * @param accountKey - lookup key to fetch cache type AccountEntity
       */
      removeOutdatedAccount(accountKey) {
        this.removeItem(accountKey);
      }
      /**
       * Checks whether key is in cache.
       * @param key - look up key for a cache entity
       */
      containsKey(key) {
        return this.getKeys().includes(key);
      }
      /**
       * Gets all keys in window.
       */
      getKeys() {
        this.logger.trace("Retrieving all cache keys");
        const cache = this.getCache();
        return [...Object.keys(cache)];
      }
      /**
       * Clears all cache entries created by MSAL (except tokens).
       */
      clear() {
        this.logger.trace("Clearing cache entries created by MSAL");
        const cacheKeys = this.getKeys();
        cacheKeys.forEach((key) => {
          this.removeItem(key);
        });
        this.emitChange();
      }
      /**
       * Initialize in memory cache from an exisiting cache vault
       * @param cache - blob formatted cache (JSON)
       */
      static generateInMemoryCache(cache) {
        return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
      }
      /**
       * retrieves the final JSON
       * @param inMemoryCache - itemised cache read from the JSON
       */
      static generateJsonCache(inMemoryCache) {
        return Serializer.serializeAllCache(inMemoryCache);
      }
      /**
       * Updates a credential's cache key if the current cache key is outdated
       */
      updateCredentialCacheKey(currentCacheKey, credential) {
        const updatedCacheKey = this.generateCredentialKey(credential);
        if (currentCacheKey !== updatedCacheKey) {
          const cacheItem = this.getItem(currentCacheKey);
          if (cacheItem) {
            this.removeItem(currentCacheKey);
            this.setItem(updatedCacheKey, cacheItem);
            this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
            return updatedCacheKey;
          } else {
            this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
          }
        }
        return currentCacheKey;
      }
    };
    var defaultSerializedCache = {
      Account: {},
      IdToken: {},
      AccessToken: {},
      RefreshToken: {},
      AppMetadata: {}
    };
    var TokenCache = class {
      constructor(storage, logger, cachePlugin) {
        this.cacheHasChanged = false;
        this.storage = storage;
        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
        if (cachePlugin) {
          this.persistence = cachePlugin;
        }
        this.logger = logger;
      }
      /**
       * Set to true if cache state has changed since last time serialize or writeToPersistence was called
       */
      hasChanged() {
        return this.cacheHasChanged;
      }
      /**
       * Serializes in memory cache to JSON
       */
      serialize() {
        this.logger.trace("Serializing in-memory cache");
        let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
        if (this.cacheSnapshot) {
          this.logger.trace("Reading cache snapshot from disk");
          finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
        } else {
          this.logger.trace("No cache snapshot to merge");
        }
        this.cacheHasChanged = false;
        return JSON.stringify(finalState);
      }
      /**
       * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format
       * @param cache - blob formatted cache
       */
      deserialize(cache) {
        this.logger.trace("Deserializing JSON to in-memory cache");
        this.cacheSnapshot = cache;
        if (this.cacheSnapshot) {
          this.logger.trace("Reading cache snapshot from disk");
          const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
          this.storage.setInMemoryCache(deserializedCache);
        } else {
          this.logger.trace("No cache snapshot to deserialize");
        }
      }
      /**
       * Fetches the cache key-value map
       */
      getKVStore() {
        return this.storage.getCache();
      }
      /**
       * Gets cache snapshot in CacheKVStore format
       */
      getCacheSnapshot() {
        const deserializedPersistentStorage = NodeStorage.generateInMemoryCache(this.cacheSnapshot);
        return this.storage.inMemoryCacheToCache(deserializedPersistentStorage);
      }
      /**
       * API that retrieves all accounts currently in cache to the user
       */
      async getAllAccounts(correlationId = new CryptoProvider().createNewGuid()) {
        this.logger.trace("getAllAccounts called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, false);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          return this.storage.getAllAccounts({}, correlationId);
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId - unique identifier for an account (uid.utid)
       */
      async getAccountByHomeId(homeAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (homeAccountId && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null;
        } else {
          return null;
        }
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)
       */
      async getAccountByLocalId(localAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (localAccountId && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null;
        } else {
          return null;
        }
      }
      /**
       * API to remove a specific account and the relevant data from cache
       * @param account - AccountInfo passed by the user
       */
      async removeAccount(account, correlationId) {
        this.logger.trace("removeAccount called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new TokenCacheContext(this, true);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          this.storage.removeAccount(account, correlationId || new GuidGenerator().generateGuid());
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      /**
       * Overwrites in-memory cache with persistent cache
       */
      async overwriteCache() {
        if (!this.persistence) {
          this.logger.info("No persistence layer specified, cache cannot be overwritten");
          return;
        }
        this.logger.info("Overwriting in-memory cache with persistent cache");
        this.storage.clear();
        const cacheContext = new TokenCacheContext(this, false);
        await this.persistence.beforeCacheAccess(cacheContext);
        const cacheSnapshot = this.getCacheSnapshot();
        this.storage.setCache(cacheSnapshot);
        await this.persistence.afterCacheAccess(cacheContext);
      }
      /**
       * Called when the cache has changed state.
       */
      handleChangeEvent() {
        this.cacheHasChanged = true;
      }
      /**
       * Merge in memory cache with the cache snapshot.
       * @param oldState - cache before changes
       * @param currentState - current cache state in the library
       */
      mergeState(oldState, currentState) {
        this.logger.trace("Merging in-memory cache with cache snapshot");
        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
        return this.mergeUpdates(stateAfterRemoval, currentState);
      }
      /**
       * Deep update of oldState based on newState values
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeUpdates(oldState, newState) {
        Object.keys(newState).forEach((newKey) => {
          const newValue = newState[newKey];
          if (!oldState.hasOwnProperty(newKey)) {
            if (newValue !== null) {
              oldState[newKey] = newValue;
            }
          } else {
            const newValueNotNull = newValue !== null;
            const newValueIsObject = typeof newValue === "object";
            const newValueIsNotArray = !Array.isArray(newValue);
            const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" && oldState[newKey] !== null;
            if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {
              this.mergeUpdates(oldState[newKey], newValue);
            } else {
              oldState[newKey] = newValue;
            }
          }
        });
        return oldState;
      }
      /**
       * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of
       * oldState that are not recognized, they are left untouched.
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovals(oldState, newState) {
        this.logger.trace("Remove updated entries in cache");
        const accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;
        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;
        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;
        const idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;
        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;
        return {
          ...oldState,
          Account: accounts,
          AccessToken: accessTokens,
          RefreshToken: refreshTokens,
          IdToken: idTokens,
          AppMetadata: appMetadata
        };
      }
      /**
       * Helper to merge new cache with the old one
       * @param oldState - cache before changes
       * @param newState - updated cache
       */
      mergeRemovalsDict(oldState, newState) {
        const finalState = { ...oldState };
        Object.keys(oldState).forEach((oldKey) => {
          if (!newState || !newState.hasOwnProperty(oldKey)) {
            delete finalState[oldKey];
          }
        });
        return finalState;
      }
      /**
       * Helper to overlay as a part of cache merge
       * @param passedInCache - cache read from the blob
       */
      overlayDefaults(passedInCache) {
        this.logger.trace("Overlaying input cache with the default cache");
        return {
          Account: {
            ...defaultSerializedCache.Account,
            ...passedInCache.Account
          },
          IdToken: {
            ...defaultSerializedCache.IdToken,
            ...passedInCache.IdToken
          },
          AccessToken: {
            ...defaultSerializedCache.AccessToken,
            ...passedInCache.AccessToken
          },
          RefreshToken: {
            ...defaultSerializedCache.RefreshToken,
            ...passedInCache.RefreshToken
          },
          AppMetadata: {
            ...defaultSerializedCache.AppMetadata,
            ...passedInCache.AppMetadata
          }
        };
      }
    };
    var ClientAssertion = class _ClientAssertion {
      /**
       * Initialize the ClientAssertion class from the clientAssertion passed by the user
       * @param assertion - refer https://tools.ietf.org/html/rfc7521
       */
      static fromAssertion(assertion) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.jwt = assertion;
        return clientAssertion;
      }
      /**
       * @deprecated Use fromCertificateWithSha256Thumbprint instead, with a SHA-256 thumprint
       * Initialize the ClientAssertion class from the certificate passed by the user
       * @param thumbprint - identifier of a certificate
       * @param privateKey - secret key
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static fromCertificate(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        clientAssertion.useSha256 = false;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      /**
       * Initialize the ClientAssertion class from the certificate passed by the user
       * @param thumbprint - identifier of a certificate
       * @param privateKey - secret key
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static fromCertificateWithSha256Thumbprint(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new _ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        clientAssertion.useSha256 = true;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      /**
       * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is
       * @param cryptoProvider - library's crypto helper
       * @param issuer - iss claim
       * @param jwtAudience - aud claim
       */
      getJwt(cryptoProvider, issuer, jwtAudience) {
        if (this.privateKey && this.thumbprint) {
          if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {
            return this.jwt;
          }
          return this.createJwt(cryptoProvider, issuer, jwtAudience);
        }
        if (this.jwt) {
          return this.jwt;
        }
        throw createClientAuthError(invalidAssertion);
      }
      /**
       * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3
       */
      createJwt(cryptoProvider, issuer, jwtAudience) {
        this.issuer = issuer;
        this.jwtAudience = jwtAudience;
        const issuedAt = nowSeconds();
        this.expirationTime = issuedAt + 600;
        const algorithm = this.useSha256 ? JwtConstants.PSS_256 : JwtConstants.RSA_256;
        const header = {
          alg: algorithm
        };
        const thumbprintHeader = this.useSha256 ? JwtConstants.X5T_256 : JwtConstants.X5T;
        Object.assign(header, {
          [thumbprintHeader]: EncodingUtils.base64EncodeUrl(this.thumbprint, EncodingTypes.HEX)
        });
        if (this.publicCertificate) {
          Object.assign(header, {
            [JwtConstants.X5C]: this.publicCertificate
          });
        }
        const payload = {
          [JwtConstants.AUDIENCE]: this.jwtAudience,
          [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
          [JwtConstants.ISSUER]: this.issuer,
          [JwtConstants.SUBJECT]: this.issuer,
          [JwtConstants.NOT_BEFORE]: issuedAt,
          [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()
        };
        this.jwt = jwt.sign(payload, this.privateKey, { header });
        return this.jwt;
      }
      /**
       * Utility API to check expiration
       */
      isExpired() {
        return this.expirationTime < nowSeconds();
      }
      /**
       * Extracts the raw certs from a given certificate string and returns them in an array.
       * @param publicCertificate - electronic document provided to prove the ownership of the public key
       */
      static parseCertificate(publicCertificate) {
        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
        const certs = [];
        let matches;
        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {
          certs.push(matches[1].replace(/\r*\n/g, Constants$1.EMPTY_STRING));
        }
        return certs;
      }
    };
    var UsernamePasswordClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * API to acquire a token by passing the username and password to the service in exchage of credentials
       * password_grant
       * @param request - CommonUsernamePasswordRequest
       */
      async acquireToken(request) {
        this.logger.info("in acquireToken call in username-password client");
        const reqTimestamp = nowSeconds();
        const response = await this.executeTokenRequest(this.authority, request);
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        const tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, ApiId.acquireTokenByUsernamePassword);
        return tokenResponse;
      }
      /**
       * Executes POST request to token endpoint
       * @param authority - authority object
       * @param request - CommonUsernamePasswordRequest provided by the developer
       */
      async executeTokenRequest(authority, request) {
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await this.createTokenRequestBody(request);
        const headers = this.createTokenRequestHeaders({
          credential: request.username,
          type: CcsCredentialType.UPN
        });
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: authority.canonicalAuthority,
          scopes: request.scopes,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid
        };
        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
      }
      /**
       * Generates a map for all the params to be sent to the service
       * @param request - CommonUsernamePasswordRequest provided by the developer
       */
      async createTokenRequestBody(request) {
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, this.config.authOptions.clientId);
        addUsername(parameters, request.username);
        addPassword(parameters, request.password);
        addScopes(parameters, request.scopes);
        addResponseType(parameters, OAuthResponseType.IDTOKEN_TOKEN);
        addGrantType(parameters, GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
        addClientInfo(parameters);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        addCorrelationId(parameters, correlationId);
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        const clientAssertion = this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request.username) {
          addCcsUpn(parameters, request.username);
        }
        return mapToQueryString(parameters);
      }
    };
    function getAuthCodeRequestUrl(config, authority, request, logger) {
      const parameters = getStandardAuthorizeRequestParameters({
        ...config.auth,
        authority,
        redirectUri: request.redirectUri || ""
      }, request, logger);
      addLibraryInfo(parameters, {
        sku: Constants.MSAL_SKU,
        version: version2,
        cpu: process.arch || "",
        os: process.platform || ""
      });
      if (config.auth.protocolMode !== ProtocolMode.OIDC) {
        addApplicationTelemetry(parameters, config.telemetry.application);
      }
      addResponseType(parameters, OAuthResponseType.CODE);
      if (request.codeChallenge && request.codeChallengeMethod) {
        addCodeChallengeParams(parameters, request.codeChallenge, request.codeChallengeMethod);
      }
      addExtraQueryParameters(parameters, request.extraQueryParameters || {});
      return getAuthorizeUrl(authority, parameters, config.auth.encodeExtraQueryParams, request.extraQueryParameters);
    }
    var ClientApplication = class {
      /**
       * Constructor for the ClientApplication
       */
      constructor(configuration) {
        this.config = buildAppConfiguration(configuration);
        this.cryptoProvider = new CryptoProvider();
        this.logger = new Logger(this.config.system.loggerOptions, name, version2);
        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider, buildStaticAuthorityOptions(this.config.auth));
        this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
      }
      /**
       * Creates the URL of the authorization request, letting the user input credentials and consent to the
       * application. The URL targets the /authorize endpoint of the authority configured in the
       * application object.
       *
       * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
       * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
       * `acquireTokenByCode(AuthorizationCodeRequest)`.
       */
      async getAuthCodeUrl(request) {
        this.logger.info("getAuthCodeUrl called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          responseMode: request.responseMode || ResponseMode.QUERY,
          authenticationScheme: AuthenticationScheme.BEARER,
          state: request.state || "",
          nonce: request.nonce || ""
        };
        const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
        return getAuthCodeRequestUrl(this.config, discoveredAuthority, validRequest, this.logger);
      }
      /**
       * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0
       * Authorization Code flow.
       *
       * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0
       * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and
       * AuthorizationCodeRequest are the same.
       */
      async acquireTokenByCode(request, authCodePayLoad) {
        this.logger.info("acquireTokenByCode called");
        if (request.state && authCodePayLoad) {
          this.logger.info("acquireTokenByCode - validating state");
          this.validateState(request.state, authCodePayLoad.state || "");
          authCodePayLoad = { ...authCodePayLoad, state: "" };
        }
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const authClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri, serverTelemetryManager);
          const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
          this.logger.verbose("Auth code client created", validRequest.correlationId);
          return await authorizationCodeClient.acquireToken(validRequest, ApiId.acquireTokenByCode, authCodePayLoad);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token by exchanging the refresh token provided for a new set of tokens.
       *
       * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is
       * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will
       * handle the caching and refreshing of tokens automatically.
       */
      async acquireTokenByRefreshToken(request) {
        this.logger.info("acquireTokenByRefreshToken called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          authenticationScheme: AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const refreshTokenClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);
          const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);
          this.logger.verbose("Refresh token client created", validRequest.correlationId);
          return await refreshTokenClient.acquireToken(validRequest, ApiId.acquireTokenByRefreshToken);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token silently when a user specifies the account the token is requested for.
       *
       * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.
       * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.
       * In case the refresh_token is expired or not found, an error is thrown
       * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).
       */
      async acquireTokenSilent(request) {
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          forceRefresh: request.forceRefresh || false
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const clientConfiguration = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);
          const silentFlowClient = new SilentFlowClient(clientConfiguration);
          this.logger.verbose("Silent flow client created", validRequest.correlationId);
          try {
            await this.tokenCache.overwriteCache();
            return await this.acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration);
          } catch (error) {
            if (error instanceof ClientAuthError && error.errorCode === tokenRefreshRequired) {
              const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
              return refreshTokenClient.acquireTokenByRefreshToken(validRequest, ApiId.acquireTokenSilent);
            }
            throw error;
          }
        } catch (error) {
          if (error instanceof AuthError) {
            error.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(error);
          throw error;
        }
      }
      async acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration) {
        const [authResponse, cacheOutcome] = await silentFlowClient.acquireCachedToken({
          ...validRequest,
          scopes: validRequest.scopes?.length ? validRequest.scopes : [...OIDC_DEFAULT_SCOPES]
        });
        if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
          this.logger.info("ClientApplication:acquireCachedTokenSilent - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
          const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
          try {
            await refreshTokenClient.acquireTokenByRefreshToken(validRequest, ApiId.acquireTokenSilent);
          } catch {
          }
        }
        return authResponse;
      }
      /**
       * Acquires tokens with password grant by exchanging client applications username and password for credentials
       *
       * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.
       * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4
       * Microsoft's documentation and recommendations are at:
       * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword
       *
       * @param request - UsenamePasswordRequest
       * @deprecated - Use a more secure flow instead
       */
      async acquireTokenByUsernamePassword(request) {
        this.logger.info("acquireTokenByUsernamePassword called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request)
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
          const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);
          this.logger.verbose("Username password client created", validRequest.correlationId);
          return await usernamePasswordClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Gets the token cache for the application.
       */
      getTokenCache() {
        this.logger.info("getTokenCache called");
        return this.tokenCache;
      }
      /**
       * Validates OIDC state by comparing the user cached state with the state received from the server.
       *
       * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against
       * CSRF attacks.
       * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.
       * @param state - Unique GUID generated by the user that is cached by the user and sent to the server during the first leg of the flow
       * @param cachedState - This string is sent back by the server with the authorization code
       */
      validateState(state, cachedState) {
        if (!state) {
          throw NodeAuthError.createStateNotFoundError();
        }
        if (state !== cachedState) {
          throw createClientAuthError(stateMismatch);
        }
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.logger;
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger - Logger instance
       */
      setLogger(logger) {
        this.logger = logger;
      }
      /**
       * Builds the common configuration to be passed to the common component based on the platform configurarion
       * @param authority - user passed authority in configuration
       * @param serverTelemetryManager - initializes servertelemetry if passed
       */
      async buildOauthClientConfiguration(discoveredAuthority, requestCorrelationId, redirectUri, serverTelemetryManager) {
        this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);
        this.logger.info(`Building oauth client configuration with the following authority: ${discoveredAuthority.tokenEndpoint}.`, requestCorrelationId);
        serverTelemetryManager?.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
        const clientConfiguration = {
          authOptions: {
            clientId: this.config.auth.clientId,
            authority: discoveredAuthority,
            clientCapabilities: this.config.auth.clientCapabilities,
            redirectUri
          },
          loggerOptions: {
            logLevel: this.config.system.loggerOptions.logLevel,
            loggerCallback: this.config.system.loggerOptions.loggerCallback,
            piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
            correlationId: requestCorrelationId
          },
          cacheOptions: {
            claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled
          },
          cryptoInterface: this.cryptoProvider,
          networkInterface: this.config.system.networkClient,
          storageInterface: this.storage,
          serverTelemetryManager,
          clientCredentials: {
            clientSecret: this.clientSecret,
            clientAssertion: await this.getClientAssertion(discoveredAuthority)
          },
          libraryInfo: {
            sku: Constants.MSAL_SKU,
            version: version2,
            cpu: process.arch || Constants$1.EMPTY_STRING,
            os: process.platform || Constants$1.EMPTY_STRING
          },
          telemetry: this.config.telemetry,
          persistencePlugin: this.config.cache.cachePlugin,
          serializableCache: this.tokenCache
        };
        return clientConfiguration;
      }
      async getClientAssertion(authority) {
        if (this.developerProvidedClientAssertion) {
          this.clientAssertion = ClientAssertion.fromAssertion(await getClientAssertion(this.developerProvidedClientAssertion, this.config.auth.clientId, authority.tokenEndpoint));
        }
        return this.clientAssertion && {
          assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
          assertionType: Constants.JWT_BEARER_ASSERTION_TYPE
        };
      }
      /**
       * Generates a request with the default scopes & generates a correlationId.
       * @param authRequest - BaseAuthRequest for initialization
       */
      async initializeBaseRequest(authRequest) {
        this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);
        if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {
          this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
        }
        authRequest.authenticationScheme = AuthenticationScheme.BEARER;
        if (this.config.cache.claimsBasedCachingEnabled && authRequest.claims && // Checks for empty stringified object "{}" which doesn't qualify as requested claims
        !StringUtils.isEmptyObj(authRequest.claims)) {
          authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);
        }
        return {
          ...authRequest,
          scopes: [
            ...authRequest && authRequest.scopes || [],
            ...OIDC_DEFAULT_SCOPES
          ],
          correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),
          authority: authRequest.authority || this.config.auth.authority
        };
      }
      /**
       * Initializes the server telemetry payload
       * @param apiId - Id for a specific request
       * @param correlationId - GUID
       * @param forceRefresh - boolean to indicate network call
       */
      initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
        const telemetryPayload = {
          clientId: this.config.auth.clientId,
          correlationId,
          apiId,
          forceRefresh: forceRefresh || false
        };
        return new ServerTelemetryManager(telemetryPayload, this.storage);
      }
      /**
       * Create authority instance. If authority not passed in request, default to authority set on the application
       * object. If no authority set in application object, then default to common authority.
       * @param authorityString - authority from user configuration
       */
      async createAuthority(authorityString, requestCorrelationId, azureRegionConfiguration, azureCloudOptions) {
        this.logger.verbose("createAuthority called", requestCorrelationId);
        const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions || this.config.auth.azureCloudOptions);
        const authorityOptions = {
          protocolMode: this.config.auth.protocolMode,
          knownAuthorities: this.config.auth.knownAuthorities,
          cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
          authorityMetadata: this.config.auth.authorityMetadata,
          azureRegionConfiguration,
          skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
        };
        return createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger, requestCorrelationId);
      }
      /**
       * Clear the cache
       */
      clearCache() {
        this.storage.clear();
      }
    };
    var LoopbackClient = class {
      /**
       * Spins up a loopback server which returns the server response when the localhost redirectUri is hit
       * @param successTemplate
       * @param errorTemplate
       * @returns
       */
      async listenForAuthCode(successTemplate, errorTemplate) {
        if (this.server) {
          throw NodeAuthError.createLoopbackServerAlreadyExistsError();
        }
        return new Promise((resolve, reject) => {
          this.server = http.createServer((req, res) => {
            const url = req.url;
            if (!url) {
              res.end(errorTemplate || "Error occurred loading redirectUrl");
              reject(NodeAuthError.createUnableToLoadRedirectUrlError());
              return;
            } else if (url === Constants$1.FORWARD_SLASH) {
              res.end(successTemplate || "Auth code was successfully acquired. You can close this window now.");
              return;
            }
            const redirectUri = this.getRedirectUri();
            const parsedUrl = new URL(url, redirectUri);
            const authCodeResponse = getDeserializedResponse(parsedUrl.search) || {};
            if (authCodeResponse.code) {
              res.writeHead(HttpStatus.REDIRECT, {
                location: redirectUri
              });
              res.end();
            }
            if (authCodeResponse.error) {
              res.end(errorTemplate || `Error occurred: ${authCodeResponse.error}`);
            }
            resolve(authCodeResponse);
          });
          this.server.listen(0, "127.0.0.1");
        });
      }
      /**
       * Get the port that the loopback server is running on
       * @returns
       */
      getRedirectUri() {
        if (!this.server || !this.server.listening) {
          throw NodeAuthError.createNoLoopbackServerExistsError();
        }
        const address = this.server.address();
        if (!address || typeof address === "string" || !address.port) {
          this.closeServer();
          throw NodeAuthError.createInvalidLoopbackAddressTypeError();
        }
        const port = address && address.port;
        return `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}:${port}`;
      }
      /**
       * Close the loopback server
       */
      closeServer() {
        if (this.server) {
          this.server.close();
          if (typeof this.server.closeAllConnections === "function") {
            this.server.closeAllConnections();
          }
          this.server.unref();
          this.server = void 0;
        }
      }
    };
    var DeviceCodeClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * Gets device code from device code endpoint, calls back to with device code response, and
       * polls token endpoint to exchange device code for tokens
       * @param request - developer provided CommonDeviceCodeRequest
       */
      async acquireToken(request) {
        const deviceCodeResponse = await this.getDeviceCode(request);
        request.deviceCodeCallback(deviceCodeResponse);
        const reqTimestamp = nowSeconds();
        const response = await this.acquireTokenWithDeviceCode(request, deviceCodeResponse);
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response);
        return responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request, ApiId.acquireTokenByDeviceCode);
      }
      /**
       * Creates device code request and executes http GET
       * @param request - developer provided CommonDeviceCodeRequest
       */
      async getDeviceCode(request) {
        const queryParametersString = this.createExtraQueryParameters(request);
        const endpoint = UrlString.appendQueryString(this.authority.deviceCodeEndpoint, queryParametersString);
        const queryString = this.createQueryString(request);
        const headers = this.createTokenRequestHeaders();
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: request.authority,
          scopes: request.scopes,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid
        };
        return this.executePostRequestToDeviceCodeEndpoint(endpoint, queryString, headers, thumbprint, request.correlationId);
      }
      /**
       * Creates query string for the device code request
       * @param request - developer provided CommonDeviceCodeRequest
       */
      createExtraQueryParameters(request) {
        const parameters = /* @__PURE__ */ new Map();
        if (request.extraQueryParameters) {
          addExtraQueryParameters(parameters, request.extraQueryParameters);
        }
        return mapToQueryString(parameters);
      }
      /**
       * Executes POST request to device code endpoint
       * @param deviceCodeEndpoint - token endpoint
       * @param queryString - string to be used in the body of the request
       * @param headers - headers for the request
       * @param thumbprint - unique request thumbprint
       * @param correlationId - correlation id to be used in the request
       */
      async executePostRequestToDeviceCodeEndpoint(deviceCodeEndpoint, queryString, headers, thumbprint, correlationId) {
        const { body: { user_code: userCode, device_code: deviceCode, verification_uri: verificationUri, expires_in: expiresIn, interval, message } } = await this.sendPostRequest(thumbprint, deviceCodeEndpoint, {
          body: queryString,
          headers
        }, correlationId);
        return {
          userCode,
          deviceCode,
          verificationUri,
          expiresIn,
          interval,
          message
        };
      }
      /**
       * Create device code endpoint query parameters and returns string
       * @param request - developer provided CommonDeviceCodeRequest
       */
      createQueryString(request) {
        const parameters = /* @__PURE__ */ new Map();
        addScopes(parameters, request.scopes);
        addClientId(parameters, this.config.authOptions.clientId);
        if (request.extraQueryParameters) {
          addExtraQueryParameters(parameters, request.extraQueryParameters);
        }
        if (request.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        return mapToQueryString(parameters);
      }
      /**
       * Breaks the polling with specific conditions
       * @param deviceCodeExpirationTime - expiration time for the device code request
       * @param userSpecifiedTimeout - developer provided timeout, to be compared against deviceCodeExpirationTime
       * @param userSpecifiedCancelFlag - boolean indicating the developer would like to cancel the request
       */
      continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
        if (userSpecifiedCancelFlag) {
          this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");
          throw createClientAuthError(deviceCodePollingCancelled);
        } else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && nowSeconds() > userSpecifiedTimeout) {
          this.logger.error(`User defined timeout for device code polling reached. The timeout was set for ${userSpecifiedTimeout}`);
          throw createClientAuthError(userTimeoutReached);
        } else if (nowSeconds() > deviceCodeExpirationTime) {
          if (userSpecifiedTimeout) {
            this.logger.verbose(`User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for ${userSpecifiedTimeout}`);
          }
          this.logger.error(`Device code expired. Expiration time of device code was ${deviceCodeExpirationTime}`);
          throw createClientAuthError(deviceCodeExpired);
        }
        return true;
      }
      /**
       * Creates token request with device code response and polls token endpoint at interval set by the device code response
       * @param request - developer provided CommonDeviceCodeRequest
       * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint
       */
      async acquireTokenWithDeviceCode(request, deviceCodeResponse) {
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(this.authority.tokenEndpoint, queryParametersString);
        const requestBody = this.createTokenRequestBody(request, deviceCodeResponse);
        const headers = this.createTokenRequestHeaders();
        const userSpecifiedTimeout = request.timeout ? nowSeconds() + request.timeout : void 0;
        const deviceCodeExpirationTime = nowSeconds() + deviceCodeResponse.expiresIn;
        const pollingIntervalMilli = deviceCodeResponse.interval * 1e3;
        while (this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel)) {
          const thumbprint = {
            clientId: this.config.authOptions.clientId,
            authority: request.authority,
            scopes: request.scopes,
            claims: request.claims,
            authenticationScheme: request.authenticationScheme,
            resourceRequestMethod: request.resourceRequestMethod,
            resourceRequestUri: request.resourceRequestUri,
            shrClaims: request.shrClaims,
            sshKid: request.sshKid
          };
          const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
          if (response.body && response.body.error) {
            if (response.body.error === Constants$1.AUTHORIZATION_PENDING) {
              this.logger.info("Authorization pending. Continue polling.");
              await delay(pollingIntervalMilli);
            } else {
              this.logger.info("Unexpected error in polling from the server");
              throw createAuthError(postRequestFailed, response.body.error);
            }
          } else {
            this.logger.verbose("Authorization completed successfully. Polling stopped.");
            return response.body;
          }
        }
        this.logger.error("Polling stopped for unknown reasons.");
        throw createClientAuthError(deviceCodeUnknownError);
      }
      /**
       * Creates query parameters and converts to string.
       * @param request - developer provided CommonDeviceCodeRequest
       * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint
       */
      createTokenRequestBody(request, deviceCodeResponse) {
        const parameters = /* @__PURE__ */ new Map();
        addScopes(parameters, request.scopes);
        addClientId(parameters, this.config.authOptions.clientId);
        addGrantType(parameters, GrantType.DEVICE_CODE_GRANT);
        addDeviceCode(parameters, deviceCodeResponse.deviceCode);
        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        addCorrelationId(parameters, correlationId);
        addClientInfo(parameters);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        return mapToQueryString(parameters);
      }
    };
    var PublicClientApplication = class extends ClientApplication {
      /**
       * Important attributes in the Configuration object for auth are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.
       * - authority: the authority URL for your application.
       *
       * AAD authorities are of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
       * - If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * - If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * - To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * Azure B2C authorities are of the form https://\{instance\}/\{tenant\}/\{policy\}. Each policy is considered
       * its own authority. You will have to set the all of the knownAuthorities at the time of the client application
       * construction.
       *
       * ADFS authorities are of the form https://\{instance\}/adfs.
       */
      constructor(configuration) {
        super(configuration);
        if (this.config.broker.nativeBrokerPlugin) {
          if (this.config.broker.nativeBrokerPlugin.isBrokerAvailable) {
            this.nativeBrokerPlugin = this.config.broker.nativeBrokerPlugin;
            this.nativeBrokerPlugin.setLogger(this.config.system.loggerOptions);
          } else {
            this.logger.warning("NativeBroker implementation was provided but the broker is unavailable.");
          }
        }
        this.skus = ServerTelemetryManager.makeExtraSkuString({
          libraryName: Constants.MSAL_SKU,
          libraryVersion: version2
        });
      }
      /**
       * Acquires a token from the authority using OAuth2.0 device code flow.
       * This flow is designed for devices that do not have access to a browser or have input constraints.
       * The authorization server issues a DeviceCode object with a verification code, an end-user code,
       * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be
       * instructed to use another device to navigate to the verification URI to input credentials.
       * Since the client cannot receive incoming requests, it polls the authorization server repeatedly
       * until the end-user completes input of credentials.
       */
      async acquireTokenByDeviceCode(request) {
        this.logger.info("acquireTokenByDeviceCode called", request.correlationId);
        const validRequest = Object.assign(request, await this.initializeBaseRequest(request));
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const deviceCodeConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
          const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);
          this.logger.verbose("Device code client created", validRequest.correlationId);
          return await deviceCodeClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires a token interactively via the browser by requesting an authorization code then exchanging it for a token.
       */
      async acquireTokenInteractive(request) {
        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();
        this.logger.trace("acquireTokenInteractive called", correlationId);
        const { openBrowser, successTemplate, errorTemplate, windowHandle, loopbackClient: customLoopbackClient, ...remainingProperties } = request;
        if (this.nativeBrokerPlugin) {
          const brokerRequest = {
            ...remainingProperties,
            clientId: this.config.auth.clientId,
            scopes: request.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri: request.redirectUri || "",
            authority: request.authority || this.config.auth.authority,
            correlationId,
            extraParameters: {
              ...remainingProperties.extraQueryParameters,
              ...remainingProperties.tokenQueryParameters,
              [X_CLIENT_EXTRA_SKU]: this.skus
            },
            accountId: remainingProperties.account?.nativeAccountId
          };
          return this.nativeBrokerPlugin.acquireTokenInteractive(brokerRequest, windowHandle);
        }
        if (request.redirectUri) {
          if (!this.config.broker.nativeBrokerPlugin) {
            throw NodeAuthError.createRedirectUriNotSupportedError();
          }
          request.redirectUri = "";
        }
        const { verifier, challenge } = await this.cryptoProvider.generatePkceCodes();
        const loopbackClient = customLoopbackClient || new LoopbackClient();
        let authCodeResponse = {};
        let authCodeListenerError = null;
        try {
          const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate).then((response) => {
            authCodeResponse = response;
          }).catch((e) => {
            authCodeListenerError = e;
          });
          const redirectUri = await this.waitForRedirectUri(loopbackClient);
          const validRequest = {
            ...remainingProperties,
            correlationId,
            scopes: request.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri,
            responseMode: ResponseMode.QUERY,
            codeChallenge: challenge,
            codeChallengeMethod: CodeChallengeMethodValues.S256
          };
          const authCodeUrl = await this.getAuthCodeUrl(validRequest);
          await openBrowser(authCodeUrl);
          await authCodeListener;
          if (authCodeListenerError) {
            throw authCodeListenerError;
          }
          if (authCodeResponse.error) {
            throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);
          } else if (!authCodeResponse.code) {
            throw NodeAuthError.createNoAuthCodeInResponseError();
          }
          const clientInfo = authCodeResponse.client_info;
          const tokenRequest = {
            code: authCodeResponse.code,
            codeVerifier: verifier,
            clientInfo: clientInfo || Constants$1.EMPTY_STRING,
            ...validRequest
          };
          return await this.acquireTokenByCode(tokenRequest);
        } finally {
          loopbackClient.closeServer();
        }
      }
      /**
       * Returns a token retrieved either from the cache or by exchanging the refresh token for a fresh access token. If brokering is enabled the token request will be serviced by the broker.
       * @param request - developer provided SilentFlowRequest
       * @returns
       */
      async acquireTokenSilent(request) {
        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();
        this.logger.trace("acquireTokenSilent called", correlationId);
        if (this.nativeBrokerPlugin) {
          const brokerRequest = {
            ...request,
            clientId: this.config.auth.clientId,
            scopes: request.scopes || OIDC_DEFAULT_SCOPES,
            redirectUri: request.redirectUri || "",
            authority: request.authority || this.config.auth.authority,
            correlationId,
            extraParameters: {
              ...request.tokenQueryParameters,
              [X_CLIENT_EXTRA_SKU]: this.skus
            },
            accountId: request.account.nativeAccountId,
            forceRefresh: request.forceRefresh || false
          };
          return this.nativeBrokerPlugin.acquireTokenSilent(brokerRequest);
        }
        if (request.redirectUri) {
          if (!this.config.broker.nativeBrokerPlugin) {
            throw NodeAuthError.createRedirectUriNotSupportedError();
          }
          request.redirectUri = "";
        }
        return super.acquireTokenSilent(request);
      }
      /**
       * Removes cache artifacts associated with the given account
       * @param request - developer provided SignOutRequest
       * @returns
       */
      async signOut(request) {
        if (this.nativeBrokerPlugin && request.account.nativeAccountId) {
          const signoutRequest = {
            clientId: this.config.auth.clientId,
            accountId: request.account.nativeAccountId,
            correlationId: request.correlationId || this.cryptoProvider.createNewGuid()
          };
          await this.nativeBrokerPlugin.signOut(signoutRequest);
        }
        await this.getTokenCache().removeAccount(request.account, request.correlationId);
      }
      /**
       * Returns all cached accounts for this application. If brokering is enabled this request will be serviced by the broker.
       * @returns
       */
      async getAllAccounts() {
        if (this.nativeBrokerPlugin) {
          const correlationId = this.cryptoProvider.createNewGuid();
          return this.nativeBrokerPlugin.getAllAccounts(this.config.auth.clientId, correlationId);
        }
        return this.getTokenCache().getAllAccounts();
      }
      /**
       * Attempts to retrieve the redirectUri from the loopback server. If the loopback server does not start listening for requests within the timeout this will throw.
       * @param loopbackClient - developer provided custom loopback server implementation
       * @returns
       */
      async waitForRedirectUri(loopbackClient) {
        return new Promise((resolve, reject) => {
          let ticks = 0;
          const id = setInterval(() => {
            if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS < ticks) {
              clearInterval(id);
              reject(NodeAuthError.createLoopbackServerTimeoutError());
              return;
            }
            try {
              const r = loopbackClient.getRedirectUri();
              clearInterval(id);
              resolve(r);
              return;
            } catch (e) {
              if (e instanceof AuthError && e.errorCode === NodeAuthErrorMessage.noLoopbackServerExists.code) {
                ticks++;
                return;
              }
              clearInterval(id);
              reject(e);
              return;
            }
          }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
        });
      }
    };
    var ClientCredentialClient = class extends BaseClient {
      constructor(configuration, appTokenProvider) {
        super(configuration);
        this.appTokenProvider = appTokenProvider;
      }
      /**
       * Public API to acquire a token with ClientCredential Flow for Confidential clients
       * @param request - CommonClientCredentialRequest provided by the developer
       */
      async acquireToken(request) {
        if (request.skipCache || request.claims) {
          return this.executeTokenRequest(request, this.authority);
        }
        const [cachedAuthenticationResult, lastCacheOutcome] = await this.getCachedAuthenticationResult(request, this.config, this.cryptoUtils, this.authority, this.cacheManager, this.serverTelemetryManager);
        if (cachedAuthenticationResult) {
          if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
            this.logger.info("ClientCredentialClient:getCachedAuthenticationResult - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
            const refreshAccessToken = true;
            await this.executeTokenRequest(request, this.authority, refreshAccessToken);
          }
          return cachedAuthenticationResult;
        } else {
          return this.executeTokenRequest(request, this.authority);
        }
      }
      /**
       * looks up cache if the tokens are cached already
       */
      async getCachedAuthenticationResult(request, config, cryptoUtils, authority, cacheManager, serverTelemetryManager) {
        const clientConfiguration = config;
        const managedIdentityConfiguration = config;
        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
        let cacheContext;
        if (clientConfiguration.serializableCache && clientConfiguration.persistencePlugin) {
          cacheContext = new TokenCacheContext(clientConfiguration.serializableCache, false);
          await clientConfiguration.persistencePlugin.beforeCacheAccess(cacheContext);
        }
        const cachedAccessToken = this.readAccessTokenFromCache(authority, managedIdentityConfiguration.managedIdentityId?.id || clientConfiguration.authOptions.clientId, new ScopeSet(request.scopes || []), cacheManager, request.correlationId);
        if (clientConfiguration.serializableCache && clientConfiguration.persistencePlugin && cacheContext) {
          await clientConfiguration.persistencePlugin.afterCacheAccess(cacheContext);
        }
        if (!cachedAccessToken) {
          serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
          return [null, CacheOutcome.NO_CACHED_ACCESS_TOKEN];
        }
        if (isTokenExpired(cachedAccessToken.expiresOn, clientConfiguration.systemOptions?.tokenRenewalOffsetSeconds || DEFAULT_TOKEN_RENEWAL_OFFSET_SEC)) {
          serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
          return [null, CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED];
        }
        if (cachedAccessToken.refreshOn && isTokenExpired(cachedAccessToken.refreshOn.toString(), 0)) {
          lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
          serverTelemetryManager?.setCacheOutcome(CacheOutcome.PROACTIVELY_REFRESHED);
        }
        return [
          await ResponseHandler.generateAuthenticationResult(cryptoUtils, authority, {
            account: null,
            idToken: null,
            accessToken: cachedAccessToken,
            refreshToken: null,
            appMetadata: null
          }, true, request),
          lastCacheOutcome
        ];
      }
      /**
       * Reads access token from the cache
       */
      readAccessTokenFromCache(authority, id, scopeSet, cacheManager, correlationId) {
        const accessTokenFilter = {
          homeAccountId: Constants$1.EMPTY_STRING,
          environment: authority.canonicalAuthorityUrlComponents.HostNameAndPort,
          credentialType: CredentialType.ACCESS_TOKEN,
          clientId: id,
          realm: authority.tenant,
          target: ScopeSet.createSearchScopes(scopeSet.asArray())
        };
        const accessTokens = cacheManager.getAccessTokensByFilter(accessTokenFilter, correlationId);
        if (accessTokens.length < 1) {
          return null;
        } else if (accessTokens.length > 1) {
          throw createClientAuthError(multipleMatchingTokens);
        }
        return accessTokens[0];
      }
      /**
       * Makes a network call to request the token from the service
       * @param request - CommonClientCredentialRequest provided by the developer
       * @param authority - authority object
       */
      async executeTokenRequest(request, authority, refreshAccessToken) {
        let serverTokenResponse;
        let reqTimestamp;
        if (this.appTokenProvider) {
          this.logger.info("Using appTokenProvider extensibility.");
          const appTokenPropviderParameters = {
            correlationId: request.correlationId,
            tenantId: this.config.authOptions.authority.tenant,
            scopes: request.scopes,
            claims: request.claims
          };
          reqTimestamp = nowSeconds();
          const appTokenProviderResult = await this.appTokenProvider(appTokenPropviderParameters);
          serverTokenResponse = {
            access_token: appTokenProviderResult.accessToken,
            expires_in: appTokenProviderResult.expiresInSeconds,
            refresh_in: appTokenProviderResult.refreshInSeconds,
            token_type: AuthenticationScheme.BEARER
          };
        } else {
          const queryParametersString = this.createTokenQueryParameters(request);
          const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
          const requestBody = await this.createTokenRequestBody(request);
          const headers = this.createTokenRequestHeaders();
          const thumbprint = {
            clientId: this.config.authOptions.clientId,
            authority: request.authority,
            scopes: request.scopes,
            claims: request.claims,
            authenticationScheme: request.authenticationScheme,
            resourceRequestMethod: request.resourceRequestMethod,
            resourceRequestUri: request.resourceRequestUri,
            shrClaims: request.shrClaims,
            sshKid: request.sshKid
          };
          this.logger.info("Sending token request to endpoint: " + authority.tokenEndpoint);
          reqTimestamp = nowSeconds();
          const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
          serverTokenResponse = response.body;
          serverTokenResponse.status = response.status;
        }
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
        const tokenResponse = await responseHandler.handleServerTokenResponse(serverTokenResponse, this.authority, reqTimestamp, request, ApiId.acquireTokenByClientCredential);
        return tokenResponse;
      }
      /**
       * generate the request to the server in the acceptable format
       * @param request - CommonClientCredentialRequest provided by the developer
       */
      async createTokenRequestBody(request) {
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, this.config.authOptions.clientId);
        addScopes(parameters, request.scopes, false);
        addGrantType(parameters, GrantType.CLIENT_CREDENTIALS_GRANT);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        addCorrelationId(parameters, correlationId);
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        const clientAssertion = request.clientAssertion || this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        return mapToQueryString(parameters);
      }
    };
    var OnBehalfOfClient = class extends BaseClient {
      constructor(configuration) {
        super(configuration);
      }
      /**
       * Public API to acquire tokens with on behalf of flow
       * @param request - developer provided CommonOnBehalfOfRequest
       */
      async acquireToken(request) {
        this.scopeSet = new ScopeSet(request.scopes || []);
        this.userAssertionHash = await this.cryptoUtils.hashString(request.oboAssertion);
        if (request.skipCache || request.claims) {
          return this.executeTokenRequest(request, this.authority, this.userAssertionHash);
        }
        try {
          return await this.getCachedAuthenticationResult(request);
        } catch (e) {
          return await this.executeTokenRequest(request, this.authority, this.userAssertionHash);
        }
      }
      /**
       * look up cache for tokens
       * Find idtoken in the cache
       * Find accessToken based on user assertion and account info in the cache
       * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires
       * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session
       * @param request - developer provided CommonOnBehalfOfRequest
       */
      async getCachedAuthenticationResult(request) {
        const cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);
        if (!cachedAccessToken) {
          this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
          this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
          throw createClientAuthError(tokenRefreshRequired);
        } else if (isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
          this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
          this.logger.info(`OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`);
          throw createClientAuthError(tokenRefreshRequired);
        }
        const cachedIdToken = this.readIdTokenFromCacheForOBO(cachedAccessToken.homeAccountId, request.correlationId);
        let idTokenClaims;
        let cachedAccount = null;
        if (cachedIdToken) {
          idTokenClaims = extractTokenClaims(cachedIdToken.secret, EncodingUtils.base64Decode);
          const localAccountId = idTokenClaims.oid || idTokenClaims.sub;
          const accountInfo = {
            homeAccountId: cachedIdToken.homeAccountId,
            environment: cachedIdToken.environment,
            tenantId: cachedIdToken.realm,
            username: Constants$1.EMPTY_STRING,
            localAccountId: localAccountId || Constants$1.EMPTY_STRING
          };
          cachedAccount = this.cacheManager.getAccount(this.cacheManager.generateAccountKey(accountInfo), request.correlationId);
        }
        if (this.config.serverTelemetryManager) {
          this.config.serverTelemetryManager.incrementCacheHits();
        }
        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
          account: cachedAccount,
          accessToken: cachedAccessToken,
          idToken: cachedIdToken,
          refreshToken: null,
          appMetadata: null
        }, true, request, idTokenClaims);
      }
      /**
       * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager
       * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service
       * @param atHomeAccountId - account id
       */
      readIdTokenFromCacheForOBO(atHomeAccountId, correlationId) {
        const idTokenFilter = {
          homeAccountId: atHomeAccountId,
          environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
          credentialType: CredentialType.ID_TOKEN,
          clientId: this.config.authOptions.clientId,
          realm: this.authority.tenant
        };
        const idTokenMap = this.cacheManager.getIdTokensByFilter(idTokenFilter, correlationId);
        if (Object.values(idTokenMap).length < 1) {
          return null;
        }
        return Object.values(idTokenMap)[0];
      }
      /**
       * Fetches the cached access token based on incoming assertion
       * @param clientId - client id
       * @param request - developer provided CommonOnBehalfOfRequest
       */
      readAccessTokenFromCacheForOBO(clientId, request) {
        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
        const credentialType = authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        const accessTokenFilter = {
          credentialType,
          clientId,
          target: ScopeSet.createSearchScopes(this.scopeSet.asArray()),
          tokenType: authScheme,
          keyId: request.sshKid,
          requestedClaimsHash: request.requestedClaimsHash,
          userAssertionHash: this.userAssertionHash
        };
        const accessTokens = this.cacheManager.getAccessTokensByFilter(accessTokenFilter, request.correlationId);
        const numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          return null;
        } else if (numAccessTokens > 1) {
          throw createClientAuthError(multipleMatchingTokens);
        }
        return accessTokens[0];
      }
      /**
       * Make a network call to the server requesting credentials
       * @param request - developer provided CommonOnBehalfOfRequest
       * @param authority - authority object
       */
      async executeTokenRequest(request, authority, userAssertionHash) {
        const queryParametersString = this.createTokenQueryParameters(request);
        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
        const requestBody = await this.createTokenRequestBody(request);
        const headers = this.createTokenRequestHeaders();
        const thumbprint = {
          clientId: this.config.authOptions.clientId,
          authority: request.authority,
          scopes: request.scopes,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid
        };
        const reqTimestamp = nowSeconds();
        const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
        responseHandler.validateTokenResponse(response.body);
        const tokenResponse = await responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, ApiId.acquireTokenByOBO, void 0, userAssertionHash);
        return tokenResponse;
      }
      /**
       * generate a server request in accepable format
       * @param request - developer provided CommonOnBehalfOfRequest
       */
      async createTokenRequestBody(request) {
        const parameters = /* @__PURE__ */ new Map();
        addClientId(parameters, this.config.authOptions.clientId);
        addScopes(parameters, request.scopes);
        addGrantType(parameters, GrantType.JWT_BEARER);
        addClientInfo(parameters);
        addLibraryInfo(parameters, this.config.libraryInfo);
        addApplicationTelemetry(parameters, this.config.telemetry.application);
        addThrottling(parameters);
        if (this.serverTelemetryManager) {
          addServerTelemetry(parameters, this.serverTelemetryManager);
        }
        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        addCorrelationId(parameters, correlationId);
        addRequestTokenUse(parameters, ON_BEHALF_OF);
        addOboAssertion(parameters, request.oboAssertion);
        if (this.config.clientCredentials.clientSecret) {
          addClientSecret(parameters, this.config.clientCredentials.clientSecret);
        }
        const clientAssertion = this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
          addClientAssertionType(parameters, clientAssertion.assertionType);
        }
        if (request.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
        }
        return mapToQueryString(parameters);
      }
    };
    var ConfidentialClientApplication = class extends ClientApplication {
      /**
       * Constructor for the ConfidentialClientApplication
       *
       * Required attributes in the Configuration object are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal
       * - authority: the authority URL for your application.
       * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.
       *
       * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
       * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * In Azure B2C, authority is of the form https://\{instance\}/tfp/\{tenant\}/\{policyName\}/
       * Full B2C functionality will be available in this library in future versions.
       *
       * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance
       */
      constructor(configuration) {
        super(configuration);
        const clientSecretNotEmpty = !!this.config.auth.clientSecret;
        const clientAssertionNotEmpty = !!this.config.auth.clientAssertion;
        const certificateNotEmpty = (!!this.config.auth.clientCertificate?.thumbprint || !!this.config.auth.clientCertificate?.thumbprintSha256) && !!this.config.auth.clientCertificate?.privateKey;
        if (this.appTokenProvider) {
          return;
        }
        if (clientSecretNotEmpty && clientAssertionNotEmpty || clientAssertionNotEmpty && certificateNotEmpty || clientSecretNotEmpty && certificateNotEmpty) {
          throw createClientAuthError(invalidClientCredential);
        }
        if (this.config.auth.clientSecret) {
          this.clientSecret = this.config.auth.clientSecret;
          return;
        }
        if (this.config.auth.clientAssertion) {
          this.developerProvidedClientAssertion = this.config.auth.clientAssertion;
          return;
        }
        if (!certificateNotEmpty) {
          throw createClientAuthError(invalidClientCredential);
        } else {
          this.clientAssertion = !!this.config.auth.clientCertificate.thumbprintSha256 ? ClientAssertion.fromCertificateWithSha256Thumbprint(this.config.auth.clientCertificate.thumbprintSha256, this.config.auth.clientCertificate.privateKey, this.config.auth.clientCertificate.x5c) : ClientAssertion.fromCertificate(
            // guaranteed to be a string, due to prior error checking in this function
            this.config.auth.clientCertificate.thumbprint,
            this.config.auth.clientCertificate.privateKey,
            this.config.auth.clientCertificate.x5c
          );
        }
        this.appTokenProvider = void 0;
      }
      /**
       * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and
       * is meant for Azure SDK to enhance Managed Identity support.
       *
       * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.
       */
      SetAppTokenProvider(provider) {
        this.appTokenProvider = provider;
      }
      /**
       * Acquires tokens from the authority for the application (not for an end user).
       */
      async acquireTokenByClientCredential(request) {
        this.logger.info("acquireTokenByClientCredential called", request.correlationId);
        let clientAssertion;
        if (request.clientAssertion) {
          clientAssertion = {
            assertion: await getClientAssertion(
              request.clientAssertion,
              this.config.auth.clientId
              // tokenEndpoint will be undefined. resourceRequestUri is omitted in ClientCredentialRequest
            ),
            assertionType: Constants.JWT_BEARER_ASSERTION_TYPE
          };
        }
        const baseRequest = await this.initializeBaseRequest(request);
        const validBaseRequest = {
          ...baseRequest,
          scopes: baseRequest.scopes.filter((scope) => !OIDC_DEFAULT_SCOPES.includes(scope))
        };
        const validRequest = {
          ...request,
          ...validBaseRequest,
          clientAssertion
        };
        const authority = new UrlString(validRequest.authority);
        const tenantId = authority.getUrlComponents().PathSegments[0];
        if (Object.values(AADAuthorityConstants).includes(tenantId)) {
          throw createClientAuthError(missingTenantIdError);
        }
        const ENV_MSAL_FORCE_REGION = process.env[MSAL_FORCE_REGION];
        let region;
        if (validRequest.azureRegion !== "DisableMsalForceRegion") {
          if (!validRequest.azureRegion && ENV_MSAL_FORCE_REGION) {
            region = ENV_MSAL_FORCE_REGION;
          } else {
            region = validRequest.azureRegion;
          }
        }
        const azureRegionConfiguration = {
          azureRegion: region,
          environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, azureRegionConfiguration, request.azureCloudOptions);
          const clientCredentialConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
          const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);
          this.logger.verbose("Client credential client created", validRequest.correlationId);
          return await clientCredentialClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      /**
       * Acquires tokens from the authority for the application.
       *
       * Used in scenarios where the current app is a middle-tier service which was called with a token
       * representing an end user. The current app can use the token (oboAssertion) to request another
       * token to access downstream web API, on behalf of that user.
       *
       * The current middle-tier app has no user interaction to obtain consent.
       * See how to gain consent upfront for your middle-tier app from this article.
       * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application
       */
      async acquireTokenOnBehalfOf(request) {
        this.logger.info("acquireTokenOnBehalfOf called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request)
        };
        try {
          const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, void 0, request.azureCloudOptions);
          const onBehalfOfConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", void 0);
          const oboClient = new OnBehalfOfClient(onBehalfOfConfig);
          this.logger.verbose("On behalf of client created", validRequest.correlationId);
          return await oboClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          throw e;
        }
      }
    };
    function isIso8601(dateString) {
      if (typeof dateString !== "string") {
        return false;
      }
      const date = new Date(dateString);
      return !isNaN(date.getTime()) && date.toISOString() === dateString;
    }
    var HttpClientWithRetries = class {
      constructor(httpClientNoRetries, retryPolicy, logger) {
        this.httpClientNoRetries = httpClientNoRetries;
        this.retryPolicy = retryPolicy;
        this.logger = logger;
      }
      async sendNetworkRequestAsyncHelper(httpMethod, url, options) {
        if (httpMethod === HttpMethod.GET) {
          return this.httpClientNoRetries.sendGetRequestAsync(url, options);
        } else {
          return this.httpClientNoRetries.sendPostRequestAsync(url, options);
        }
      }
      async sendNetworkRequestAsync(httpMethod, url, options) {
        let response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);
        if ("isNewRequest" in this.retryPolicy) {
          this.retryPolicy.isNewRequest = true;
        }
        let currentRetry = 0;
        while (await this.retryPolicy.pauseForRetry(response.status, currentRetry, this.logger, response.headers[HeaderNames.RETRY_AFTER])) {
          response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);
          currentRetry++;
        }
        return response;
      }
      async sendGetRequestAsync(url, options) {
        return this.sendNetworkRequestAsync(HttpMethod.GET, url, options);
      }
      async sendPostRequestAsync(url, options) {
        return this.sendNetworkRequestAsync(HttpMethod.POST, url, options);
      }
    };
    var ManagedIdentityUserAssignedIdQueryParameterNames = {
      MANAGED_IDENTITY_CLIENT_ID_2017: "clientid",
      MANAGED_IDENTITY_CLIENT_ID: "client_id",
      MANAGED_IDENTITY_OBJECT_ID: "object_id",
      MANAGED_IDENTITY_RESOURCE_ID_IMDS: "msi_res_id",
      MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS: "mi_res_id"
    };
    var BaseManagedIdentitySource = class {
      /**
       * Creates an instance of BaseManagedIdentitySource.
       *
       * @param logger - Logger instance for diagnostic information
       * @param nodeStorage - Storage interface for caching tokens
       * @param networkClient - Network client for making HTTP requests
       * @param cryptoProvider - Cryptographic provider for token operations
       * @param disableInternalRetries - Whether to disable automatic retry logic
       */
      constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
        this.logger = logger;
        this.nodeStorage = nodeStorage;
        this.networkClient = networkClient;
        this.cryptoProvider = cryptoProvider;
        this.disableInternalRetries = disableInternalRetries;
      }
      /**
       * Processes the network response and converts it to a standardized server token response.
       * This async version allows for source-specific response processing logic while maintaining
       * backward compatibility with the synchronous version.
       *
       * @param response - The network response containing the managed identity token
       * @param _networkClient - Network client used for the request (unused in base implementation)
       * @param _networkRequest - The original network request parameters (unused in base implementation)
       * @param _networkRequestOptions - The network request options (unused in base implementation)
       *
       * @returns Promise resolving to a standardized server authorization token response
       */
      async getServerTokenResponseAsync(response, _networkClient, _networkRequest, _networkRequestOptions) {
        return this.getServerTokenResponse(response);
      }
      /**
       * Converts a managed identity token response to a standardized server authorization token response.
       * Handles time format conversion, expiration calculation, and error mapping to ensure
       * compatibility with the MSAL response handling pipeline.
       *
       * @param response - The network response containing the managed identity token
       *
       * @returns Standardized server authorization token response with normalized fields
       */
      getServerTokenResponse(response) {
        let refreshIn, expiresIn;
        if (response.body.expires_on) {
          if (isIso8601(response.body.expires_on)) {
            response.body.expires_on = new Date(response.body.expires_on).getTime() / 1e3;
          }
          expiresIn = response.body.expires_on - nowSeconds();
          if (expiresIn > 2 * 3600) {
            refreshIn = expiresIn / 2;
          }
        }
        const serverTokenResponse = {
          status: response.status,
          // success
          access_token: response.body.access_token,
          expires_in: expiresIn,
          scope: response.body.resource,
          token_type: response.body.token_type,
          refresh_in: refreshIn,
          // error
          correlation_id: response.body.correlation_id || response.body.correlationId,
          error: typeof response.body.error === "string" ? response.body.error : response.body.error?.code,
          error_description: response.body.message || (typeof response.body.error === "string" ? response.body.error_description : response.body.error?.message),
          error_codes: response.body.error_codes,
          timestamp: response.body.timestamp,
          trace_id: response.body.trace_id
        };
        return serverTokenResponse;
      }
      /**
       * Acquires an access token using the managed identity endpoint for the specified resource.
       * This is the primary method for token acquisition, handling the complete flow from
       * request creation through response processing and token caching.
       *
       * @param managedIdentityRequest - The managed identity request containing resource and optional parameters
       * @param managedIdentityId - The managed identity configuration (system or user-assigned)
       * @param fakeAuthority - Authority instance used for token caching (managed identity uses a placeholder authority)
       * @param refreshAccessToken - Whether this is a token refresh operation
       *
       * @returns Promise resolving to an authentication result containing the access token and metadata
       *
       * @throws {AuthError} When network requests fail or token validation fails
       * @throws {ClientAuthError} When network errors occur during the request
       */
      async acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
        const networkRequest = this.createRequest(managedIdentityRequest.resource, managedIdentityId);
        if (managedIdentityRequest.revokedTokenSha256Hash) {
          this.logger.info(`[Managed Identity] The following claims are present in the request: ${managedIdentityRequest.claims}`);
          networkRequest.queryParameters[ManagedIdentityQueryParameters.SHA256_TOKEN_TO_REFRESH] = managedIdentityRequest.revokedTokenSha256Hash;
        }
        if (managedIdentityRequest.clientCapabilities?.length) {
          const clientCapabilities = managedIdentityRequest.clientCapabilities.toString();
          this.logger.info(`[Managed Identity] The following client capabilities are present in the request: ${clientCapabilities}`);
          networkRequest.queryParameters[ManagedIdentityQueryParameters.XMS_CC] = clientCapabilities;
        }
        const headers = networkRequest.headers;
        headers[HeaderNames.CONTENT_TYPE] = Constants$1.URL_FORM_CONTENT_TYPE;
        const networkRequestOptions = { headers };
        if (Object.keys(networkRequest.bodyParameters).length) {
          networkRequestOptions.body = networkRequest.computeParametersBodyString();
        }
        const networkClientHelper = this.disableInternalRetries ? this.networkClient : new HttpClientWithRetries(this.networkClient, networkRequest.retryPolicy, this.logger);
        const reqTimestamp = nowSeconds();
        let response;
        try {
          if (networkRequest.httpMethod === HttpMethod.POST) {
            response = await networkClientHelper.sendPostRequestAsync(networkRequest.computeUri(), networkRequestOptions);
          } else {
            response = await networkClientHelper.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);
          }
        } catch (error) {
          if (error instanceof AuthError) {
            throw error;
          } else {
            throw createClientAuthError(networkError);
          }
        }
        const responseHandler = new ResponseHandler(managedIdentityId.id, this.nodeStorage, this.cryptoProvider, this.logger, null, null);
        const serverTokenResponse = await this.getServerTokenResponseAsync(response, networkClientHelper, networkRequest, networkRequestOptions);
        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
        return responseHandler.handleServerTokenResponse(serverTokenResponse, fakeAuthority, reqTimestamp, managedIdentityRequest, ApiId.acquireTokenWithManagedIdentity);
      }
      /**
       * Determines the appropriate query parameter name for user-assigned managed identity
       * based on the identity type, API version, and endpoint characteristics.
       * Different Azure services and API versions use different parameter names for the same identity types.
       *
       * @param managedIdentityIdType - The type of user-assigned managed identity (client ID, object ID, or resource ID)
       * @param isImds - Whether the request is being made to the IMDS (Instance Metadata Service) endpoint
       * @param usesApi2017 - Whether the endpoint uses the 2017-09-01 API version (affects client ID parameter name)
       *
       * @returns The correct query parameter name for the specified identity type and endpoint
       *
       * @throws {ManagedIdentityError} When an invalid managed identity ID type is provided
       */
      getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityIdType, isImds, usesApi2017) {
        switch (managedIdentityIdType) {
          case ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID:
            this.logger.info(`[Managed Identity] [API version ${usesApi2017 ? "2017+" : "2019+"}] Adding user assigned client id to the request.`);
            return usesApi2017 ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID_2017 : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID;
          case ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID:
            this.logger.info("[Managed Identity] Adding user assigned resource id to the request.");
            return isImds ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_IMDS : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS;
          case ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID:
            this.logger.info("[Managed Identity] Adding user assigned object id to the request.");
            return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_OBJECT_ID;
          default:
            throw createManagedIdentityError(invalidManagedIdentityIdType);
        }
      }
    };
    BaseManagedIdentitySource.getValidatedEnvVariableUrlString = (envVariableStringName, envVariable, sourceName, logger) => {
      try {
        return new UrlString(envVariable).urlString;
      } catch (error) {
        logger.info(`[Managed Identity] ${sourceName} managed identity is unavailable because the '${envVariableStringName}' environment variable is malformed.`);
        throw createManagedIdentityError(MsiEnvironmentVariableUrlMalformedErrorCodes[envVariableStringName]);
      }
    };
    var LinearRetryStrategy = class {
      /**
       * Calculates the number of milliseconds to sleep based on the `retry-after` HTTP header.
       *
       * @param retryHeader - The value of the `retry-after` HTTP header. This can be either a number of seconds
       *                      or an HTTP date string.
       * @returns The number of milliseconds to sleep before retrying the request. If the `retry-after` header is not
       *          present or cannot be parsed, returns 0.
       */
      calculateDelay(retryHeader, minimumDelay) {
        if (!retryHeader) {
          return minimumDelay;
        }
        let millisToSleep = Math.round(parseFloat(retryHeader) * 1e3);
        if (isNaN(millisToSleep)) {
          millisToSleep = new Date(retryHeader).valueOf() - (/* @__PURE__ */ new Date()).valueOf();
        }
        return Math.max(minimumDelay, millisToSleep);
      }
    };
    var DEFAULT_MANAGED_IDENTITY_MAX_RETRIES = 3;
    var DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS = 1e3;
    var DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON = [
      msalCommon.HttpStatus.NOT_FOUND,
      msalCommon.HttpStatus.REQUEST_TIMEOUT,
      msalCommon.HttpStatus.TOO_MANY_REQUESTS,
      msalCommon.HttpStatus.SERVER_ERROR,
      msalCommon.HttpStatus.SERVICE_UNAVAILABLE,
      msalCommon.HttpStatus.GATEWAY_TIMEOUT
    ];
    var DefaultManagedIdentityRetryPolicy = class _DefaultManagedIdentityRetryPolicy {
      constructor() {
        this.linearRetryStrategy = new LinearRetryStrategy();
      }
      /*
       * this is defined here as a static variable despite being defined as a constant outside of the
       * class because it needs to be overridden in the unit tests so that the unit tests run faster
       */
      static get DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS() {
        return DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS;
      }
      async pauseForRetry(httpStatusCode, currentRetry, logger, retryAfterHeader) {
        if (DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON.includes(httpStatusCode) && currentRetry < DEFAULT_MANAGED_IDENTITY_MAX_RETRIES) {
          const retryAfterDelay = this.linearRetryStrategy.calculateDelay(retryAfterHeader, _DefaultManagedIdentityRetryPolicy.DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS);
          logger.verbose(`Retrying request in ${retryAfterDelay}ms (retry attempt: ${currentRetry + 1})`);
          await new Promise((resolve) => {
            return setTimeout(resolve, retryAfterDelay);
          });
          return true;
        }
        return false;
      }
    };
    var ManagedIdentityRequestParameters = class {
      constructor(httpMethod, endpoint, retryPolicy) {
        this.httpMethod = httpMethod;
        this._baseEndpoint = endpoint;
        this.headers = {};
        this.bodyParameters = {};
        this.queryParameters = {};
        this.retryPolicy = retryPolicy || new DefaultManagedIdentityRetryPolicy();
      }
      computeUri() {
        const parameters = /* @__PURE__ */ new Map();
        if (this.queryParameters) {
          addExtraQueryParameters(parameters, this.queryParameters);
        }
        const queryParametersString = mapToQueryString(parameters);
        return UrlString.appendQueryString(this._baseEndpoint, queryParametersString);
      }
      computeParametersBodyString() {
        const parameters = /* @__PURE__ */ new Map();
        if (this.bodyParameters) {
          addExtraQueryParameters(parameters, this.bodyParameters);
        }
        return mapToQueryString(parameters);
      }
    };
    var APP_SERVICE_MSI_API_VERSION = "2019-08-01";
    var AppService = class _AppService extends BaseManagedIdentitySource {
      /**
       * Creates a new instance of the AppService managed identity source.
       *
       * @param logger - Logger instance for diagnostic output
       * @param nodeStorage - Node.js storage implementation for caching
       * @param networkClient - Network client for making HTTP requests
       * @param cryptoProvider - Cryptographic operations provider
       * @param disableInternalRetries - Whether to disable internal retry logic
       * @param identityEndpoint - The App Service identity endpoint URL
       * @param identityHeader - The secret header value required for authentication
       */
      constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader) {
        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
        this.identityEndpoint = identityEndpoint;
        this.identityHeader = identityHeader;
      }
      /**
       * Retrieves the required environment variables for App Service managed identity.
       *
       * App Service managed identity requires two environment variables:
       * - IDENTITY_ENDPOINT: The URL of the local metadata service
       * - IDENTITY_HEADER: A secret header value for authentication
       *
       * @returns An array containing [identityEndpoint, identityHeader] values from environment variables.
       *          Either value may be undefined if the environment variable is not set.
       */
      static getEnvironmentVariables() {
        const identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];
        const identityHeader = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER];
        return [identityEndpoint, identityHeader];
      }
      /**
       * Attempts to create an AppService managed identity source if the environment supports it.
       *
       * This method checks for the presence of required environment variables and validates
       * the identity endpoint URL. If the environment is not suitable for App Service managed
       * identity (missing environment variables or invalid endpoint), it returns null.
       *
       * @param logger - Logger instance for diagnostic output
       * @param nodeStorage - Node.js storage implementation for caching
       * @param networkClient - Network client for making HTTP requests
       * @param cryptoProvider - Cryptographic operations provider
       * @param disableInternalRetries - Whether to disable internal retry logic
       *
       * @returns A new AppService instance if the environment is suitable, null otherwise
       */
      static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
        const [identityEndpoint, identityHeader] = _AppService.getEnvironmentVariables();
        if (!identityEndpoint || !identityHeader) {
          logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.APP_SERVICE} managed identity is unavailable because one or both of the '${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}' and '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variables are not defined.`);
          return null;
        }
        const validatedIdentityEndpoint = _AppService.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, ManagedIdentitySourceNames.APP_SERVICE, logger);
        logger.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.APP_SERVICE} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.APP_SERVICE} managed identity.`);
        return new _AppService(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader);
      }
      /**
       * Creates a managed identity token request for the App Service environment.
       *
       * This method constructs an HTTP GET request to the App Service identity endpoint
       * with the required headers, query parameters, and managed identity configuration.
       * The request includes the secret header for authentication and appropriate API version.
       *
       * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
       * @param managedIdentityId - The managed identity configuration specifying whether to use system-assigned or user-assigned identity
       *
       * @returns A configured ManagedIdentityRequestParameters object ready for network execution
       */
      createRequest(resource, managedIdentityId) {
        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);
        request.headers[ManagedIdentityHeaders.APP_SERVICE_SECRET_HEADER_NAME] = this.identityHeader;
        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] = APP_SERVICE_MSI_API_VERSION;
        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] = resource;
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType)] = managedIdentityId.id;
        }
        return request;
      }
    };
    var ARC_API_VERSION = "2019-11-01";
    var DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT = "http://127.0.0.1:40342/metadata/identity/oauth2/token";
    var HIMDS_EXECUTABLE_HELPER_STRING = "N/A: himds executable exists";
    var SUPPORTED_AZURE_ARC_PLATFORMS = {
      win32: `${process.env["ProgramData"]}\\AzureConnectedMachineAgent\\Tokens\\`,
      linux: "/var/opt/azcmagent/tokens/"
    };
    var AZURE_ARC_FILE_DETECTION = {
      win32: `${process.env["ProgramFiles"]}\\AzureConnectedMachineAgent\\himds.exe`,
      linux: "/opt/azcmagent/bin/himds"
    };
    var AzureArc = class _AzureArc extends BaseManagedIdentitySource {
      /**
       * Creates a new instance of the AzureArc managed identity source.
       *
       * @param logger - Logger instance for capturing telemetry and diagnostic information
       * @param nodeStorage - Storage implementation for caching tokens and metadata
       * @param networkClient - Network client for making HTTP requests to the identity endpoint
       * @param cryptoProvider - Cryptographic operations provider for token validation and encryption
       * @param disableInternalRetries - Flag to disable automatic retry logic for failed requests
       * @param identityEndpoint - The Azure Arc identity endpoint URL for token requests
       */
      constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint) {
        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
        this.identityEndpoint = identityEndpoint;
      }
      /**
       * Retrieves and validates Azure Arc environment variables for managed identity configuration.
       *
       * This method checks for IDENTITY_ENDPOINT and IMDS_ENDPOINT environment variables.
       * If either is missing, it attempts to detect the Azure Arc environment by checking for
       * the HIMDS executable at platform-specific paths. On successful detection, it returns
       * the default identity endpoint and a helper string indicating file-based detection.
       *
       * @returns An array containing [identityEndpoint, imdsEndpoint] where both values are
       *          strings if Azure Arc is available, or undefined if not available.
       */
      static getEnvironmentVariables() {
        let identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];
        let imdsEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT];
        if (!identityEndpoint || !imdsEndpoint) {
          const fileDetectionPath = AZURE_ARC_FILE_DETECTION[process.platform];
          try {
            fs6.accessSync(fileDetectionPath, fs6.constants.F_OK | fs6.constants.R_OK);
            identityEndpoint = DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT;
            imdsEndpoint = HIMDS_EXECUTABLE_HELPER_STRING;
          } catch (err) {
          }
        }
        return [identityEndpoint, imdsEndpoint];
      }
      /**
       * Attempts to create an AzureArc managed identity source instance.
       *
       * Validates the Azure Arc environment by checking environment variables
       * and performing file-based detection. It ensures that only system-assigned managed identities
       * are supported for Azure Arc scenarios. The method performs comprehensive validation of
       * endpoint URLs and logs detailed information about the detection process.
       *
       * @param logger - Logger instance for capturing creation and validation steps
       * @param nodeStorage - Storage implementation for the managed identity source
       * @param networkClient - Network client for HTTP communication
       * @param cryptoProvider - Cryptographic operations provider
       * @param disableInternalRetries - Whether to disable automatic retry mechanisms
       * @param managedIdentityId - The managed identity configuration, must be system-assigned
       *
       * @returns AzureArc instance if the environment supports Azure Arc managed identity, null otherwise
       *
       * @throws {ManagedIdentityError} When a user-assigned managed identity is specified (not supported for Azure Arc)
       */
      static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {
        const [identityEndpoint, imdsEndpoint] = _AzureArc.getEnvironmentVariables();
        if (!identityEndpoint || !imdsEndpoint) {
          logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is unavailable through environment variables because one or both of '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' and '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' are not defined. ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is also unavailable through file detection.`);
          return null;
        }
        if (imdsEndpoint === HIMDS_EXECUTABLE_HELPER_STRING) {
          logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is available through file detection. Defaulting to known ${ManagedIdentitySourceNames.AZURE_ARC} endpoint: ${DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT}. Creating ${ManagedIdentitySourceNames.AZURE_ARC} managed identity.`);
        } else {
          const validatedIdentityEndpoint = _AzureArc.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, ManagedIdentitySourceNames.AZURE_ARC, logger);
          validatedIdentityEndpoint.endsWith("/") ? validatedIdentityEndpoint.slice(0, -1) : validatedIdentityEndpoint;
          _AzureArc.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT, imdsEndpoint, ManagedIdentitySourceNames.AZURE_ARC, logger);
          logger.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.AZURE_ARC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.AZURE_ARC} managed identity.`);
        }
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          throw createManagedIdentityError(unableToCreateAzureArc);
        }
        return new _AzureArc(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint);
      }
      /**
       * Creates a properly formatted HTTP request for acquiring tokens from the Azure Arc identity endpoint.
       *
       * This method constructs a GET request to the Azure Arc HIMDS endpoint with the required metadata header
       * and query parameters. The endpoint URL is normalized to use 127.0.0.1 instead of localhost for
       * consistency. Additional body parameters are calculated by the base class during token acquisition.
       *
       * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
       *
       * @returns A configured ManagedIdentityRequestParameters object ready for network execution
       */
      createRequest(resource) {
        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint.replace("localhost", "127.0.0.1"));
        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";
        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] = ARC_API_VERSION;
        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] = resource;
        return request;
      }
      /**
       * Processes the server response and handles Azure Arc-specific authentication challenges.
       *
       * This method implements the Azure Arc authentication flow which may require reading a secret file
       * for authorization. When the initial request returns HTTP 401 Unauthorized, it extracts the file
       * path from the WWW-Authenticate header, validates the file location and size, reads the secret,
       * and retries the request with Basic authentication. The method includes comprehensive security
       * validations to prevent path traversal and ensure file integrity.
       *
       * @param originalResponse - The initial HTTP response from the identity endpoint
       * @param networkClient - Network client for making the retry request if needed
       * @param networkRequest - The original request parameters (modified with auth header for retry)
       * @param networkRequestOptions - Additional options for network requests
       *
       * @returns A promise that resolves to the server token response with access token and metadata
       *
       * @throws {ManagedIdentityError} When:
       *   - WWW-Authenticate header is missing or has unsupported format
       *   - Platform is not supported (not Windows or Linux)
       *   - Secret file has invalid extension (not .key)
       *   - Secret file path doesn't match expected platform path
       *   - Secret file cannot be read or is too large (>4096 bytes)
       * @throws {ClientAuthError} When network errors occur during retry request
       */
      async getServerTokenResponseAsync(originalResponse, networkClient, networkRequest, networkRequestOptions) {
        let retryResponse;
        if (originalResponse.status === HttpStatus.UNAUTHORIZED) {
          const wwwAuthHeader = originalResponse.headers["www-authenticate"];
          if (!wwwAuthHeader) {
            throw createManagedIdentityError(wwwAuthenticateHeaderMissing);
          }
          if (!wwwAuthHeader.includes("Basic realm=")) {
            throw createManagedIdentityError(wwwAuthenticateHeaderUnsupportedFormat);
          }
          const secretFilePath = wwwAuthHeader.split("Basic realm=")[1];
          if (!SUPPORTED_AZURE_ARC_PLATFORMS.hasOwnProperty(process.platform)) {
            throw createManagedIdentityError(platformNotSupported);
          }
          const expectedSecretFilePath = SUPPORTED_AZURE_ARC_PLATFORMS[process.platform];
          const fileName = path2.basename(secretFilePath);
          if (!fileName.endsWith(".key")) {
            throw createManagedIdentityError(invalidFileExtension);
          }
          if (expectedSecretFilePath + fileName !== secretFilePath) {
            throw createManagedIdentityError(invalidFilePath);
          }
          let secretFileSize;
          try {
            secretFileSize = await fs6.statSync(secretFilePath).size;
          } catch (e) {
            throw createManagedIdentityError(unableToReadSecretFile);
          }
          if (secretFileSize > AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES) {
            throw createManagedIdentityError(invalidSecret);
          }
          let secret;
          try {
            secret = fs6.readFileSync(secretFilePath, EncodingTypes.UTF8);
          } catch (e) {
            throw createManagedIdentityError(unableToReadSecretFile);
          }
          const authHeaderValue = `Basic ${secret}`;
          this.logger.info(`[Managed Identity] Adding authorization header to the request.`);
          networkRequest.headers[ManagedIdentityHeaders.AUTHORIZATION_HEADER_NAME] = authHeaderValue;
          try {
            retryResponse = await networkClient.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);
          } catch (error) {
            if (error instanceof AuthError) {
              throw error;
            } else {
              throw createClientAuthError(networkError);
            }
          }
        }
        return this.getServerTokenResponse(retryResponse || originalResponse);
      }
    };
    var CloudShell = class _CloudShell extends BaseManagedIdentitySource {
      /**
       * Creates a new CloudShell managed identity source instance.
       *
       * @param logger - Logger instance for diagnostic logging
       * @param nodeStorage - Node.js storage implementation for caching
       * @param networkClient - HTTP client for making requests to the managed identity endpoint
       * @param cryptoProvider - Cryptographic operations provider
       * @param disableInternalRetries - Whether to disable automatic retry logic for failed requests
       * @param msiEndpoint - The MSI endpoint URL obtained from environment variables
       */
      constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint) {
        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
        this.msiEndpoint = msiEndpoint;
      }
      /**
       * Retrieves the required environment variables for Cloud Shell managed identity.
       *
       * Cloud Shell requires the MSI_ENDPOINT environment variable to be set, which
       * contains the URL of the managed identity service endpoint.
       *
       * @returns An array containing the MSI_ENDPOINT environment variable value (or undefined if not set)
       */
      static getEnvironmentVariables() {
        const msiEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT];
        return [msiEndpoint];
      }
      /**
       * Attempts to create a CloudShell managed identity source instance.
       *
       * This method validates that the required environment variables are present and
       * creates a CloudShell instance if the environment is properly configured.
       * Cloud Shell only supports system-assigned managed identities.
       *
       * @param logger - Logger instance for diagnostic logging
       * @param nodeStorage - Node.js storage implementation for caching
       * @param networkClient - HTTP client for making requests
       * @param cryptoProvider - Cryptographic operations provider
       * @param disableInternalRetries - Whether to disable automatic retry logic
       * @param managedIdentityId - The managed identity configuration (must be system-assigned)
       *
       * @returns A CloudShell instance if the environment is valid, null otherwise
       *
       * @throws {ManagedIdentityError} When a user-assigned managed identity is requested,
       *         as Cloud Shell only supports system-assigned identities
       */
      static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {
        const [msiEndpoint] = _CloudShell.getEnvironmentVariables();
        if (!msiEndpoint) {
          logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity is unavailable because the '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT} environment variable is not defined.`);
          return null;
        }
        const validatedMsiEndpoint = _CloudShell.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT, msiEndpoint, ManagedIdentitySourceNames.CLOUD_SHELL, logger);
        logger.info(`[Managed Identity] Environment variable validation passed for ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity. Endpoint URI: ${validatedMsiEndpoint}. Creating ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity.`);
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          throw createManagedIdentityError(unableToCreateCloudShell);
        }
        return new _CloudShell(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint);
      }
      /**
       * Creates an HTTP request to acquire an access token from the Cloud Shell managed identity endpoint.
       *
       * This method constructs a POST request to the MSI endpoint with the required headers and
       * body parameters for Cloud Shell authentication. The request includes the target resource
       * for which the access token is being requested.
       *
       * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
       *
       * @returns A configured ManagedIdentityRequestParameters object ready for network execution
       */
      createRequest(resource) {
        const request = new ManagedIdentityRequestParameters(HttpMethod.POST, this.msiEndpoint);
        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";
        request.bodyParameters[ManagedIdentityQueryParameters.RESOURCE] = resource;
        return request;
      }
    };
    var ExponentialRetryStrategy = class {
      constructor(minExponentialBackoff, maxExponentialBackoff, exponentialDeltaBackoff) {
        this.minExponentialBackoff = minExponentialBackoff;
        this.maxExponentialBackoff = maxExponentialBackoff;
        this.exponentialDeltaBackoff = exponentialDeltaBackoff;
      }
      /**
       * Calculates the exponential delay based on the current retry attempt.
       *
       * @param {number} currentRetry - The current retry attempt number.
       * @returns {number} - The calculated exponential delay in milliseconds.
       *
       * The delay is calculated using the formula:
       * - If `currentRetry` is 0, it returns the minimum backoff time.
       * - Otherwise, it calculates the delay as the minimum of:
       *   - `(2^(currentRetry - 1)) * deltaBackoff`
       *   - `maxBackoff`
       *
       * This ensures that the delay increases exponentially with each retry attempt,
       * but does not exceed the maximum backoff time.
       */
      calculateDelay(currentRetry) {
        if (currentRetry === 0) {
          return this.minExponentialBackoff;
        }
        const exponentialDelay = Math.min(Math.pow(2, currentRetry - 1) * this.exponentialDeltaBackoff, this.maxExponentialBackoff);
        return exponentialDelay;
      }
    };
    var HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY = [
      msalCommon.HttpStatus.NOT_FOUND,
      msalCommon.HttpStatus.REQUEST_TIMEOUT,
      msalCommon.HttpStatus.GONE,
      msalCommon.HttpStatus.TOO_MANY_REQUESTS
    ];
    var EXPONENTIAL_STRATEGY_NUM_RETRIES = 3;
    var LINEAR_STRATEGY_NUM_RETRIES = 7;
    var MIN_EXPONENTIAL_BACKOFF_MS = 1e3;
    var MAX_EXPONENTIAL_BACKOFF_MS = 4e3;
    var EXPONENTIAL_DELTA_BACKOFF_MS = 2e3;
    var HTTP_STATUS_GONE_RETRY_AFTER_MS = 10 * 1e3;
    var ImdsRetryPolicy = class _ImdsRetryPolicy {
      constructor() {
        this.exponentialRetryStrategy = new ExponentialRetryStrategy(_ImdsRetryPolicy.MIN_EXPONENTIAL_BACKOFF_MS, _ImdsRetryPolicy.MAX_EXPONENTIAL_BACKOFF_MS, _ImdsRetryPolicy.EXPONENTIAL_DELTA_BACKOFF_MS);
      }
      /*
       * these are defined here as static variables despite being defined as constants outside of the
       * class because they need to be overridden in the unit tests so that the unit tests run faster
       */
      static get MIN_EXPONENTIAL_BACKOFF_MS() {
        return MIN_EXPONENTIAL_BACKOFF_MS;
      }
      static get MAX_EXPONENTIAL_BACKOFF_MS() {
        return MAX_EXPONENTIAL_BACKOFF_MS;
      }
      static get EXPONENTIAL_DELTA_BACKOFF_MS() {
        return EXPONENTIAL_DELTA_BACKOFF_MS;
      }
      static get HTTP_STATUS_GONE_RETRY_AFTER_MS() {
        return HTTP_STATUS_GONE_RETRY_AFTER_MS;
      }
      set isNewRequest(value) {
        this._isNewRequest = value;
      }
      /**
       * Pauses execution for a calculated delay before retrying a request.
       *
       * @param httpStatusCode - The HTTP status code of the response.
       * @param currentRetry - The current retry attempt number.
       * @param retryAfterHeader - The value of the "retry-after" header from the response.
       * @returns A promise that resolves to a boolean indicating whether a retry should be attempted.
       */
      async pauseForRetry(httpStatusCode, currentRetry, logger) {
        if (this._isNewRequest) {
          this._isNewRequest = false;
          this.maxRetries = httpStatusCode === msalCommon.HttpStatus.GONE ? LINEAR_STRATEGY_NUM_RETRIES : EXPONENTIAL_STRATEGY_NUM_RETRIES;
        }
        if ((HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY.includes(httpStatusCode) || httpStatusCode >= msalCommon.HttpStatus.SERVER_ERROR_RANGE_START && httpStatusCode <= msalCommon.HttpStatus.SERVER_ERROR_RANGE_END && currentRetry < this.maxRetries) && currentRetry < this.maxRetries) {
          const retryAfterDelay = httpStatusCode === msalCommon.HttpStatus.GONE ? _ImdsRetryPolicy.HTTP_STATUS_GONE_RETRY_AFTER_MS : this.exponentialRetryStrategy.calculateDelay(currentRetry);
          logger.verbose(`Retrying request in ${retryAfterDelay}ms (retry attempt: ${currentRetry + 1})`);
          await new Promise((resolve) => {
            return setTimeout(resolve, retryAfterDelay);
          });
          return true;
        }
        return false;
      }
    };
    var IMDS_TOKEN_PATH = "/metadata/identity/oauth2/token";
    var DEFAULT_IMDS_ENDPOINT = `http://169.254.169.254${IMDS_TOKEN_PATH}`;
    var IMDS_API_VERSION = "2018-02-01";
    var Imds = class _Imds extends BaseManagedIdentitySource {
      /**
       * Constructs an Imds instance with the specified configuration.
       *
       * @param logger - Logger instance for recording debug information and errors
       * @param nodeStorage - NodeStorage instance used for token caching operations
       * @param networkClient - Network client implementation for making HTTP requests to IMDS
       * @param cryptoProvider - CryptoProvider for generating correlation IDs and other cryptographic operations
       * @param disableInternalRetries - When true, disables the built-in retry logic for IMDS requests
       * @param identityEndpoint - The complete IMDS endpoint URL including the token path
       */
      constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint) {
        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
        this.identityEndpoint = identityEndpoint;
      }
      /**
       * Creates an Imds instance with the appropriate endpoint configuration.
       *
       * This method checks for the presence of the AZURE_POD_IDENTITY_AUTHORITY_HOST environment
       * variable, which is used in Azure Kubernetes Service (AKS) environments with Azure AD
       * Pod Identity. If found, it uses that endpoint; otherwise, it falls back to the standard
       * IMDS endpoint (169.254.169.254).
       *
       * @param logger - Logger instance for recording endpoint discovery and validation
       * @param nodeStorage - NodeStorage instance for token caching
       * @param networkClient - Network client for HTTP requests
       * @param cryptoProvider - CryptoProvider for cryptographic operations
       * @param disableInternalRetries - Whether to disable built-in retry logic
       *
       * @returns A configured Imds instance ready to make token requests
       */
      static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
        let validatedIdentityEndpoint;
        if (process.env[ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]) {
          logger.info(`[Managed Identity] Environment variable ${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST} for ${ManagedIdentitySourceNames.IMDS} returned endpoint: ${process.env[ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]}`);
          validatedIdentityEndpoint = _Imds.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST, `${process.env[ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]}${IMDS_TOKEN_PATH}`, ManagedIdentitySourceNames.IMDS, logger);
        } else {
          logger.info(`[Managed Identity] Unable to find ${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST} environment variable for ${ManagedIdentitySourceNames.IMDS}, using the default endpoint.`);
          validatedIdentityEndpoint = DEFAULT_IMDS_ENDPOINT;
        }
        return new _Imds(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, validatedIdentityEndpoint);
      }
      /**
       * Creates a properly configured HTTP request for acquiring an access token from IMDS.
       *
       * This method builds a complete request object with all necessary headers, query parameters,
       * and retry policies required by the Azure Instance Metadata Service.
       *
       * Key request components:
       * - HTTP GET method to the IMDS token endpoint
       * - Metadata header set to "true" (required by IMDS)
       * - API version parameter (currently "2018-02-01")
       * - Resource parameter specifying the target audience
       * - Identity-specific parameters for user-assigned managed identities
       * - IMDS-specific retry policy
       *
       * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
       * @param managedIdentityId - The managed identity configuration specifying whether to use system-assigned or user-assigned identity
       *
       * @returns A configured ManagedIdentityRequestParameters object ready for network execution
       */
      createRequest(resource, managedIdentityId) {
        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);
        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";
        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] = IMDS_API_VERSION;
        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] = resource;
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(
            managedIdentityId.idType,
            true
            // indicates source is IMDS
          )] = managedIdentityId.id;
        }
        request.retryPolicy = new ImdsRetryPolicy();
        return request;
      }
    };
    var SERVICE_FABRIC_MSI_API_VERSION = "2019-07-01-preview";
    var ServiceFabric = class _ServiceFabric extends BaseManagedIdentitySource {
      /**
       * Constructs a new ServiceFabric managed identity source for acquiring tokens from Azure Service Fabric clusters.
       *
       * Service Fabric managed identity allows applications running in Service Fabric clusters to authenticate
       * without storing credentials in code. This source handles token acquisition using the Service Fabric
       * Managed Identity Token Service (MITS).
       *
       * @param logger - Logger instance for logging authentication events and debugging information
       * @param nodeStorage - NodeStorage instance for caching tokens and other authentication artifacts
       * @param networkClient - Network client for making HTTP requests to the Service Fabric identity endpoint
       * @param cryptoProvider - Crypto provider for cryptographic operations like token validation
       * @param disableInternalRetries - Whether to disable internal retry logic for failed requests
       * @param identityEndpoint - The Service Fabric managed identity endpoint URL
       * @param identityHeader - The Service Fabric managed identity secret header value
       */
      constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader) {
        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
        this.identityEndpoint = identityEndpoint;
        this.identityHeader = identityHeader;
      }
      /**
       * Retrieves the environment variables required for Service Fabric managed identity authentication.
       *
       * Service Fabric managed identity requires three specific environment variables to be set by the
       * Service Fabric runtime:
       * - IDENTITY_ENDPOINT: The endpoint URL for the Managed Identity Token Service (MITS)
       * - IDENTITY_HEADER: A secret value used for authentication with the MITS
       * - IDENTITY_SERVER_THUMBPRINT: The thumbprint of the MITS server certificate for secure communication
       *
       * @returns An array containing the identity endpoint, identity header, and identity server thumbprint values.
       *          Elements will be undefined if the corresponding environment variables are not set.
       */
      static getEnvironmentVariables() {
        const identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];
        const identityHeader = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER];
        const identityServerThumbprint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_SERVER_THUMBPRINT];
        return [identityEndpoint, identityHeader, identityServerThumbprint];
      }
      /**
       * Attempts to create a ServiceFabric managed identity source if the runtime environment supports it.
       *
       * Checks for the presence of all required Service Fabric environment variables
       * and validates the endpoint URL format. It will only create a ServiceFabric instance if the application
       * is running in a properly configured Service Fabric cluster with managed identity enabled.
       *
       * Note: User-assigned managed identities must be configured at the cluster level, not at runtime.
       * This method will log a warning if a user-assigned identity is requested.
       *
       * @param logger - Logger instance for logging creation events and validation results
       * @param nodeStorage - NodeStorage instance for caching tokens and authentication artifacts
       * @param networkClient - Network client for making HTTP requests to the identity endpoint
       * @param cryptoProvider - Crypto provider for cryptographic operations
       * @param disableInternalRetries - Whether to disable internal retry logic for failed requests
       * @param managedIdentityId - Managed identity identifier specifying system-assigned or user-assigned identity
       *
       * @returns A ServiceFabric instance if all environment variables are valid and present, otherwise null
       */
      static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {
        const [identityEndpoint, identityHeader, identityServerThumbprint] = _ServiceFabric.getEnvironmentVariables();
        if (!identityEndpoint || !identityHeader || !identityServerThumbprint) {
          logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity is unavailable because one or all of the '${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}', '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' or '${ManagedIdentityEnvironmentVariableNames.IDENTITY_SERVER_THUMBPRINT}' environment variables are not defined.`);
          return null;
        }
        const validatedIdentityEndpoint = _ServiceFabric.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, ManagedIdentitySourceNames.SERVICE_FABRIC, logger);
        logger.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity.`);
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          logger.warning(`[Managed Identity] ${ManagedIdentitySourceNames.SERVICE_FABRIC} user assigned managed identity is configured in the cluster, not during runtime. See also: https://learn.microsoft.com/en-us/azure/service-fabric/configure-existing-cluster-enable-managed-identity-token-service.`);
        }
        return new _ServiceFabric(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader);
      }
      /**
       * Creates HTTP request parameters for acquiring an access token from the Service Fabric Managed Identity Token Service (MITS).
       *
       * This method constructs a properly formatted HTTP GET request that includes:
       * - The secret header for authentication with MITS
       * - API version parameter for the Service Fabric MSI endpoint
       * - Resource parameter specifying the target Azure service
       * - Optional identity parameters for user-assigned managed identities
       *
       * The request follows the Service Fabric managed identity protocol and uses the 2019-07-01-preview API version.
       * For user-assigned identities, the appropriate query parameter (client_id, object_id, or resource_id) is added
       * based on the identity type.
       *
       * @param resource - The Azure resource URI for which the access token is requested (e.g., "https://vault.azure.net/")
       * @param managedIdentityId - The managed identity configuration specifying system-assigned or user-assigned identity details
       *
       * @returns A configured ManagedIdentityRequestParameters object ready for network execution
       */
      createRequest(resource, managedIdentityId) {
        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);
        request.headers[ManagedIdentityHeaders.ML_AND_SF_SECRET_HEADER_NAME] = this.identityHeader;
        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] = SERVICE_FABRIC_MSI_API_VERSION;
        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] = resource;
        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType)] = managedIdentityId.id;
        }
        return request;
      }
    };
    var MACHINE_LEARNING_MSI_API_VERSION = "2017-09-01";
    var MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR = `Only client id is supported for user-assigned managed identity in ${ManagedIdentitySourceNames.MACHINE_LEARNING}.`;
    var MachineLearning = class _MachineLearning extends BaseManagedIdentitySource {
      /**
       * Creates a new MachineLearning managed identity source instance.
       *
       * @param logger - Logger instance for diagnostic information
       * @param nodeStorage - Node storage implementation for caching
       * @param networkClient - Network client for making HTTP requests
       * @param cryptoProvider - Cryptographic operations provider
       * @param disableInternalRetries - Whether to disable automatic request retries
       * @param msiEndpoint - The MSI endpoint URL from environment variables
       * @param secret - The MSI secret from environment variables
       */
      constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint, secret) {
        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
        this.msiEndpoint = msiEndpoint;
        this.secret = secret;
      }
      /**
       * Retrieves the required environment variables for Azure Machine Learning managed identity.
       *
       * This method checks for the presence of MSI_ENDPOINT and MSI_SECRET environment variables
       * that are automatically set by the Azure Machine Learning platform when managed identity
       * is enabled for the compute instance or cluster.
       *
       * @returns An array containing [msiEndpoint, secret] where either value may be undefined
       *          if the corresponding environment variable is not set
       */
      static getEnvironmentVariables() {
        const msiEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT];
        const secret = process.env[ManagedIdentityEnvironmentVariableNames.MSI_SECRET];
        return [msiEndpoint, secret];
      }
      /**
       * Attempts to create a MachineLearning managed identity source.
       *
       * This method validates the Azure Machine Learning environment by checking for the required
       * MSI_ENDPOINT and MSI_SECRET environment variables. If both are present and valid,
       * it creates and returns a MachineLearning instance. If either is missing or invalid,
       * it returns null, indicating that this managed identity source is not available
       * in the current environment.
       *
       * @param logger - Logger instance for diagnostic information
       * @param nodeStorage - Node storage implementation for caching
       * @param networkClient - Network client for making HTTP requests
       * @param cryptoProvider - Cryptographic operations provider
       * @param disableInternalRetries - Whether to disable automatic request retries
       *
       * @returns A new MachineLearning instance if the environment is valid, null otherwise
       */
      static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
        const [msiEndpoint, secret] = _MachineLearning.getEnvironmentVariables();
        if (!msiEndpoint || !secret) {
          logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity is unavailable because one or both of the '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' and '${ManagedIdentityEnvironmentVariableNames.MSI_SECRET}' environment variables are not defined.`);
          return null;
        }
        const validatedMsiEndpoint = _MachineLearning.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT, msiEndpoint, ManagedIdentitySourceNames.MACHINE_LEARNING, logger);
        logger.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity. Endpoint URI: ${validatedMsiEndpoint}. Creating ${ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity.`);
        return new _MachineLearning(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint, secret);
      }
      /**
       * Creates a managed identity token request for Azure Machine Learning environments.
       *
       * This method constructs the HTTP request parameters needed to acquire an access token
       * from the Azure Machine Learning managed identity endpoint. It handles both system-assigned
       * and user-assigned managed identities with specific logic for each type:
       *
       * - System-assigned: Uses the DEFAULT_IDENTITY_CLIENT_ID environment variable
       * - User-assigned: Only supports client ID-based identification (not object ID or resource ID)
       *
       * The request uses the 2017-09-01 API version and includes the required secret header
       * for authentication with the MSI endpoint.
       *
       * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
       * @param managedIdentityId - The managed identity configuration specifying whether to use system-assigned or user-assigned identity
       *
       * @returns A configured ManagedIdentityRequestParameters object ready for network execution
       *
       * @throws Error if an unsupported managed identity ID type is specified (only client ID is supported for user-assigned)
       */
      createRequest(resource, managedIdentityId) {
        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.msiEndpoint);
        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";
        request.headers[ManagedIdentityHeaders.ML_AND_SF_SECRET_HEADER_NAME] = this.secret;
        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] = MACHINE_LEARNING_MSI_API_VERSION;
        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] = resource;
        if (managedIdentityId.idType === ManagedIdentityIdType.SYSTEM_ASSIGNED) {
          request.queryParameters[ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID_2017] = process.env[ManagedIdentityEnvironmentVariableNames.DEFAULT_IDENTITY_CLIENT_ID];
        } else if (managedIdentityId.idType === ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID) {
          request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(
            managedIdentityId.idType,
            false,
            // isIMDS
            true
            // uses2017API
          )] = managedIdentityId.id;
        } else {
          throw new Error(MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR);
        }
        return request;
      }
    };
    var ManagedIdentityClient = class _ManagedIdentityClient {
      constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
        this.logger = logger;
        this.nodeStorage = nodeStorage;
        this.networkClient = networkClient;
        this.cryptoProvider = cryptoProvider;
        this.disableInternalRetries = disableInternalRetries;
      }
      async sendManagedIdentityTokenRequest(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
        if (!_ManagedIdentityClient.identitySource) {
          _ManagedIdentityClient.identitySource = this.selectManagedIdentitySource(this.logger, this.nodeStorage, this.networkClient, this.cryptoProvider, this.disableInternalRetries, managedIdentityId);
        }
        return _ManagedIdentityClient.identitySource.acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken);
      }
      allEnvironmentVariablesAreDefined(environmentVariables) {
        return Object.values(environmentVariables).every((environmentVariable) => {
          return environmentVariable !== void 0;
        });
      }
      /**
       * Determine the Managed Identity Source based on available environment variables. This API is consumed by ManagedIdentityApplication's getManagedIdentitySource.
       * @returns ManagedIdentitySourceNames - The Managed Identity source's name
       */
      getManagedIdentitySource() {
        _ManagedIdentityClient.sourceName = this.allEnvironmentVariablesAreDefined(ServiceFabric.getEnvironmentVariables()) ? ManagedIdentitySourceNames.SERVICE_FABRIC : this.allEnvironmentVariablesAreDefined(AppService.getEnvironmentVariables()) ? ManagedIdentitySourceNames.APP_SERVICE : this.allEnvironmentVariablesAreDefined(MachineLearning.getEnvironmentVariables()) ? ManagedIdentitySourceNames.MACHINE_LEARNING : this.allEnvironmentVariablesAreDefined(CloudShell.getEnvironmentVariables()) ? ManagedIdentitySourceNames.CLOUD_SHELL : this.allEnvironmentVariablesAreDefined(AzureArc.getEnvironmentVariables()) ? ManagedIdentitySourceNames.AZURE_ARC : ManagedIdentitySourceNames.DEFAULT_TO_IMDS;
        return _ManagedIdentityClient.sourceName;
      }
      /**
       * Tries to create a managed identity source for all sources
       * @returns the managed identity Source
       */
      selectManagedIdentitySource(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {
        const source = ServiceFabric.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) || AppService.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) || MachineLearning.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) || CloudShell.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) || AzureArc.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) || Imds.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
        if (!source) {
          throw createManagedIdentityError(unableToCreateSource);
        }
        return source;
      }
    };
    var SOURCES_THAT_SUPPORT_TOKEN_REVOCATION = [ManagedIdentitySourceNames.SERVICE_FABRIC];
    var ManagedIdentityApplication = class _ManagedIdentityApplication {
      constructor(configuration) {
        this.config = buildManagedIdentityConfiguration(configuration || {});
        this.logger = new Logger(this.config.system.loggerOptions, name, version2);
        const fakeStatusAuthorityOptions = {
          canonicalAuthority: Constants$1.DEFAULT_AUTHORITY
        };
        if (!_ManagedIdentityApplication.nodeStorage) {
          _ManagedIdentityApplication.nodeStorage = new NodeStorage(this.logger, this.config.managedIdentityId.id, DEFAULT_CRYPTO_IMPLEMENTATION, fakeStatusAuthorityOptions);
        }
        this.networkClient = this.config.system.networkClient;
        this.cryptoProvider = new CryptoProvider();
        const fakeAuthorityOptions = {
          protocolMode: ProtocolMode.AAD,
          knownAuthorities: [DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY],
          cloudDiscoveryMetadata: "",
          authorityMetadata: ""
        };
        this.fakeAuthority = new Authority(
          DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY,
          this.networkClient,
          _ManagedIdentityApplication.nodeStorage,
          fakeAuthorityOptions,
          this.logger,
          this.cryptoProvider.createNewGuid(),
          // correlationID
          void 0,
          true
        );
        this.fakeClientCredentialClient = new ClientCredentialClient({
          authOptions: {
            clientId: this.config.managedIdentityId.id,
            authority: this.fakeAuthority
          }
        });
        this.managedIdentityClient = new ManagedIdentityClient(this.logger, _ManagedIdentityApplication.nodeStorage, this.networkClient, this.cryptoProvider, this.config.disableInternalRetries);
        this.hashUtils = new HashUtils();
      }
      /**
       * Acquire an access token from the cache or the managed identity
       * @param managedIdentityRequest - the ManagedIdentityRequestParams object passed in by the developer
       * @returns the access token
       */
      async acquireToken(managedIdentityRequestParams) {
        if (!managedIdentityRequestParams.resource) {
          throw createClientConfigurationError(urlEmptyError);
        }
        const managedIdentityRequest = {
          forceRefresh: managedIdentityRequestParams.forceRefresh,
          resource: managedIdentityRequestParams.resource.replace("/.default", ""),
          scopes: [
            managedIdentityRequestParams.resource.replace("/.default", "")
          ],
          authority: this.fakeAuthority.canonicalAuthority,
          correlationId: this.cryptoProvider.createNewGuid(),
          claims: managedIdentityRequestParams.claims,
          clientCapabilities: this.config.clientCapabilities
        };
        if (managedIdentityRequest.forceRefresh) {
          return this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);
        }
        const [cachedAuthenticationResult, lastCacheOutcome] = await this.fakeClientCredentialClient.getCachedAuthenticationResult(managedIdentityRequest, this.config, this.cryptoProvider, this.fakeAuthority, _ManagedIdentityApplication.nodeStorage);
        if (managedIdentityRequest.claims) {
          const sourceName = this.managedIdentityClient.getManagedIdentitySource();
          if (cachedAuthenticationResult && SOURCES_THAT_SUPPORT_TOKEN_REVOCATION.includes(sourceName)) {
            const revokedTokenSha256Hash = this.hashUtils.sha256(cachedAuthenticationResult.accessToken).toString(EncodingTypes.HEX);
            managedIdentityRequest.revokedTokenSha256Hash = revokedTokenSha256Hash;
          }
          return this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);
        }
        if (cachedAuthenticationResult) {
          if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
            this.logger.info("ClientCredentialClient:getCachedAuthenticationResult - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
            const refreshAccessToken = true;
            await this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority, refreshAccessToken);
          }
          return cachedAuthenticationResult;
        } else {
          return this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);
        }
      }
      /**
       * Acquires a token from a managed identity endpoint.
       *
       * @param managedIdentityRequest - The request object containing parameters for the managed identity token request.
       * @param managedIdentityId - The identifier for the managed identity (e.g., client ID or resource ID).
       * @param fakeAuthority - A placeholder authority used for the token request.
       * @param refreshAccessToken - Optional flag indicating whether to force a refresh of the access token.
       * @returns A promise that resolves to an AuthenticationResult containing the acquired token and related information.
       */
      async acquireTokenFromManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
        return this.managedIdentityClient.sendManagedIdentityTokenRequest(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken);
      }
      /**
       * Determine the Managed Identity Source based on available environment variables. This API is consumed by Azure Identity SDK.
       * @returns ManagedIdentitySourceNames - The Managed Identity source's name
       */
      getManagedIdentitySource() {
        return ManagedIdentityClient.sourceName || this.managedIdentityClient.getManagedIdentitySource();
      }
    };
    var DistributedCachePlugin = class {
      constructor(client, partitionManager) {
        this.client = client;
        this.partitionManager = partitionManager;
      }
      /**
       * Deserializes the cache before accessing it
       * @param cacheContext - TokenCacheContext
       */
      async beforeCacheAccess(cacheContext) {
        const partitionKey = await this.partitionManager.getKey();
        const cacheData = await this.client.get(partitionKey);
        cacheContext.tokenCache.deserialize(cacheData);
      }
      /**
       * Serializes the cache after accessing it
       * @param cacheContext - TokenCacheContext
       */
      async afterCacheAccess(cacheContext) {
        if (cacheContext.cacheHasChanged) {
          const kvStore = cacheContext.tokenCache.getKVStore();
          const accountEntities = Object.values(kvStore).filter((value) => AccountEntity.isAccountEntity(value));
          let partitionKey;
          if (accountEntities.length > 0) {
            const accountEntity = accountEntities[0];
            partitionKey = await this.partitionManager.extractKey(accountEntity);
          } else {
            partitionKey = await this.partitionManager.getKey();
          }
          await this.client.set(partitionKey, cacheContext.tokenCache.serialize());
        }
      }
    };
    exports2.AuthError = AuthError;
    exports2.AuthErrorCodes = AuthErrorCodes;
    exports2.AuthErrorMessage = AuthErrorMessage;
    exports2.AzureCloudInstance = AzureCloudInstance;
    exports2.ClientApplication = ClientApplication;
    exports2.ClientAssertion = ClientAssertion;
    exports2.ClientAuthError = ClientAuthError;
    exports2.ClientAuthErrorCodes = ClientAuthErrorCodes;
    exports2.ClientAuthErrorMessage = ClientAuthErrorMessage;
    exports2.ClientConfigurationError = ClientConfigurationError;
    exports2.ClientConfigurationErrorCodes = ClientConfigurationErrorCodes;
    exports2.ClientConfigurationErrorMessage = ClientConfigurationErrorMessage;
    exports2.ClientCredentialClient = ClientCredentialClient;
    exports2.ConfidentialClientApplication = ConfidentialClientApplication;
    exports2.CryptoProvider = CryptoProvider;
    exports2.DeviceCodeClient = DeviceCodeClient;
    exports2.DistributedCachePlugin = DistributedCachePlugin;
    exports2.InteractionRequiredAuthError = InteractionRequiredAuthError;
    exports2.InteractionRequiredAuthErrorCodes = InteractionRequiredAuthErrorCodes;
    exports2.InteractionRequiredAuthErrorMessage = InteractionRequiredAuthErrorMessage;
    exports2.Logger = Logger;
    exports2.ManagedIdentityApplication = ManagedIdentityApplication;
    exports2.ManagedIdentitySourceNames = ManagedIdentitySourceNames;
    exports2.OnBehalfOfClient = OnBehalfOfClient;
    exports2.PromptValue = PromptValue;
    exports2.ProtocolMode = ProtocolMode;
    exports2.PublicClientApplication = PublicClientApplication;
    exports2.ResponseMode = ResponseMode;
    exports2.ServerError = ServerError;
    exports2.TokenCache = TokenCache;
    exports2.TokenCacheContext = TokenCacheContext;
    exports2.UsernamePasswordClient = UsernamePasswordClient;
    exports2.internals = internals;
    exports2.version = version2;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/random.js
var require_random = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/random.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRandomIntegerInclusive = getRandomIntegerInclusive;
    function getRandomIntegerInclusive(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      const offset = Math.floor(Math.random() * (max - min + 1));
      return offset + min;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/delay.js
var require_delay = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/delay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateRetryDelay = calculateRetryDelay;
    var random_js_1 = require_random();
    function calculateRetryDelay(retryAttempt, config) {
      const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
      const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
      const retryAfterInMs = clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
      return { retryAfterInMs };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/object.js
var require_object = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isObject = isObject;
    function isObject(input) {
      return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/error.js
var require_error2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isError = isError;
    var object_js_1 = require_object();
    function isError(e) {
      if ((0, object_js_1.isObject)(e)) {
        const hasName = typeof e.name === "string";
        const hasMessage = typeof e.message === "string";
        return hasName && hasMessage;
      }
      return false;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sha256.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeSha256Hmac = computeSha256Hmac;
    exports2.computeSha256Hash = computeSha256Hash;
    var node_crypto_1 = require("node:crypto");
    async function computeSha256Hmac(key, stringToSign, encoding) {
      const decodedKey = Buffer.from(key, "base64");
      return (0, node_crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
    }
    async function computeSha256Hash(content, encoding) {
      return (0, node_crypto_1.createHash)("sha256").update(content).digest(encoding);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/uuidUtils.js
var require_uuidUtils = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/uuidUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomUUID = randomUUID;
    function randomUUID() {
      return crypto.randomUUID();
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/checkEnvironment.js
var require_checkEnvironment = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/checkEnvironment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isReactNative = exports2.isNodeRuntime = exports2.isNodeLike = exports2.isBun = exports2.isDeno = exports2.isWebWorker = exports2.isBrowser = void 0;
    exports2.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    exports2.isWebWorker = typeof self === "object" && typeof self?.importScripts === "function" && (self.constructor?.name === "DedicatedWorkerGlobalScope" || self.constructor?.name === "ServiceWorkerGlobalScope" || self.constructor?.name === "SharedWorkerGlobalScope");
    exports2.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    exports2.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    exports2.isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean(globalThis.process.versions?.node);
    exports2.isNodeRuntime = exports2.isNodeLike && !exports2.isBun && !exports2.isDeno;
    exports2.isReactNative = typeof navigator !== "undefined" && navigator?.product === "ReactNative";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/bytesEncoding.js
var require_bytesEncoding = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/bytesEncoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uint8ArrayToString = uint8ArrayToString;
    exports2.stringToUint8Array = stringToUint8Array;
    function uint8ArrayToString(bytes, format) {
      return Buffer.from(bytes).toString(format);
    }
    function stringToUint8Array(value, format) {
      return Buffer.from(value, format);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sanitizer.js
var require_sanitizer = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sanitizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Sanitizer = void 0;
    var object_js_1 = require_object();
    var RedactedString = "REDACTED";
    var defaultAllowedHeaderNames = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    var defaultAllowedQueryParameters = ["api-version"];
    var Sanitizer = class {
      allowedHeaderNames;
      allowedQueryParameters;
      constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      /**
       * Sanitizes an object for logging.
       * @param obj - The object to sanitize
       * @returns - The sanitized object as a string
       */
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return {
              ...value,
              name: value.name,
              message: value.message
            };
          }
          if (key === "headers") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || (0, object_js_1.isObject)(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      /**
       * Sanitizes a URL for logging.
       * @param value - The URL to sanitize
       * @returns - The sanitized URL as a string
       */
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null || value === "") {
          return value;
        }
        const url = new URL(value);
        if (!url.search) {
          return value;
        }
        for (const [key] of url.searchParams) {
          if (!this.allowedQueryParameters.has(key.toLowerCase())) {
            url.searchParams.set(key, RedactedString);
          }
        }
        return url.toString();
      }
      sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
          if (this.allowedHeaderNames.has(key.toLowerCase())) {
            sanitized[key] = obj[key];
          } else {
            sanitized[key] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (this.allowedQueryParameters.has(k.toLowerCase())) {
            sanitized[k] = value[k];
          } else {
            sanitized[k] = RedactedString;
          }
        }
        return sanitized;
      }
    };
    exports2.Sanitizer = Sanitizer;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/internal.js
var require_internal2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/internal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Sanitizer = exports2.uint8ArrayToString = exports2.stringToUint8Array = exports2.isWebWorker = exports2.isReactNative = exports2.isDeno = exports2.isNodeRuntime = exports2.isNodeLike = exports2.isBun = exports2.isBrowser = exports2.randomUUID = exports2.computeSha256Hmac = exports2.computeSha256Hash = exports2.isError = exports2.isObject = exports2.getRandomIntegerInclusive = exports2.calculateRetryDelay = void 0;
    var delay_js_1 = require_delay();
    Object.defineProperty(exports2, "calculateRetryDelay", { enumerable: true, get: function() {
      return delay_js_1.calculateRetryDelay;
    } });
    var random_js_1 = require_random();
    Object.defineProperty(exports2, "getRandomIntegerInclusive", { enumerable: true, get: function() {
      return random_js_1.getRandomIntegerInclusive;
    } });
    var object_js_1 = require_object();
    Object.defineProperty(exports2, "isObject", { enumerable: true, get: function() {
      return object_js_1.isObject;
    } });
    var error_js_1 = require_error2();
    Object.defineProperty(exports2, "isError", { enumerable: true, get: function() {
      return error_js_1.isError;
    } });
    var sha256_js_1 = require_sha256();
    Object.defineProperty(exports2, "computeSha256Hash", { enumerable: true, get: function() {
      return sha256_js_1.computeSha256Hash;
    } });
    Object.defineProperty(exports2, "computeSha256Hmac", { enumerable: true, get: function() {
      return sha256_js_1.computeSha256Hmac;
    } });
    var uuidUtils_js_1 = require_uuidUtils();
    Object.defineProperty(exports2, "randomUUID", { enumerable: true, get: function() {
      return uuidUtils_js_1.randomUUID;
    } });
    var checkEnvironment_js_1 = require_checkEnvironment();
    Object.defineProperty(exports2, "isBrowser", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isBrowser;
    } });
    Object.defineProperty(exports2, "isBun", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isBun;
    } });
    Object.defineProperty(exports2, "isNodeLike", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isNodeLike;
    } });
    Object.defineProperty(exports2, "isNodeRuntime", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isNodeRuntime;
    } });
    Object.defineProperty(exports2, "isDeno", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isDeno;
    } });
    Object.defineProperty(exports2, "isReactNative", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isReactNative;
    } });
    Object.defineProperty(exports2, "isWebWorker", { enumerable: true, get: function() {
      return checkEnvironment_js_1.isWebWorker;
    } });
    var bytesEncoding_js_1 = require_bytesEncoding();
    Object.defineProperty(exports2, "stringToUint8Array", { enumerable: true, get: function() {
      return bytesEncoding_js_1.stringToUint8Array;
    } });
    Object.defineProperty(exports2, "uint8ArrayToString", { enumerable: true, get: function() {
      return bytesEncoding_js_1.uint8ArrayToString;
    } });
    var sanitizer_js_1 = require_sanitizer();
    Object.defineProperty(exports2, "Sanitizer", { enumerable: true, get: function() {
      return sanitizer_js_1.Sanitizer;
    } });
  }
});

// node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/aborterUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cancelablePromiseRace = cancelablePromiseRace;
    async function cancelablePromiseRace(abortablePromiseBuilders, options) {
      const aborter = new AbortController();
      function abortHandler() {
        aborter.abort();
      }
      options?.abortSignal?.addEventListener("abort", abortHandler);
      try {
        return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
      } finally {
        aborter.abort();
        options?.abortSignal?.removeEventListener("abort", abortHandler);
      }
    }
  }
});

// node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError = __commonJS({
  "node_modules/@azure/abort-controller/dist/commonjs/AbortError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbortError = void 0;
    var AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError;
  }
});

// node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs3 = __commonJS({
  "node_modules/@azure/abort-controller/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbortError = void 0;
    var AbortError_js_1 = require_AbortError();
    Object.defineProperty(exports2, "AbortError", { enumerable: true, get: function() {
      return AbortError_js_1.AbortError;
    } });
  }
});

// node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createAbortablePromise = createAbortablePromise;
    var abort_controller_1 = require_commonjs3();
    function createAbortablePromise(buildPromise, options) {
      const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options ?? {};
      return new Promise((resolve, reject) => {
        function rejectOnAbort() {
          reject(new abort_controller_1.AbortError(abortErrorMsg ?? "The operation was aborted."));
        }
        function removeListeners() {
          abortSignal?.removeEventListener("abort", onAbort);
        }
        function onAbort() {
          cleanupBeforeAbort?.();
          removeListeners();
          rejectOnAbort();
        }
        if (abortSignal?.aborted) {
          return rejectOnAbort();
        }
        try {
          buildPromise((x) => {
            removeListeners();
            resolve(x);
          }, (x) => {
            removeListeners();
            reject(x);
          });
        } catch (err) {
          reject(err);
        }
        abortSignal?.addEventListener("abort", onAbort);
      });
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay2 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/delay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delay = delay;
    exports2.calculateRetryDelay = calculateRetryDelay;
    var createAbortablePromise_js_1 = require_createAbortablePromise();
    var util_1 = require_internal2();
    var StandardAbortMessage = "The delay was aborted.";
    function delay(timeInMs, options) {
      let token;
      const { abortSignal, abortErrorMsg } = options ?? {};
      return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
        token = setTimeout(resolve, timeInMs);
      }, {
        cleanupBeforeAbort: () => clearTimeout(token),
        abortSignal,
        abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
      });
    }
    function calculateRetryDelay(retryAttempt, config) {
      const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
      const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
      const retryAfterInMs = clampedDelay / 2 + (0, util_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
      return { retryAfterInMs };
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/error.js
var require_error3 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getErrorMessage = getErrorMessage;
    var util_1 = require_internal2();
    function getErrorMessage(e) {
      if ((0, util_1.isError)(e)) {
        return e.message;
      } else {
        let stringified;
        try {
          if (typeof e === "object" && e) {
            stringified = JSON.stringify(e);
          } else {
            stringified = String(e);
          }
        } catch (err) {
          stringified = "[unable to stringify input]";
        }
        return `Unknown error ${stringified}`;
      }
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/typeGuards.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDefined = isDefined;
    exports2.isObjectWithProperties = isObjectWithProperties;
    exports2.objectHasProperty = objectHasProperty;
    function isDefined(thing) {
      return typeof thing !== "undefined" && thing !== null;
    }
    function isObjectWithProperties(thing, properties) {
      if (!isDefined(thing) || typeof thing !== "object") {
        return false;
      }
      for (const property of properties) {
        if (!objectHasProperty(thing, property)) {
          return false;
        }
      }
      return true;
    }
    function objectHasProperty(thing, property) {
      return isDefined(thing) && typeof thing === "object" && property in thing;
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs4 = __commonJS({
  "node_modules/@azure/core-util/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWebWorker = exports2.isReactNative = exports2.isNodeRuntime = exports2.isNodeLike = exports2.isNode = exports2.isDeno = exports2.isBun = exports2.isBrowser = exports2.objectHasProperty = exports2.isObjectWithProperties = exports2.isDefined = exports2.getErrorMessage = exports2.delay = exports2.createAbortablePromise = exports2.cancelablePromiseRace = void 0;
    exports2.calculateRetryDelay = calculateRetryDelay;
    exports2.computeSha256Hash = computeSha256Hash;
    exports2.computeSha256Hmac = computeSha256Hmac;
    exports2.getRandomIntegerInclusive = getRandomIntegerInclusive;
    exports2.isError = isError;
    exports2.isObject = isObject;
    exports2.randomUUID = randomUUID;
    exports2.uint8ArrayToString = uint8ArrayToString;
    exports2.stringToUint8Array = stringToUint8Array;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var tspRuntime = tslib_1.__importStar(require_internal2());
    var aborterUtils_js_1 = require_aborterUtils();
    Object.defineProperty(exports2, "cancelablePromiseRace", { enumerable: true, get: function() {
      return aborterUtils_js_1.cancelablePromiseRace;
    } });
    var createAbortablePromise_js_1 = require_createAbortablePromise();
    Object.defineProperty(exports2, "createAbortablePromise", { enumerable: true, get: function() {
      return createAbortablePromise_js_1.createAbortablePromise;
    } });
    var delay_js_1 = require_delay2();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_js_1.delay;
    } });
    var error_js_1 = require_error3();
    Object.defineProperty(exports2, "getErrorMessage", { enumerable: true, get: function() {
      return error_js_1.getErrorMessage;
    } });
    var typeGuards_js_1 = require_typeGuards();
    Object.defineProperty(exports2, "isDefined", { enumerable: true, get: function() {
      return typeGuards_js_1.isDefined;
    } });
    Object.defineProperty(exports2, "isObjectWithProperties", { enumerable: true, get: function() {
      return typeGuards_js_1.isObjectWithProperties;
    } });
    Object.defineProperty(exports2, "objectHasProperty", { enumerable: true, get: function() {
      return typeGuards_js_1.objectHasProperty;
    } });
    function calculateRetryDelay(retryAttempt, config) {
      return tspRuntime.calculateRetryDelay(retryAttempt, config);
    }
    function computeSha256Hash(content, encoding) {
      return tspRuntime.computeSha256Hash(content, encoding);
    }
    function computeSha256Hmac(key, stringToSign, encoding) {
      return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
    }
    function getRandomIntegerInclusive(min, max) {
      return tspRuntime.getRandomIntegerInclusive(min, max);
    }
    function isError(e) {
      return tspRuntime.isError(e);
    }
    function isObject(input) {
      return tspRuntime.isObject(input);
    }
    function randomUUID() {
      return tspRuntime.randomUUID();
    }
    exports2.isBrowser = tspRuntime.isBrowser;
    exports2.isBun = tspRuntime.isBun;
    exports2.isDeno = tspRuntime.isDeno;
    exports2.isNode = tspRuntime.isNodeLike;
    exports2.isNodeLike = tspRuntime.isNodeLike;
    exports2.isNodeRuntime = tspRuntime.isNodeRuntime;
    exports2.isReactNative = tspRuntime.isReactNative;
    exports2.isWebWorker = tspRuntime.isWebWorker;
    function uint8ArrayToString(bytes, format) {
      return tspRuntime.uint8ArrayToString(bytes, format);
    }
    function stringToUint8Array(value, format) {
      return tspRuntime.stringToUint8Array(value, format);
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/msal/msal.js
var require_msal = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/msal/msal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.msalCommon = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var msalCommon = tslib_1.__importStar(require_msal_node());
    exports2.msalCommon = msalCommon;
  }
});

// node_modules/@azure/identity/dist/commonjs/msal/utils.js
var require_utils3 = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/msal/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultLoggerCallback = void 0;
    exports2.ensureValidMsalToken = ensureValidMsalToken;
    exports2.getAuthorityHost = getAuthorityHost;
    exports2.getAuthority = getAuthority;
    exports2.getKnownAuthorities = getKnownAuthorities;
    exports2.getMSALLogLevel = getMSALLogLevel;
    exports2.randomUUID = randomUUID;
    exports2.handleMsalError = handleMsalError;
    exports2.publicToMsal = publicToMsal;
    exports2.msalToPublic = msalToPublic;
    exports2.serializeAuthenticationRecord = serializeAuthenticationRecord;
    exports2.deserializeAuthenticationRecord = deserializeAuthenticationRecord;
    var errors_js_1 = require_errors();
    var logging_js_1 = require_logging();
    var constants_js_1 = require_constants();
    var core_util_1 = require_commonjs4();
    var abort_controller_1 = require_commonjs3();
    var msal_js_1 = require_msal();
    var logger = (0, logging_js_1.credentialLogger)("IdentityUtils");
    var LatestAuthenticationRecordVersion = "1.0";
    function ensureValidMsalToken(scopes, msalToken, getTokenOptions) {
      const error = (message) => {
        logger.getToken.info(message);
        return new errors_js_1.AuthenticationRequiredError({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          getTokenOptions,
          message
        });
      };
      if (!msalToken) {
        throw error("No response");
      }
      if (!msalToken.expiresOn) {
        throw error(`Response had no "expiresOn" property.`);
      }
      if (!msalToken.accessToken) {
        throw error(`Response had no "accessToken" property.`);
      }
    }
    function getAuthorityHost(options) {
      let authorityHost = options?.authorityHost;
      if (!authorityHost && core_util_1.isNodeLike) {
        authorityHost = process.env.AZURE_AUTHORITY_HOST;
      }
      return authorityHost ?? constants_js_1.DefaultAuthorityHost;
    }
    function getAuthority(tenantId, host) {
      if (!host) {
        host = constants_js_1.DefaultAuthorityHost;
      }
      if (new RegExp(`${tenantId}/?$`).test(host)) {
        return host;
      }
      if (host.endsWith("/")) {
        return host + tenantId;
      } else {
        return `${host}/${tenantId}`;
      }
    }
    function getKnownAuthorities(tenantId, authorityHost, disableInstanceDiscovery) {
      if (tenantId === "adfs" && authorityHost || disableInstanceDiscovery) {
        return [authorityHost];
      }
      return [];
    }
    var defaultLoggerCallback = (credLogger, platform2 = core_util_1.isNode ? "Node" : "Browser") => (level, message, containsPii) => {
      if (containsPii) {
        return;
      }
      switch (level) {
        case msal_js_1.msalCommon.LogLevel.Error:
          credLogger.info(`MSAL ${platform2} V2 error: ${message}`);
          return;
        case msal_js_1.msalCommon.LogLevel.Info:
          credLogger.info(`MSAL ${platform2} V2 info message: ${message}`);
          return;
        case msal_js_1.msalCommon.LogLevel.Verbose:
          credLogger.info(`MSAL ${platform2} V2 verbose message: ${message}`);
          return;
        case msal_js_1.msalCommon.LogLevel.Warning:
          credLogger.info(`MSAL ${platform2} V2 warning: ${message}`);
          return;
      }
    };
    exports2.defaultLoggerCallback = defaultLoggerCallback;
    function getMSALLogLevel(logLevel) {
      switch (logLevel) {
        case "error":
          return msal_js_1.msalCommon.LogLevel.Error;
        case "info":
          return msal_js_1.msalCommon.LogLevel.Info;
        case "verbose":
          return msal_js_1.msalCommon.LogLevel.Verbose;
        case "warning":
          return msal_js_1.msalCommon.LogLevel.Warning;
        default:
          return msal_js_1.msalCommon.LogLevel.Info;
      }
    }
    function randomUUID() {
      return (0, core_util_1.randomUUID)();
    }
    function handleMsalError(scopes, error, getTokenOptions) {
      if (error.name === "AuthError" || error.name === "ClientAuthError" || error.name === "BrowserAuthError") {
        const msalError = error;
        switch (msalError.errorCode) {
          case "endpoints_resolution_error":
            logger.info((0, logging_js_1.formatError)(scopes, error.message));
            return new errors_js_1.CredentialUnavailableError(error.message);
          case "device_code_polling_cancelled":
            return new abort_controller_1.AbortError("The authentication has been aborted by the caller.");
          case "consent_required":
          case "interaction_required":
          case "login_required":
            logger.info((0, logging_js_1.formatError)(scopes, `Authentication returned errorCode ${msalError.errorCode}`));
            break;
          default:
            logger.info((0, logging_js_1.formatError)(scopes, `Failed to acquire token: ${error.message}`));
            break;
        }
      }
      if (error.name === "ClientConfigurationError" || error.name === "BrowserConfigurationAuthError" || error.name === "AbortError" || error.name === "AuthenticationError") {
        return error;
      }
      if (error.name === "NativeAuthError") {
        logger.info((0, logging_js_1.formatError)(scopes, `Error from the native broker: ${error.message} with status code: ${error.statusCode}`));
        return error;
      }
      return new errors_js_1.AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });
    }
    function publicToMsal(account) {
      return {
        localAccountId: account.homeAccountId,
        environment: account.authority,
        username: account.username,
        homeAccountId: account.homeAccountId,
        tenantId: account.tenantId
      };
    }
    function msalToPublic(clientId, account) {
      const record = {
        authority: account.environment ?? constants_js_1.DefaultAuthority,
        homeAccountId: account.homeAccountId,
        tenantId: account.tenantId || constants_js_1.DefaultTenantId,
        username: account.username,
        clientId,
        version: LatestAuthenticationRecordVersion
      };
      return record;
    }
    function serializeAuthenticationRecord(record) {
      return JSON.stringify(record);
    }
    function deserializeAuthenticationRecord(serializedRecord) {
      const parsed = JSON.parse(serializedRecord);
      if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {
        throw Error("Unsupported AuthenticationRecord version");
      }
      return parsed;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/base64.js
var require_base64 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeString = encodeString;
    exports2.encodeByteArray = encodeByteArray;
    exports2.decodeString = decodeString;
    exports2.decodeStringToString = decodeStringToString;
    function encodeString(value) {
      return Buffer.from(value).toString("base64");
    }
    function encodeByteArray(value) {
      const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
      return bufferValue.toString("base64");
    }
    function decodeString(value) {
      return Buffer.from(value, "base64");
    }
    function decodeStringToString(value) {
      return Buffer.from(value, "base64").toString();
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaces.js
var require_interfaces = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XML_CHARKEY = exports2.XML_ATTRKEY = void 0;
    exports2.XML_ATTRKEY = "$";
    exports2.XML_CHARKEY = "_";
  }
});

// node_modules/@azure/core-client/dist/commonjs/utils.js
var require_utils4 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPrimitiveBody = isPrimitiveBody;
    exports2.isDuration = isDuration;
    exports2.isValidUuid = isValidUuid;
    exports2.flattenResponse = flattenResponse;
    function isPrimitiveBody(value, mapperTypeName) {
      return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !== null || value === void 0 || value === null);
    }
    var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function isDuration(value) {
      return validateISODuration.test(value);
    }
    var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
    function isValidUuid(uuid) {
      return validUuidRegex.test(uuid);
    }
    function handleNullableResponseAndWrappableBody(responseObject) {
      const combinedHeadersAndBody = {
        ...responseObject.headers,
        ...responseObject.body
      };
      if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
        return responseObject.shouldWrapBody ? { body: null } : null;
      } else {
        return responseObject.shouldWrapBody ? {
          ...responseObject.headers,
          body: responseObject.body
        } : combinedHeadersAndBody;
      }
    }
    function flattenResponse(fullResponse, responseSpec) {
      const parsedHeaders = fullResponse.parsedHeaders;
      if (fullResponse.request.method === "HEAD") {
        return {
          ...parsedHeaders,
          body: fullResponse.parsedBody
        };
      }
      const bodyMapper = responseSpec && responseSpec.bodyMapper;
      const isNullable = Boolean(bodyMapper?.nullable);
      const expectedBodyTypeName = bodyMapper?.type.name;
      if (expectedBodyTypeName === "Stream") {
        return {
          ...parsedHeaders,
          blobBody: fullResponse.blobBody,
          readableStreamBody: fullResponse.readableStreamBody
        };
      }
      const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
      const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
      if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
        const arrayResponse = fullResponse.parsedBody ?? [];
        for (const key of Object.keys(modelProperties)) {
          if (modelProperties[key].serializedName) {
            arrayResponse[key] = fullResponse.parsedBody?.[key];
          }
        }
        if (parsedHeaders) {
          for (const key of Object.keys(parsedHeaders)) {
            arrayResponse[key] = parsedHeaders[key];
          }
        }
        return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
      }
      return handleNullableResponseAndWrappableBody({
        body: fullResponse.parsedBody,
        headers: parsedHeaders,
        hasNullableType: isNullable,
        shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
      });
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializer.js
var require_serializer = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/serializer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MapperTypeNames = void 0;
    exports2.createSerializer = createSerializer;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var base64 = tslib_1.__importStar(require_base64());
    var interfaces_js_1 = require_interfaces();
    var utils_js_1 = require_utils4();
    var SerializerImpl = class {
      modelMappers;
      isXML;
      constructor(modelMappers = {}, isXML = false) {
        this.modelMappers = modelMappers;
        this.isXML = isXML;
      }
      /**
       * @deprecated Removing the constraints validation on client side.
       */
      validateConstraints(mapper, value, objectName) {
        const failValidation = (constraintName, constraintValue) => {
          throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
        };
        if (mapper.constraints && value !== void 0 && value !== null) {
          const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
          if (ExclusiveMaximum !== void 0 && value >= ExclusiveMaximum) {
            failValidation("ExclusiveMaximum", ExclusiveMaximum);
          }
          if (ExclusiveMinimum !== void 0 && value <= ExclusiveMinimum) {
            failValidation("ExclusiveMinimum", ExclusiveMinimum);
          }
          if (InclusiveMaximum !== void 0 && value > InclusiveMaximum) {
            failValidation("InclusiveMaximum", InclusiveMaximum);
          }
          if (InclusiveMinimum !== void 0 && value < InclusiveMinimum) {
            failValidation("InclusiveMinimum", InclusiveMinimum);
          }
          if (MaxItems !== void 0 && value.length > MaxItems) {
            failValidation("MaxItems", MaxItems);
          }
          if (MaxLength !== void 0 && value.length > MaxLength) {
            failValidation("MaxLength", MaxLength);
          }
          if (MinItems !== void 0 && value.length < MinItems) {
            failValidation("MinItems", MinItems);
          }
          if (MinLength !== void 0 && value.length < MinLength) {
            failValidation("MinLength", MinLength);
          }
          if (MultipleOf !== void 0 && value % MultipleOf !== 0) {
            failValidation("MultipleOf", MultipleOf);
          }
          if (Pattern) {
            const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
            if (typeof value !== "string" || value.match(pattern) === null) {
              failValidation("Pattern", Pattern);
            }
          }
          if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i)) {
            failValidation("UniqueItems", UniqueItems);
          }
        }
      }
      /**
       * Serialize the given object based on its metadata defined in the mapper
       *
       * @param mapper - The mapper which defines the metadata of the serializable object
       *
       * @param object - A valid Javascript object to be serialized
       *
       * @param objectName - Name of the serialized object
       *
       * @param options - additional options to serialization
       *
       * @returns A valid serialized Javascript object
       */
      serialize(mapper, object, objectName, options = { xml: {} }) {
        const updatedOptions = {
          xml: {
            rootName: options.xml.rootName ?? "",
            includeRoot: options.xml.includeRoot ?? false,
            xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
          }
        };
        let payload = {};
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Sequence$/i) !== null) {
          payload = [];
        }
        if (mapper.isConstant) {
          object = mapper.defaultValue;
        }
        const { required, nullable } = mapper;
        if (required && nullable && object === void 0) {
          throw new Error(`${objectName} cannot be undefined.`);
        }
        if (required && !nullable && (object === void 0 || object === null)) {
          throw new Error(`${objectName} cannot be null or undefined.`);
        }
        if (!required && nullable === false && object === null) {
          throw new Error(`${objectName} cannot be null.`);
        }
        if (object === void 0 || object === null) {
          payload = object;
        } else {
          if (mapperType.match(/^any$/i) !== null) {
            payload = object;
          } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
            payload = serializeBasicTypes(mapperType, objectName, object);
          } else if (mapperType.match(/^Enum$/i) !== null) {
            const enumMapper = mapper;
            payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
          } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
            payload = serializeDateTypes(mapperType, object, objectName);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = serializeByteArrayType(objectName, object);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = serializeBase64UrlType(objectName, object);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Composite$/i) !== null) {
            payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          }
        }
        return payload;
      }
      /**
       * Deserialize the given object based on its metadata defined in the mapper
       *
       * @param mapper - The mapper which defines the metadata of the serializable object
       *
       * @param responseBody - A valid Javascript entity to be deserialized
       *
       * @param objectName - Name of the deserialized object
       *
       * @param options - Controls behavior of XML parser and builder.
       *
       * @returns A valid deserialized Javascript object
       */
      deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
        const updatedOptions = {
          xml: {
            rootName: options.xml.rootName ?? "",
            includeRoot: options.xml.includeRoot ?? false,
            xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
          },
          ignoreUnknownProperties: options.ignoreUnknownProperties ?? false
        };
        if (responseBody === void 0 || responseBody === null) {
          if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
            responseBody = [];
          }
          if (mapper.defaultValue !== void 0) {
            responseBody = mapper.defaultValue;
          }
          return responseBody;
        }
        let payload;
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Composite$/i) !== null) {
          payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
        } else {
          if (this.isXML) {
            const xmlCharKey = updatedOptions.xml.xmlCharKey;
            if (responseBody[interfaces_js_1.XML_ATTRKEY] !== void 0 && responseBody[xmlCharKey] !== void 0) {
              responseBody = responseBody[xmlCharKey];
            }
          }
          if (mapperType.match(/^Number$/i) !== null) {
            payload = parseFloat(responseBody);
            if (isNaN(payload)) {
              payload = responseBody;
            }
          } else if (mapperType.match(/^Boolean$/i) !== null) {
            if (responseBody === "true") {
              payload = true;
            } else if (responseBody === "false") {
              payload = false;
            } else {
              payload = responseBody;
            }
          } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
            payload = responseBody;
          } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
            payload = new Date(responseBody);
          } else if (mapperType.match(/^UnixTime$/i) !== null) {
            payload = unixTimeToDate(responseBody);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = base64.decodeString(responseBody);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = base64UrlToByteArray(responseBody);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
          }
        }
        if (mapper.isConstant) {
          payload = mapper.defaultValue;
        }
        return payload;
      }
    };
    function createSerializer(modelMappers = {}, isXML = false) {
      return new SerializerImpl(modelMappers, isXML);
    }
    function trimEnd(str, ch) {
      let len = str.length;
      while (len - 1 >= 0 && str[len - 1] === ch) {
        --len;
      }
      return str.substr(0, len);
    }
    function bufferToBase64Url(buffer) {
      if (!buffer) {
        return void 0;
      }
      if (!(buffer instanceof Uint8Array)) {
        throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
      }
      const str = base64.encodeByteArray(buffer);
      return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function base64UrlToByteArray(str) {
      if (!str) {
        return void 0;
      }
      if (str && typeof str.valueOf() !== "string") {
        throw new Error("Please provide an input of type string for converting to Uint8Array");
      }
      str = str.replace(/-/g, "+").replace(/_/g, "/");
      return base64.decodeString(str);
    }
    function splitSerializeName(prop) {
      const classes = [];
      let partialclass = "";
      if (prop) {
        const subwords = prop.split(".");
        for (const item of subwords) {
          if (item.charAt(item.length - 1) === "\\") {
            partialclass += item.substr(0, item.length - 1) + ".";
          } else {
            partialclass += item;
            classes.push(partialclass);
            partialclass = "";
          }
        }
      }
      return classes;
    }
    function dateToUnixTime(d) {
      if (!d) {
        return void 0;
      }
      if (typeof d.valueOf() === "string") {
        d = new Date(d);
      }
      return Math.floor(d.getTime() / 1e3);
    }
    function unixTimeToDate(n) {
      if (!n) {
        return void 0;
      }
      return new Date(n * 1e3);
    }
    function serializeBasicTypes(typeName, objectName, value) {
      if (value !== null && value !== void 0) {
        if (typeName.match(/^Number$/i) !== null) {
          if (typeof value !== "number") {
            throw new Error(`${objectName} with value ${value} must be of type number.`);
          }
        } else if (typeName.match(/^String$/i) !== null) {
          if (typeof value.valueOf() !== "string") {
            throw new Error(`${objectName} with value "${value}" must be of type string.`);
          }
        } else if (typeName.match(/^Uuid$/i) !== null) {
          if (!(typeof value.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value))) {
            throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
          }
        } else if (typeName.match(/^Boolean$/i) !== null) {
          if (typeof value !== "boolean") {
            throw new Error(`${objectName} with value ${value} must be of type boolean.`);
          }
        } else if (typeName.match(/^Stream$/i) !== null) {
          const objectType = typeof value;
          if (objectType !== "string" && typeof value.pipe !== "function" && // NodeJS.ReadableStream
          typeof value.tee !== "function" && // browser ReadableStream
          !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && // File objects count as a type of Blob, so we want to use instanceof explicitly
          !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
            throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
          }
        }
      }
      return value;
    }
    function serializeEnumType(objectName, allowedValues, value) {
      if (!allowedValues) {
        throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
      }
      const isPresent = allowedValues.some((item) => {
        if (typeof item.valueOf() === "string") {
          return item.toLowerCase() === value.toLowerCase();
        }
        return item === value;
      });
      if (!isPresent) {
        throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
      }
      return value;
    }
    function serializeByteArrayType(objectName, value) {
      if (value !== void 0 && value !== null) {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`${objectName} must be of type Uint8Array.`);
        }
        value = base64.encodeByteArray(value);
      }
      return value;
    }
    function serializeBase64UrlType(objectName, value) {
      if (value !== void 0 && value !== null) {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`${objectName} must be of type Uint8Array.`);
        }
        value = bufferToBase64Url(value);
      }
      return value;
    }
    function serializeDateTypes(typeName, value, objectName) {
      if (value !== void 0 && value !== null) {
        if (typeName.match(/^Date$/i) !== null) {
          if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
            throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
          }
          value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
        } else if (typeName.match(/^DateTime$/i) !== null) {
          if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
            throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
          }
          value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
        } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
          if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
            throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
          }
          value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
        } else if (typeName.match(/^UnixTime$/i) !== null) {
          if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
            throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
          }
          value = dateToUnixTime(value);
        } else if (typeName.match(/^TimeSpan$/i) !== null) {
          if (!(0, utils_js_1.isDuration)(value)) {
            throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
          }
        }
      }
      return value;
    }
    function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
      if (!Array.isArray(object)) {
        throw new Error(`${objectName} must be of type Array.`);
      }
      let elementType = mapper.type.element;
      if (!elementType || typeof elementType !== "object") {
        throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
      }
      if (elementType.type.name === "Composite" && elementType.type.className) {
        elementType = serializer.modelMappers[elementType.type.className] ?? elementType;
      }
      const tempArray = [];
      for (let i = 0; i < object.length; i++) {
        const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
        if (isXml && elementType.xmlNamespace) {
          const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
          if (elementType.type.name === "Composite") {
            tempArray[i] = { ...serializedValue };
            tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
          } else {
            tempArray[i] = {};
            tempArray[i][options.xml.xmlCharKey] = serializedValue;
            tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
          }
        } else {
          tempArray[i] = serializedValue;
        }
      }
      return tempArray;
    }
    function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
      if (typeof object !== "object") {
        throw new Error(`${objectName} must be of type object.`);
      }
      const valueType = mapper.type.value;
      if (!valueType || typeof valueType !== "object") {
        throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
      }
      const tempDictionary = {};
      for (const key of Object.keys(object)) {
        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
      }
      if (isXml && mapper.xmlNamespace) {
        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
        const result = tempDictionary;
        result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
        return result;
      }
      return tempDictionary;
    }
    function resolveAdditionalProperties(serializer, mapper, objectName) {
      const additionalProperties = mapper.type.additionalProperties;
      if (!additionalProperties && mapper.type.className) {
        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        return modelMapper?.type.additionalProperties;
      }
      return additionalProperties;
    }
    function resolveReferencedMapper(serializer, mapper, objectName) {
      const className = mapper.type.className;
      if (!className) {
        throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
      }
      return serializer.modelMappers[className];
    }
    function resolveModelProperties(serializer, mapper, objectName) {
      let modelProps = mapper.type.modelProperties;
      if (!modelProps) {
        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        if (!modelMapper) {
          throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
        }
        modelProps = modelMapper?.type.modelProperties;
        if (!modelProps) {
          throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
        }
      }
      return modelProps;
    }
    function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
      if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
        mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
      }
      if (object !== void 0 && object !== null) {
        const payload = {};
        const modelProps = resolveModelProperties(serializer, mapper, objectName);
        for (const key of Object.keys(modelProps)) {
          const propertyMapper = modelProps[key];
          if (propertyMapper.readOnly) {
            continue;
          }
          let propName;
          let parentObject = payload;
          if (serializer.isXML) {
            if (propertyMapper.xmlIsWrapped) {
              propName = propertyMapper.xmlName;
            } else {
              propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
            }
          } else {
            const paths = splitSerializeName(propertyMapper.serializedName);
            propName = paths.pop();
            for (const pathName of paths) {
              const childObject = parentObject[pathName];
              if ((childObject === void 0 || childObject === null) && (object[key] !== void 0 && object[key] !== null || propertyMapper.defaultValue !== void 0)) {
                parentObject[pathName] = {};
              }
              parentObject = parentObject[pathName];
            }
          }
          if (parentObject !== void 0 && parentObject !== null) {
            if (isXml && mapper.xmlNamespace) {
              const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
              parentObject[interfaces_js_1.XML_ATTRKEY] = {
                ...parentObject[interfaces_js_1.XML_ATTRKEY],
                [xmlnsKey]: mapper.xmlNamespace
              };
            }
            const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
            let toSerialize = object[key];
            const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
            if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === void 0 || toSerialize === null)) {
              toSerialize = mapper.serializedName;
            }
            const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
            if (serializedValue !== void 0 && propName !== void 0 && propName !== null) {
              const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
              if (isXml && propertyMapper.xmlIsAttribute) {
                parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {};
                parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
              } else if (isXml && propertyMapper.xmlIsWrapped) {
                parentObject[propName] = { [propertyMapper.xmlElementName]: value };
              } else {
                parentObject[propName] = value;
              }
            }
          }
        }
        const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
        if (additionalPropertiesMapper) {
          const propNames = Object.keys(modelProps);
          for (const clientPropName in object) {
            const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
            if (isAdditionalProperty) {
              payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
            }
          }
        }
        return payload;
      }
      return object;
    }
    function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
      if (!isXml || !propertyMapper.xmlNamespace) {
        return serializedValue;
      }
      const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
      const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
      if (["Composite"].includes(propertyMapper.type.name)) {
        if (serializedValue[interfaces_js_1.XML_ATTRKEY]) {
          return serializedValue;
        } else {
          const result2 = { ...serializedValue };
          result2[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
          return result2;
        }
      }
      const result = {};
      result[options.xml.xmlCharKey] = serializedValue;
      result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
      return result;
    }
    function isSpecialXmlProperty(propertyName, options) {
      return [interfaces_js_1.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
    }
    function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
      const xmlCharKey = options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY;
      if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
        mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
      }
      const modelProps = resolveModelProperties(serializer, mapper, objectName);
      let instance = {};
      const handledPropertyNames = [];
      for (const key of Object.keys(modelProps)) {
        const propertyMapper = modelProps[key];
        const paths = splitSerializeName(modelProps[key].serializedName);
        handledPropertyNames.push(paths[0]);
        const { serializedName, xmlName, xmlElementName } = propertyMapper;
        let propertyObjectName = objectName;
        if (serializedName !== "" && serializedName !== void 0) {
          propertyObjectName = objectName + "." + serializedName;
        }
        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          const dictionary = {};
          for (const headerKey of Object.keys(responseBody)) {
            if (headerKey.startsWith(headerCollectionPrefix)) {
              dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
            }
            handledPropertyNames.push(headerKey);
          }
          instance[key] = dictionary;
        } else if (serializer.isXML) {
          if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY]) {
            instance[key] = serializer.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options);
          } else if (propertyMapper.xmlIsMsText) {
            if (responseBody[xmlCharKey] !== void 0) {
              instance[key] = responseBody[xmlCharKey];
            } else if (typeof responseBody === "string") {
              instance[key] = responseBody;
            }
          } else {
            const propertyName = xmlElementName || xmlName || serializedName;
            if (propertyMapper.xmlIsWrapped) {
              const wrapped = responseBody[xmlName];
              const elementList = wrapped?.[xmlElementName] ?? [];
              instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
              handledPropertyNames.push(xmlName);
            } else {
              const property = responseBody[propertyName];
              instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
              handledPropertyNames.push(propertyName);
            }
          }
        } else {
          let propertyInstance;
          let res = responseBody;
          let steps = 0;
          for (const item of paths) {
            if (!res)
              break;
            steps++;
            res = res[item];
          }
          if (res === null && steps < paths.length) {
            res = void 0;
          }
          propertyInstance = res;
          const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
          if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === void 0 || propertyInstance === null)) {
            propertyInstance = mapper.serializedName;
          }
          let serializedValue;
          if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
            propertyInstance = responseBody[key];
            const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
            for (const [k, v] of Object.entries(instance)) {
              if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
                arrayInstance[k] = v;
              }
            }
            instance = arrayInstance;
          } else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) {
            serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
            instance[key] = serializedValue;
          }
        }
      }
      const additionalPropertiesMapper = mapper.type.additionalProperties;
      if (additionalPropertiesMapper) {
        const isAdditionalProperty = (responsePropName) => {
          for (const clientPropName in modelProps) {
            const paths = splitSerializeName(modelProps[clientPropName].serializedName);
            if (paths[0] === responsePropName) {
              return false;
            }
          }
          return true;
        };
        for (const responsePropName in responseBody) {
          if (isAdditionalProperty(responsePropName)) {
            instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
          }
        }
      } else if (responseBody && !options.ignoreUnknownProperties) {
        for (const key of Object.keys(responseBody)) {
          if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {
            instance[key] = responseBody[key];
          }
        }
      }
      return instance;
    }
    function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
      const value = mapper.type.value;
      if (!value || typeof value !== "object") {
        throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
      }
      if (responseBody) {
        const tempDictionary = {};
        for (const key of Object.keys(responseBody)) {
          tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
        }
        return tempDictionary;
      }
      return responseBody;
    }
    function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
      let element = mapper.type.element;
      if (!element || typeof element !== "object") {
        throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
      }
      if (responseBody) {
        if (!Array.isArray(responseBody)) {
          responseBody = [responseBody];
        }
        if (element.type.name === "Composite" && element.type.className) {
          element = serializer.modelMappers[element.type.className] ?? element;
        }
        const tempArray = [];
        for (let i = 0; i < responseBody.length; i++) {
          tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
        }
        return tempArray;
      }
      return responseBody;
    }
    function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
      const typeNamesToCheck = [typeName];
      while (typeNamesToCheck.length) {
        const currentName = typeNamesToCheck.shift();
        const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
        if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
          return discriminators[indexDiscriminator];
        } else {
          for (const [name, mapper] of Object.entries(discriminators)) {
            if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
              typeNamesToCheck.push(mapper.type.className);
            }
          }
        }
      }
      return void 0;
    }
    function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
      const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
      if (polymorphicDiscriminator) {
        let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
        if (discriminatorName) {
          if (polymorphicPropertyName === "serializedName") {
            discriminatorName = discriminatorName.replace(/\\/gi, "");
          }
          const discriminatorValue = object[discriminatorName];
          const typeName = mapper.type.uberParent ?? mapper.type.className;
          if (typeof discriminatorValue === "string" && typeName) {
            const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
            if (polymorphicMapper) {
              mapper = polymorphicMapper;
            }
          }
        }
      }
      return mapper;
    }
    function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
      return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
    }
    function getPolymorphicDiscriminatorSafely(serializer, typeName) {
      return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
    }
    exports2.MapperTypeNames = {
      Base64Url: "Base64Url",
      Boolean: "Boolean",
      ByteArray: "ByteArray",
      Composite: "Composite",
      Date: "Date",
      DateTime: "DateTime",
      DateTimeRfc1123: "DateTimeRfc1123",
      Dictionary: "Dictionary",
      Enum: "Enum",
      Number: "Number",
      Object: "Object",
      Sequence: "Sequence",
      String: "String",
      Stream: "Stream",
      TimeSpan: "TimeSpan",
      UnixTime: "UnixTime"
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/abort-controller/AbortError.js
var require_AbortError2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/abort-controller/AbortError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbortError = void 0;
    var AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/httpHeaders.js
var require_httpHeaders = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/httpHeaders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createHttpHeaders = createHttpHeaders;
    function normalizeName(name) {
      return name.toLowerCase();
    }
    function* headerIterator(map) {
      for (const entry of map.values()) {
        yield [entry.name, entry.value];
      }
    }
    var HttpHeadersImpl = class {
      _headersMap;
      constructor(rawHeaders) {
        this._headersMap = /* @__PURE__ */ new Map();
        if (rawHeaders) {
          for (const headerName of Object.keys(rawHeaders)) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param name - The name of the header to set. This value is case-insensitive.
       * @param value - The value of the header to set.
       */
      set(name, value) {
        this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param name - The name of the header. This value is case-insensitive.
       */
      get(name) {
        return this._headersMap.get(normalizeName(name))?.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       * @param name - The name of the header to set. This value is case-insensitive.
       */
      has(name) {
        return this._headersMap.has(normalizeName(name));
      }
      /**
       * Remove the header with the provided headerName.
       * @param name - The name of the header to remove.
       */
      delete(name) {
        this._headersMap.delete(normalizeName(name));
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const entry of this._headersMap.values()) {
            result[entry.name] = entry.value;
          }
        } else {
          for (const [normalizedName, entry] of this._headersMap) {
            result[normalizedName] = entry.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
      }
      /**
       * Iterate over tuples of header [name, value] pairs.
       */
      [Symbol.iterator]() {
        return headerIterator(this._headersMap);
      }
    };
    function createHttpHeaders(rawHeaders) {
      return new HttpHeadersImpl(rawHeaders);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/schemes.js
var require_schemes = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/schemes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/oauth2Flows.js
var require_oauth2Flows = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/oauth2Flows.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipelineRequest.js
var require_pipelineRequest = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/pipelineRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPipelineRequest = createPipelineRequest;
    var httpHeaders_js_1 = require_httpHeaders();
    var uuidUtils_js_1 = require_uuidUtils();
    var PipelineRequestImpl = class {
      url;
      method;
      headers;
      timeout;
      withCredentials;
      body;
      multipartBody;
      formData;
      streamResponseStatusCodes;
      enableBrowserStreams;
      proxySettings;
      disableKeepAlive;
      abortSignal;
      requestId;
      allowInsecureConnection;
      onUploadProgress;
      onDownloadProgress;
      requestOverrides;
      authSchemes;
      constructor(options) {
        this.url = options.url;
        this.body = options.body;
        this.headers = options.headers ?? (0, httpHeaders_js_1.createHttpHeaders)();
        this.method = options.method ?? "GET";
        this.timeout = options.timeout ?? 0;
        this.multipartBody = options.multipartBody;
        this.formData = options.formData;
        this.disableKeepAlive = options.disableKeepAlive ?? false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = options.withCredentials ?? false;
        this.abortSignal = options.abortSignal;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || (0, uuidUtils_js_1.randomUUID)();
        this.allowInsecureConnection = options.allowInsecureConnection ?? false;
        this.enableBrowserStreams = options.enableBrowserStreams ?? false;
        this.requestOverrides = options.requestOverrides;
        this.authSchemes = options.authSchemes;
      }
    };
    function createPipelineRequest(options) {
      return new PipelineRequestImpl(options);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/pipeline.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEmptyPipeline = createEmptyPipeline;
    var ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
    var HttpPipeline = class _HttpPipeline {
      _policies = [];
      _orderedPolicies;
      constructor(policies) {
        this._policies = policies?.slice(0) ?? [];
        this._orderedPolicies = void 0;
      }
      addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
          throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
          throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
          throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
          policy,
          options
        });
        this._orderedPolicies = void 0;
      }
      removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
          if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
            removedPolicies.push(policyDescriptor.policy);
            return false;
          } else {
            return true;
          }
        });
        this._orderedPolicies = void 0;
        return removedPolicies;
      }
      sendRequest(httpClient, request) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
          return (req) => {
            return policy.sendRequest(req, next);
          };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request);
      }
      getOrderedPolicies() {
        if (!this._orderedPolicies) {
          this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
      }
      clone() {
        return new _HttpPipeline(this._policies);
      }
      static create() {
        return new _HttpPipeline();
      }
      orderPolicies() {
        const result = [];
        const policyMap = /* @__PURE__ */ new Map();
        function createPhase(name) {
          return {
            name,
            policies: /* @__PURE__ */ new Set(),
            hasRun: false,
            hasAfterPolicies: false
          };
        }
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        function getPhase(phase) {
          if (phase === "Retry") {
            return retryPhase;
          } else if (phase === "Serialize") {
            return serializePhase;
          } else if (phase === "Deserialize") {
            return deserializePhase;
          } else if (phase === "Sign") {
            return signPhase;
          } else {
            return noPhase;
          }
        }
        for (const descriptor of this._policies) {
          const policy = descriptor.policy;
          const options = descriptor.options;
          const policyName = policy.name;
          if (policyMap.has(policyName)) {
            throw new Error("Duplicate policy names not allowed in pipeline");
          }
          const node = {
            policy,
            dependsOn: /* @__PURE__ */ new Set(),
            dependants: /* @__PURE__ */ new Set()
          };
          if (options.afterPhase) {
            node.afterPhase = getPhase(options.afterPhase);
            node.afterPhase.hasAfterPolicies = true;
          }
          policyMap.set(policyName, node);
          const phase = getPhase(options.phase);
          phase.policies.add(node);
        }
        for (const descriptor of this._policies) {
          const { policy, options } = descriptor;
          const policyName = policy.name;
          const node = policyMap.get(policyName);
          if (!node) {
            throw new Error(`Missing node for policy ${policyName}`);
          }
          if (options.afterPolicies) {
            for (const afterPolicyName of options.afterPolicies) {
              const afterNode = policyMap.get(afterPolicyName);
              if (afterNode) {
                node.dependsOn.add(afterNode);
                afterNode.dependants.add(node);
              }
            }
          }
          if (options.beforePolicies) {
            for (const beforePolicyName of options.beforePolicies) {
              const beforeNode = policyMap.get(beforePolicyName);
              if (beforeNode) {
                beforeNode.dependsOn.add(node);
                node.dependants.add(beforeNode);
              }
            }
          }
        }
        function walkPhase(phase) {
          phase.hasRun = true;
          for (const node of phase.policies) {
            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
              continue;
            }
            if (node.dependsOn.size === 0) {
              result.push(node.policy);
              for (const dependant of node.dependants) {
                dependant.dependsOn.delete(node);
              }
              policyMap.delete(node.policy.name);
              phase.policies.delete(node);
            }
          }
        }
        function walkPhases() {
          for (const phase of orderedPhases) {
            walkPhase(phase);
            if (phase.policies.size > 0 && phase !== noPhase) {
              if (!noPhase.hasRun) {
                walkPhase(noPhase);
              }
              return;
            }
            if (phase.hasAfterPolicies) {
              walkPhase(noPhase);
            }
          }
        }
        let iteration = 0;
        while (policyMap.size > 0) {
          iteration++;
          const initialResultLength = result.length;
          walkPhases();
          if (result.length <= initialResultLength && iteration > 1) {
            throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
          }
        }
        return result;
      }
    };
    function createEmptyPipeline() {
      return HttpPipeline.create();
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/inspect.js
var require_inspect = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/inspect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.custom = void 0;
    var node_util_1 = require("node:util");
    exports2.custom = node_util_1.inspect.custom;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/restError.js
var require_restError = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/restError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestError = void 0;
    exports2.isRestError = isRestError;
    var error_js_1 = require_error2();
    var inspect_js_1 = require_inspect();
    var sanitizer_js_1 = require_sanitizer();
    var errorSanitizer = new sanitizer_js_1.Sanitizer();
    var RestError = class _RestError extends Error {
      /**
       * Something went wrong when making the request.
       * This means the actual request failed for some reason,
       * such as a DNS issue or the connection being lost.
       */
      static REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
      /**
       * This means that parsing the response from the server failed.
       * It may have been malformed.
       */
      static PARSE_ERROR = "PARSE_ERROR";
      /**
       * The code of the error itself (use statics on RestError if possible.)
       */
      code;
      /**
       * The HTTP status code of the request (if applicable.)
       */
      statusCode;
      /**
       * The request that was made.
       * This property is non-enumerable.
       */
      request;
      /**
       * The response received (if any.)
       * This property is non-enumerable.
       */
      response;
      /**
       * Bonus property set by the throw site.
       */
      details;
      constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        Object.defineProperty(this, "request", { value: options.request, enumerable: false });
        Object.defineProperty(this, "response", { value: options.response, enumerable: false });
        const agent = this.request?.agent ? {
          maxFreeSockets: this.request.agent.maxFreeSockets,
          maxSockets: this.request.agent.maxSockets
        } : void 0;
        Object.defineProperty(this, inspect_js_1.custom, {
          value: () => {
            return `RestError: ${this.message} 
 ${errorSanitizer.sanitize({
              ...this,
              request: { ...this.request, agent },
              response: this.response
            })}`;
          },
          enumerable: false
        });
        Object.setPrototypeOf(this, _RestError.prototype);
      }
    };
    exports2.RestError = RestError;
    function isRestError(e) {
      if (e instanceof RestError) {
        return true;
      }
      return (0, error_js_1.isError)(e) && e.name === "RestError";
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/log.js
var require_log2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/log.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logger = void 0;
    var logger_js_1 = require_logger();
    exports2.logger = (0, logger_js_1.createClientLogger)("ts-http-runtime");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/nodeHttpClient.js
var require_nodeHttpClient = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/nodeHttpClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBodyLength = getBodyLength;
    exports2.createNodeHttpClient = createNodeHttpClient;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_http_1 = tslib_1.__importDefault(require("node:http"));
    var node_https_1 = tslib_1.__importDefault(require("node:https"));
    var node_zlib_1 = tslib_1.__importDefault(require("node:zlib"));
    var node_stream_1 = require("node:stream");
    var AbortError_js_1 = require_AbortError2();
    var httpHeaders_js_1 = require_httpHeaders();
    var restError_js_1 = require_restError();
    var log_js_1 = require_log2();
    var sanitizer_js_1 = require_sanitizer();
    var DEFAULT_TLS_SETTINGS = {};
    function isReadableStream(body) {
      return body && typeof body.pipe === "function";
    }
    function isStreamComplete(stream) {
      if (stream.readable === false) {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        const handler = () => {
          resolve();
          stream.removeListener("close", handler);
          stream.removeListener("end", handler);
          stream.removeListener("error", handler);
        };
        stream.on("close", handler);
        stream.on("end", handler);
        stream.on("error", handler);
      });
    }
    function isArrayBuffer(body) {
      return body && typeof body.byteLength === "number";
    }
    var ReportTransform = class extends node_stream_1.Transform {
      loadedBytes = 0;
      progressCallback;
      // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
      _transform(chunk, _encoding, callback) {
        this.push(chunk);
        this.loadedBytes += chunk.length;
        try {
          this.progressCallback({ loadedBytes: this.loadedBytes });
          callback();
        } catch (e) {
          callback(e);
        }
      }
      constructor(progressCallback) {
        super();
        this.progressCallback = progressCallback;
      }
    };
    var NodeHttpClient = class {
      cachedHttpAgent;
      cachedHttpsAgents = /* @__PURE__ */ new WeakMap();
      /**
       * Makes a request over an underlying transport layer and returns the response.
       * @param request - The request to be made.
       */
      async sendRequest(request) {
        const abortController = new AbortController();
        let abortListener;
        if (request.abortSignal) {
          if (request.abortSignal.aborted) {
            throw new AbortError_js_1.AbortError("The operation was aborted. Request has already been canceled.");
          }
          abortListener = (event) => {
            if (event.type === "abort") {
              abortController.abort();
            }
          };
          request.abortSignal.addEventListener("abort", abortListener);
        }
        let timeoutId;
        if (request.timeout > 0) {
          timeoutId = setTimeout(() => {
            const sanitizer = new sanitizer_js_1.Sanitizer();
            log_js_1.logger.info(`request to '${sanitizer.sanitizeUrl(request.url)}' timed out. canceling...`);
            abortController.abort();
          }, request.timeout);
        }
        const acceptEncoding = request.headers.get("Accept-Encoding");
        const shouldDecompress = acceptEncoding?.includes("gzip") || acceptEncoding?.includes("deflate");
        let body = typeof request.body === "function" ? request.body() : request.body;
        if (body && !request.headers.has("Content-Length")) {
          const bodyLength = getBodyLength(body);
          if (bodyLength !== null) {
            request.headers.set("Content-Length", bodyLength);
          }
        }
        let responseStream;
        try {
          if (body && request.onUploadProgress) {
            const onUploadProgress = request.onUploadProgress;
            const uploadReportStream = new ReportTransform(onUploadProgress);
            uploadReportStream.on("error", (e) => {
              log_js_1.logger.error("Error in upload progress", e);
            });
            if (isReadableStream(body)) {
              body.pipe(uploadReportStream);
            } else {
              uploadReportStream.end(body);
            }
            body = uploadReportStream;
          }
          const res = await this.makeRequest(request, abortController, body);
          if (timeoutId !== void 0) {
            clearTimeout(timeoutId);
          }
          const headers = getResponseHeaders(res);
          const status = res.statusCode ?? 0;
          const response = {
            status,
            headers,
            request
          };
          if (request.method === "HEAD") {
            res.resume();
            return response;
          }
          responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
          const onDownloadProgress = request.onDownloadProgress;
          if (onDownloadProgress) {
            const downloadReportStream = new ReportTransform(onDownloadProgress);
            downloadReportStream.on("error", (e) => {
              log_js_1.logger.error("Error in download progress", e);
            });
            responseStream.pipe(downloadReportStream);
            responseStream = downloadReportStream;
          }
          if (
            // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
            request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) || request.streamResponseStatusCodes?.has(response.status)
          ) {
            response.readableStreamBody = responseStream;
          } else {
            response.bodyAsText = await streamToText(responseStream);
          }
          return response;
        } finally {
          if (request.abortSignal && abortListener) {
            let uploadStreamDone = Promise.resolve();
            if (isReadableStream(body)) {
              uploadStreamDone = isStreamComplete(body);
            }
            let downloadStreamDone = Promise.resolve();
            if (isReadableStream(responseStream)) {
              downloadStreamDone = isStreamComplete(responseStream);
            }
            Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
              if (abortListener) {
                request.abortSignal?.removeEventListener("abort", abortListener);
              }
            }).catch((e) => {
              log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e);
            });
          }
        }
      }
      makeRequest(request, abortController, body) {
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) {
          throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        }
        const agent = request.agent ?? this.getOrCreateAgent(request, isInsecure);
        const options = {
          agent,
          hostname: url.hostname,
          path: `${url.pathname}${url.search}`,
          port: url.port,
          method: request.method,
          headers: request.headers.toJSON({ preserveCase: true }),
          ...request.requestOverrides
        };
        return new Promise((resolve, reject) => {
          const req = isInsecure ? node_http_1.default.request(options, resolve) : node_https_1.default.request(options, resolve);
          req.once("error", (err) => {
            reject(new restError_js_1.RestError(err.message, { code: err.code ?? restError_js_1.RestError.REQUEST_SEND_ERROR, request }));
          });
          abortController.signal.addEventListener("abort", () => {
            const abortError = new AbortError_js_1.AbortError("The operation was aborted. Rejecting from abort signal callback while making request.");
            req.destroy(abortError);
            reject(abortError);
          });
          if (body && isReadableStream(body)) {
            body.pipe(req);
          } else if (body) {
            if (typeof body === "string" || Buffer.isBuffer(body)) {
              req.end(body);
            } else if (isArrayBuffer(body)) {
              req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
            } else {
              log_js_1.logger.error("Unrecognized body type", body);
              reject(new restError_js_1.RestError("Unrecognized body type"));
            }
          } else {
            req.end();
          }
        });
      }
      getOrCreateAgent(request, isInsecure) {
        const disableKeepAlive = request.disableKeepAlive;
        if (isInsecure) {
          if (disableKeepAlive) {
            return node_http_1.default.globalAgent;
          }
          if (!this.cachedHttpAgent) {
            this.cachedHttpAgent = new node_http_1.default.Agent({ keepAlive: true });
          }
          return this.cachedHttpAgent;
        } else {
          if (disableKeepAlive && !request.tlsSettings) {
            return node_https_1.default.globalAgent;
          }
          const tlsSettings = request.tlsSettings ?? DEFAULT_TLS_SETTINGS;
          let agent = this.cachedHttpsAgents.get(tlsSettings);
          if (agent && agent.options.keepAlive === !disableKeepAlive) {
            return agent;
          }
          log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent");
          agent = new node_https_1.default.Agent({
            // keepAlive is true if disableKeepAlive is false.
            keepAlive: !disableKeepAlive,
            // Since we are spreading, if no tslSettings were provided, nothing is added to the agent options.
            ...tlsSettings
          });
          this.cachedHttpsAgents.set(tlsSettings, agent);
          return agent;
        }
      }
    };
    function getResponseHeaders(res) {
      const headers = (0, httpHeaders_js_1.createHttpHeaders)();
      for (const header of Object.keys(res.headers)) {
        const value = res.headers[header];
        if (Array.isArray(value)) {
          if (value.length > 0) {
            headers.set(header, value[0]);
          }
        } else if (value) {
          headers.set(header, value);
        }
      }
      return headers;
    }
    function getDecodedResponseStream(stream, headers) {
      const contentEncoding = headers.get("Content-Encoding");
      if (contentEncoding === "gzip") {
        const unzip = node_zlib_1.default.createGunzip();
        stream.pipe(unzip);
        return unzip;
      } else if (contentEncoding === "deflate") {
        const inflate = node_zlib_1.default.createInflate();
        stream.pipe(inflate);
        return inflate;
      }
      return stream;
    }
    function streamToText(stream) {
      return new Promise((resolve, reject) => {
        const buffer = [];
        stream.on("data", (chunk) => {
          if (Buffer.isBuffer(chunk)) {
            buffer.push(chunk);
          } else {
            buffer.push(Buffer.from(chunk));
          }
        });
        stream.on("end", () => {
          resolve(Buffer.concat(buffer).toString("utf8"));
        });
        stream.on("error", (e) => {
          if (e && e?.name === "AbortError") {
            reject(e);
          } else {
            reject(new restError_js_1.RestError(`Error reading response as text: ${e.message}`, {
              code: restError_js_1.RestError.PARSE_ERROR
            }));
          }
        });
      });
    }
    function getBodyLength(body) {
      if (!body) {
        return 0;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (isReadableStream(body)) {
        return null;
      } else if (isArrayBuffer(body)) {
        return body.byteLength;
      } else if (typeof body === "string") {
        return Buffer.from(body).length;
      } else {
        return null;
      }
    }
    function createNodeHttpClient() {
      return new NodeHttpClient();
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/defaultHttpClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultHttpClient = createDefaultHttpClient;
    var nodeHttpClient_js_1 = require_nodeHttpClient();
    function createDefaultHttpClient() {
      return (0, nodeHttpClient_js_1.createNodeHttpClient)();
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/logPolicy.js
var require_logPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/logPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logPolicyName = void 0;
    exports2.logPolicy = logPolicy;
    var log_js_1 = require_log2();
    var sanitizer_js_1 = require_sanitizer();
    exports2.logPolicyName = "logPolicy";
    function logPolicy(options = {}) {
      const logger = options.logger ?? log_js_1.logger.info;
      const sanitizer = new sanitizer_js_1.Sanitizer({
        additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
      });
      return {
        name: exports2.logPolicyName,
        async sendRequest(request, next) {
          if (!logger.enabled) {
            return next(request);
          }
          logger(`Request: ${sanitizer.sanitize(request)}`);
          const response = await next(request);
          logger(`Response status code: ${response.status}`);
          logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
          return response;
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/redirectPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.redirectPolicyName = void 0;
    exports2.redirectPolicy = redirectPolicy;
    exports2.redirectPolicyName = "redirectPolicy";
    var allowedRedirect = ["GET", "HEAD"];
    function redirectPolicy(options = {}) {
      const { maxRetries = 20 } = options;
      return {
        name: exports2.redirectPolicyName,
        async sendRequest(request, next) {
          const response = await next(request);
          return handleRedirect(next, response, maxRetries);
        }
      };
    }
    async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
      const { request, status, headers } = response;
      const locationHeader = headers.get("location");
      if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
        const url = new URL(locationHeader, request.url);
        request.url = url.toString();
        if (status === 303) {
          request.method = "GET";
          request.headers.delete("Content-Length");
          delete request.body;
        }
        request.headers.delete("Authorization");
        const res = await next(request);
        return handleRedirect(next, res, maxRetries, currentRetries + 1);
      }
      return response;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgentPlatform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getHeaderName = getHeaderName;
    exports2.setPlatformSpecificData = setPlatformSpecificData;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_os_1 = tslib_1.__importDefault(require("node:os"));
    var node_process_1 = tslib_1.__importDefault(require("node:process"));
    function getHeaderName() {
      return "User-Agent";
    }
    async function setPlatformSpecificData(map) {
      if (node_process_1.default && node_process_1.default.versions) {
        const osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`;
        const versions = node_process_1.default.versions;
        if (versions.bun) {
          map.set("Bun", `${versions.bun} (${osInfo})`);
        } else if (versions.deno) {
          map.set("Deno", `${versions.deno} (${osInfo})`);
        } else if (versions.node) {
          map.set("Node", `${versions.node} (${osInfo})`);
        }
      }
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/constants.js
var require_constants3 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_RETRY_POLICY_COUNT = exports2.SDK_VERSION = void 0;
    exports2.SDK_VERSION = "0.3.3";
    exports2.DEFAULT_RETRY_POLICY_COUNT = 3;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgent.js
var require_userAgent = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUserAgentHeaderName = getUserAgentHeaderName;
    exports2.getUserAgentValue = getUserAgentValue;
    var userAgentPlatform_js_1 = require_userAgentPlatform();
    var constants_js_1 = require_constants3();
    function getUserAgentString(telemetryInfo) {
      const parts = [];
      for (const [key, value] of telemetryInfo) {
        const token = value ? `${key}/${value}` : key;
        parts.push(token);
      }
      return parts.join(" ");
    }
    function getUserAgentHeaderName() {
      return (0, userAgentPlatform_js_1.getHeaderName)();
    }
    async function getUserAgentValue(prefix) {
      const runtimeInfo = /* @__PURE__ */ new Map();
      runtimeInfo.set("ts-http-runtime", constants_js_1.SDK_VERSION);
      await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
      const defaultAgent = getUserAgentString(runtimeInfo);
      const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
      return userAgentValue;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/userAgentPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.userAgentPolicyName = void 0;
    exports2.userAgentPolicy = userAgentPolicy;
    var userAgent_js_1 = require_userAgent();
    var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
    exports2.userAgentPolicyName = "userAgentPolicy";
    function userAgentPolicy(options = {}) {
      const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
      return {
        name: exports2.userAgentPolicyName,
        async sendRequest(request, next) {
          if (!request.headers.has(UserAgentHeaderName)) {
            request.headers.set(UserAgentHeaderName, await userAgentValue);
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/decompressResponsePolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decompressResponsePolicyName = void 0;
    exports2.decompressResponsePolicy = decompressResponsePolicy;
    exports2.decompressResponsePolicyName = "decompressResponsePolicy";
    function decompressResponsePolicy() {
      return {
        name: exports2.decompressResponsePolicyName,
        async sendRequest(request, next) {
          if (request.method !== "HEAD") {
            request.headers.set("Accept-Encoding", "gzip,deflate");
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/helpers.js
var require_helpers = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delay = delay;
    exports2.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
    var AbortError_js_1 = require_AbortError2();
    var StandardAbortMessage = "The operation was aborted.";
    function delay(delayInMs, value, options) {
      return new Promise((resolve, reject) => {
        let timer = void 0;
        let onAborted = void 0;
        const rejectOnAbort = () => {
          return reject(new AbortError_js_1.AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage));
        };
        const removeListeners = () => {
          if (options?.abortSignal && onAborted) {
            options.abortSignal.removeEventListener("abort", onAborted);
          }
        };
        onAborted = () => {
          if (timer) {
            clearTimeout(timer);
          }
          removeListeners();
          return rejectOnAbort();
        };
        if (options?.abortSignal && options.abortSignal.aborted) {
          return rejectOnAbort();
        }
        timer = setTimeout(() => {
          removeListeners();
          resolve(value);
        }, delayInMs);
        if (options?.abortSignal) {
          options.abortSignal.addEventListener("abort", onAborted);
        }
      });
    }
    function parseHeaderValueAsNumber(response, headerName) {
      const value = response.headers.get(headerName);
      if (!value)
        return;
      const valueAsNum = Number(value);
      if (Number.isNaN(valueAsNum))
        return;
      return valueAsNum;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/throttlingRetryStrategy.js
var require_throttlingRetryStrategy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/throttlingRetryStrategy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isThrottlingRetryResponse = isThrottlingRetryResponse;
    exports2.throttlingRetryStrategy = throttlingRetryStrategy;
    var helpers_js_1 = require_helpers();
    var RetryAfterHeader = "Retry-After";
    var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
    function getRetryAfterInMs(response) {
      if (!(response && [429, 503].includes(response.status)))
        return void 0;
      try {
        for (const header of AllRetryAfterHeaders) {
          const retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response, header);
          if (retryAfterValue === 0 || retryAfterValue) {
            const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
            return retryAfterValue * multiplyingFactor;
          }
        }
        const retryAfterHeader = response.headers.get(RetryAfterHeader);
        if (!retryAfterHeader)
          return;
        const date = Date.parse(retryAfterHeader);
        const diff = date - Date.now();
        return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
      } catch {
        return void 0;
      }
    }
    function isThrottlingRetryResponse(response) {
      return Number.isFinite(getRetryAfterInMs(response));
    }
    function throttlingRetryStrategy() {
      return {
        name: "throttlingRetryStrategy",
        retry({ response }) {
          const retryAfterInMs = getRetryAfterInMs(response);
          if (!Number.isFinite(retryAfterInMs)) {
            return { skipStrategy: true };
          }
          return {
            retryAfterInMs
          };
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/exponentialRetryStrategy.js
var require_exponentialRetryStrategy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/exponentialRetryStrategy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exponentialRetryStrategy = exponentialRetryStrategy;
    exports2.isExponentialRetryResponse = isExponentialRetryResponse;
    exports2.isSystemError = isSystemError;
    var delay_js_1 = require_delay();
    var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
    var DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
    var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
    function exponentialRetryStrategy(options = {}) {
      const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;
      const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
      return {
        name: "exponentialRetryStrategy",
        retry({ retryCount, response, responseError }) {
          const matchedSystemError = isSystemError(responseError);
          const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
          const isExponential = isExponentialRetryResponse(response);
          const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
          const unknownResponse = response && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response) || !isExponential);
          if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
            return { skipStrategy: true };
          }
          if (responseError && !matchedSystemError && !isExponential) {
            return { errorToThrow: responseError };
          }
          return (0, delay_js_1.calculateRetryDelay)(retryCount, {
            retryDelayInMs: retryInterval,
            maxRetryDelayInMs: maxRetryInterval
          });
        }
      };
    }
    function isExponentialRetryResponse(response) {
      return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
    }
    function isSystemError(err) {
      if (!err) {
        return false;
      }
      return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/retryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryPolicy = retryPolicy;
    var helpers_js_1 = require_helpers();
    var AbortError_js_1 = require_AbortError2();
    var logger_js_1 = require_logger();
    var constants_js_1 = require_constants3();
    var retryPolicyLogger = (0, logger_js_1.createClientLogger)("ts-http-runtime retryPolicy");
    var retryPolicyName = "retryPolicy";
    function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
      const logger = options.logger || retryPolicyLogger;
      return {
        name: retryPolicyName,
        async sendRequest(request, next) {
          let response;
          let responseError;
          let retryCount = -1;
          retryRequest:
            while (true) {
              retryCount += 1;
              response = void 0;
              responseError = void 0;
              try {
                logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
                response = await next(request);
                logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
              } catch (e) {
                logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
                responseError = e;
                if (!e || responseError.name !== "RestError") {
                  throw e;
                }
                response = responseError.response;
              }
              if (request.abortSignal?.aborted) {
                logger.error(`Retry ${retryCount}: Request aborted.`);
                const abortError = new AbortError_js_1.AbortError();
                throw abortError;
              }
              if (retryCount >= (options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT)) {
                logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
                if (responseError) {
                  throw responseError;
                } else if (response) {
                  return response;
                } else {
                  throw new Error("Maximum retries reached with no response or error to throw");
                }
              }
              logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
              strategiesLoop:
                for (const strategy of strategies) {
                  const strategyLogger = strategy.logger || logger;
                  strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                  const modifiers = strategy.retry({
                    retryCount,
                    response,
                    responseError
                  });
                  if (modifiers.skipStrategy) {
                    strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                    continue strategiesLoop;
                  }
                  const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                  if (errorToThrow) {
                    strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                    throw errorToThrow;
                  }
                  if (retryAfterInMs || retryAfterInMs === 0) {
                    strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                    await (0, helpers_js_1.delay)(retryAfterInMs, void 0, { abortSignal: request.abortSignal });
                    continue retryRequest;
                  }
                  if (redirectTo) {
                    strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                    request.url = redirectTo;
                    continue retryRequest;
                  }
                }
              if (responseError) {
                logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
                throw responseError;
              }
              if (response) {
                logger.info(`None of the retry strategies could work with the received response. Returning it.`);
                return response;
              }
            }
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/defaultRetryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultRetryPolicyName = void 0;
    exports2.defaultRetryPolicy = defaultRetryPolicy;
    var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
    var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
    var retryPolicy_js_1 = require_retryPolicy();
    var constants_js_1 = require_constants3();
    exports2.defaultRetryPolicyName = "defaultRetryPolicy";
    function defaultRetryPolicy(options = {}) {
      return {
        name: exports2.defaultRetryPolicyName,
        sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options)], {
          maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/formDataPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formDataPolicyName = void 0;
    exports2.formDataPolicy = formDataPolicy;
    var bytesEncoding_js_1 = require_bytesEncoding();
    var checkEnvironment_js_1 = require_checkEnvironment();
    var httpHeaders_js_1 = require_httpHeaders();
    exports2.formDataPolicyName = "formDataPolicy";
    function formDataToFormDataMap(formData) {
      const formDataMap = {};
      for (const [key, value] of formData.entries()) {
        formDataMap[key] ??= [];
        formDataMap[key].push(value);
      }
      return formDataMap;
    }
    function formDataPolicy() {
      return {
        name: exports2.formDataPolicyName,
        async sendRequest(request, next) {
          if (checkEnvironment_js_1.isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
            request.formData = formDataToFormDataMap(request.body);
            request.body = void 0;
          }
          if (request.formData) {
            const contentType = request.headers.get("Content-Type");
            if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
              request.body = wwwFormUrlEncode(request.formData);
            } else {
              await prepareFormData(request.formData, request);
            }
            request.formData = void 0;
          }
          return next(request);
        }
      };
    }
    function wwwFormUrlEncode(formData) {
      const urlSearchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(formData)) {
        if (Array.isArray(value)) {
          for (const subValue of value) {
            urlSearchParams.append(key, subValue.toString());
          }
        } else {
          urlSearchParams.append(key, value.toString());
        }
      }
      return urlSearchParams.toString();
    }
    async function prepareFormData(formData, request) {
      const contentType = request.headers.get("Content-Type");
      if (contentType && !contentType.startsWith("multipart/form-data")) {
        return;
      }
      request.headers.set("Content-Type", contentType ?? "multipart/form-data");
      const parts = [];
      for (const [fieldName, values] of Object.entries(formData)) {
        for (const value of Array.isArray(values) ? values : [values]) {
          if (typeof value === "string") {
            parts.push({
              headers: (0, httpHeaders_js_1.createHttpHeaders)({
                "Content-Disposition": `form-data; name="${fieldName}"`
              }),
              body: (0, bytesEncoding_js_1.stringToUint8Array)(value, "utf-8")
            });
          } else if (value === void 0 || value === null || typeof value !== "object") {
            throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
          } else {
            const fileName = value.name || "blob";
            const headers = (0, httpHeaders_js_1.createHttpHeaders)();
            headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
            headers.set("Content-Type", value.type || "application/octet-stream");
            parts.push({
              headers,
              body: value
            });
          }
        }
      }
      request.multipartBody = { parts };
    }
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/agent-base/dist/helpers.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.req = exports2.json = exports2.toBuffer = void 0;
    var http = __importStar2(require("http"));
    var https = __importStar2(require("https"));
    async function toBuffer(stream) {
      let length = 0;
      const chunks = [];
      for await (const chunk of stream) {
        length += chunk.length;
        chunks.push(chunk);
      }
      return Buffer.concat(chunks, length);
    }
    exports2.toBuffer = toBuffer;
    async function json(stream) {
      const buf = await toBuffer(stream);
      const str = buf.toString("utf8");
      try {
        return JSON.parse(str);
      } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
      }
    }
    exports2.json = json;
    function req(url, opts = {}) {
      const href = typeof url === "string" ? url : url.href;
      const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
      const promise = new Promise((resolve, reject) => {
        req2.once("response", resolve).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    exports2.req = req;
  }
});

// node_modules/agent-base/dist/index.js
var require_dist = __commonJS({
  "node_modules/agent-base/dist/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Agent = void 0;
    var net = __importStar2(require("net"));
    var http = __importStar2(require("http"));
    var https_1 = require("https");
    __exportStar2(require_helpers2(), exports2);
    var INTERNAL = Symbol("AgentBaseInternalState");
    var Agent = class extends http.Agent {
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options) {
        if (options) {
          if (typeof options.secureEndpoint === "boolean") {
            return options.secureEndpoint;
          }
          if (typeof options.protocol === "string") {
            return options.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
          return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options) {
        const secureEndpoint = this.isSecureEndpoint(options);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options);
        }
        return super.getName(options);
      }
      createSocket(req, options, cb) {
        const connectOpts = {
          ...options,
          secureEndpoint: this.isSecureEndpoint(options)
        };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name, fakeSocket);
          if (socket instanceof http.Agent) {
            try {
              return socket.addRequest(req, connectOpts);
            } catch (err) {
              return cb(err);
            }
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options, cb);
        }, (err) => {
          this.decrementSockets(name, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v;
        }
      }
      get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v;
        }
      }
    };
    exports2.Agent = Agent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseProxyResponse = void 0;
    var debug_1 = __importDefault2(require_src());
    var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports2.parseProxyResponse = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpsProxyAgent = void 0;
    var net = __importStar2(require("net"));
    var tls = __importStar2(require("tls"));
    var assert_1 = __importDefault2(require("assert"));
    var debug_1 = __importDefault2(require_src());
    var agent_base_1 = require_dist();
    var url_1 = require("url");
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug = (0, debug_1.default)("https-proxy-agent");
    var setServernameFromNonIpHost = (options) => {
      if (options.servername === void 0 && options.host && !net.isIP(options.host)) {
        return {
          ...options,
          servername: options.host
        };
      }
      return options;
    };
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r
`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect);
        this.emit("proxyConnect", connect, req);
        if (connect.statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            return tls.connect({
              ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
              socket
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug("Replaying proxy buffer for failed request");
          (0, assert_1.default)(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent.protocols = ["http", "https"];
    exports2.HttpsProxyAgent = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/http-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpProxyAgent = void 0;
    var net = __importStar2(require("net"));
    var tls = __importStar2(require("tls"));
    var debug_1 = __importDefault2(require_src());
    var events_1 = require("events");
    var agent_base_1 = require_dist();
    var url_1 = require("url");
    var debug = (0, debug_1.default)("http-proxy-agent");
    var HttpProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      addRequest(req, opts) {
        req._header = null;
        this.setRequestProps(req, opts);
        super.addRequest(req, opts);
      }
      setRequestProps(req, opts) {
        const { proxy } = this;
        const protocol = opts.secureEndpoint ? "https:" : "http:";
        const hostname = req.getHeader("host") || "localhost";
        const base = `${protocol}//${hostname}`;
        const url = new url_1.URL(req.path, base);
        if (opts.port !== 80) {
          url.port = String(opts.port);
        }
        req.path = String(url);
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          const value = headers[name];
          if (value) {
            req.setHeader(name, value);
          }
        }
      }
      async connect(req, opts) {
        req._header = null;
        if (!req.path.includes("://")) {
          this.setRequestProps(req, opts);
        }
        let first;
        let endOfHeaders;
        debug("Regenerating stored HTTP header string for request");
        req._implicitHeader();
        if (req.outputData && req.outputData.length > 0) {
          debug("Patching connection write() output buffer with updated header");
          first = req.outputData[0].data;
          endOfHeaders = first.indexOf("\r\n\r\n") + 4;
          req.outputData[0].data = req._header + first.substring(endOfHeaders);
          debug("Output buffer: %o", req.outputData[0].data);
        }
        let socket;
        if (this.proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(this.connectOpts);
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        await (0, events_1.once)(socket, "connect");
        return socket;
      }
    };
    HttpProxyAgent.protocols = ["http", "https"];
    exports2.HttpProxyAgent = HttpProxyAgent;
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/proxyPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalNoProxyList = exports2.proxyPolicyName = void 0;
    exports2.loadNoProxy = loadNoProxy;
    exports2.getDefaultProxySettings = getDefaultProxySettings;
    exports2.proxyPolicy = proxyPolicy;
    var https_proxy_agent_1 = require_dist2();
    var http_proxy_agent_1 = require_dist3();
    var log_js_1 = require_log2();
    var HTTPS_PROXY = "HTTPS_PROXY";
    var HTTP_PROXY = "HTTP_PROXY";
    var ALL_PROXY = "ALL_PROXY";
    var NO_PROXY = "NO_PROXY";
    exports2.proxyPolicyName = "proxyPolicy";
    exports2.globalNoProxyList = [];
    var noProxyListLoaded = false;
    var globalBypassedMap = /* @__PURE__ */ new Map();
    function getEnvironmentValue(name) {
      if (process.env[name]) {
        return process.env[name];
      } else if (process.env[name.toLowerCase()]) {
        return process.env[name.toLowerCase()];
      }
      return void 0;
    }
    function loadEnvironmentProxyValue() {
      if (!process) {
        return void 0;
      }
      const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
      const allProxy = getEnvironmentValue(ALL_PROXY);
      const httpProxy = getEnvironmentValue(HTTP_PROXY);
      return httpsProxy || allProxy || httpProxy;
    }
    function isBypassed(uri, noProxyList, bypassedMap) {
      if (noProxyList.length === 0) {
        return false;
      }
      const host = new URL(uri).hostname;
      if (bypassedMap?.has(host)) {
        return bypassedMap.get(host);
      }
      let isBypassedFlag = false;
      for (const pattern of noProxyList) {
        if (pattern[0] === ".") {
          if (host.endsWith(pattern)) {
            isBypassedFlag = true;
          } else {
            if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
              isBypassedFlag = true;
            }
          }
        } else {
          if (host === pattern) {
            isBypassedFlag = true;
          }
        }
      }
      bypassedMap?.set(host, isBypassedFlag);
      return isBypassedFlag;
    }
    function loadNoProxy() {
      const noProxy = getEnvironmentValue(NO_PROXY);
      noProxyListLoaded = true;
      if (noProxy) {
        return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
      }
      return [];
    }
    function getDefaultProxySettings(proxyUrl) {
      if (!proxyUrl) {
        proxyUrl = loadEnvironmentProxyValue();
        if (!proxyUrl) {
          return void 0;
        }
      }
      const parsedUrl = new URL(proxyUrl);
      const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
      return {
        host: schema + parsedUrl.hostname,
        port: Number.parseInt(parsedUrl.port || "80"),
        username: parsedUrl.username,
        password: parsedUrl.password
      };
    }
    function getDefaultProxySettingsInternal() {
      const envProxy = loadEnvironmentProxyValue();
      return envProxy ? new URL(envProxy) : void 0;
    }
    function getUrlFromProxySettings(settings) {
      let parsedProxyUrl;
      try {
        parsedProxyUrl = new URL(settings.host);
      } catch {
        throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
      }
      parsedProxyUrl.port = String(settings.port);
      if (settings.username) {
        parsedProxyUrl.username = settings.username;
      }
      if (settings.password) {
        parsedProxyUrl.password = settings.password;
      }
      return parsedProxyUrl;
    }
    function setProxyAgentOnRequest(request, cachedAgents, proxyUrl) {
      if (request.agent) {
        return;
      }
      const url = new URL(request.url);
      const isInsecure = url.protocol !== "https:";
      if (request.tlsSettings) {
        log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
      }
      const headers = request.headers.toJSON();
      if (isInsecure) {
        if (!cachedAgents.httpProxyAgent) {
          cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers });
        }
        request.agent = cachedAgents.httpProxyAgent;
      } else {
        if (!cachedAgents.httpsProxyAgent) {
          cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers });
        }
        request.agent = cachedAgents.httpsProxyAgent;
      }
    }
    function proxyPolicy(proxySettings, options) {
      if (!noProxyListLoaded) {
        exports2.globalNoProxyList.push(...loadNoProxy());
      }
      const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
      const cachedAgents = {};
      return {
        name: exports2.proxyPolicyName,
        async sendRequest(request, next) {
          if (!request.proxySettings && defaultProxy && !isBypassed(request.url, options?.customNoProxyList ?? exports2.globalNoProxyList, options?.customNoProxyList ? void 0 : globalBypassedMap)) {
            setProxyAgentOnRequest(request, cachedAgents, defaultProxy);
          } else if (request.proxySettings) {
            setProxyAgentOnRequest(request, cachedAgents, getUrlFromProxySettings(request.proxySettings));
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/agentPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.agentPolicyName = void 0;
    exports2.agentPolicy = agentPolicy;
    exports2.agentPolicyName = "agentPolicy";
    function agentPolicy(agent) {
      return {
        name: exports2.agentPolicyName,
        sendRequest: async (req, next) => {
          if (!req.agent) {
            req.agent = agent;
          }
          return next(req);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/tlsPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tlsPolicyName = void 0;
    exports2.tlsPolicy = tlsPolicy;
    exports2.tlsPolicyName = "tlsPolicy";
    function tlsPolicy(tlsSettings) {
      return {
        name: exports2.tlsPolicyName,
        sendRequest: async (req, next) => {
          if (!req.tlsSettings) {
            req.tlsSettings = tlsSettings;
          }
          return next(req);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/typeGuards.js
var require_typeGuards2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/typeGuards.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNodeReadableStream = isNodeReadableStream;
    exports2.isWebReadableStream = isWebReadableStream;
    exports2.isBinaryBody = isBinaryBody;
    exports2.isReadableStream = isReadableStream;
    exports2.isBlob = isBlob;
    function isNodeReadableStream(x) {
      return Boolean(x && typeof x["pipe"] === "function");
    }
    function isWebReadableStream(x) {
      return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
    }
    function isBinaryBody(body) {
      return body !== void 0 && (body instanceof Uint8Array || isReadableStream(body) || typeof body === "function" || body instanceof Blob);
    }
    function isReadableStream(x) {
      return isNodeReadableStream(x) || isWebReadableStream(x);
    }
    function isBlob(x) {
      return typeof x.stream === "function";
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/concat.js
var require_concat = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/util/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concat = concat;
    var stream_1 = require("stream");
    var typeGuards_js_1 = require_typeGuards2();
    async function* streamAsyncIterator() {
      const reader = this.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            return;
          }
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
    function makeAsyncIterable(webStream) {
      if (!webStream[Symbol.asyncIterator]) {
        webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
      }
      if (!webStream.values) {
        webStream.values = streamAsyncIterator.bind(webStream);
      }
    }
    function ensureNodeStream(stream) {
      if (stream instanceof ReadableStream) {
        makeAsyncIterable(stream);
        return stream_1.Readable.fromWeb(stream);
      } else {
        return stream;
      }
    }
    function toStream(source) {
      if (source instanceof Uint8Array) {
        return stream_1.Readable.from(Buffer.from(source));
      } else if ((0, typeGuards_js_1.isBlob)(source)) {
        return ensureNodeStream(source.stream());
      } else {
        return ensureNodeStream(source);
      }
    }
    async function concat(sources) {
      return function() {
        const streams = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
        return stream_1.Readable.from(async function* () {
          for (const stream of streams) {
            for await (const chunk of stream) {
              yield chunk;
            }
          }
        }());
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/multipartPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.multipartPolicyName = void 0;
    exports2.multipartPolicy = multipartPolicy;
    var bytesEncoding_js_1 = require_bytesEncoding();
    var typeGuards_js_1 = require_typeGuards2();
    var uuidUtils_js_1 = require_uuidUtils();
    var concat_js_1 = require_concat();
    function generateBoundary() {
      return `----AzSDKFormBoundary${(0, uuidUtils_js_1.randomUUID)()}`;
    }
    function encodeHeaders(headers) {
      let result = "";
      for (const [key, value] of headers) {
        result += `${key}: ${value}\r
`;
      }
      return result;
    }
    function getLength(source) {
      if (source instanceof Uint8Array) {
        return source.byteLength;
      } else if ((0, typeGuards_js_1.isBlob)(source)) {
        return source.size === -1 ? void 0 : source.size;
      } else {
        return void 0;
      }
    }
    function getTotalLength(sources) {
      let total = 0;
      for (const source of sources) {
        const partLength = getLength(source);
        if (partLength === void 0) {
          return void 0;
        } else {
          total += partLength;
        }
      }
      return total;
    }
    async function buildRequestBody(request, parts, boundary) {
      const sources = [
        (0, bytesEncoding_js_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
        ...parts.flatMap((part) => [
          (0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
          (0, bytesEncoding_js_1.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"),
          (0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
          part.body,
          (0, bytesEncoding_js_1.stringToUint8Array)(`\r
--${boundary}`, "utf-8")
        ]),
        (0, bytesEncoding_js_1.stringToUint8Array)("--\r\n\r\n", "utf-8")
      ];
      const contentLength = getTotalLength(sources);
      if (contentLength) {
        request.headers.set("Content-Length", contentLength);
      }
      request.body = await (0, concat_js_1.concat)(sources);
    }
    exports2.multipartPolicyName = "multipartPolicy";
    var maxBoundaryLength = 70;
    var validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
    function assertValidBoundary(boundary) {
      if (boundary.length > maxBoundaryLength) {
        throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
      }
      if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
        throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
      }
    }
    function multipartPolicy() {
      return {
        name: exports2.multipartPolicyName,
        async sendRequest(request, next) {
          if (!request.multipartBody) {
            return next(request);
          }
          if (request.body) {
            throw new Error("multipartBody and regular body cannot be set at the same time");
          }
          let boundary = request.multipartBody.boundary;
          const contentTypeHeader = request.headers.get("Content-Type") ?? "multipart/mixed";
          const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
          if (!parsedHeader) {
            throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
          }
          const [, contentType, parsedBoundary] = parsedHeader;
          if (parsedBoundary && boundary && parsedBoundary !== boundary) {
            throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
          }
          boundary ??= parsedBoundary;
          if (boundary) {
            assertValidBoundary(boundary);
          } else {
            boundary = generateBoundary();
          }
          request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
          await buildRequestBody(request, request.multipartBody.parts, boundary);
          request.multipartBody = void 0;
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/createPipelineFromOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPipelineFromOptions = createPipelineFromOptions;
    var logPolicy_js_1 = require_logPolicy();
    var pipeline_js_1 = require_pipeline();
    var redirectPolicy_js_1 = require_redirectPolicy();
    var userAgentPolicy_js_1 = require_userAgentPolicy();
    var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
    var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
    var formDataPolicy_js_1 = require_formDataPolicy();
    var checkEnvironment_js_1 = require_checkEnvironment();
    var proxyPolicy_js_1 = require_proxyPolicy();
    var agentPolicy_js_1 = require_agentPolicy();
    var tlsPolicy_js_1 = require_tlsPolicy();
    var multipartPolicy_js_1 = require_multipartPolicy();
    function createPipelineFromOptions(options) {
      const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
      if (checkEnvironment_js_1.isNodeLike) {
        if (options.agent) {
          pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
        }
        if (options.tlsOptions) {
          pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
        }
        pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
        pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
      }
      pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
      pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
      pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
      pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
      if (checkEnvironment_js_1.isNodeLike) {
        pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
      }
      pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
      return pipeline;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/apiVersionPolicy.js
var require_apiVersionPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/apiVersionPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.apiVersionPolicyName = void 0;
    exports2.apiVersionPolicy = apiVersionPolicy;
    exports2.apiVersionPolicyName = "ApiVersionPolicy";
    function apiVersionPolicy(options) {
      return {
        name: exports2.apiVersionPolicyName,
        sendRequest: (req, next) => {
          const url = new URL(req.url);
          if (!url.searchParams.get("api-version") && options.apiVersion) {
            req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
          }
          return next(req);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/credentials.js
var require_credentials = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isOAuth2TokenCredential = isOAuth2TokenCredential;
    exports2.isBearerTokenCredential = isBearerTokenCredential;
    exports2.isBasicCredential = isBasicCredential;
    exports2.isApiKeyCredential = isApiKeyCredential;
    function isOAuth2TokenCredential(credential) {
      return "getOAuth2Token" in credential;
    }
    function isBearerTokenCredential(credential) {
      return "getBearerToken" in credential;
    }
    function isBasicCredential(credential) {
      return "username" in credential && "password" in credential;
    }
    function isApiKeyCredential(credential) {
      return "key" in credential;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/checkInsecureConnection.js
var require_checkInsecureConnection = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/checkInsecureConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureSecureConnection = ensureSecureConnection;
    var log_js_1 = require_log2();
    var insecureConnectionWarningEmmitted = false;
    function allowInsecureConnection(request, options) {
      if (options.allowInsecureConnection && request.allowInsecureConnection) {
        const url = new URL(request.url);
        if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
          return true;
        }
      }
      return false;
    }
    function emitInsecureConnectionWarning() {
      const warning = "Sending token over insecure transport. Assume any token issued is compromised.";
      log_js_1.logger.warning(warning);
      if (typeof process?.emitWarning === "function" && !insecureConnectionWarningEmmitted) {
        insecureConnectionWarningEmmitted = true;
        process.emitWarning(warning);
      }
    }
    function ensureSecureConnection(request, options) {
      if (!request.url.toLowerCase().startsWith("https://")) {
        if (allowInsecureConnection(request, options)) {
          emitInsecureConnectionWarning();
        } else {
          throw new Error("Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.");
        }
      }
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/apiKeyAuthenticationPolicy.js
var require_apiKeyAuthenticationPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/apiKeyAuthenticationPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.apiKeyAuthenticationPolicyName = void 0;
    exports2.apiKeyAuthenticationPolicy = apiKeyAuthenticationPolicy;
    var checkInsecureConnection_js_1 = require_checkInsecureConnection();
    exports2.apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
    function apiKeyAuthenticationPolicy(options) {
      return {
        name: exports2.apiKeyAuthenticationPolicyName,
        async sendRequest(request, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
          const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "apiKey");
          if (!scheme) {
            return next(request);
          }
          if (scheme.apiKeyLocation !== "header") {
            throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
          }
          request.headers.set(scheme.name, options.credential.key);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/basicAuthenticationPolicy.js
var require_basicAuthenticationPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/basicAuthenticationPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.basicAuthenticationPolicyName = void 0;
    exports2.basicAuthenticationPolicy = basicAuthenticationPolicy;
    var bytesEncoding_js_1 = require_bytesEncoding();
    var checkInsecureConnection_js_1 = require_checkInsecureConnection();
    exports2.basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
    function basicAuthenticationPolicy(options) {
      return {
        name: exports2.basicAuthenticationPolicyName,
        async sendRequest(request, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
          const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "basic");
          if (!scheme) {
            return next(request);
          }
          const { username, password } = options.credential;
          const headerValue = (0, bytesEncoding_js_1.uint8ArrayToString)((0, bytesEncoding_js_1.stringToUint8Array)(`${username}:${password}`, "utf-8"), "base64");
          request.headers.set("Authorization", `Basic ${headerValue}`);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/bearerAuthenticationPolicy.js
var require_bearerAuthenticationPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/bearerAuthenticationPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bearerAuthenticationPolicyName = void 0;
    exports2.bearerAuthenticationPolicy = bearerAuthenticationPolicy;
    var checkInsecureConnection_js_1 = require_checkInsecureConnection();
    exports2.bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
    function bearerAuthenticationPolicy(options) {
      return {
        name: exports2.bearerAuthenticationPolicyName,
        async sendRequest(request, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
          const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "bearer");
          if (!scheme) {
            return next(request);
          }
          const token = await options.credential.getBearerToken({
            abortSignal: request.abortSignal
          });
          request.headers.set("Authorization", `Bearer ${token}`);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/oauth2AuthenticationPolicy.js
var require_oauth2AuthenticationPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/oauth2AuthenticationPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.oauth2AuthenticationPolicyName = void 0;
    exports2.oauth2AuthenticationPolicy = oauth2AuthenticationPolicy;
    var checkInsecureConnection_js_1 = require_checkInsecureConnection();
    exports2.oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
    function oauth2AuthenticationPolicy(options) {
      return {
        name: exports2.oauth2AuthenticationPolicyName,
        async sendRequest(request, next) {
          (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
          const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "oauth2");
          if (!scheme) {
            return next(request);
          }
          const token = await options.credential.getOAuth2Token(scheme.flows, {
            abortSignal: request.abortSignal
          });
          request.headers.set("Authorization", `Bearer ${token}`);
          return next(request);
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/clientHelpers.js
var require_clientHelpers = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/clientHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultPipeline = createDefaultPipeline;
    exports2.getCachedDefaultHttpsClient = getCachedDefaultHttpsClient;
    var defaultHttpClient_js_1 = require_defaultHttpClient();
    var createPipelineFromOptions_js_1 = require_createPipelineFromOptions();
    var apiVersionPolicy_js_1 = require_apiVersionPolicy();
    var credentials_js_1 = require_credentials();
    var apiKeyAuthenticationPolicy_js_1 = require_apiKeyAuthenticationPolicy();
    var basicAuthenticationPolicy_js_1 = require_basicAuthenticationPolicy();
    var bearerAuthenticationPolicy_js_1 = require_bearerAuthenticationPolicy();
    var oauth2AuthenticationPolicy_js_1 = require_oauth2AuthenticationPolicy();
    var cachedHttpClient;
    function createDefaultPipeline(options = {}) {
      const pipeline = (0, createPipelineFromOptions_js_1.createPipelineFromOptions)(options);
      pipeline.addPolicy((0, apiVersionPolicy_js_1.apiVersionPolicy)(options));
      const { credential, authSchemes, allowInsecureConnection } = options;
      if (credential) {
        if ((0, credentials_js_1.isApiKeyCredential)(credential)) {
          pipeline.addPolicy((0, apiKeyAuthenticationPolicy_js_1.apiKeyAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
        } else if ((0, credentials_js_1.isBasicCredential)(credential)) {
          pipeline.addPolicy((0, basicAuthenticationPolicy_js_1.basicAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
        } else if ((0, credentials_js_1.isBearerTokenCredential)(credential)) {
          pipeline.addPolicy((0, bearerAuthenticationPolicy_js_1.bearerAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
        } else if ((0, credentials_js_1.isOAuth2TokenCredential)(credential)) {
          pipeline.addPolicy((0, oauth2AuthenticationPolicy_js_1.oauth2AuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
        }
      }
      return pipeline;
    }
    function getCachedDefaultHttpsClient() {
      if (!cachedHttpClient) {
        cachedHttpClient = (0, defaultHttpClient_js_1.createDefaultHttpClient)();
      }
      return cachedHttpClient;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/multipart.js
var require_multipart = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/multipart.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildBodyPart = buildBodyPart;
    exports2.buildMultipartBody = buildMultipartBody;
    var restError_js_1 = require_restError();
    var httpHeaders_js_1 = require_httpHeaders();
    var bytesEncoding_js_1 = require_bytesEncoding();
    var typeGuards_js_1 = require_typeGuards2();
    function getHeaderValue(descriptor, headerName) {
      if (descriptor.headers) {
        const actualHeaderName = Object.keys(descriptor.headers).find((x) => x.toLowerCase() === headerName.toLowerCase());
        if (actualHeaderName) {
          return descriptor.headers[actualHeaderName];
        }
      }
      return void 0;
    }
    function getPartContentType(descriptor) {
      const contentTypeHeader = getHeaderValue(descriptor, "content-type");
      if (contentTypeHeader) {
        return contentTypeHeader;
      }
      if (descriptor.contentType === null) {
        return void 0;
      }
      if (descriptor.contentType) {
        return descriptor.contentType;
      }
      const { body } = descriptor;
      if (body === null || body === void 0) {
        return void 0;
      }
      if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
        return "text/plain; charset=UTF-8";
      }
      if (body instanceof Blob) {
        return body.type || "application/octet-stream";
      }
      if ((0, typeGuards_js_1.isBinaryBody)(body)) {
        return "application/octet-stream";
      }
      return "application/json";
    }
    function escapeDispositionField(value) {
      return JSON.stringify(value);
    }
    function getContentDisposition(descriptor) {
      const contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
      if (contentDispositionHeader) {
        return contentDispositionHeader;
      }
      if (descriptor.dispositionType === void 0 && descriptor.name === void 0 && descriptor.filename === void 0) {
        return void 0;
      }
      const dispositionType = descriptor.dispositionType ?? "form-data";
      let disposition = dispositionType;
      if (descriptor.name) {
        disposition += `; name=${escapeDispositionField(descriptor.name)}`;
      }
      let filename = void 0;
      if (descriptor.filename) {
        filename = descriptor.filename;
      } else if (typeof File !== "undefined" && descriptor.body instanceof File) {
        const filenameFromFile = descriptor.body.name;
        if (filenameFromFile !== "") {
          filename = filenameFromFile;
        }
      }
      if (filename) {
        disposition += `; filename=${escapeDispositionField(filename)}`;
      }
      return disposition;
    }
    function normalizeBody(body, contentType) {
      if (body === void 0) {
        return new Uint8Array([]);
      }
      if ((0, typeGuards_js_1.isBinaryBody)(body)) {
        return body;
      }
      if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
        return (0, bytesEncoding_js_1.stringToUint8Array)(String(body), "utf-8");
      }
      if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) {
        return (0, bytesEncoding_js_1.stringToUint8Array)(JSON.stringify(body), "utf-8");
      }
      throw new restError_js_1.RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
    }
    function buildBodyPart(descriptor) {
      const contentType = getPartContentType(descriptor);
      const contentDisposition = getContentDisposition(descriptor);
      const headers = (0, httpHeaders_js_1.createHttpHeaders)(descriptor.headers ?? {});
      if (contentType) {
        headers.set("content-type", contentType);
      }
      if (contentDisposition) {
        headers.set("content-disposition", contentDisposition);
      }
      const body = normalizeBody(descriptor.body, contentType);
      return {
        headers,
        body
      };
    }
    function buildMultipartBody(parts) {
      return { parts: parts.map(buildBodyPart) };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/sendRequest.js
var require_sendRequest = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/sendRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sendRequest = sendRequest;
    var restError_js_1 = require_restError();
    var httpHeaders_js_1 = require_httpHeaders();
    var pipelineRequest_js_1 = require_pipelineRequest();
    var clientHelpers_js_1 = require_clientHelpers();
    var typeGuards_js_1 = require_typeGuards2();
    var multipart_js_1 = require_multipart();
    async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
      const httpClient = customHttpClient ?? (0, clientHelpers_js_1.getCachedDefaultHttpsClient)();
      const request = buildPipelineRequest(method, url, options);
      try {
        const response = await pipeline.sendRequest(httpClient, request);
        const headers = response.headers.toJSON();
        const stream = response.readableStreamBody ?? response.browserStreamBody;
        const parsedBody = options.responseAsStream || stream !== void 0 ? void 0 : getResponseBody(response);
        const body = stream ?? parsedBody;
        if (options?.onResponse) {
          options.onResponse({ ...response, request, rawHeaders: headers, parsedBody });
        }
        return {
          request,
          headers,
          status: `${response.status}`,
          body
        };
      } catch (e) {
        if ((0, restError_js_1.isRestError)(e) && e.response && options.onResponse) {
          const { response } = e;
          const rawHeaders = response.headers.toJSON();
          options?.onResponse({ ...response, request, rawHeaders }, e);
        }
        throw e;
      }
    }
    function getRequestContentType(options = {}) {
      return options.contentType ?? options.headers?.["content-type"] ?? getContentType(options.body);
    }
    function getContentType(body) {
      if (body === void 0) {
        return void 0;
      }
      if (ArrayBuffer.isView(body)) {
        return "application/octet-stream";
      }
      if (typeof body === "string") {
        try {
          JSON.parse(body);
          return "application/json";
        } catch (error) {
          return void 0;
        }
      }
      return "application/json";
    }
    function buildPipelineRequest(method, url, options = {}) {
      const requestContentType = getRequestContentType(options);
      const { body, multipartBody } = getRequestBody(options.body, requestContentType);
      const headers = (0, httpHeaders_js_1.createHttpHeaders)({
        ...options.headers ? options.headers : {},
        accept: options.accept ?? options.headers?.accept ?? "application/json",
        ...requestContentType && {
          "content-type": requestContentType
        }
      });
      return (0, pipelineRequest_js_1.createPipelineRequest)({
        url,
        method,
        body,
        multipartBody,
        headers,
        allowInsecureConnection: options.allowInsecureConnection,
        abortSignal: options.abortSignal,
        onUploadProgress: options.onUploadProgress,
        onDownloadProgress: options.onDownloadProgress,
        timeout: options.timeout,
        enableBrowserStreams: true,
        streamResponseStatusCodes: options.responseAsStream ? /* @__PURE__ */ new Set([Number.POSITIVE_INFINITY]) : void 0
      });
    }
    function getRequestBody(body, contentType = "") {
      if (body === void 0) {
        return { body: void 0 };
      }
      if (typeof FormData !== "undefined" && body instanceof FormData) {
        return { body };
      }
      if ((0, typeGuards_js_1.isReadableStream)(body)) {
        return { body };
      }
      if (ArrayBuffer.isView(body)) {
        return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
      }
      const firstType = contentType.split(";")[0];
      switch (firstType) {
        case "application/json":
          return { body: JSON.stringify(body) };
        case "multipart/form-data":
          if (Array.isArray(body)) {
            return { multipartBody: (0, multipart_js_1.buildMultipartBody)(body) };
          }
          return { body: JSON.stringify(body) };
        case "text/plain":
          return { body: String(body) };
        default:
          if (typeof body === "string") {
            return { body };
          }
          return { body: JSON.stringify(body) };
      }
    }
    function getResponseBody(response) {
      const contentType = response.headers.get("content-type") ?? "";
      const firstType = contentType.split(";")[0];
      const bodyToParse = response.bodyAsText ?? "";
      if (firstType === "text/plain") {
        return String(bodyToParse);
      }
      try {
        return bodyToParse ? JSON.parse(bodyToParse) : void 0;
      } catch (error) {
        if (firstType === "application/json") {
          throw createParseError(response, error);
        }
        return String(bodyToParse);
      }
    }
    function createParseError(response, err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
      const errCode = err.code ?? restError_js_1.RestError.PARSE_ERROR;
      return new restError_js_1.RestError(msg, {
        code: errCode,
        statusCode: response.status,
        request: response.request,
        response
      });
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/urlHelpers.js
var require_urlHelpers = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/urlHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildRequestUrl = buildRequestUrl;
    exports2.buildBaseUrl = buildBaseUrl;
    exports2.replaceAll = replaceAll;
    function isQueryParameterWithOptions(x) {
      const value = x.value;
      return value !== void 0 && value.toString !== void 0 && typeof value.toString === "function";
    }
    function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {
      if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
        return routePath;
      }
      endpoint = buildBaseUrl(endpoint, options);
      routePath = buildRoutePath(routePath, pathParameters, options);
      const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);
      const url = new URL(requestUrl);
      return url.toString().replace(/([^:]\/)\/+/g, "$1");
    }
    function getQueryParamValue(key, allowReserved, style, param) {
      let separator;
      if (style === "pipeDelimited") {
        separator = "|";
      } else if (style === "spaceDelimited") {
        separator = "%20";
      } else {
        separator = ",";
      }
      let paramValues;
      if (Array.isArray(param)) {
        paramValues = param;
      } else if (typeof param === "object" && param.toString === Object.prototype.toString) {
        paramValues = Object.entries(param).flat();
      } else {
        paramValues = [param];
      }
      const value = paramValues.map((p) => {
        if (p === null || p === void 0) {
          return "";
        }
        if (!p.toString || typeof p.toString !== "function") {
          throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
        }
        const rawValue = p.toISOString !== void 0 ? p.toISOString() : p.toString();
        return allowReserved ? rawValue : encodeURIComponent(rawValue);
      }).join(separator);
      return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;
    }
    function appendQueryParams(url, options = {}) {
      if (!options.queryParameters) {
        return url;
      }
      const parsedUrl = new URL(url);
      const queryParams = options.queryParameters;
      const paramStrings = [];
      for (const key of Object.keys(queryParams)) {
        const param = queryParams[key];
        if (param === void 0 || param === null) {
          continue;
        }
        const hasMetadata = isQueryParameterWithOptions(param);
        const rawValue = hasMetadata ? param.value : param;
        const explode = hasMetadata ? param.explode ?? false : false;
        const style = hasMetadata && param.style ? param.style : "form";
        if (explode) {
          if (Array.isArray(rawValue)) {
            for (const item of rawValue) {
              paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, item));
            }
          } else if (typeof rawValue === "object") {
            for (const [actualKey, value] of Object.entries(rawValue)) {
              paramStrings.push(getQueryParamValue(actualKey, options.skipUrlEncoding ?? false, style, value));
            }
          } else {
            throw new Error("explode can only be set to true for objects and arrays");
          }
        } else {
          paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, rawValue));
        }
      }
      if (parsedUrl.search !== "") {
        parsedUrl.search += "&";
      }
      parsedUrl.search += paramStrings.join("&");
      return parsedUrl.toString();
    }
    function buildBaseUrl(endpoint, options) {
      if (!options.pathParameters) {
        return endpoint;
      }
      const pathParams = options.pathParameters;
      for (const [key, param] of Object.entries(pathParams)) {
        if (param === void 0 || param === null) {
          throw new Error(`Path parameters ${key} must not be undefined or null`);
        }
        if (!param.toString || typeof param.toString !== "function") {
          throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
        }
        let value = param.toISOString !== void 0 ? param.toISOString() : String(param);
        if (!options.skipUrlEncoding) {
          value = encodeURIComponent(param);
        }
        endpoint = replaceAll(endpoint, `{${key}}`, value) ?? "";
      }
      return endpoint;
    }
    function buildRoutePath(routePath, pathParameters, options = {}) {
      for (const pathParam of pathParameters) {
        const allowReserved = typeof pathParam === "object" && (pathParam.allowReserved ?? false);
        let value = typeof pathParam === "object" ? pathParam.value : pathParam;
        if (!options.skipUrlEncoding && !allowReserved) {
          value = encodeURIComponent(value);
        }
        routePath = routePath.replace(/\{[\w-]+\}/, String(value));
      }
      return routePath;
    }
    function replaceAll(value, searchValue, replaceValue) {
      return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/getClient.js
var require_getClient = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/getClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getClient = getClient;
    var clientHelpers_js_1 = require_clientHelpers();
    var sendRequest_js_1 = require_sendRequest();
    var urlHelpers_js_1 = require_urlHelpers();
    var checkEnvironment_js_1 = require_checkEnvironment();
    function getClient(endpoint, clientOptions = {}) {
      const pipeline = clientOptions.pipeline ?? (0, clientHelpers_js_1.createDefaultPipeline)(clientOptions);
      if (clientOptions.additionalPolicies?.length) {
        for (const { policy, position } of clientOptions.additionalPolicies) {
          const afterPhase = position === "perRetry" ? "Sign" : void 0;
          pipeline.addPolicy(policy, {
            afterPhase
          });
        }
      }
      const { allowInsecureConnection, httpClient } = clientOptions;
      const endpointUrl = clientOptions.endpoint ?? endpoint;
      const client = (path2, ...args) => {
        const getUrl = (requestOptions) => (0, urlHelpers_js_1.buildRequestUrl)(endpointUrl, path2, args, { allowInsecureConnection, ...requestOptions });
        return {
          get: (requestOptions = {}) => {
            return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          post: (requestOptions = {}) => {
            return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          put: (requestOptions = {}) => {
            return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          patch: (requestOptions = {}) => {
            return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          delete: (requestOptions = {}) => {
            return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          head: (requestOptions = {}) => {
            return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          options: (requestOptions = {}) => {
            return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          },
          trace: (requestOptions = {}) => {
            return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
          }
        };
      };
      return {
        path: client,
        pathUnchecked: client,
        pipeline
      };
    }
    function buildOperation(method, url, pipeline, options, allowInsecureConnection, httpClient) {
      allowInsecureConnection = options.allowInsecureConnection ?? allowInsecureConnection;
      return {
        then: function(onFulfilled, onrejected) {
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection }, httpClient).then(onFulfilled, onrejected);
        },
        async asBrowserStream() {
          if (checkEnvironment_js_1.isNodeLike) {
            throw new Error("`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.");
          } else {
            return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: true }, httpClient);
          }
        },
        async asNodeStream() {
          if (checkEnvironment_js_1.isNodeLike) {
            return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: true }, httpClient);
          } else {
            throw new Error("`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.");
          }
        }
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/operationOptionHelpers.js
var require_operationOptionHelpers = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/operationOptionHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.operationOptionsToRequestParameters = operationOptionsToRequestParameters;
    function operationOptionsToRequestParameters(options) {
      return {
        allowInsecureConnection: options.requestOptions?.allowInsecureConnection,
        timeout: options.requestOptions?.timeout,
        skipUrlEncoding: options.requestOptions?.skipUrlEncoding,
        abortSignal: options.abortSignal,
        onUploadProgress: options.requestOptions?.onUploadProgress,
        onDownloadProgress: options.requestOptions?.onDownloadProgress,
        headers: { ...options.requestOptions?.headers },
        onResponse: options.onResponse
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/restError.js
var require_restError2 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/client/restError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createRestError = createRestError;
    var restError_js_1 = require_restError();
    var httpHeaders_js_1 = require_httpHeaders();
    function createRestError(messageOrResponse, response) {
      const resp = typeof messageOrResponse === "string" ? response : messageOrResponse;
      const internalError = resp.body?.error ?? resp.body;
      const message = typeof messageOrResponse === "string" ? messageOrResponse : internalError?.message ?? `Unexpected status code: ${resp.status}`;
      return new restError_js_1.RestError(message, {
        statusCode: statusCodeToNumber(resp.status),
        code: internalError?.code,
        request: resp.request,
        response: toPipelineResponse(resp)
      });
    }
    function toPipelineResponse(response) {
      return {
        headers: (0, httpHeaders_js_1.createHttpHeaders)(response.headers),
        request: response.request,
        status: statusCodeToNumber(response.status) ?? -1
      };
    }
    function statusCodeToNumber(statusCode) {
      const status = Number.parseInt(statusCode);
      return Number.isNaN(status) ? void 0 : status;
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/index.js
var require_commonjs5 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createRestError = exports2.operationOptionsToRequestParameters = exports2.getClient = exports2.createDefaultHttpClient = exports2.uint8ArrayToString = exports2.stringToUint8Array = exports2.isRestError = exports2.RestError = exports2.createEmptyPipeline = exports2.createPipelineRequest = exports2.createHttpHeaders = exports2.TypeSpecRuntimeLogger = exports2.setLogLevel = exports2.getLogLevel = exports2.createClientLogger = exports2.AbortError = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var AbortError_js_1 = require_AbortError2();
    Object.defineProperty(exports2, "AbortError", { enumerable: true, get: function() {
      return AbortError_js_1.AbortError;
    } });
    var logger_js_1 = require_logger();
    Object.defineProperty(exports2, "createClientLogger", { enumerable: true, get: function() {
      return logger_js_1.createClientLogger;
    } });
    Object.defineProperty(exports2, "getLogLevel", { enumerable: true, get: function() {
      return logger_js_1.getLogLevel;
    } });
    Object.defineProperty(exports2, "setLogLevel", { enumerable: true, get: function() {
      return logger_js_1.setLogLevel;
    } });
    Object.defineProperty(exports2, "TypeSpecRuntimeLogger", { enumerable: true, get: function() {
      return logger_js_1.TypeSpecRuntimeLogger;
    } });
    var httpHeaders_js_1 = require_httpHeaders();
    Object.defineProperty(exports2, "createHttpHeaders", { enumerable: true, get: function() {
      return httpHeaders_js_1.createHttpHeaders;
    } });
    tslib_1.__exportStar(require_schemes(), exports2);
    tslib_1.__exportStar(require_oauth2Flows(), exports2);
    var pipelineRequest_js_1 = require_pipelineRequest();
    Object.defineProperty(exports2, "createPipelineRequest", { enumerable: true, get: function() {
      return pipelineRequest_js_1.createPipelineRequest;
    } });
    var pipeline_js_1 = require_pipeline();
    Object.defineProperty(exports2, "createEmptyPipeline", { enumerable: true, get: function() {
      return pipeline_js_1.createEmptyPipeline;
    } });
    var restError_js_1 = require_restError();
    Object.defineProperty(exports2, "RestError", { enumerable: true, get: function() {
      return restError_js_1.RestError;
    } });
    Object.defineProperty(exports2, "isRestError", { enumerable: true, get: function() {
      return restError_js_1.isRestError;
    } });
    var bytesEncoding_js_1 = require_bytesEncoding();
    Object.defineProperty(exports2, "stringToUint8Array", { enumerable: true, get: function() {
      return bytesEncoding_js_1.stringToUint8Array;
    } });
    Object.defineProperty(exports2, "uint8ArrayToString", { enumerable: true, get: function() {
      return bytesEncoding_js_1.uint8ArrayToString;
    } });
    var defaultHttpClient_js_1 = require_defaultHttpClient();
    Object.defineProperty(exports2, "createDefaultHttpClient", { enumerable: true, get: function() {
      return defaultHttpClient_js_1.createDefaultHttpClient;
    } });
    var getClient_js_1 = require_getClient();
    Object.defineProperty(exports2, "getClient", { enumerable: true, get: function() {
      return getClient_js_1.getClient;
    } });
    var operationOptionHelpers_js_1 = require_operationOptionHelpers();
    Object.defineProperty(exports2, "operationOptionsToRequestParameters", { enumerable: true, get: function() {
      return operationOptionHelpers_js_1.operationOptionsToRequestParameters;
    } });
    var restError_js_2 = require_restError2();
    Object.defineProperty(exports2, "createRestError", { enumerable: true, get: function() {
      return restError_js_2.createRestError;
    } });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipeline.js
var require_pipeline2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/pipeline.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEmptyPipeline = createEmptyPipeline;
    var ts_http_runtime_1 = require_commonjs5();
    function createEmptyPipeline() {
      return (0, ts_http_runtime_1.createEmptyPipeline)();
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/log.js
var require_log3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/log.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logger = void 0;
    var logger_1 = require_commonjs();
    exports2.logger = (0, logger_1.createClientLogger)("core-rest-pipeline");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/exponentialRetryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exponentialRetryPolicyName = void 0;
    exports2.exponentialRetryPolicy = exponentialRetryPolicy;
    var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
    var retryPolicy_js_1 = require_retryPolicy();
    var constants_js_1 = require_constants3();
    exports2.exponentialRetryPolicyName = "exponentialRetryPolicy";
    function exponentialRetryPolicy(options = {}) {
      return (0, retryPolicy_js_1.retryPolicy)([
        (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
          ...options,
          ignoreSystemErrors: true
        })
      ], {
        maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      });
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/systemErrorRetryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.systemErrorRetryPolicyName = void 0;
    exports2.systemErrorRetryPolicy = systemErrorRetryPolicy;
    var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
    var retryPolicy_js_1 = require_retryPolicy();
    var constants_js_1 = require_constants3();
    exports2.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
    function systemErrorRetryPolicy(options = {}) {
      return {
        name: exports2.systemErrorRetryPolicyName,
        sendRequest: (0, retryPolicy_js_1.retryPolicy)([
          (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
            ...options,
            ignoreHttpStatusCodes: true
          })
        ], {
          maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/throttlingRetryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throttlingRetryPolicyName = void 0;
    exports2.throttlingRetryPolicy = throttlingRetryPolicy;
    var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
    var retryPolicy_js_1 = require_retryPolicy();
    var constants_js_1 = require_constants3();
    exports2.throttlingRetryPolicyName = "throttlingRetryPolicy";
    function throttlingRetryPolicy(options = {}) {
      return {
        name: exports2.throttlingRetryPolicyName,
        sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], {
          maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/internal.js
var require_internal3 = __commonJS({
  "node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/internal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.userAgentPolicyName = exports2.userAgentPolicy = exports2.tlsPolicyName = exports2.tlsPolicy = exports2.redirectPolicyName = exports2.redirectPolicy = exports2.getDefaultProxySettings = exports2.proxyPolicyName = exports2.proxyPolicy = exports2.multipartPolicyName = exports2.multipartPolicy = exports2.logPolicyName = exports2.logPolicy = exports2.formDataPolicyName = exports2.formDataPolicy = exports2.throttlingRetryPolicyName = exports2.throttlingRetryPolicy = exports2.systemErrorRetryPolicyName = exports2.systemErrorRetryPolicy = exports2.retryPolicy = exports2.exponentialRetryPolicyName = exports2.exponentialRetryPolicy = exports2.defaultRetryPolicyName = exports2.defaultRetryPolicy = exports2.decompressResponsePolicyName = exports2.decompressResponsePolicy = exports2.agentPolicyName = exports2.agentPolicy = void 0;
    var agentPolicy_js_1 = require_agentPolicy();
    Object.defineProperty(exports2, "agentPolicy", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicy;
    } });
    Object.defineProperty(exports2, "agentPolicyName", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicyName;
    } });
    var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
    Object.defineProperty(exports2, "decompressResponsePolicy", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicy;
    } });
    Object.defineProperty(exports2, "decompressResponsePolicyName", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicyName;
    } });
    var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
    Object.defineProperty(exports2, "defaultRetryPolicy", { enumerable: true, get: function() {
      return defaultRetryPolicy_js_1.defaultRetryPolicy;
    } });
    Object.defineProperty(exports2, "defaultRetryPolicyName", { enumerable: true, get: function() {
      return defaultRetryPolicy_js_1.defaultRetryPolicyName;
    } });
    var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy();
    Object.defineProperty(exports2, "exponentialRetryPolicy", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
    } });
    Object.defineProperty(exports2, "exponentialRetryPolicyName", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
    } });
    var retryPolicy_js_1 = require_retryPolicy();
    Object.defineProperty(exports2, "retryPolicy", { enumerable: true, get: function() {
      return retryPolicy_js_1.retryPolicy;
    } });
    var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy();
    Object.defineProperty(exports2, "systemErrorRetryPolicy", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
    } });
    Object.defineProperty(exports2, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
    } });
    var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy();
    Object.defineProperty(exports2, "throttlingRetryPolicy", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
    } });
    Object.defineProperty(exports2, "throttlingRetryPolicyName", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
    } });
    var formDataPolicy_js_1 = require_formDataPolicy();
    Object.defineProperty(exports2, "formDataPolicy", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicy;
    } });
    Object.defineProperty(exports2, "formDataPolicyName", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicyName;
    } });
    var logPolicy_js_1 = require_logPolicy();
    Object.defineProperty(exports2, "logPolicy", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicy;
    } });
    Object.defineProperty(exports2, "logPolicyName", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicyName;
    } });
    var multipartPolicy_js_1 = require_multipartPolicy();
    Object.defineProperty(exports2, "multipartPolicy", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicy;
    } });
    Object.defineProperty(exports2, "multipartPolicyName", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicyName;
    } });
    var proxyPolicy_js_1 = require_proxyPolicy();
    Object.defineProperty(exports2, "proxyPolicy", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicy;
    } });
    Object.defineProperty(exports2, "proxyPolicyName", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicyName;
    } });
    Object.defineProperty(exports2, "getDefaultProxySettings", { enumerable: true, get: function() {
      return proxyPolicy_js_1.getDefaultProxySettings;
    } });
    var redirectPolicy_js_1 = require_redirectPolicy();
    Object.defineProperty(exports2, "redirectPolicy", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicy;
    } });
    Object.defineProperty(exports2, "redirectPolicyName", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicyName;
    } });
    var tlsPolicy_js_1 = require_tlsPolicy();
    Object.defineProperty(exports2, "tlsPolicy", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicy;
    } });
    Object.defineProperty(exports2, "tlsPolicyName", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicyName;
    } });
    var userAgentPolicy_js_1 = require_userAgentPolicy();
    Object.defineProperty(exports2, "userAgentPolicy", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicy;
    } });
    Object.defineProperty(exports2, "userAgentPolicyName", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicyName;
    } });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/logPolicy.js
var require_logPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/logPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logPolicyName = void 0;
    exports2.logPolicy = logPolicy;
    var log_js_1 = require_log3();
    var policies_1 = require_internal3();
    exports2.logPolicyName = policies_1.logPolicyName;
    function logPolicy(options = {}) {
      return (0, policies_1.logPolicy)({
        logger: log_js_1.logger.info,
        ...options
      });
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/redirectPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.redirectPolicyName = void 0;
    exports2.redirectPolicy = redirectPolicy;
    var policies_1 = require_internal3();
    exports2.redirectPolicyName = policies_1.redirectPolicyName;
    function redirectPolicy(options = {}) {
      return (0, policies_1.redirectPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgentPlatform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getHeaderName = getHeaderName;
    exports2.setPlatformSpecificData = setPlatformSpecificData;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_os_1 = tslib_1.__importDefault(require("node:os"));
    var node_process_1 = tslib_1.__importDefault(require("node:process"));
    function getHeaderName() {
      return "User-Agent";
    }
    async function setPlatformSpecificData(map) {
      if (node_process_1.default && node_process_1.default.versions) {
        const osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`;
        const versions = node_process_1.default.versions;
        if (versions.bun) {
          map.set("Bun", `${versions.bun} (${osInfo})`);
        } else if (versions.deno) {
          map.set("Deno", `${versions.deno} (${osInfo})`);
        } else if (versions.node) {
          map.set("Node", `${versions.node} (${osInfo})`);
        }
      }
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/constants.js
var require_constants4 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_RETRY_POLICY_COUNT = exports2.SDK_VERSION = void 0;
    exports2.SDK_VERSION = "1.22.2";
    exports2.DEFAULT_RETRY_POLICY_COUNT = 3;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgent.js
var require_userAgent2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUserAgentHeaderName = getUserAgentHeaderName;
    exports2.getUserAgentValue = getUserAgentValue;
    var userAgentPlatform_js_1 = require_userAgentPlatform2();
    var constants_js_1 = require_constants4();
    function getUserAgentString(telemetryInfo) {
      const parts = [];
      for (const [key, value] of telemetryInfo) {
        const token = value ? `${key}/${value}` : key;
        parts.push(token);
      }
      return parts.join(" ");
    }
    function getUserAgentHeaderName() {
      return (0, userAgentPlatform_js_1.getHeaderName)();
    }
    async function getUserAgentValue(prefix) {
      const runtimeInfo = /* @__PURE__ */ new Map();
      runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION);
      await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
      const defaultAgent = getUserAgentString(runtimeInfo);
      const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
      return userAgentValue;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/userAgentPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.userAgentPolicyName = void 0;
    exports2.userAgentPolicy = userAgentPolicy;
    var userAgent_js_1 = require_userAgent2();
    var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
    exports2.userAgentPolicyName = "userAgentPolicy";
    function userAgentPolicy(options = {}) {
      const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
      return {
        name: exports2.userAgentPolicyName,
        async sendRequest(request, next) {
          if (!request.headers.has(UserAgentHeaderName)) {
            request.headers.set(UserAgentHeaderName, await userAgentValue);
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/file.js
var require_file = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasRawContent = hasRawContent;
    exports2.getRawContent = getRawContent;
    exports2.createFileFromStream = createFileFromStream;
    exports2.createFile = createFile;
    var core_util_1 = require_commonjs4();
    function isNodeReadableStream(x) {
      return Boolean(x && typeof x["pipe"] === "function");
    }
    var unimplementedMethods = {
      arrayBuffer: () => {
        throw new Error("Not implemented");
      },
      bytes: () => {
        throw new Error("Not implemented");
      },
      slice: () => {
        throw new Error("Not implemented");
      },
      text: () => {
        throw new Error("Not implemented");
      }
    };
    var rawContent = Symbol("rawContent");
    function hasRawContent(x) {
      return typeof x[rawContent] === "function";
    }
    function getRawContent(blob) {
      if (hasRawContent(blob)) {
        return blob[rawContent]();
      } else {
        return blob;
      }
    }
    function createFileFromStream(stream, name, options = {}) {
      return {
        ...unimplementedMethods,
        type: options.type ?? "",
        lastModified: options.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
        webkitRelativePath: options.webkitRelativePath ?? "",
        size: options.size ?? -1,
        name,
        stream: () => {
          const s = stream();
          if (isNodeReadableStream(s)) {
            throw new Error("Not supported: a Node stream was provided as input to createFileFromStream.");
          }
          return s;
        },
        [rawContent]: stream
      };
    }
    function createFile(content, name, options = {}) {
      if (core_util_1.isNodeLike) {
        return {
          ...unimplementedMethods,
          type: options.type ?? "",
          lastModified: options.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
          webkitRelativePath: options.webkitRelativePath ?? "",
          size: content.byteLength,
          name,
          arrayBuffer: async () => content.buffer,
          stream: () => new Blob([toArrayBuffer(content)]).stream(),
          [rawContent]: () => content
        };
      } else {
        return new File([toArrayBuffer(content)], name, options);
      }
    }
    function toArrayBuffer(source) {
      if ("resize" in source.buffer) {
        return source;
      }
      return source.map((x) => x);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/multipartPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.multipartPolicyName = void 0;
    exports2.multipartPolicy = multipartPolicy;
    var policies_1 = require_internal3();
    var file_js_1 = require_file();
    exports2.multipartPolicyName = policies_1.multipartPolicyName;
    function multipartPolicy() {
      const tspPolicy = (0, policies_1.multipartPolicy)();
      return {
        name: exports2.multipartPolicyName,
        sendRequest: async (request, next) => {
          if (request.multipartBody) {
            for (const part of request.multipartBody.parts) {
              if ((0, file_js_1.hasRawContent)(part.body)) {
                part.body = (0, file_js_1.getRawContent)(part.body);
              }
            }
          }
          return tspPolicy.sendRequest(request, next);
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/decompressResponsePolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decompressResponsePolicyName = void 0;
    exports2.decompressResponsePolicy = decompressResponsePolicy;
    var policies_1 = require_internal3();
    exports2.decompressResponsePolicyName = policies_1.decompressResponsePolicyName;
    function decompressResponsePolicy() {
      return (0, policies_1.decompressResponsePolicy)();
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/defaultRetryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultRetryPolicyName = void 0;
    exports2.defaultRetryPolicy = defaultRetryPolicy;
    var policies_1 = require_internal3();
    exports2.defaultRetryPolicyName = policies_1.defaultRetryPolicyName;
    function defaultRetryPolicy(options = {}) {
      return (0, policies_1.defaultRetryPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/formDataPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formDataPolicyName = void 0;
    exports2.formDataPolicy = formDataPolicy;
    var policies_1 = require_internal3();
    exports2.formDataPolicyName = policies_1.formDataPolicyName;
    function formDataPolicy() {
      return (0, policies_1.formDataPolicy)();
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/proxyPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.proxyPolicyName = void 0;
    exports2.getDefaultProxySettings = getDefaultProxySettings;
    exports2.proxyPolicy = proxyPolicy;
    var policies_1 = require_internal3();
    exports2.proxyPolicyName = policies_1.proxyPolicyName;
    function getDefaultProxySettings(proxyUrl) {
      return (0, policies_1.getDefaultProxySettings)(proxyUrl);
    }
    function proxyPolicy(proxySettings, options) {
      return (0, policies_1.proxyPolicy)(proxySettings, options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/setClientRequestIdPolicy.js
var require_setClientRequestIdPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/setClientRequestIdPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setClientRequestIdPolicyName = void 0;
    exports2.setClientRequestIdPolicy = setClientRequestIdPolicy;
    exports2.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
    function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
      return {
        name: exports2.setClientRequestIdPolicyName,
        async sendRequest(request, next) {
          if (!request.headers.has(requestIdHeaderName)) {
            request.headers.set(requestIdHeaderName, request.requestId);
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/agentPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.agentPolicyName = void 0;
    exports2.agentPolicy = agentPolicy;
    var policies_1 = require_internal3();
    exports2.agentPolicyName = policies_1.agentPolicyName;
    function agentPolicy(agent) {
      return (0, policies_1.agentPolicy)(agent);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tlsPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tlsPolicyName = void 0;
    exports2.tlsPolicy = tlsPolicy;
    var policies_1 = require_internal3();
    exports2.tlsPolicyName = policies_1.tlsPolicyName;
    function tlsPolicy(tlsSettings) {
      return (0, policies_1.tlsPolicy)(tlsSettings);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/restError.js
var require_restError3 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/restError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestError = void 0;
    exports2.isRestError = isRestError;
    var ts_http_runtime_1 = require_commonjs5();
    exports2.RestError = ts_http_runtime_1.RestError;
    function isRestError(e) {
      return (0, ts_http_runtime_1.isRestError)(e);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tracingPolicy.js
var require_tracingPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tracingPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tracingPolicyName = void 0;
    exports2.tracingPolicy = tracingPolicy;
    var core_tracing_1 = require_commonjs2();
    var constants_js_1 = require_constants4();
    var userAgent_js_1 = require_userAgent2();
    var log_js_1 = require_log3();
    var core_util_1 = require_commonjs4();
    var restError_js_1 = require_restError3();
    var util_1 = require_internal2();
    exports2.tracingPolicyName = "tracingPolicy";
    function tracingPolicy(options = {}) {
      const userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
      const sanitizer = new util_1.Sanitizer({
        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
      });
      const tracingClient = tryCreateTracingClient();
      return {
        name: exports2.tracingPolicyName,
        async sendRequest(request, next) {
          if (!tracingClient) {
            return next(request);
          }
          const userAgent = await userAgentPromise;
          const spanAttributes = {
            "http.url": sanitizer.sanitizeUrl(request.url),
            "http.method": request.method,
            "http.user_agent": userAgent,
            requestId: request.requestId
          };
          if (userAgent) {
            spanAttributes["http.user_agent"] = userAgent;
          }
          const { span, tracingContext } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};
          if (!span || !tracingContext) {
            return next(request);
          }
          try {
            const response = await tracingClient.withContext(tracingContext, next, request);
            tryProcessResponse(span, response);
            return response;
          } catch (err) {
            tryProcessError(span, err);
            throw err;
          }
        }
      };
    }
    function tryCreateTracingClient() {
      try {
        return (0, core_tracing_1.createTracingClient)({
          namespace: "",
          packageName: "@azure/core-rest-pipeline",
          packageVersion: constants_js_1.SDK_VERSION
        });
      } catch (e) {
        log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e)}`);
        return void 0;
      }
    }
    function tryCreateSpan(tracingClient, request, spanAttributes) {
      try {
        const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
          spanKind: "client",
          spanAttributes
        });
        if (!span.isRecording()) {
          span.end();
          return void 0;
        }
        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
        for (const [key, value] of Object.entries(headers)) {
          request.headers.set(key, value);
        }
        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
      } catch (e) {
        log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
        return void 0;
      }
    }
    function tryProcessError(span, error) {
      try {
        span.setStatus({
          status: "error",
          error: (0, core_util_1.isError)(error) ? error : void 0
        });
        if ((0, restError_js_1.isRestError)(error) && error.statusCode) {
          span.setAttribute("http.status_code", error.statusCode);
        }
        span.end();
      } catch (e) {
        log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      }
    }
    function tryProcessResponse(span, response) {
      try {
        span.setAttribute("http.status_code", response.status);
        const serviceRequestId = response.headers.get("x-ms-request-id");
        if (serviceRequestId) {
          span.setAttribute("serviceRequestId", serviceRequestId);
        }
        if (response.status >= 400) {
          span.setStatus({
            status: "error"
          });
        }
        span.end();
      } catch (e) {
        log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      }
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/wrapAbortSignal.js
var require_wrapAbortSignal = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/wrapAbortSignal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapAbortSignalLike = wrapAbortSignalLike;
    function wrapAbortSignalLike(abortSignalLike) {
      if (abortSignalLike instanceof AbortSignal) {
        return { abortSignal: abortSignalLike };
      }
      if (abortSignalLike.aborted) {
        return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
      }
      const controller = new AbortController();
      let needsCleanup = true;
      function cleanup() {
        if (needsCleanup) {
          abortSignalLike.removeEventListener("abort", listener);
          needsCleanup = false;
        }
      }
      function listener() {
        controller.abort(abortSignalLike.reason);
        cleanup();
      }
      abortSignalLike.addEventListener("abort", listener);
      return { abortSignal: controller.signal, cleanup };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/wrapAbortSignalLikePolicy.js
var require_wrapAbortSignalLikePolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/wrapAbortSignalLikePolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapAbortSignalLikePolicyName = void 0;
    exports2.wrapAbortSignalLikePolicy = wrapAbortSignalLikePolicy;
    var wrapAbortSignal_js_1 = require_wrapAbortSignal();
    exports2.wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
    function wrapAbortSignalLikePolicy() {
      return {
        name: exports2.wrapAbortSignalLikePolicyName,
        sendRequest: async (request, next) => {
          if (!request.abortSignal) {
            return next(request);
          }
          const { abortSignal, cleanup } = (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal);
          request.abortSignal = abortSignal;
          try {
            return await next(request);
          } finally {
            cleanup?.();
          }
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/createPipelineFromOptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPipelineFromOptions = createPipelineFromOptions;
    var logPolicy_js_1 = require_logPolicy2();
    var pipeline_js_1 = require_pipeline2();
    var redirectPolicy_js_1 = require_redirectPolicy2();
    var userAgentPolicy_js_1 = require_userAgentPolicy2();
    var multipartPolicy_js_1 = require_multipartPolicy2();
    var decompressResponsePolicy_js_1 = require_decompressResponsePolicy2();
    var defaultRetryPolicy_js_1 = require_defaultRetryPolicy2();
    var formDataPolicy_js_1 = require_formDataPolicy2();
    var core_util_1 = require_commonjs4();
    var proxyPolicy_js_1 = require_proxyPolicy2();
    var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
    var agentPolicy_js_1 = require_agentPolicy2();
    var tlsPolicy_js_1 = require_tlsPolicy2();
    var tracingPolicy_js_1 = require_tracingPolicy();
    var wrapAbortSignalLikePolicy_js_1 = require_wrapAbortSignalLikePolicy();
    function createPipelineFromOptions(options) {
      const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
      if (core_util_1.isNodeLike) {
        if (options.agent) {
          pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
        }
        if (options.tlsOptions) {
          pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
        }
        pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
        pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
      }
      pipeline.addPolicy((0, wrapAbortSignalLikePolicy_js_1.wrapAbortSignalLikePolicy)());
      pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
      pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
      pipeline.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)(options.telemetryOptions?.clientRequestIdHeaderName));
      pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
      pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
      pipeline.addPolicy((0, tracingPolicy_js_1.tracingPolicy)({ ...options.userAgentOptions, ...options.loggingOptions }), {
        afterPhase: "Retry"
      });
      if (core_util_1.isNodeLike) {
        pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
      }
      pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
      return pipeline;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/defaultHttpClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultHttpClient = createDefaultHttpClient;
    var ts_http_runtime_1 = require_commonjs5();
    var wrapAbortSignal_js_1 = require_wrapAbortSignal();
    function createDefaultHttpClient() {
      const client = (0, ts_http_runtime_1.createDefaultHttpClient)();
      return {
        async sendRequest(request) {
          const { abortSignal, cleanup } = request.abortSignal ? (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal) : {};
          try {
            request.abortSignal = abortSignal;
            return await client.sendRequest(request);
          } finally {
            cleanup?.();
          }
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/httpHeaders.js
var require_httpHeaders2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/httpHeaders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createHttpHeaders = createHttpHeaders;
    var ts_http_runtime_1 = require_commonjs5();
    function createHttpHeaders(rawHeaders) {
      return (0, ts_http_runtime_1.createHttpHeaders)(rawHeaders);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipelineRequest.js
var require_pipelineRequest2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/pipelineRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPipelineRequest = createPipelineRequest;
    var ts_http_runtime_1 = require_commonjs5();
    function createPipelineRequest(options) {
      return (0, ts_http_runtime_1.createPipelineRequest)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/exponentialRetryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exponentialRetryPolicyName = void 0;
    exports2.exponentialRetryPolicy = exponentialRetryPolicy;
    var policies_1 = require_internal3();
    exports2.exponentialRetryPolicyName = policies_1.exponentialRetryPolicyName;
    function exponentialRetryPolicy(options = {}) {
      return (0, policies_1.exponentialRetryPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/systemErrorRetryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.systemErrorRetryPolicyName = void 0;
    exports2.systemErrorRetryPolicy = systemErrorRetryPolicy;
    var policies_1 = require_internal3();
    exports2.systemErrorRetryPolicyName = policies_1.systemErrorRetryPolicyName;
    function systemErrorRetryPolicy(options = {}) {
      return (0, policies_1.systemErrorRetryPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/throttlingRetryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throttlingRetryPolicyName = void 0;
    exports2.throttlingRetryPolicy = throttlingRetryPolicy;
    var policies_1 = require_internal3();
    exports2.throttlingRetryPolicyName = policies_1.throttlingRetryPolicyName;
    function throttlingRetryPolicy(options = {}) {
      return (0, policies_1.throttlingRetryPolicy)(options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/retryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryPolicy = retryPolicy;
    var logger_1 = require_commonjs();
    var constants_js_1 = require_constants4();
    var policies_1 = require_internal3();
    var retryPolicyLogger = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
    function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
      return (0, policies_1.retryPolicy)(strategies, {
        logger: retryPolicyLogger,
        ...options
      });
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/tokenCycler.js
var require_tokenCycler = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/util/tokenCycler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_CYCLER_OPTIONS = void 0;
    exports2.createTokenCycler = createTokenCycler;
    var core_util_1 = require_commonjs4();
    exports2.DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      // Force waiting for a refresh 1s before the token expires
      retryIntervalInMs: 3e3,
      // Allow refresh attempts every 3s
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
    async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
      async function tryGetAccessToken() {
        if (Date.now() < refreshTimeout) {
          try {
            return await getAccessToken();
          } catch {
            return null;
          }
        } else {
          const finalToken = await getAccessToken();
          if (finalToken === null) {
            throw new Error("Failed to refresh access token.");
          }
          return finalToken;
        }
      }
      let token = await tryGetAccessToken();
      while (token === null) {
        await (0, core_util_1.delay)(retryIntervalInMs);
        token = await tryGetAccessToken();
      }
      return token;
    }
    function createTokenCycler(credential, tokenCyclerOptions) {
      let refreshWorker = null;
      let token = null;
      let tenantId;
      const options = {
        ...exports2.DEFAULT_CYCLER_OPTIONS,
        ...tokenCyclerOptions
      };
      const cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */
        get isRefreshing() {
          return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */
        get shouldRefresh() {
          if (cycler.isRefreshing) {
            return false;
          }
          if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now()) {
            return true;
          }
          return (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now();
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */
        get mustRefresh() {
          return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
        }
      };
      function refresh(scopes, getTokenOptions) {
        if (!cycler.isRefreshing) {
          const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
          refreshWorker = beginRefresh(
            tryGetAccessToken,
            options.retryIntervalInMs,
            // If we don't have a token, then we should timeout immediately
            token?.expiresOnTimestamp ?? Date.now()
          ).then((_token) => {
            refreshWorker = null;
            token = _token;
            tenantId = getTokenOptions.tenantId;
            return token;
          }).catch((reason) => {
            refreshWorker = null;
            token = null;
            tenantId = void 0;
            throw reason;
          });
        }
        return refreshWorker;
      }
      return async (scopes, tokenOptions) => {
        const hasClaimChallenge = Boolean(tokenOptions.claims);
        const tenantIdChanged = tenantId !== tokenOptions.tenantId;
        if (hasClaimChallenge) {
          token = null;
        }
        const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
        if (mustRefresh) {
          return refresh(scopes, tokenOptions);
        }
        if (cycler.shouldRefresh) {
          refresh(scopes, tokenOptions);
        }
        return token;
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/bearerTokenAuthenticationPolicy.js
var require_bearerTokenAuthenticationPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/bearerTokenAuthenticationPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bearerTokenAuthenticationPolicyName = void 0;
    exports2.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
    exports2.parseChallenges = parseChallenges;
    var tokenCycler_js_1 = require_tokenCycler();
    var log_js_1 = require_log3();
    var restError_js_1 = require_restError3();
    exports2.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
    async function trySendRequest(request, next) {
      try {
        return [await next(request), void 0];
      } catch (e) {
        if ((0, restError_js_1.isRestError)(e) && e.response) {
          return [e.response, e];
        } else {
          throw e;
        }
      }
    }
    async function defaultAuthorizeRequest(options) {
      const { scopes, getAccessToken, request } = options;
      const getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions,
        enableCae: true
      };
      const accessToken = await getAccessToken(scopes, getTokenOptions);
      if (accessToken) {
        options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
      }
    }
    function isChallengeResponse(response) {
      return response.status === 401 && response.headers.has("WWW-Authenticate");
    }
    async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
      const { scopes } = onChallengeOptions;
      const accessToken = await onChallengeOptions.getAccessToken(scopes, {
        enableCae: true,
        claims: caeClaims
      });
      if (!accessToken) {
        return false;
      }
      onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
      return true;
    }
    function bearerTokenAuthenticationPolicy(options) {
      const { credential, scopes, challengeCallbacks } = options;
      const logger = options.logger || log_js_1.logger;
      const callbacks = {
        authorizeRequest: challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,
        authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks)
      };
      const getAccessToken = credential ? (0, tokenCycler_js_1.createTokenCycler)(
        credential
        /* , options */
      ) : () => Promise.resolve(null);
      return {
        name: exports2.bearerTokenAuthenticationPolicyName,
        /**
         * If there's no challenge parameter:
         * - It will try to retrieve the token using the cache, or the credential's getToken.
         * - Then it will try the next policy with or without the retrieved token.
         *
         * It uses the challenge parameters to:
         * - Skip a first attempt to get the token from the credential if there's no cached token,
         *   since it expects the token to be retrievable only after the challenge.
         * - Prepare the outgoing request if the `prepareRequest` method has been provided.
         * - Send an initial request to receive the challenge if it fails.
         * - Process a challenge if the response contains it.
         * - Retrieve a token with the challenge information, then re-send the request.
         */
        async sendRequest(request, next) {
          if (!request.url.toLowerCase().startsWith("https://")) {
            throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
          }
          await callbacks.authorizeRequest({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request,
            getAccessToken,
            logger
          });
          let response;
          let error;
          let shouldSendRequest;
          [response, error] = await trySendRequest(request, next);
          if (isChallengeResponse(response)) {
            let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
            if (claims) {
              let parsedClaim;
              try {
                parsedClaim = atob(claims);
              } catch (e) {
                logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                return response;
              }
              shouldSendRequest = await authorizeRequestOnCaeChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                response,
                request,
                getAccessToken,
                logger
              }, parsedClaim);
              if (shouldSendRequest) {
                [response, error] = await trySendRequest(request, next);
              }
            } else if (callbacks.authorizeRequestOnChallenge) {
              shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                request,
                response,
                getAccessToken,
                logger
              });
              if (shouldSendRequest) {
                [response, error] = await trySendRequest(request, next);
              }
              if (isChallengeResponse(response)) {
                claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
                if (claims) {
                  let parsedClaim;
                  try {
                    parsedClaim = atob(claims);
                  } catch (e) {
                    logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                    return response;
                  }
                  shouldSendRequest = await authorizeRequestOnCaeChallenge({
                    scopes: Array.isArray(scopes) ? scopes : [scopes],
                    response,
                    request,
                    getAccessToken,
                    logger
                  }, parsedClaim);
                  if (shouldSendRequest) {
                    [response, error] = await trySendRequest(request, next);
                  }
                }
              }
            }
          }
          if (error) {
            throw error;
          } else {
            return response;
          }
        }
      };
    }
    function parseChallenges(challenges) {
      const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
      const paramRegex = /(\w+)="([^"]*)"/g;
      const parsedChallenges = [];
      let match;
      while ((match = challengeRegex.exec(challenges)) !== null) {
        const scheme = match[1];
        const paramsString = match[2];
        const params = {};
        let paramMatch;
        while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
          params[paramMatch[1]] = paramMatch[2];
        }
        parsedChallenges.push({ scheme, params });
      }
      return parsedChallenges;
    }
    function getCaeChallengeClaims(challenges) {
      if (!challenges) {
        return;
      }
      const parsedChallenges = parseChallenges(challenges);
      return parsedChallenges.find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")?.params.claims;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/ndJsonPolicy.js
var require_ndJsonPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/ndJsonPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ndJsonPolicyName = void 0;
    exports2.ndJsonPolicy = ndJsonPolicy;
    exports2.ndJsonPolicyName = "ndJsonPolicy";
    function ndJsonPolicy() {
      return {
        name: exports2.ndJsonPolicyName,
        async sendRequest(request, next) {
          if (typeof request.body === "string" && request.body.startsWith("[")) {
            const body = JSON.parse(request.body);
            if (Array.isArray(body)) {
              request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
            }
          }
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/auxiliaryAuthenticationHeaderPolicy.js
var require_auxiliaryAuthenticationHeaderPolicy = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/auxiliaryAuthenticationHeaderPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.auxiliaryAuthenticationHeaderPolicyName = void 0;
    exports2.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
    var tokenCycler_js_1 = require_tokenCycler();
    var log_js_1 = require_log3();
    exports2.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
    var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
    async function sendAuthorizeRequest(options) {
      const { scopes, getAccessToken, request } = options;
      const getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions
      };
      return (await getAccessToken(scopes, getTokenOptions))?.token ?? "";
    }
    function auxiliaryAuthenticationHeaderPolicy(options) {
      const { credentials, scopes } = options;
      const logger = options.logger || log_js_1.logger;
      const tokenCyclerMap = /* @__PURE__ */ new WeakMap();
      return {
        name: exports2.auxiliaryAuthenticationHeaderPolicyName,
        async sendRequest(request, next) {
          if (!request.url.toLowerCase().startsWith("https://")) {
            throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
          }
          if (!credentials || credentials.length === 0) {
            logger.info(`${exports2.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
            return next(request);
          }
          const tokenPromises = [];
          for (const credential of credentials) {
            let getAccessToken = tokenCyclerMap.get(credential);
            if (!getAccessToken) {
              getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential);
              tokenCyclerMap.set(credential, getAccessToken);
            }
            tokenPromises.push(sendAuthorizeRequest({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              request,
              getAccessToken,
              logger
            }));
          }
          const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
          if (auxiliaryTokens.length === 0) {
            logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
            return next(request);
          }
          request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
          return next(request);
        }
      };
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/index.js
var require_commonjs6 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileFromStream = exports2.createFile = exports2.agentPolicyName = exports2.agentPolicy = exports2.auxiliaryAuthenticationHeaderPolicyName = exports2.auxiliaryAuthenticationHeaderPolicy = exports2.ndJsonPolicyName = exports2.ndJsonPolicy = exports2.bearerTokenAuthenticationPolicyName = exports2.bearerTokenAuthenticationPolicy = exports2.formDataPolicyName = exports2.formDataPolicy = exports2.tlsPolicyName = exports2.tlsPolicy = exports2.userAgentPolicyName = exports2.userAgentPolicy = exports2.defaultRetryPolicy = exports2.tracingPolicyName = exports2.tracingPolicy = exports2.retryPolicy = exports2.throttlingRetryPolicyName = exports2.throttlingRetryPolicy = exports2.systemErrorRetryPolicyName = exports2.systemErrorRetryPolicy = exports2.redirectPolicyName = exports2.redirectPolicy = exports2.getDefaultProxySettings = exports2.proxyPolicyName = exports2.proxyPolicy = exports2.multipartPolicyName = exports2.multipartPolicy = exports2.logPolicyName = exports2.logPolicy = exports2.setClientRequestIdPolicyName = exports2.setClientRequestIdPolicy = exports2.exponentialRetryPolicyName = exports2.exponentialRetryPolicy = exports2.decompressResponsePolicyName = exports2.decompressResponsePolicy = exports2.isRestError = exports2.RestError = exports2.createPipelineRequest = exports2.createHttpHeaders = exports2.createDefaultHttpClient = exports2.createPipelineFromOptions = exports2.createEmptyPipeline = void 0;
    var pipeline_js_1 = require_pipeline2();
    Object.defineProperty(exports2, "createEmptyPipeline", { enumerable: true, get: function() {
      return pipeline_js_1.createEmptyPipeline;
    } });
    var createPipelineFromOptions_js_1 = require_createPipelineFromOptions2();
    Object.defineProperty(exports2, "createPipelineFromOptions", { enumerable: true, get: function() {
      return createPipelineFromOptions_js_1.createPipelineFromOptions;
    } });
    var defaultHttpClient_js_1 = require_defaultHttpClient2();
    Object.defineProperty(exports2, "createDefaultHttpClient", { enumerable: true, get: function() {
      return defaultHttpClient_js_1.createDefaultHttpClient;
    } });
    var httpHeaders_js_1 = require_httpHeaders2();
    Object.defineProperty(exports2, "createHttpHeaders", { enumerable: true, get: function() {
      return httpHeaders_js_1.createHttpHeaders;
    } });
    var pipelineRequest_js_1 = require_pipelineRequest2();
    Object.defineProperty(exports2, "createPipelineRequest", { enumerable: true, get: function() {
      return pipelineRequest_js_1.createPipelineRequest;
    } });
    var restError_js_1 = require_restError3();
    Object.defineProperty(exports2, "RestError", { enumerable: true, get: function() {
      return restError_js_1.RestError;
    } });
    Object.defineProperty(exports2, "isRestError", { enumerable: true, get: function() {
      return restError_js_1.isRestError;
    } });
    var decompressResponsePolicy_js_1 = require_decompressResponsePolicy2();
    Object.defineProperty(exports2, "decompressResponsePolicy", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicy;
    } });
    Object.defineProperty(exports2, "decompressResponsePolicyName", { enumerable: true, get: function() {
      return decompressResponsePolicy_js_1.decompressResponsePolicyName;
    } });
    var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy2();
    Object.defineProperty(exports2, "exponentialRetryPolicy", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
    } });
    Object.defineProperty(exports2, "exponentialRetryPolicyName", { enumerable: true, get: function() {
      return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
    } });
    var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
    Object.defineProperty(exports2, "setClientRequestIdPolicy", { enumerable: true, get: function() {
      return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy;
    } });
    Object.defineProperty(exports2, "setClientRequestIdPolicyName", { enumerable: true, get: function() {
      return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName;
    } });
    var logPolicy_js_1 = require_logPolicy2();
    Object.defineProperty(exports2, "logPolicy", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicy;
    } });
    Object.defineProperty(exports2, "logPolicyName", { enumerable: true, get: function() {
      return logPolicy_js_1.logPolicyName;
    } });
    var multipartPolicy_js_1 = require_multipartPolicy2();
    Object.defineProperty(exports2, "multipartPolicy", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicy;
    } });
    Object.defineProperty(exports2, "multipartPolicyName", { enumerable: true, get: function() {
      return multipartPolicy_js_1.multipartPolicyName;
    } });
    var proxyPolicy_js_1 = require_proxyPolicy2();
    Object.defineProperty(exports2, "proxyPolicy", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicy;
    } });
    Object.defineProperty(exports2, "proxyPolicyName", { enumerable: true, get: function() {
      return proxyPolicy_js_1.proxyPolicyName;
    } });
    Object.defineProperty(exports2, "getDefaultProxySettings", { enumerable: true, get: function() {
      return proxyPolicy_js_1.getDefaultProxySettings;
    } });
    var redirectPolicy_js_1 = require_redirectPolicy2();
    Object.defineProperty(exports2, "redirectPolicy", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicy;
    } });
    Object.defineProperty(exports2, "redirectPolicyName", { enumerable: true, get: function() {
      return redirectPolicy_js_1.redirectPolicyName;
    } });
    var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy2();
    Object.defineProperty(exports2, "systemErrorRetryPolicy", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
    } });
    Object.defineProperty(exports2, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
      return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
    } });
    var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy2();
    Object.defineProperty(exports2, "throttlingRetryPolicy", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
    } });
    Object.defineProperty(exports2, "throttlingRetryPolicyName", { enumerable: true, get: function() {
      return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
    } });
    var retryPolicy_js_1 = require_retryPolicy2();
    Object.defineProperty(exports2, "retryPolicy", { enumerable: true, get: function() {
      return retryPolicy_js_1.retryPolicy;
    } });
    var tracingPolicy_js_1 = require_tracingPolicy();
    Object.defineProperty(exports2, "tracingPolicy", { enumerable: true, get: function() {
      return tracingPolicy_js_1.tracingPolicy;
    } });
    Object.defineProperty(exports2, "tracingPolicyName", { enumerable: true, get: function() {
      return tracingPolicy_js_1.tracingPolicyName;
    } });
    var defaultRetryPolicy_js_1 = require_defaultRetryPolicy2();
    Object.defineProperty(exports2, "defaultRetryPolicy", { enumerable: true, get: function() {
      return defaultRetryPolicy_js_1.defaultRetryPolicy;
    } });
    var userAgentPolicy_js_1 = require_userAgentPolicy2();
    Object.defineProperty(exports2, "userAgentPolicy", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicy;
    } });
    Object.defineProperty(exports2, "userAgentPolicyName", { enumerable: true, get: function() {
      return userAgentPolicy_js_1.userAgentPolicyName;
    } });
    var tlsPolicy_js_1 = require_tlsPolicy2();
    Object.defineProperty(exports2, "tlsPolicy", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicy;
    } });
    Object.defineProperty(exports2, "tlsPolicyName", { enumerable: true, get: function() {
      return tlsPolicy_js_1.tlsPolicyName;
    } });
    var formDataPolicy_js_1 = require_formDataPolicy2();
    Object.defineProperty(exports2, "formDataPolicy", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicy;
    } });
    Object.defineProperty(exports2, "formDataPolicyName", { enumerable: true, get: function() {
      return formDataPolicy_js_1.formDataPolicyName;
    } });
    var bearerTokenAuthenticationPolicy_js_1 = require_bearerTokenAuthenticationPolicy();
    Object.defineProperty(exports2, "bearerTokenAuthenticationPolicy", { enumerable: true, get: function() {
      return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy;
    } });
    Object.defineProperty(exports2, "bearerTokenAuthenticationPolicyName", { enumerable: true, get: function() {
      return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName;
    } });
    var ndJsonPolicy_js_1 = require_ndJsonPolicy();
    Object.defineProperty(exports2, "ndJsonPolicy", { enumerable: true, get: function() {
      return ndJsonPolicy_js_1.ndJsonPolicy;
    } });
    Object.defineProperty(exports2, "ndJsonPolicyName", { enumerable: true, get: function() {
      return ndJsonPolicy_js_1.ndJsonPolicyName;
    } });
    var auxiliaryAuthenticationHeaderPolicy_js_1 = require_auxiliaryAuthenticationHeaderPolicy();
    Object.defineProperty(exports2, "auxiliaryAuthenticationHeaderPolicy", { enumerable: true, get: function() {
      return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy;
    } });
    Object.defineProperty(exports2, "auxiliaryAuthenticationHeaderPolicyName", { enumerable: true, get: function() {
      return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName;
    } });
    var agentPolicy_js_1 = require_agentPolicy2();
    Object.defineProperty(exports2, "agentPolicy", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicy;
    } });
    Object.defineProperty(exports2, "agentPolicyName", { enumerable: true, get: function() {
      return agentPolicy_js_1.agentPolicyName;
    } });
    var file_js_1 = require_file();
    Object.defineProperty(exports2, "createFile", { enumerable: true, get: function() {
      return file_js_1.createFile;
    } });
    Object.defineProperty(exports2, "createFileFromStream", { enumerable: true, get: function() {
      return file_js_1.createFileFromStream;
    } });
  }
});

// node_modules/@azure/core-client/dist/commonjs/state.js
var require_state2 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.state = void 0;
    exports2.state = {
      operationRequestMap: /* @__PURE__ */ new WeakMap()
    };
  }
});

// node_modules/@azure/core-client/dist/commonjs/operationHelpers.js
var require_operationHelpers = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/operationHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
    exports2.getOperationRequestInfo = getOperationRequestInfo;
    var state_js_1 = require_state2();
    function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
      let parameterPath = parameter.parameterPath;
      const parameterMapper = parameter.mapper;
      let value;
      if (typeof parameterPath === "string") {
        parameterPath = [parameterPath];
      }
      if (Array.isArray(parameterPath)) {
        if (parameterPath.length > 0) {
          if (parameterMapper.isConstant) {
            value = parameterMapper.defaultValue;
          } else {
            let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
            if (!propertySearchResult.propertyFound && fallbackObject) {
              propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
            }
            let useDefaultValue = false;
            if (!propertySearchResult.propertyFound) {
              useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
            }
            value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
          }
        }
      } else {
        if (parameterMapper.required) {
          value = {};
        }
        for (const propertyName in parameterPath) {
          const propertyMapper = parameterMapper.type.modelProperties[propertyName];
          const propertyPath = parameterPath[propertyName];
          const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
            parameterPath: propertyPath,
            mapper: propertyMapper
          }, fallbackObject);
          if (propertyValue !== void 0) {
            if (!value) {
              value = {};
            }
            value[propertyName] = propertyValue;
          }
        }
      }
      return value;
    }
    function getPropertyFromParameterPath(parent, parameterPath) {
      const result = { propertyFound: false };
      let i = 0;
      for (; i < parameterPath.length; ++i) {
        const parameterPathPart = parameterPath[i];
        if (parent && parameterPathPart in parent) {
          parent = parent[parameterPathPart];
        } else {
          break;
        }
      }
      if (i === parameterPath.length) {
        result.propertyValue = parent;
        result.propertyFound = true;
      }
      return result;
    }
    var originalRequestSymbol = Symbol.for("@azure/core-client original request");
    function hasOriginalRequest(request) {
      return originalRequestSymbol in request;
    }
    function getOperationRequestInfo(request) {
      if (hasOriginalRequest(request)) {
        return getOperationRequestInfo(request[originalRequestSymbol]);
      }
      let info = state_js_1.state.operationRequestMap.get(request);
      if (!info) {
        info = {};
        state_js_1.state.operationRequestMap.set(request, info);
      }
      return info;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/deserializationPolicy.js
var require_deserializationPolicy = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/deserializationPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserializationPolicyName = void 0;
    exports2.deserializationPolicy = deserializationPolicy;
    var interfaces_js_1 = require_interfaces();
    var core_rest_pipeline_1 = require_commonjs6();
    var serializer_js_1 = require_serializer();
    var operationHelpers_js_1 = require_operationHelpers();
    var defaultJsonContentTypes = ["application/json", "text/json"];
    var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
    exports2.deserializationPolicyName = "deserializationPolicy";
    function deserializationPolicy(options = {}) {
      const jsonContentTypes = options.expectedContentTypes?.json ?? defaultJsonContentTypes;
      const xmlContentTypes = options.expectedContentTypes?.xml ?? defaultXmlContentTypes;
      const parseXML = options.parseXML;
      const serializerOptions = options.serializerOptions;
      const updatedOptions = {
        xml: {
          rootName: serializerOptions?.xml.rootName ?? "",
          includeRoot: serializerOptions?.xml.includeRoot ?? false,
          xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        }
      };
      return {
        name: exports2.deserializationPolicyName,
        async sendRequest(request, next) {
          const response = await next(request);
          return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
        }
      };
    }
    function getOperationResponseMap(parsedResponse) {
      let result;
      const request = parsedResponse.request;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
      const operationSpec = operationInfo?.operationSpec;
      if (operationSpec) {
        if (!operationInfo?.operationResponseGetter) {
          result = operationSpec.responses[parsedResponse.status];
        } else {
          result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);
        }
      }
      return result;
    }
    function shouldDeserializeResponse(parsedResponse) {
      const request = parsedResponse.request;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
      const shouldDeserialize = operationInfo?.shouldDeserialize;
      let result;
      if (shouldDeserialize === void 0) {
        result = true;
      } else if (typeof shouldDeserialize === "boolean") {
        result = shouldDeserialize;
      } else {
        result = shouldDeserialize(parsedResponse);
      }
      return result;
    }
    async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
      const parsedResponse = await parse2(jsonContentTypes, xmlContentTypes, response, options, parseXML);
      if (!shouldDeserializeResponse(parsedResponse)) {
        return parsedResponse;
      }
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request);
      const operationSpec = operationInfo?.operationSpec;
      if (!operationSpec || !operationSpec.responses) {
        return parsedResponse;
      }
      const responseSpec = getOperationResponseMap(parsedResponse);
      const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
      if (error) {
        throw error;
      } else if (shouldReturnResponse) {
        return parsedResponse;
      }
      if (responseSpec) {
        if (responseSpec.bodyMapper) {
          let valueToDeserialize = parsedResponse.parsedBody;
          if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
            valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
          }
          try {
            parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
          } catch (deserializeError) {
            const restError = new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
              statusCode: parsedResponse.status,
              request: parsedResponse.request,
              response: parsedResponse
            });
            throw restError;
          }
        } else if (operationSpec.httpMethod === "HEAD") {
          parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
        }
        if (responseSpec.headersMapper) {
          parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
        }
      }
      return parsedResponse;
    }
    function isOperationSpecEmpty(operationSpec) {
      const expectedStatusCodes = Object.keys(operationSpec.responses);
      return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
    }
    function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
      const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
      const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
      if (isExpectedStatusCode) {
        if (responseSpec) {
          if (!responseSpec.isError) {
            return { error: null, shouldReturnResponse: false };
          }
        } else {
          return { error: null, shouldReturnResponse: false };
        }
      }
      const errorResponseSpec = responseSpec ?? operationSpec.responses.default;
      const initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(parsedResponse.status) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
      const error = new core_rest_pipeline_1.RestError(initialErrorMessage, {
        statusCode: parsedResponse.status,
        request: parsedResponse.request,
        response: parsedResponse
      });
      if (!errorResponseSpec && !(parsedResponse.parsedBody?.error?.code && parsedResponse.parsedBody?.error?.message)) {
        throw error;
      }
      const defaultBodyMapper = errorResponseSpec?.bodyMapper;
      const defaultHeadersMapper = errorResponseSpec?.headersMapper;
      try {
        if (parsedResponse.parsedBody) {
          const parsedBody = parsedResponse.parsedBody;
          let deserializedError;
          if (defaultBodyMapper) {
            let valueToDeserialize = parsedBody;
            if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
              valueToDeserialize = [];
              const elementName = defaultBodyMapper.xmlElementName;
              if (typeof parsedBody === "object" && elementName) {
                valueToDeserialize = parsedBody[elementName];
              }
            }
            deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
          }
          const internalError = parsedBody.error || deserializedError || parsedBody;
          error.code = internalError.code;
          if (internalError.message) {
            error.message = internalError.message;
          }
          if (defaultBodyMapper) {
            error.response.parsedBody = deserializedError;
          }
        }
        if (parsedResponse.headers && defaultHeadersMapper) {
          error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
      }
      return { error, shouldReturnResponse: false };
    }
    async function parse2(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
      if (!operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) && operationResponse.bodyAsText) {
        const text = operationResponse.bodyAsText;
        const contentType = operationResponse.headers.get("Content-Type") || "";
        const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
        try {
          if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
            operationResponse.parsedBody = JSON.parse(text);
            return operationResponse;
          } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
            if (!parseXML) {
              throw new Error("Parsing XML not supported.");
            }
            const body = await parseXML(text, opts.xml);
            operationResponse.parsedBody = body;
            return operationResponse;
          }
        } catch (err) {
          const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
          const errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
          const e = new core_rest_pipeline_1.RestError(msg, {
            code: errCode,
            statusCode: operationResponse.status,
            request: operationResponse.request,
            response: operationResponse
          });
          throw e;
        }
      }
      return operationResponse;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaceHelpers.js
var require_interfaceHelpers = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/interfaceHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
    exports2.getPathStringFromParameter = getPathStringFromParameter;
    var serializer_js_1 = require_serializer();
    function getStreamingResponseStatusCodes(operationSpec) {
      const result = /* @__PURE__ */ new Set();
      for (const statusCode in operationSpec.responses) {
        const operationResponse = operationSpec.responses[statusCode];
        if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream) {
          result.add(Number(statusCode));
        }
      }
      return result;
    }
    function getPathStringFromParameter(parameter) {
      const { parameterPath, mapper } = parameter;
      let result;
      if (typeof parameterPath === "string") {
        result = parameterPath;
      } else if (Array.isArray(parameterPath)) {
        result = parameterPath.join(".");
      } else {
        result = mapper.serializedName;
      }
      return result;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializationPolicy.js
var require_serializationPolicy = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/serializationPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serializationPolicyName = void 0;
    exports2.serializationPolicy = serializationPolicy;
    exports2.serializeHeaders = serializeHeaders;
    exports2.serializeRequestBody = serializeRequestBody;
    var interfaces_js_1 = require_interfaces();
    var operationHelpers_js_1 = require_operationHelpers();
    var serializer_js_1 = require_serializer();
    var interfaceHelpers_js_1 = require_interfaceHelpers();
    exports2.serializationPolicyName = "serializationPolicy";
    function serializationPolicy(options = {}) {
      const stringifyXML = options.stringifyXML;
      return {
        name: exports2.serializationPolicyName,
        async sendRequest(request, next) {
          const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
          const operationSpec = operationInfo?.operationSpec;
          const operationArguments = operationInfo?.operationArguments;
          if (operationSpec && operationArguments) {
            serializeHeaders(request, operationArguments, operationSpec);
            serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
          }
          return next(request);
        }
      };
    }
    function serializeHeaders(request, operationArguments, operationSpec) {
      if (operationSpec.headerParameters) {
        for (const headerParameter of operationSpec.headerParameters) {
          let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
          if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
            headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
            const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
            if (headerCollectionPrefix) {
              for (const key of Object.keys(headerValue)) {
                request.headers.set(headerCollectionPrefix + key, headerValue[key]);
              }
            } else {
              request.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
            }
          }
        }
      }
      const customHeaders = operationArguments.options?.requestOptions?.customHeaders;
      if (customHeaders) {
        for (const customHeaderName of Object.keys(customHeaders)) {
          request.headers.set(customHeaderName, customHeaders[customHeaderName]);
        }
      }
    }
    function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function() {
      throw new Error("XML serialization unsupported!");
    }) {
      const serializerOptions = operationArguments.options?.serializerOptions;
      const updatedOptions = {
        xml: {
          rootName: serializerOptions?.xml.rootName ?? "",
          includeRoot: serializerOptions?.xml.includeRoot ?? false,
          xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        }
      };
      const xmlCharKey = updatedOptions.xml.xmlCharKey;
      if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
        request.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
        const bodyMapper = operationSpec.requestBody.mapper;
        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
        const typeName = bodyMapper.type.name;
        try {
          if (request.body !== void 0 && request.body !== null || nullable && request.body === null || required) {
            const requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
            request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
            const isStream = typeName === serializer_js_1.MapperTypeNames.Stream;
            if (operationSpec.isXML) {
              const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
              const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
              if (typeName === serializer_js_1.MapperTypeNames.Sequence) {
                request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
              } else if (!isStream) {
                request.body = stringifyXML(value, {
                  rootName: xmlName || serializedName,
                  xmlCharKey
                });
              }
            } else if (typeName === serializer_js_1.MapperTypeNames.String && (operationSpec.contentType?.match("text/plain") || operationSpec.mediaType === "text")) {
              return;
            } else if (!isStream) {
              request.body = JSON.stringify(request.body);
            }
          }
        } catch (error) {
          throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
        }
      } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
        request.formData = {};
        for (const formDataParameter of operationSpec.formDataParameters) {
          const formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
          if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
            const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
            request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
          }
        }
      }
    }
    function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
      if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
        const result = {};
        result[options.xml.xmlCharKey] = serializedValue;
        result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
        return result;
      }
      return serializedValue;
    }
    function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
      if (!Array.isArray(obj)) {
        obj = [obj];
      }
      if (!xmlNamespaceKey || !xmlNamespace) {
        return { [elementName]: obj };
      }
      const result = { [elementName]: obj };
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
      return result;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/pipeline.js
var require_pipeline3 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/pipeline.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createClientPipeline = createClientPipeline;
    var deserializationPolicy_js_1 = require_deserializationPolicy();
    var core_rest_pipeline_1 = require_commonjs6();
    var serializationPolicy_js_1 = require_serializationPolicy();
    function createClientPipeline(options = {}) {
      const pipeline = (0, core_rest_pipeline_1.createPipelineFromOptions)(options ?? {});
      if (options.credentialOptions) {
        pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
          credential: options.credentialOptions.credential,
          scopes: options.credentialOptions.credentialScopes
        }));
      }
      pipeline.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options.serializationOptions), { phase: "Serialize" });
      pipeline.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options.deserializationOptions), {
        phase: "Deserialize"
      });
      return pipeline;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/httpClientCache.js
var require_httpClientCache = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/httpClientCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
    var core_rest_pipeline_1 = require_commonjs6();
    var cachedHttpClient;
    function getCachedDefaultHttpClient() {
      if (!cachedHttpClient) {
        cachedHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
      }
      return cachedHttpClient;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/urlHelpers.js
var require_urlHelpers2 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/urlHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRequestUrl = getRequestUrl;
    exports2.appendQueryParams = appendQueryParams;
    var operationHelpers_js_1 = require_operationHelpers();
    var interfaceHelpers_js_1 = require_interfaceHelpers();
    var CollectionFormatToDelimiterMap = {
      CSV: ",",
      SSV: " ",
      Multi: "Multi",
      TSV: "	",
      Pipes: "|"
    };
    function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
      const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
      let isAbsolutePath = false;
      let requestUrl = replaceAll(baseUri, urlReplacements);
      if (operationSpec.path) {
        let path2 = replaceAll(operationSpec.path, urlReplacements);
        if (operationSpec.path === "/{nextLink}" && path2.startsWith("/")) {
          path2 = path2.substring(1);
        }
        if (isAbsoluteUrl(path2)) {
          requestUrl = path2;
          isAbsolutePath = true;
        } else {
          requestUrl = appendPath(requestUrl, path2);
        }
      }
      const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
      requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
      return requestUrl;
    }
    function replaceAll(input, replacements) {
      let result = input;
      for (const [searchValue, replaceValue] of replacements) {
        result = result.split(searchValue).join(replaceValue);
      }
      return result;
    }
    function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
      const result = /* @__PURE__ */ new Map();
      if (operationSpec.urlParameters?.length) {
        for (const urlParameter of operationSpec.urlParameters) {
          let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
          const parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
          urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
          if (!urlParameter.skipEncoding) {
            urlParameterValue = encodeURIComponent(urlParameterValue);
          }
          result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
        }
      }
      return result;
    }
    function isAbsoluteUrl(url) {
      return url.includes("://");
    }
    function appendPath(url, pathToAppend) {
      if (!pathToAppend) {
        return url;
      }
      const parsedUrl = new URL(url);
      let newPath = parsedUrl.pathname;
      if (!newPath.endsWith("/")) {
        newPath = `${newPath}/`;
      }
      if (pathToAppend.startsWith("/")) {
        pathToAppend = pathToAppend.substring(1);
      }
      const searchStart = pathToAppend.indexOf("?");
      if (searchStart !== -1) {
        const path2 = pathToAppend.substring(0, searchStart);
        const search = pathToAppend.substring(searchStart + 1);
        newPath = newPath + path2;
        if (search) {
          parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
        }
      } else {
        newPath = newPath + pathToAppend;
      }
      parsedUrl.pathname = newPath;
      return parsedUrl.toString();
    }
    function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
      const result = /* @__PURE__ */ new Map();
      const sequenceParams = /* @__PURE__ */ new Set();
      if (operationSpec.queryParameters?.length) {
        for (const queryParameter of operationSpec.queryParameters) {
          if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
            sequenceParams.add(queryParameter.mapper.serializedName);
          }
          let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
          if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
            queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
            const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
            if (Array.isArray(queryParameterValue)) {
              queryParameterValue = queryParameterValue.map((item) => {
                if (item === null || item === void 0) {
                  return "";
                }
                return item;
              });
            }
            if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
              continue;
            } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
              queryParameterValue = queryParameterValue.join(delimiter);
            }
            if (!queryParameter.skipEncoding) {
              if (Array.isArray(queryParameterValue)) {
                queryParameterValue = queryParameterValue.map((item) => {
                  return encodeURIComponent(item);
                });
              } else {
                queryParameterValue = encodeURIComponent(queryParameterValue);
              }
            }
            if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
              queryParameterValue = queryParameterValue.join(delimiter);
            }
            result.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
          }
        }
      }
      return {
        queryParams: result,
        sequenceParams
      };
    }
    function simpleParseQueryParams(queryString) {
      const result = /* @__PURE__ */ new Map();
      if (!queryString || queryString[0] !== "?") {
        return result;
      }
      queryString = queryString.slice(1);
      const pairs = queryString.split("&");
      for (const pair of pairs) {
        const [name, value] = pair.split("=", 2);
        const existingValue = result.get(name);
        if (existingValue) {
          if (Array.isArray(existingValue)) {
            existingValue.push(value);
          } else {
            result.set(name, [existingValue, value]);
          }
        } else {
          result.set(name, value);
        }
      }
      return result;
    }
    function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
      if (queryParams.size === 0) {
        return url;
      }
      const parsedUrl = new URL(url);
      const combinedParams = simpleParseQueryParams(parsedUrl.search);
      for (const [name, value] of queryParams) {
        const existingValue = combinedParams.get(name);
        if (Array.isArray(existingValue)) {
          if (Array.isArray(value)) {
            existingValue.push(...value);
            const valueSet = new Set(existingValue);
            combinedParams.set(name, Array.from(valueSet));
          } else {
            existingValue.push(value);
          }
        } else if (existingValue) {
          if (Array.isArray(value)) {
            value.unshift(existingValue);
          } else if (sequenceParams.has(name)) {
            combinedParams.set(name, [existingValue, value]);
          }
          if (!noOverwrite) {
            combinedParams.set(name, value);
          }
        } else {
          combinedParams.set(name, value);
        }
      }
      const searchPieces = [];
      for (const [name, value] of combinedParams) {
        if (typeof value === "string") {
          searchPieces.push(`${name}=${value}`);
        } else if (Array.isArray(value)) {
          for (const subValue of value) {
            searchPieces.push(`${name}=${subValue}`);
          }
        } else {
          searchPieces.push(`${name}=${value}`);
        }
      }
      parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
      return parsedUrl.toString();
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/log.js
var require_log4 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/log.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logger = void 0;
    var logger_1 = require_commonjs();
    exports2.logger = (0, logger_1.createClientLogger)("core-client");
  }
});

// node_modules/@azure/core-client/dist/commonjs/serviceClient.js
var require_serviceClient = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/serviceClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceClient = void 0;
    var core_rest_pipeline_1 = require_commonjs6();
    var pipeline_js_1 = require_pipeline3();
    var utils_js_1 = require_utils4();
    var httpClientCache_js_1 = require_httpClientCache();
    var operationHelpers_js_1 = require_operationHelpers();
    var urlHelpers_js_1 = require_urlHelpers2();
    var interfaceHelpers_js_1 = require_interfaceHelpers();
    var log_js_1 = require_log4();
    var ServiceClient = class {
      /**
       * If specified, this is the base URI that requests will be made against for this ServiceClient.
       * If it is not specified, then all OperationSpecs must contain a baseUrl property.
       */
      _endpoint;
      /**
       * The default request content type for the service.
       * Used if no requestContentType is present on an OperationSpec.
       */
      _requestContentType;
      /**
       * Set to true if the request is sent over HTTP instead of HTTPS
       */
      _allowInsecureConnection;
      /**
       * The HTTP client that will be used to send requests.
       */
      _httpClient;
      /**
       * The pipeline used by this client to make requests
       */
      pipeline;
      /**
       * The ServiceClient constructor
       * @param options - The service client options that govern the behavior of the client.
       */
      constructor(options = {}) {
        this._requestContentType = options.requestContentType;
        this._endpoint = options.endpoint ?? options.baseUri;
        if (options.baseUri) {
          log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        }
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)();
        this.pipeline = options.pipeline || createDefaultPipeline(options);
        if (options.additionalPolicies?.length) {
          for (const { policy, position } of options.additionalPolicies) {
            const afterPhase = position === "perRetry" ? "Sign" : void 0;
            this.pipeline.addPolicy(policy, {
              afterPhase
            });
          }
        }
      }
      /**
       * Send the provided httpRequest.
       */
      async sendRequest(request) {
        return this.pipeline.sendRequest(this._httpClient, request);
      }
      /**
       * Send an HTTP request that is populated using the provided OperationSpec.
       * @typeParam T - The typed result of the request, based on the OperationSpec.
       * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
       * @param operationSpec - The OperationSpec to use to populate the httpRequest.
       */
      async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint = operationSpec.baseUrl || this._endpoint;
        if (!endpoint) {
          throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        }
        const url = (0, urlHelpers_js_1.getRequestUrl)(endpoint, operationSpec, operationArguments, this);
        const request = (0, core_rest_pipeline_1.createPipelineRequest)({
          url
        });
        request.method = operationSpec.httpMethod;
        const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType = operationSpec.contentType || this._requestContentType;
        if (contentType && operationSpec.requestBody) {
          request.headers.set("Content-Type", contentType);
        }
        const options = operationArguments.options;
        if (options) {
          const requestOptions = options.requestOptions;
          if (requestOptions) {
            if (requestOptions.timeout) {
              request.timeout = requestOptions.timeout;
            }
            if (requestOptions.onUploadProgress) {
              request.onUploadProgress = requestOptions.onUploadProgress;
            }
            if (requestOptions.onDownloadProgress) {
              request.onDownloadProgress = requestOptions.onDownloadProgress;
            }
            if (requestOptions.shouldDeserialize !== void 0) {
              operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
            }
            if (requestOptions.allowInsecureConnection) {
              request.allowInsecureConnection = true;
            }
          }
          if (options.abortSignal) {
            request.abortSignal = options.abortSignal;
          }
          if (options.tracingOptions) {
            request.tracingOptions = options.tracingOptions;
          }
        }
        if (this._allowInsecureConnection) {
          request.allowInsecureConnection = true;
        }
        if (request.streamResponseStatusCodes === void 0) {
          request.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
        }
        try {
          const rawResponse = await this.sendRequest(request);
          const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
          if (options?.onResponse) {
            options.onResponse(rawResponse, flatResponse);
          }
          return flatResponse;
        } catch (error) {
          if (typeof error === "object" && error?.response) {
            const rawResponse = error.response;
            const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
            error.details = flatResponse;
            if (options?.onResponse) {
              options.onResponse(rawResponse, flatResponse, error);
            }
          }
          throw error;
        }
      }
    };
    exports2.ServiceClient = ServiceClient;
    function createDefaultPipeline(options) {
      const credentialScopes = getCredentialScopes(options);
      const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
      return (0, pipeline_js_1.createClientPipeline)({
        ...options,
        credentialOptions
      });
    }
    function getCredentialScopes(options) {
      if (options.credentialScopes) {
        return options.credentialScopes;
      }
      if (options.endpoint) {
        return `${options.endpoint}/.default`;
      }
      if (options.baseUri) {
        return `${options.baseUri}/.default`;
      }
      if (options.credential && !options.credentialScopes) {
        throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
      }
      return void 0;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnClaimChallenge.js
var require_authorizeRequestOnClaimChallenge = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnClaimChallenge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseCAEChallenge = parseCAEChallenge;
    exports2.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
    var log_js_1 = require_log4();
    var base64_js_1 = require_base64();
    function parseCAEChallenge(challenges) {
      const bearerChallenges = `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x);
      return bearerChallenges.map((challenge) => {
        const challengeParts = `${challenge.trim()}, `.split('", ').filter((x) => x);
        const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="')));
        return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {});
      });
    }
    async function authorizeRequestOnClaimChallenge(onChallengeOptions) {
      const { scopes, response } = onChallengeOptions;
      const logger = onChallengeOptions.logger || log_js_1.logger;
      const challenge = response.headers.get("WWW-Authenticate");
      if (!challenge) {
        logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
        return false;
      }
      const challenges = parseCAEChallenge(challenge) || [];
      const parsedChallenge = challenges.find((x) => x.claims);
      if (!parsedChallenge) {
        logger.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
        return false;
      }
      const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
        claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims)
      });
      if (!accessToken) {
        return false;
      }
      onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
      return true;
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnTenantChallenge.js
var require_authorizeRequestOnTenantChallenge = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnTenantChallenge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.authorizeRequestOnTenantChallenge = void 0;
    var Constants = {
      DefaultScope: "/.default",
      /**
       * Defines constants for use with HTTP headers.
       */
      HeaderConstants: {
        /**
         * The Authorization header.
         */
        AUTHORIZATION: "authorization"
      }
    };
    function isUuid(text) {
      return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
    }
    var authorizeRequestOnTenantChallenge = async (challengeOptions) => {
      const requestOptions = requestToOptions(challengeOptions.request);
      const challenge = getChallenge(challengeOptions.response);
      if (challenge) {
        const challengeInfo = parseChallenge(challenge);
        const challengeScopes = buildScopes(challengeOptions, challengeInfo);
        const tenantId = extractTenantId(challengeInfo);
        if (!tenantId) {
          return false;
        }
        const accessToken = await challengeOptions.getAccessToken(challengeScopes, {
          ...requestOptions,
          tenantId
        });
        if (!accessToken) {
          return false;
        }
        challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
        return true;
      }
      return false;
    };
    exports2.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge;
    function extractTenantId(challengeInfo) {
      const parsedAuthUri = new URL(challengeInfo.authorization_uri);
      const pathSegments = parsedAuthUri.pathname.split("/");
      const tenantId = pathSegments[1];
      if (tenantId && isUuid(tenantId)) {
        return tenantId;
      }
      return void 0;
    }
    function buildScopes(challengeOptions, challengeInfo) {
      if (!challengeInfo.resource_id) {
        return challengeOptions.scopes;
      }
      const challengeScopes = new URL(challengeInfo.resource_id);
      challengeScopes.pathname = Constants.DefaultScope;
      let scope = challengeScopes.toString();
      if (scope === "https://disk.azure.com/.default") {
        scope = "https://disk.azure.com//.default";
      }
      return [scope];
    }
    function getChallenge(response) {
      const challenge = response.headers.get("WWW-Authenticate");
      if (response.status === 401 && challenge) {
        return challenge;
      }
      return;
    }
    function parseChallenge(challenge) {
      const bearerChallenge = challenge.slice("Bearer ".length);
      const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x) => x);
      const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
      return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {});
    }
    function requestToOptions(request) {
      return {
        abortSignal: request.abortSignal,
        requestOptions: {
          timeout: request.timeout
        },
        tracingOptions: request.tracingOptions
      };
    }
  }
});

// node_modules/@azure/core-client/dist/commonjs/index.js
var require_commonjs7 = __commonJS({
  "node_modules/@azure/core-client/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.authorizeRequestOnTenantChallenge = exports2.authorizeRequestOnClaimChallenge = exports2.serializationPolicyName = exports2.serializationPolicy = exports2.deserializationPolicyName = exports2.deserializationPolicy = exports2.XML_CHARKEY = exports2.XML_ATTRKEY = exports2.createClientPipeline = exports2.ServiceClient = exports2.MapperTypeNames = exports2.createSerializer = void 0;
    var serializer_js_1 = require_serializer();
    Object.defineProperty(exports2, "createSerializer", { enumerable: true, get: function() {
      return serializer_js_1.createSerializer;
    } });
    Object.defineProperty(exports2, "MapperTypeNames", { enumerable: true, get: function() {
      return serializer_js_1.MapperTypeNames;
    } });
    var serviceClient_js_1 = require_serviceClient();
    Object.defineProperty(exports2, "ServiceClient", { enumerable: true, get: function() {
      return serviceClient_js_1.ServiceClient;
    } });
    var pipeline_js_1 = require_pipeline3();
    Object.defineProperty(exports2, "createClientPipeline", { enumerable: true, get: function() {
      return pipeline_js_1.createClientPipeline;
    } });
    var interfaces_js_1 = require_interfaces();
    Object.defineProperty(exports2, "XML_ATTRKEY", { enumerable: true, get: function() {
      return interfaces_js_1.XML_ATTRKEY;
    } });
    Object.defineProperty(exports2, "XML_CHARKEY", { enumerable: true, get: function() {
      return interfaces_js_1.XML_CHARKEY;
    } });
    var deserializationPolicy_js_1 = require_deserializationPolicy();
    Object.defineProperty(exports2, "deserializationPolicy", { enumerable: true, get: function() {
      return deserializationPolicy_js_1.deserializationPolicy;
    } });
    Object.defineProperty(exports2, "deserializationPolicyName", { enumerable: true, get: function() {
      return deserializationPolicy_js_1.deserializationPolicyName;
    } });
    var serializationPolicy_js_1 = require_serializationPolicy();
    Object.defineProperty(exports2, "serializationPolicy", { enumerable: true, get: function() {
      return serializationPolicy_js_1.serializationPolicy;
    } });
    Object.defineProperty(exports2, "serializationPolicyName", { enumerable: true, get: function() {
      return serializationPolicy_js_1.serializationPolicyName;
    } });
    var authorizeRequestOnClaimChallenge_js_1 = require_authorizeRequestOnClaimChallenge();
    Object.defineProperty(exports2, "authorizeRequestOnClaimChallenge", { enumerable: true, get: function() {
      return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge;
    } });
    var authorizeRequestOnTenantChallenge_js_1 = require_authorizeRequestOnTenantChallenge();
    Object.defineProperty(exports2, "authorizeRequestOnTenantChallenge", { enumerable: true, get: function() {
      return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge;
    } });
  }
});

// node_modules/@azure/identity/dist/commonjs/util/identityTokenEndpoint.js
var require_identityTokenEndpoint = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/util/identityTokenEndpoint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getIdentityTokenEndpointSuffix = getIdentityTokenEndpointSuffix;
    function getIdentityTokenEndpointSuffix(tenantId) {
      if (tenantId === "adfs") {
        return "oauth2/token";
      } else {
        return "oauth2/v2.0/token";
      }
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/utils.js
var require_utils5 = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceFabricErrorMessage = void 0;
    exports2.mapScopesToResource = mapScopesToResource;
    exports2.parseExpirationTimestamp = parseExpirationTimestamp;
    exports2.parseRefreshTimestamp = parseRefreshTimestamp;
    var DefaultScopeSuffix = "/.default";
    exports2.serviceFabricErrorMessage = "Specifying a `clientId` or `resourceId` is not supported by the Service Fabric managed identity environment. The managed identity configuration is determined by the Service Fabric cluster resource configuration. See https://aka.ms/servicefabricmi for more information";
    function mapScopesToResource(scopes) {
      let scope = "";
      if (Array.isArray(scopes)) {
        if (scopes.length !== 1) {
          return;
        }
        scope = scopes[0];
      } else if (typeof scopes === "string") {
        scope = scopes;
      }
      if (!scope.endsWith(DefaultScopeSuffix)) {
        return scope;
      }
      return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));
    }
    function parseExpirationTimestamp(body) {
      if (typeof body.expires_on === "number") {
        return body.expires_on * 1e3;
      }
      if (typeof body.expires_on === "string") {
        const asNumber = +body.expires_on;
        if (!isNaN(asNumber)) {
          return asNumber * 1e3;
        }
        const asDate = Date.parse(body.expires_on);
        if (!isNaN(asDate)) {
          return asDate;
        }
      }
      if (typeof body.expires_in === "number") {
        return Date.now() + body.expires_in * 1e3;
      }
      throw new Error(`Failed to parse token expiration from body. expires_in="${body.expires_in}", expires_on="${body.expires_on}"`);
    }
    function parseRefreshTimestamp(body) {
      if (body.refresh_on) {
        if (typeof body.refresh_on === "number") {
          return body.refresh_on * 1e3;
        }
        if (typeof body.refresh_on === "string") {
          const asNumber = +body.refresh_on;
          if (!isNaN(asNumber)) {
            return asNumber * 1e3;
          }
          const asDate = Date.parse(body.refresh_on);
          if (!isNaN(asDate)) {
            return asDate;
          }
        }
        throw new Error(`Failed to parse refresh_on from body. refresh_on="${body.refresh_on}"`);
      } else {
        return void 0;
      }
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/client/identityClient.js
var require_identityClient = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/client/identityClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IdentityClient = void 0;
    exports2.getIdentityClientAuthorityHost = getIdentityClientAuthorityHost;
    var core_client_1 = require_commonjs7();
    var core_util_1 = require_commonjs4();
    var core_rest_pipeline_1 = require_commonjs6();
    var errors_js_1 = require_errors();
    var identityTokenEndpoint_js_1 = require_identityTokenEndpoint();
    var constants_js_1 = require_constants();
    var tracing_js_1 = require_tracing();
    var logging_js_1 = require_logging();
    var utils_js_1 = require_utils5();
    var noCorrelationId = "noCorrelationId";
    function getIdentityClientAuthorityHost(options) {
      let authorityHost = options?.authorityHost;
      if (core_util_1.isNode) {
        authorityHost = authorityHost ?? process.env.AZURE_AUTHORITY_HOST;
      }
      return authorityHost ?? constants_js_1.DefaultAuthorityHost;
    }
    var IdentityClient = class extends core_client_1.ServiceClient {
      authorityHost;
      allowLoggingAccountIdentifiers;
      abortControllers;
      allowInsecureConnection = false;
      // used for WorkloadIdentity
      tokenCredentialOptions;
      constructor(options) {
        const packageDetails = `azsdk-js-identity/${constants_js_1.SDK_VERSION}`;
        const userAgentPrefix = options?.userAgentOptions?.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        const baseUri = getIdentityClientAuthorityHost(options);
        if (!baseUri.startsWith("https:")) {
          throw new Error("The authorityHost address must use the 'https' protocol.");
        }
        super({
          requestContentType: "application/json; charset=utf-8",
          retryOptions: {
            maxRetries: 3
          },
          ...options,
          userAgentOptions: {
            userAgentPrefix
          },
          baseUri
        });
        this.authorityHost = baseUri;
        this.abortControllers = /* @__PURE__ */ new Map();
        this.allowLoggingAccountIdentifiers = options?.loggingOptions?.allowLoggingAccountIdentifiers;
        this.tokenCredentialOptions = { ...options };
        if (options?.allowInsecureConnection) {
          this.allowInsecureConnection = options.allowInsecureConnection;
        }
      }
      async sendTokenRequest(request) {
        logging_js_1.logger.info(`IdentityClient: sending token request to [${request.url}]`);
        const response = await this.sendRequest(request);
        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {
          const parsedBody = JSON.parse(response.bodyAsText);
          if (!parsedBody.access_token) {
            return null;
          }
          this.logIdentifiers(response);
          const token = {
            accessToken: {
              token: parsedBody.access_token,
              expiresOnTimestamp: (0, utils_js_1.parseExpirationTimestamp)(parsedBody),
              refreshAfterTimestamp: (0, utils_js_1.parseRefreshTimestamp)(parsedBody),
              tokenType: "Bearer"
            },
            refreshToken: parsedBody.refresh_token
          };
          logging_js_1.logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
          return token;
        } else {
          const error = new errors_js_1.AuthenticationError(response.status, response.bodyAsText);
          logging_js_1.logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
          throw error;
        }
      }
      async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, options = {}) {
        if (refreshToken === void 0) {
          return null;
        }
        logging_js_1.logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
        const refreshParams = {
          grant_type: "refresh_token",
          client_id: clientId,
          refresh_token: refreshToken,
          scope: scopes
        };
        if (clientSecret !== void 0) {
          refreshParams.client_secret = clientSecret;
        }
        const query = new URLSearchParams(refreshParams);
        return tracing_js_1.tracingClient.withSpan("IdentityClient.refreshAccessToken", options, async (updatedOptions) => {
          try {
            const urlSuffix = (0, identityTokenEndpoint_js_1.getIdentityTokenEndpointSuffix)(tenantId);
            const request = (0, core_rest_pipeline_1.createPipelineRequest)({
              url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,
              method: "POST",
              body: query.toString(),
              abortSignal: options.abortSignal,
              headers: (0, core_rest_pipeline_1.createHttpHeaders)({
                Accept: "application/json",
                "Content-Type": "application/x-www-form-urlencoded"
              }),
              tracingOptions: updatedOptions.tracingOptions
            });
            const response = await this.sendTokenRequest(request);
            logging_js_1.logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
            return response;
          } catch (err) {
            if (err.name === errors_js_1.AuthenticationErrorName && err.errorResponse.error === "interaction_required") {
              logging_js_1.logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);
              return null;
            } else {
              logging_js_1.logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
              throw err;
            }
          }
        });
      }
      // Here is a custom layer that allows us to abort requests that go through MSAL,
      // since MSAL doesn't allow us to pass options all the way through.
      generateAbortSignal(correlationId) {
        const controller = new AbortController();
        const controllers = this.abortControllers.get(correlationId) || [];
        controllers.push(controller);
        this.abortControllers.set(correlationId, controllers);
        const existingOnAbort = controller.signal.onabort;
        controller.signal.onabort = (...params) => {
          this.abortControllers.set(correlationId, void 0);
          if (existingOnAbort) {
            existingOnAbort.apply(controller.signal, params);
          }
        };
        return controller.signal;
      }
      abortRequests(correlationId) {
        const key = correlationId || noCorrelationId;
        const controllers = [
          ...this.abortControllers.get(key) || [],
          // MSAL passes no correlation ID to the get requests...
          ...this.abortControllers.get(noCorrelationId) || []
        ];
        if (!controllers.length) {
          return;
        }
        for (const controller of controllers) {
          controller.abort();
        }
        this.abortControllers.set(key, void 0);
      }
      getCorrelationId(options) {
        const parameter = options?.body?.split("&").map((part) => part.split("=")).find(([key]) => key === "client-request-id");
        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;
      }
      // The MSAL network module methods follow
      async sendGetRequestAsync(url, options) {
        const request = (0, core_rest_pipeline_1.createPipelineRequest)({
          url,
          method: "GET",
          body: options?.body,
          allowInsecureConnection: this.allowInsecureConnection,
          headers: (0, core_rest_pipeline_1.createHttpHeaders)(options?.headers),
          abortSignal: this.generateAbortSignal(noCorrelationId)
        });
        const response = await this.sendRequest(request);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      async sendPostRequestAsync(url, options) {
        const request = (0, core_rest_pipeline_1.createPipelineRequest)({
          url,
          method: "POST",
          body: options?.body,
          headers: (0, core_rest_pipeline_1.createHttpHeaders)(options?.headers),
          allowInsecureConnection: this.allowInsecureConnection,
          // MSAL doesn't send the correlation ID on the get requests.
          abortSignal: this.generateAbortSignal(this.getCorrelationId(options))
        });
        const response = await this.sendRequest(request);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      /**
       *
       * @internal
       */
      getTokenCredentialOptions() {
        return this.tokenCredentialOptions;
      }
      /**
       * If allowLoggingAccountIdentifiers was set on the constructor options
       * we try to log the account identifiers by parsing the received access token.
       *
       * The account identifiers we try to log are:
       * - `appid`: The application or Client Identifier.
       * - `upn`: User Principal Name.
       *   - It might not be available in some authentication scenarios.
       *   - If it's not available, we put a placeholder: "No User Principal Name available".
       * - `tid`: Tenant Identifier.
       * - `oid`: Object Identifier of the authenticated user.
       */
      logIdentifiers(response) {
        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {
          return;
        }
        const unavailableUpn = "No User Principal Name available";
        try {
          const parsed = response.parsedBody || JSON.parse(response.bodyAsText);
          const accessToken = parsed.access_token;
          if (!accessToken) {
            return;
          }
          const base64Metadata = accessToken.split(".")[1];
          const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, "base64").toString("utf8"));
          logging_js_1.logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);
        } catch (e) {
          logging_js_1.logger.warning("allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:", e.message);
        }
      }
    };
    exports2.IdentityClient = IdentityClient;
  }
});

// node_modules/@azure/identity/dist/commonjs/regionalAuthority.js
var require_regionalAuthority = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/regionalAuthority.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RegionalAuthority = void 0;
    exports2.calculateRegionalAuthority = calculateRegionalAuthority;
    var RegionalAuthority;
    (function(RegionalAuthority2) {
      RegionalAuthority2["AutoDiscoverRegion"] = "AutoDiscoverRegion";
      RegionalAuthority2["USWest"] = "westus";
      RegionalAuthority2["USWest2"] = "westus2";
      RegionalAuthority2["USCentral"] = "centralus";
      RegionalAuthority2["USEast"] = "eastus";
      RegionalAuthority2["USEast2"] = "eastus2";
      RegionalAuthority2["USNorthCentral"] = "northcentralus";
      RegionalAuthority2["USSouthCentral"] = "southcentralus";
      RegionalAuthority2["USWestCentral"] = "westcentralus";
      RegionalAuthority2["CanadaCentral"] = "canadacentral";
      RegionalAuthority2["CanadaEast"] = "canadaeast";
      RegionalAuthority2["BrazilSouth"] = "brazilsouth";
      RegionalAuthority2["EuropeNorth"] = "northeurope";
      RegionalAuthority2["EuropeWest"] = "westeurope";
      RegionalAuthority2["UKSouth"] = "uksouth";
      RegionalAuthority2["UKWest"] = "ukwest";
      RegionalAuthority2["FranceCentral"] = "francecentral";
      RegionalAuthority2["FranceSouth"] = "francesouth";
      RegionalAuthority2["SwitzerlandNorth"] = "switzerlandnorth";
      RegionalAuthority2["SwitzerlandWest"] = "switzerlandwest";
      RegionalAuthority2["GermanyNorth"] = "germanynorth";
      RegionalAuthority2["GermanyWestCentral"] = "germanywestcentral";
      RegionalAuthority2["NorwayWest"] = "norwaywest";
      RegionalAuthority2["NorwayEast"] = "norwayeast";
      RegionalAuthority2["AsiaEast"] = "eastasia";
      RegionalAuthority2["AsiaSouthEast"] = "southeastasia";
      RegionalAuthority2["JapanEast"] = "japaneast";
      RegionalAuthority2["JapanWest"] = "japanwest";
      RegionalAuthority2["AustraliaEast"] = "australiaeast";
      RegionalAuthority2["AustraliaSouthEast"] = "australiasoutheast";
      RegionalAuthority2["AustraliaCentral"] = "australiacentral";
      RegionalAuthority2["AustraliaCentral2"] = "australiacentral2";
      RegionalAuthority2["IndiaCentral"] = "centralindia";
      RegionalAuthority2["IndiaSouth"] = "southindia";
      RegionalAuthority2["IndiaWest"] = "westindia";
      RegionalAuthority2["KoreaSouth"] = "koreasouth";
      RegionalAuthority2["KoreaCentral"] = "koreacentral";
      RegionalAuthority2["UAECentral"] = "uaecentral";
      RegionalAuthority2["UAENorth"] = "uaenorth";
      RegionalAuthority2["SouthAfricaNorth"] = "southafricanorth";
      RegionalAuthority2["SouthAfricaWest"] = "southafricawest";
      RegionalAuthority2["ChinaNorth"] = "chinanorth";
      RegionalAuthority2["ChinaEast"] = "chinaeast";
      RegionalAuthority2["ChinaNorth2"] = "chinanorth2";
      RegionalAuthority2["ChinaEast2"] = "chinaeast2";
      RegionalAuthority2["GermanyCentral"] = "germanycentral";
      RegionalAuthority2["GermanyNorthEast"] = "germanynortheast";
      RegionalAuthority2["GovernmentUSVirginia"] = "usgovvirginia";
      RegionalAuthority2["GovernmentUSIowa"] = "usgoviowa";
      RegionalAuthority2["GovernmentUSArizona"] = "usgovarizona";
      RegionalAuthority2["GovernmentUSTexas"] = "usgovtexas";
      RegionalAuthority2["GovernmentUSDodEast"] = "usdodeast";
      RegionalAuthority2["GovernmentUSDodCentral"] = "usdodcentral";
    })(RegionalAuthority || (exports2.RegionalAuthority = RegionalAuthority = {}));
    function calculateRegionalAuthority(regionalAuthority) {
      let azureRegion = regionalAuthority;
      if (azureRegion === void 0 && globalThis.process?.env?.AZURE_REGIONAL_AUTHORITY_NAME !== void 0) {
        azureRegion = process.env.AZURE_REGIONAL_AUTHORITY_NAME;
      }
      if (azureRegion === RegionalAuthority.AutoDiscoverRegion) {
        return "AUTO_DISCOVER";
      }
      return azureRegion;
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/util/processMultiTenantRequest.js
var require_processMultiTenantRequest = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/util/processMultiTenantRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processMultiTenantRequest = processMultiTenantRequest;
    var errors_js_1 = require_errors();
    function createConfigurationErrorMessage(tenantId) {
      return `The current credential is not configured to acquire tokens for tenant ${tenantId}. To enable acquiring tokens for this tenant add it to the AdditionallyAllowedTenants on the credential options, or add "*" to AdditionallyAllowedTenants to allow acquiring tokens for any tenant.`;
    }
    function processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds = [], logger) {
      let resolvedTenantId;
      if (process.env.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH) {
        resolvedTenantId = tenantId;
      } else if (tenantId === "adfs") {
        resolvedTenantId = tenantId;
      } else {
        resolvedTenantId = getTokenOptions?.tenantId ?? tenantId;
      }
      if (tenantId && resolvedTenantId !== tenantId && !additionallyAllowedTenantIds.includes("*") && !additionallyAllowedTenantIds.some((t) => t.localeCompare(resolvedTenantId) === 0)) {
        const message = createConfigurationErrorMessage(resolvedTenantId);
        logger?.info(message);
        throw new errors_js_1.CredentialUnavailableError(message);
      }
      return resolvedTenantId;
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/util/tenantIdUtils.js
var require_tenantIdUtils = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/util/tenantIdUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processMultiTenantRequest = void 0;
    exports2.checkTenantId = checkTenantId;
    exports2.resolveTenantId = resolveTenantId;
    exports2.resolveAdditionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds;
    var constants_js_1 = require_constants();
    var logging_js_1 = require_logging();
    var processMultiTenantRequest_js_1 = require_processMultiTenantRequest();
    Object.defineProperty(exports2, "processMultiTenantRequest", { enumerable: true, get: function() {
      return processMultiTenantRequest_js_1.processMultiTenantRequest;
    } });
    function checkTenantId(logger, tenantId) {
      if (!tenantId.match(/^[0-9a-zA-Z-.]+$/)) {
        const error = new Error("Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://learn.microsoft.com/partner-center/find-ids-and-domain-names.");
        logger.info((0, logging_js_1.formatError)("", error));
        throw error;
      }
    }
    function resolveTenantId(logger, tenantId, clientId) {
      if (tenantId) {
        checkTenantId(logger, tenantId);
        return tenantId;
      }
      if (!clientId) {
        clientId = constants_js_1.DeveloperSignOnClientId;
      }
      if (clientId !== constants_js_1.DeveloperSignOnClientId) {
        return "common";
      }
      return "organizations";
    }
    function resolveAdditionallyAllowedTenantIds(additionallyAllowedTenants) {
      if (!additionallyAllowedTenants || additionallyAllowedTenants.length === 0) {
        return [];
      }
      if (additionallyAllowedTenants.includes("*")) {
        return constants_js_1.ALL_TENANTS;
      }
      return additionallyAllowedTenants;
    }
  }
});

// node_modules/is-docker/index.js
function hasDockerEnv() {
  try {
    import_node_fs.default.statSync("/.dockerenv");
    return true;
  } catch {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return import_node_fs.default.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch {
    return false;
  }
}
function isDocker() {
  if (isDockerCached === void 0) {
    isDockerCached = hasDockerEnv() || hasDockerCGroup();
  }
  return isDockerCached;
}
var import_node_fs, isDockerCached;
var init_is_docker = __esm({
  "node_modules/is-docker/index.js"() {
    import_node_fs = __toESM(require("node:fs"), 1);
  }
});

// node_modules/is-inside-container/index.js
function isInsideContainer() {
  if (cachedResult === void 0) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}
var import_node_fs2, cachedResult, hasContainerEnv;
var init_is_inside_container = __esm({
  "node_modules/is-inside-container/index.js"() {
    import_node_fs2 = __toESM(require("node:fs"), 1);
    init_is_docker();
    hasContainerEnv = () => {
      try {
        import_node_fs2.default.statSync("/run/.containerenv");
        return true;
      } catch {
        return false;
      }
    };
  }
});

// node_modules/is-wsl/index.js
var import_node_process, import_node_os, import_node_fs3, isWsl, is_wsl_default;
var init_is_wsl = __esm({
  "node_modules/is-wsl/index.js"() {
    import_node_process = __toESM(require("node:process"), 1);
    import_node_os = __toESM(require("node:os"), 1);
    import_node_fs3 = __toESM(require("node:fs"), 1);
    init_is_inside_container();
    isWsl = () => {
      if (import_node_process.default.platform !== "linux") {
        return false;
      }
      if (import_node_os.default.release().toLowerCase().includes("microsoft")) {
        if (isInsideContainer()) {
          return false;
        }
        return true;
      }
      try {
        if (import_node_fs3.default.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft")) {
          return !isInsideContainer();
        }
      } catch {
      }
      if (import_node_fs3.default.existsSync("/proc/sys/fs/binfmt_misc/WSLInterop") || import_node_fs3.default.existsSync("/run/WSL")) {
        return !isInsideContainer();
      }
      return false;
    };
    is_wsl_default = import_node_process.default.env.__IS_WSL_TEST__ ? isWsl : isWsl();
  }
});

// node_modules/wsl-utils/index.js
var import_node_process2, import_promises, wslDrivesMountPoint, powerShellPathFromWsl, powerShellPath;
var init_wsl_utils = __esm({
  "node_modules/wsl-utils/index.js"() {
    import_node_process2 = __toESM(require("node:process"), 1);
    import_promises = __toESM(require("node:fs/promises"), 1);
    init_is_wsl();
    init_is_wsl();
    wslDrivesMountPoint = /* @__PURE__ */ (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await import_promises.default.access(configFilePath, import_promises.constants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await import_promises.default.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    powerShellPathFromWsl = async () => {
      const mountPoint = await wslDrivesMountPoint();
      return `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;
    };
    powerShellPath = async () => {
      if (is_wsl_default) {
        return powerShellPathFromWsl();
      }
      return `${import_node_process2.default.env.SYSTEMROOT || import_node_process2.default.env.windir || String.raw`C:\Windows`}\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`;
    };
  }
});

// node_modules/define-lazy-prop/index.js
function defineLazyProperty(object, propertyName, valueGetter) {
  const define2 = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get() {
      const result = valueGetter();
      define2(result);
      return result;
    },
    set(value) {
      define2(value);
    }
  });
  return object;
}
var init_define_lazy_prop = __esm({
  "node_modules/define-lazy-prop/index.js"() {
  }
});

// node_modules/default-browser-id/index.js
async function defaultBrowserId() {
  if (import_node_process3.default.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const { stdout } = await execFileAsync("defaults", ["read", "com.apple.LaunchServices/com.apple.launchservices.secure", "LSHandlers"]);
  const match = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);
  const browserId = match?.groups.id ?? "com.apple.Safari";
  if (browserId === "com.apple.safari") {
    return "com.apple.Safari";
  }
  return browserId;
}
var import_node_util, import_node_process3, import_node_child_process, execFileAsync;
var init_default_browser_id = __esm({
  "node_modules/default-browser-id/index.js"() {
    import_node_util = require("node:util");
    import_node_process3 = __toESM(require("node:process"), 1);
    import_node_child_process = require("node:child_process");
    execFileAsync = (0, import_node_util.promisify)(import_node_child_process.execFile);
  }
});

// node_modules/run-applescript/index.js
async function runAppleScript(script, { humanReadableOutput = true, signal } = {}) {
  if (import_node_process4.default.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const outputArguments = humanReadableOutput ? [] : ["-ss"];
  const execOptions = {};
  if (signal) {
    execOptions.signal = signal;
  }
  const { stdout } = await execFileAsync2("osascript", ["-e", script, outputArguments], execOptions);
  return stdout.trim();
}
var import_node_process4, import_node_util2, import_node_child_process2, execFileAsync2;
var init_run_applescript = __esm({
  "node_modules/run-applescript/index.js"() {
    import_node_process4 = __toESM(require("node:process"), 1);
    import_node_util2 = require("node:util");
    import_node_child_process2 = require("node:child_process");
    execFileAsync2 = (0, import_node_util2.promisify)(import_node_child_process2.execFile);
  }
});

// node_modules/bundle-name/index.js
async function bundleName(bundleId) {
  return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string
tell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}
var init_bundle_name = __esm({
  "node_modules/bundle-name/index.js"() {
    init_run_applescript();
  }
});

// node_modules/default-browser/windows.js
async function defaultBrowser(_execFileAsync = execFileAsync3) {
  const { stdout } = await _execFileAsync("reg", [
    "QUERY",
    " HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
    "/v",
    "ProgId"
  ]);
  const match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
  if (!match) {
    throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
  }
  const { id } = match.groups;
  const dotIndex = id.lastIndexOf(".");
  const hyphenIndex = id.lastIndexOf("-");
  const baseIdByDot = dotIndex === -1 ? void 0 : id.slice(0, dotIndex);
  const baseIdByHyphen = hyphenIndex === -1 ? void 0 : id.slice(0, hyphenIndex);
  return windowsBrowserProgIds[id] ?? windowsBrowserProgIds[baseIdByDot] ?? windowsBrowserProgIds[baseIdByHyphen] ?? { name: id, id };
}
var import_node_util3, import_node_child_process3, execFileAsync3, windowsBrowserProgIds, _windowsBrowserProgIdMap, UnknownBrowserError;
var init_windows = __esm({
  "node_modules/default-browser/windows.js"() {
    import_node_util3 = require("node:util");
    import_node_child_process3 = require("node:child_process");
    execFileAsync3 = (0, import_node_util3.promisify)(import_node_child_process3.execFile);
    windowsBrowserProgIds = {
      MSEdgeHTM: { name: "Edge", id: "com.microsoft.edge" },
      // The missing `L` is correct.
      MSEdgeBHTML: { name: "Edge Beta", id: "com.microsoft.edge.beta" },
      MSEdgeDHTML: { name: "Edge Dev", id: "com.microsoft.edge.dev" },
      AppXq0fevzme2pys62n3e0fbqa7peapykr8v: { name: "Edge", id: "com.microsoft.edge.old" },
      ChromeHTML: { name: "Chrome", id: "com.google.chrome" },
      ChromeBHTML: { name: "Chrome Beta", id: "com.google.chrome.beta" },
      ChromeDHTML: { name: "Chrome Dev", id: "com.google.chrome.dev" },
      ChromiumHTM: { name: "Chromium", id: "org.chromium.Chromium" },
      BraveHTML: { name: "Brave", id: "com.brave.Browser" },
      BraveBHTML: { name: "Brave Beta", id: "com.brave.Browser.beta" },
      BraveDHTML: { name: "Brave Dev", id: "com.brave.Browser.dev" },
      BraveSSHTM: { name: "Brave Nightly", id: "com.brave.Browser.nightly" },
      FirefoxURL: { name: "Firefox", id: "org.mozilla.firefox" },
      OperaStable: { name: "Opera", id: "com.operasoftware.Opera" },
      VivaldiHTM: { name: "Vivaldi", id: "com.vivaldi.Vivaldi" },
      "IE.HTTP": { name: "Internet Explorer", id: "com.microsoft.ie" }
    };
    _windowsBrowserProgIdMap = new Map(Object.entries(windowsBrowserProgIds));
    UnknownBrowserError = class extends Error {
    };
  }
});

// node_modules/default-browser/index.js
async function defaultBrowser2() {
  if (import_node_process5.default.platform === "darwin") {
    const id = await defaultBrowserId();
    const name = await bundleName(id);
    return { name, id };
  }
  if (import_node_process5.default.platform === "linux") {
    const { stdout } = await execFileAsync4("xdg-mime", ["query", "default", "x-scheme-handler/http"]);
    const id = stdout.trim();
    const name = titleize(id.replace(/.desktop$/, "").replace("-", " "));
    return { name, id };
  }
  if (import_node_process5.default.platform === "win32") {
    return defaultBrowser();
  }
  throw new Error("Only macOS, Linux, and Windows are supported");
}
var import_node_util4, import_node_process5, import_node_child_process4, execFileAsync4, titleize;
var init_default_browser = __esm({
  "node_modules/default-browser/index.js"() {
    import_node_util4 = require("node:util");
    import_node_process5 = __toESM(require("node:process"), 1);
    import_node_child_process4 = require("node:child_process");
    init_default_browser_id();
    init_bundle_name();
    init_windows();
    execFileAsync4 = (0, import_node_util4.promisify)(import_node_child_process4.execFile);
    titleize = (string) => string.toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x) => x.toUpperCase());
  }
});

// node_modules/open/index.js
var open_exports = {};
__export(open_exports, {
  apps: () => apps,
  default: () => open_default,
  openApp: () => openApp
});
async function getWindowsDefaultBrowserFromWsl() {
  const powershellPath = await powerShellPath();
  const rawCommand = String.raw`(Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice").ProgId`;
  const encodedCommand = import_node_buffer.Buffer.from(rawCommand, "utf16le").toString("base64");
  const { stdout } = await execFile5(
    powershellPath,
    [
      "-NoProfile",
      "-NonInteractive",
      "-ExecutionPolicy",
      "Bypass",
      "-EncodedCommand",
      encodedCommand
    ],
    { encoding: "utf8" }
  );
  const progId = stdout.trim();
  const browserMap = {
    ChromeHTML: "com.google.chrome",
    BraveHTML: "com.brave.Browser",
    MSEdgeHTM: "com.microsoft.edge",
    FirefoxURL: "org.mozilla.firefox"
  };
  return browserMap[progId] ? { id: browserMap[progId] } : {};
}
function detectArchBinary(binary) {
  if (typeof binary === "string" || Array.isArray(binary)) {
    return binary;
  }
  const { [arch]: archBinary } = binary;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
  if (wsl && is_wsl_default) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
var import_node_process6, import_node_buffer, import_node_path, import_node_url, import_node_util5, import_node_child_process5, import_promises2, import_meta, execFile5, __dirname, localXdgOpenPath, platform, arch, pTryEach, baseOpen, open, openApp, apps, open_default;
var init_open = __esm({
  "node_modules/open/index.js"() {
    import_node_process6 = __toESM(require("node:process"), 1);
    import_node_buffer = require("node:buffer");
    import_node_path = __toESM(require("node:path"), 1);
    import_node_url = require("node:url");
    import_node_util5 = require("node:util");
    import_node_child_process5 = __toESM(require("node:child_process"), 1);
    import_promises2 = __toESM(require("node:fs/promises"), 1);
    init_wsl_utils();
    init_define_lazy_prop();
    init_default_browser();
    init_is_inside_container();
    import_meta = {};
    execFile5 = (0, import_node_util5.promisify)(import_node_child_process5.default.execFile);
    __dirname = import_node_path.default.dirname((0, import_node_url.fileURLToPath)(import_meta.url));
    localXdgOpenPath = import_node_path.default.join(__dirname, "xdg-open");
    ({ platform, arch } = import_node_process6.default);
    pTryEach = async (array, mapper) => {
      let latestError;
      for (const item of array) {
        try {
          return await mapper(item);
        } catch (error) {
          latestError = error;
        }
      }
      throw latestError;
    };
    baseOpen = async (options) => {
      options = {
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false,
        ...options
      };
      if (Array.isArray(options.app)) {
        return pTryEach(options.app, (singleApp) => baseOpen({
          ...options,
          app: singleApp
        }));
      }
      let { name: app, arguments: appArguments = [] } = options.app ?? {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen({
          ...options,
          app: {
            name: appName,
            arguments: appArguments
          }
        }));
      }
      if (app === "browser" || app === "browserPrivate") {
        const ids = {
          "com.google.chrome": "chrome",
          "google-chrome.desktop": "chrome",
          "com.brave.Browser": "brave",
          "org.mozilla.firefox": "firefox",
          "firefox.desktop": "firefox",
          "com.microsoft.msedge": "edge",
          "com.microsoft.edge": "edge",
          "com.microsoft.edgemac": "edge",
          "microsoft-edge.desktop": "edge"
        };
        const flags = {
          chrome: "--incognito",
          brave: "--incognito",
          firefox: "--private-window",
          edge: "--inPrivate"
        };
        const browser = is_wsl_default ? await getWindowsDefaultBrowserFromWsl() : await defaultBrowser2();
        if (browser.id in ids) {
          const browserName = ids[browser.id];
          if (app === "browserPrivate") {
            appArguments.push(flags[browserName]);
          }
          return baseOpen({
            ...options,
            app: {
              name: apps[browserName],
              arguments: appArguments
            }
          });
        }
        throw new Error(`${browser.name} is not supported as a default browser`);
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options.background) {
          cliArguments.push("--background");
        }
        if (options.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || is_wsl_default && !isInsideContainer() && !app) {
        command = await powerShellPath();
        cliArguments.push(
          "-NoProfile",
          "-NonInteractive",
          "-ExecutionPolicy",
          "Bypass",
          "-EncodedCommand"
        );
        if (!is_wsl_default) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`);
          if (options.target) {
            appArguments.push(options.target);
          }
        } else if (options.target) {
          encodedArguments.push(`"${options.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((argument) => `"\`"${argument}\`""`);
          encodedArguments.push("-ArgumentList", appArguments.join(","));
        }
        options.target = import_node_buffer.Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await import_promises2.default.access(localXdgOpenPath, import_promises2.constants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = import_node_process6.default.versions.electron ?? (platform === "android" || isBundled || !exeLocalXdgOpen);
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      if (options.target) {
        cliArguments.push(options.target);
      }
      const subprocess = import_node_child_process5.default.spawn(command, cliArguments, childProcessOptions);
      if (options.wait) {
        return new Promise((resolve, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (!options.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    open = (target, options) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen({
        ...options,
        target
      });
    };
    openApp = (name, options) => {
      if (typeof name !== "string" && !Array.isArray(name)) {
        throw new TypeError("Expected a valid `name`");
      }
      const { arguments: appArguments = [] } = options ?? {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen({
        ...options,
        app: {
          name,
          arguments: appArguments
        }
      });
    };
    apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "brave", () => detectPlatformBinary({
      darwin: "brave browser",
      win32: "brave",
      linux: ["brave-browser", "brave"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe",
        x64: ["/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe", "/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: String.raw`C:\Program Files\Mozilla Firefox\firefox.exe`,
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    defineLazyProperty(apps, "browser", () => "browser");
    defineLazyProperty(apps, "browserPrivate", () => "browserPrivate");
    open_default = open;
  }
});

// node_modules/@azure/identity/dist/commonjs/msal/nodeFlows/msalClient.js
var require_msalClient = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/msal/nodeFlows/msalClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateMsalConfiguration = generateMsalConfiguration;
    exports2.createMsalClient = createMsalClient;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var msal = tslib_1.__importStar(require_msal_node());
    var logging_js_1 = require_logging();
    var msalPlugins_js_1 = require_msalPlugins();
    var utils_js_1 = require_utils3();
    var errors_js_1 = require_errors();
    var identityClient_js_1 = require_identityClient();
    var regionalAuthority_js_1 = require_regionalAuthority();
    var logger_1 = require_commonjs();
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var msalLogger = (0, logging_js_1.credentialLogger)("MsalClient");
    function generateMsalConfiguration(clientId, tenantId, msalClientOptions = {}) {
      const resolvedTenant = (0, tenantIdUtils_js_1.resolveTenantId)(msalClientOptions.logger ?? msalLogger, tenantId, clientId);
      const authority = (0, utils_js_1.getAuthority)(resolvedTenant, (0, utils_js_1.getAuthorityHost)(msalClientOptions));
      const httpClient = new identityClient_js_1.IdentityClient({
        ...msalClientOptions.tokenCredentialOptions,
        authorityHost: authority,
        loggingOptions: msalClientOptions.loggingOptions
      });
      const msalConfig = {
        auth: {
          clientId,
          authority,
          knownAuthorities: (0, utils_js_1.getKnownAuthorities)(resolvedTenant, authority, msalClientOptions.disableInstanceDiscovery)
        },
        system: {
          networkClient: httpClient,
          loggerOptions: {
            loggerCallback: (0, utils_js_1.defaultLoggerCallback)(msalClientOptions.logger ?? msalLogger),
            logLevel: (0, utils_js_1.getMSALLogLevel)((0, logger_1.getLogLevel)()),
            piiLoggingEnabled: msalClientOptions.loggingOptions?.enableUnsafeSupportLogging
          }
        }
      };
      return msalConfig;
    }
    function createMsalClient(clientId, tenantId, createMsalClientOptions = {}) {
      const state = {
        msalConfig: generateMsalConfiguration(clientId, tenantId, createMsalClientOptions),
        cachedAccount: createMsalClientOptions.authenticationRecord ? (0, utils_js_1.publicToMsal)(createMsalClientOptions.authenticationRecord) : null,
        pluginConfiguration: msalPlugins_js_1.msalPlugins.generatePluginConfiguration(createMsalClientOptions),
        logger: createMsalClientOptions.logger ?? msalLogger
      };
      const publicApps = /* @__PURE__ */ new Map();
      async function getPublicApp(options = {}) {
        const appKey = options.enableCae ? "CAE" : "default";
        let publicClientApp = publicApps.get(appKey);
        if (publicClientApp) {
          state.logger.getToken.info("Existing PublicClientApplication found in cache, returning it.");
          return publicClientApp;
        }
        state.logger.getToken.info(`Creating new PublicClientApplication with CAE ${options.enableCae ? "enabled" : "disabled"}.`);
        const cachePlugin = options.enableCae ? state.pluginConfiguration.cache.cachePluginCae : state.pluginConfiguration.cache.cachePlugin;
        state.msalConfig.auth.clientCapabilities = options.enableCae ? ["cp1"] : void 0;
        publicClientApp = new msal.PublicClientApplication({
          ...state.msalConfig,
          broker: { nativeBrokerPlugin: state.pluginConfiguration.broker.nativeBrokerPlugin },
          cache: { cachePlugin: await cachePlugin }
        });
        publicApps.set(appKey, publicClientApp);
        return publicClientApp;
      }
      const confidentialApps = /* @__PURE__ */ new Map();
      async function getConfidentialApp(options = {}) {
        const appKey = options.enableCae ? "CAE" : "default";
        let confidentialClientApp = confidentialApps.get(appKey);
        if (confidentialClientApp) {
          state.logger.getToken.info("Existing ConfidentialClientApplication found in cache, returning it.");
          return confidentialClientApp;
        }
        state.logger.getToken.info(`Creating new ConfidentialClientApplication with CAE ${options.enableCae ? "enabled" : "disabled"}.`);
        const cachePlugin = options.enableCae ? state.pluginConfiguration.cache.cachePluginCae : state.pluginConfiguration.cache.cachePlugin;
        state.msalConfig.auth.clientCapabilities = options.enableCae ? ["cp1"] : void 0;
        confidentialClientApp = new msal.ConfidentialClientApplication({
          ...state.msalConfig,
          broker: { nativeBrokerPlugin: state.pluginConfiguration.broker.nativeBrokerPlugin },
          cache: { cachePlugin: await cachePlugin }
        });
        confidentialApps.set(appKey, confidentialClientApp);
        return confidentialClientApp;
      }
      async function getTokenSilent(app, scopes, options = {}) {
        if (state.cachedAccount === null) {
          state.logger.getToken.info("No cached account found in local state.");
          throw new errors_js_1.AuthenticationRequiredError({ scopes });
        }
        if (options.claims) {
          state.cachedClaims = options.claims;
        }
        const silentRequest = {
          account: state.cachedAccount,
          scopes,
          claims: state.cachedClaims
        };
        if (state.pluginConfiguration.broker.isEnabled) {
          silentRequest.tokenQueryParameters ||= {};
          if (state.pluginConfiguration.broker.enableMsaPassthrough) {
            silentRequest.tokenQueryParameters["msal_request_type"] = "consumer_passthrough";
          }
        }
        if (options.proofOfPossessionOptions) {
          silentRequest.shrNonce = options.proofOfPossessionOptions.nonce;
          silentRequest.authenticationScheme = "pop";
          silentRequest.resourceRequestMethod = options.proofOfPossessionOptions.resourceRequestMethod;
          silentRequest.resourceRequestUri = options.proofOfPossessionOptions.resourceRequestUrl;
        }
        state.logger.getToken.info("Attempting to acquire token silently");
        try {
          return await app.acquireTokenSilent(silentRequest);
        } catch (err) {
          throw (0, utils_js_1.handleMsalError)(scopes, err, options);
        }
      }
      function calculateRequestAuthority(options) {
        if (options?.tenantId) {
          return (0, utils_js_1.getAuthority)(options.tenantId, (0, utils_js_1.getAuthorityHost)(createMsalClientOptions));
        }
        return state.msalConfig.auth.authority;
      }
      async function withSilentAuthentication(msalApp, scopes, options, onAuthenticationRequired) {
        let response = null;
        try {
          response = await getTokenSilent(msalApp, scopes, options);
        } catch (e) {
          if (e.name !== "AuthenticationRequiredError") {
            throw e;
          }
          if (options.disableAutomaticAuthentication) {
            throw new errors_js_1.AuthenticationRequiredError({
              scopes,
              getTokenOptions: options,
              message: "Automatic authentication has been disabled. You may call the authentication() method."
            });
          }
        }
        if (response === null) {
          try {
            response = await onAuthenticationRequired();
          } catch (err) {
            throw (0, utils_js_1.handleMsalError)(scopes, err, options);
          }
        }
        (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
        state.cachedAccount = response?.account ?? null;
        state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
        return {
          token: response.accessToken,
          expiresOnTimestamp: response.expiresOn.getTime(),
          refreshAfterTimestamp: response.refreshOn?.getTime(),
          tokenType: response.tokenType
        };
      }
      async function getTokenByClientSecret(scopes, clientSecret, options = {}) {
        state.logger.getToken.info(`Attempting to acquire token using client secret`);
        state.msalConfig.auth.clientSecret = clientSecret;
        const msalApp = await getConfidentialApp(options);
        try {
          const response = await msalApp.acquireTokenByClientCredential({
            scopes,
            authority: calculateRequestAuthority(options),
            azureRegion: (0, regionalAuthority_js_1.calculateRegionalAuthority)(),
            claims: options?.claims
          });
          (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
          state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
          return {
            token: response.accessToken,
            expiresOnTimestamp: response.expiresOn.getTime(),
            refreshAfterTimestamp: response.refreshOn?.getTime(),
            tokenType: response.tokenType
          };
        } catch (err) {
          throw (0, utils_js_1.handleMsalError)(scopes, err, options);
        }
      }
      async function getTokenByClientAssertion(scopes, clientAssertion, options = {}) {
        state.logger.getToken.info(`Attempting to acquire token using client assertion`);
        state.msalConfig.auth.clientAssertion = clientAssertion;
        const msalApp = await getConfidentialApp(options);
        try {
          const response = await msalApp.acquireTokenByClientCredential({
            scopes,
            authority: calculateRequestAuthority(options),
            azureRegion: (0, regionalAuthority_js_1.calculateRegionalAuthority)(),
            claims: options?.claims,
            clientAssertion
          });
          (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
          state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
          return {
            token: response.accessToken,
            expiresOnTimestamp: response.expiresOn.getTime(),
            refreshAfterTimestamp: response.refreshOn?.getTime(),
            tokenType: response.tokenType
          };
        } catch (err) {
          throw (0, utils_js_1.handleMsalError)(scopes, err, options);
        }
      }
      async function getTokenByClientCertificate(scopes, certificate, options = {}) {
        state.logger.getToken.info(`Attempting to acquire token using client certificate`);
        state.msalConfig.auth.clientCertificate = certificate;
        const msalApp = await getConfidentialApp(options);
        try {
          const response = await msalApp.acquireTokenByClientCredential({
            scopes,
            authority: calculateRequestAuthority(options),
            azureRegion: (0, regionalAuthority_js_1.calculateRegionalAuthority)(),
            claims: options?.claims
          });
          (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
          state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
          return {
            token: response.accessToken,
            expiresOnTimestamp: response.expiresOn.getTime(),
            refreshAfterTimestamp: response.refreshOn?.getTime(),
            tokenType: response.tokenType
          };
        } catch (err) {
          throw (0, utils_js_1.handleMsalError)(scopes, err, options);
        }
      }
      async function getTokenByDeviceCode(scopes, deviceCodeCallback, options = {}) {
        state.logger.getToken.info(`Attempting to acquire token using device code`);
        const msalApp = await getPublicApp(options);
        return withSilentAuthentication(msalApp, scopes, options, () => {
          const requestOptions = {
            scopes,
            cancel: options?.abortSignal?.aborted ?? false,
            deviceCodeCallback,
            authority: calculateRequestAuthority(options),
            claims: options?.claims
          };
          const deviceCodeRequest = msalApp.acquireTokenByDeviceCode(requestOptions);
          if (options.abortSignal) {
            options.abortSignal.addEventListener("abort", () => {
              requestOptions.cancel = true;
            });
          }
          return deviceCodeRequest;
        });
      }
      async function getTokenByUsernamePassword(scopes, username, password, options = {}) {
        state.logger.getToken.info(`Attempting to acquire token using username and password`);
        const msalApp = await getPublicApp(options);
        return withSilentAuthentication(msalApp, scopes, options, () => {
          const requestOptions = {
            scopes,
            username,
            password,
            authority: calculateRequestAuthority(options),
            claims: options?.claims
          };
          return msalApp.acquireTokenByUsernamePassword(requestOptions);
        });
      }
      function getActiveAccount() {
        if (!state.cachedAccount) {
          return void 0;
        }
        return (0, utils_js_1.msalToPublic)(clientId, state.cachedAccount);
      }
      async function getTokenByAuthorizationCode(scopes, redirectUri, authorizationCode, clientSecret, options = {}) {
        state.logger.getToken.info(`Attempting to acquire token using authorization code`);
        let msalApp;
        if (clientSecret) {
          state.msalConfig.auth.clientSecret = clientSecret;
          msalApp = await getConfidentialApp(options);
        } else {
          msalApp = await getPublicApp(options);
        }
        return withSilentAuthentication(msalApp, scopes, options, () => {
          return msalApp.acquireTokenByCode({
            scopes,
            redirectUri,
            code: authorizationCode,
            authority: calculateRequestAuthority(options),
            claims: options?.claims
          });
        });
      }
      async function getTokenOnBehalfOf(scopes, userAssertionToken, clientCredentials, options = {}) {
        msalLogger.getToken.info(`Attempting to acquire token on behalf of another user`);
        if (typeof clientCredentials === "string") {
          msalLogger.getToken.info(`Using client secret for on behalf of flow`);
          state.msalConfig.auth.clientSecret = clientCredentials;
        } else if (typeof clientCredentials === "function") {
          msalLogger.getToken.info(`Using client assertion callback for on behalf of flow`);
          state.msalConfig.auth.clientAssertion = clientCredentials;
        } else {
          msalLogger.getToken.info(`Using client certificate for on behalf of flow`);
          state.msalConfig.auth.clientCertificate = clientCredentials;
        }
        const msalApp = await getConfidentialApp(options);
        try {
          const response = await msalApp.acquireTokenOnBehalfOf({
            scopes,
            authority: calculateRequestAuthority(options),
            claims: options.claims,
            oboAssertion: userAssertionToken
          });
          (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
          msalLogger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
          return {
            token: response.accessToken,
            expiresOnTimestamp: response.expiresOn.getTime(),
            refreshAfterTimestamp: response.refreshOn?.getTime(),
            tokenType: response.tokenType
          };
        } catch (err) {
          throw (0, utils_js_1.handleMsalError)(scopes, err, options);
        }
      }
      function createBaseInteractiveRequest(scopes, options) {
        return {
          openBrowser: async (url) => {
            const open2 = await Promise.resolve().then(() => (init_open(), open_exports));
            await open2.default(url, { newInstance: true });
          },
          scopes,
          authority: calculateRequestAuthority(options),
          claims: options?.claims,
          loginHint: options?.loginHint,
          errorTemplate: options?.browserCustomizationOptions?.errorMessage,
          successTemplate: options?.browserCustomizationOptions?.successMessage,
          prompt: options?.loginHint ? "login" : "select_account"
        };
      }
      async function getBrokeredTokenInternal(scopes, useDefaultBrokerAccount, options = {}) {
        msalLogger.verbose("Authentication will resume through the broker");
        const app = await getPublicApp(options);
        const interactiveRequest = createBaseInteractiveRequest(scopes, options);
        if (state.pluginConfiguration.broker.parentWindowHandle) {
          interactiveRequest.windowHandle = Buffer.from(state.pluginConfiguration.broker.parentWindowHandle);
        } else {
          msalLogger.warning("Parent window handle is not specified for the broker. This may cause unexpected behavior. Please provide the parentWindowHandle.");
        }
        if (state.pluginConfiguration.broker.enableMsaPassthrough) {
          (interactiveRequest.tokenQueryParameters ??= {})["msal_request_type"] = "consumer_passthrough";
        }
        if (useDefaultBrokerAccount) {
          interactiveRequest.prompt = "none";
          msalLogger.verbose("Attempting broker authentication using the default broker account");
        } else {
          msalLogger.verbose("Attempting broker authentication without the default broker account");
        }
        if (options.proofOfPossessionOptions) {
          interactiveRequest.shrNonce = options.proofOfPossessionOptions.nonce;
          interactiveRequest.authenticationScheme = "pop";
          interactiveRequest.resourceRequestMethod = options.proofOfPossessionOptions.resourceRequestMethod;
          interactiveRequest.resourceRequestUri = options.proofOfPossessionOptions.resourceRequestUrl;
        }
        try {
          return await app.acquireTokenInteractive(interactiveRequest);
        } catch (e) {
          msalLogger.verbose(`Failed to authenticate through the broker: ${e.message}`);
          if (options.disableAutomaticAuthentication) {
            throw new errors_js_1.AuthenticationRequiredError({
              scopes,
              getTokenOptions: options,
              message: "Cannot silently authenticate with default broker account."
            });
          }
          if (useDefaultBrokerAccount) {
            return getBrokeredTokenInternal(scopes, false, options);
          } else {
            throw e;
          }
        }
      }
      async function getBrokeredToken(scopes, useDefaultBrokerAccount, options = {}) {
        msalLogger.getToken.info(`Attempting to acquire token using brokered authentication with useDefaultBrokerAccount: ${useDefaultBrokerAccount}`);
        const response = await getBrokeredTokenInternal(scopes, useDefaultBrokerAccount, options);
        (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
        state.cachedAccount = response?.account ?? null;
        state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
        return {
          token: response.accessToken,
          expiresOnTimestamp: response.expiresOn.getTime(),
          refreshAfterTimestamp: response.refreshOn?.getTime(),
          tokenType: response.tokenType
        };
      }
      async function getTokenByInteractiveRequest(scopes, options = {}) {
        msalLogger.getToken.info(`Attempting to acquire token interactively`);
        const app = await getPublicApp(options);
        return withSilentAuthentication(app, scopes, options, async () => {
          const interactiveRequest = createBaseInteractiveRequest(scopes, options);
          if (state.pluginConfiguration.broker.isEnabled) {
            return getBrokeredTokenInternal(scopes, state.pluginConfiguration.broker.useDefaultBrokerAccount ?? false, options);
          }
          if (options.proofOfPossessionOptions) {
            interactiveRequest.shrNonce = options.proofOfPossessionOptions.nonce;
            interactiveRequest.authenticationScheme = "pop";
            interactiveRequest.resourceRequestMethod = options.proofOfPossessionOptions.resourceRequestMethod;
            interactiveRequest.resourceRequestUri = options.proofOfPossessionOptions.resourceRequestUrl;
          }
          return app.acquireTokenInteractive(interactiveRequest);
        });
      }
      return {
        getActiveAccount,
        getBrokeredToken,
        getTokenByClientSecret,
        getTokenByClientAssertion,
        getTokenByClientCertificate,
        getTokenByDeviceCode,
        getTokenByUsernamePassword,
        getTokenByAuthorizationCode,
        getTokenOnBehalfOf,
        getTokenByInteractiveRequest
      };
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/clientCertificateCredential.js
var require_clientCertificateCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/clientCertificateCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientCertificateCredential = void 0;
    exports2.parseCertificate = parseCertificate;
    var msalClient_js_1 = require_msalClient();
    var node_crypto_1 = require("node:crypto");
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var logging_js_1 = require_logging();
    var promises_1 = require("node:fs/promises");
    var tracing_js_1 = require_tracing();
    var credentialName = "ClientCertificateCredential";
    var logger = (0, logging_js_1.credentialLogger)(credentialName);
    var ClientCertificateCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      certificateConfiguration;
      sendCertificateChain;
      msalClient;
      constructor(tenantId, clientId, certificatePathOrConfiguration, options = {}) {
        if (!tenantId || !clientId) {
          throw new Error(`${credentialName}: tenantId and clientId are required parameters.`);
        }
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        this.sendCertificateChain = options.sendCertificateChain;
        this.certificateConfiguration = {
          ...typeof certificatePathOrConfiguration === "string" ? {
            certificatePath: certificatePathOrConfiguration
          } : certificatePathOrConfiguration
        };
        const certificate = this.certificateConfiguration.certificate;
        const certificatePath = this.certificateConfiguration.certificatePath;
        if (!this.certificateConfiguration || !(certificate || certificatePath)) {
          throw new Error(`${credentialName}: Provide either a PEM certificate in string form, or the path to that certificate in the filesystem. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        if (certificate && certificatePath) {
          throw new Error(`${credentialName}: To avoid unexpected behaviors, providing both the contents of a PEM certificate and the path to a PEM certificate is forbidden. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
          ...options,
          logger,
          tokenCredentialOptions: options
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${credentialName}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          const certificate = await this.buildClientCertificate();
          return this.msalClient.getTokenByClientCertificate(arrayScopes, certificate, newOptions);
        });
      }
      async buildClientCertificate() {
        const parts = await parseCertificate(this.certificateConfiguration, this.sendCertificateChain ?? false);
        let privateKey;
        if (this.certificateConfiguration.certificatePassword !== void 0) {
          privateKey = (0, node_crypto_1.createPrivateKey)({
            key: parts.certificateContents,
            passphrase: this.certificateConfiguration.certificatePassword,
            format: "pem"
          }).export({
            format: "pem",
            type: "pkcs8"
          }).toString();
        } else {
          privateKey = parts.certificateContents;
        }
        return {
          thumbprint: parts.thumbprint,
          thumbprintSha256: parts.thumbprintSha256,
          privateKey,
          x5c: parts.x5c
        };
      }
    };
    exports2.ClientCertificateCredential = ClientCertificateCredential;
    async function parseCertificate(certificateConfiguration, sendCertificateChain) {
      const certificate = certificateConfiguration.certificate;
      const certificatePath = certificateConfiguration.certificatePath;
      const certificateContents = certificate || await (0, promises_1.readFile)(certificatePath, "utf8");
      const x5c = sendCertificateChain ? certificateContents : void 0;
      const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/g;
      const publicKeys = [];
      let match;
      do {
        match = certificatePattern.exec(certificateContents);
        if (match) {
          publicKeys.push(match[3]);
        }
      } while (match);
      if (publicKeys.length === 0) {
        throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
      }
      const thumbprint = (0, node_crypto_1.createHash)("sha1").update(Buffer.from(publicKeys[0], "base64")).digest("hex").toUpperCase();
      const thumbprintSha256 = (0, node_crypto_1.createHash)("sha256").update(Buffer.from(publicKeys[0], "base64")).digest("hex").toUpperCase();
      return {
        certificateContents,
        thumbprintSha256,
        thumbprint,
        x5c
      };
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/util/scopeUtils.js
var require_scopeUtils = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/util/scopeUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureScopes = ensureScopes;
    exports2.ensureValidScopeForDevTimeCreds = ensureValidScopeForDevTimeCreds;
    exports2.getScopeResource = getScopeResource;
    var logging_js_1 = require_logging();
    function ensureScopes(scopes) {
      return Array.isArray(scopes) ? scopes : [scopes];
    }
    function ensureValidScopeForDevTimeCreds(scope, logger) {
      if (!scope.match(/^[0-9a-zA-Z-_.:/]+$/)) {
        const error = new Error("Invalid scope was specified by the user or calling client");
        logger.getToken.info((0, logging_js_1.formatError)(scope, error));
        throw error;
      }
    }
    function getScopeResource(scope) {
      return scope.replace(/\/.default$/, "");
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/clientSecretCredential.js
var require_clientSecretCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/clientSecretCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientSecretCredential = void 0;
    var msalClient_js_1 = require_msalClient();
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var errors_js_1 = require_errors();
    var logging_js_1 = require_logging();
    var scopeUtils_js_1 = require_scopeUtils();
    var tracing_js_1 = require_tracing();
    var logger = (0, logging_js_1.credentialLogger)("ClientSecretCredential");
    var ClientSecretCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      msalClient;
      clientSecret;
      /**
       * Creates an instance of the ClientSecretCredential with the details
       * needed to authenticate against Microsoft Entra ID with a client
       * secret.
       *
       * @param tenantId - The Microsoft Entra tenant (directory) ID.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param clientSecret - A client secret that was generated for the App Registration.
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, clientSecret, options = {}) {
        if (!tenantId) {
          throw new errors_js_1.CredentialUnavailableError("ClientSecretCredential: tenantId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
        }
        if (!clientId) {
          throw new errors_js_1.CredentialUnavailableError("ClientSecretCredential: clientId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
        }
        if (!clientSecret) {
          throw new errors_js_1.CredentialUnavailableError("ClientSecretCredential: clientSecret is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
        }
        this.clientSecret = clientSecret;
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
          ...options,
          logger,
          tokenCredentialOptions: options
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
          const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
          return this.msalClient.getTokenByClientSecret(arrayScopes, this.clientSecret, newOptions);
        });
      }
    };
    exports2.ClientSecretCredential = ClientSecretCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/usernamePasswordCredential.js
var require_usernamePasswordCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/usernamePasswordCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UsernamePasswordCredential = void 0;
    var msalClient_js_1 = require_msalClient();
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var errors_js_1 = require_errors();
    var logging_js_1 = require_logging();
    var scopeUtils_js_1 = require_scopeUtils();
    var tracing_js_1 = require_tracing();
    var logger = (0, logging_js_1.credentialLogger)("UsernamePasswordCredential");
    var UsernamePasswordCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      msalClient;
      username;
      password;
      /**
       * Creates an instance of the UsernamePasswordCredential with the details
       * needed to authenticate against Microsoft Entra ID with a username
       * and password.
       *
       * @param tenantId - The Microsoft Entra tenant (directory).
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param username - The user account's e-mail address (user name).
       * @param password - The user account's account password
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, username, password, options = {}) {
        if (!tenantId) {
          throw new errors_js_1.CredentialUnavailableError("UsernamePasswordCredential: tenantId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
        }
        if (!clientId) {
          throw new errors_js_1.CredentialUnavailableError("UsernamePasswordCredential: clientId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
        }
        if (!username) {
          throw new errors_js_1.CredentialUnavailableError("UsernamePasswordCredential: username is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
        }
        if (!password) {
          throw new errors_js_1.CredentialUnavailableError("UsernamePasswordCredential: password is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
        }
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        this.username = username;
        this.password = password;
        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, this.tenantId, {
          ...options,
          tokenCredentialOptions: options ?? {}
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
          const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
          return this.msalClient.getTokenByUsernamePassword(arrayScopes, this.username, this.password, newOptions);
        });
      }
    };
    exports2.UsernamePasswordCredential = UsernamePasswordCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/environmentCredential.js
var require_environmentCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/environmentCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EnvironmentCredential = exports2.AllSupportedEnvironmentVariables = void 0;
    exports2.getSendCertificateChain = getSendCertificateChain;
    var errors_js_1 = require_errors();
    var logging_js_1 = require_logging();
    var clientCertificateCredential_js_1 = require_clientCertificateCredential();
    var clientSecretCredential_js_1 = require_clientSecretCredential();
    var usernamePasswordCredential_js_1 = require_usernamePasswordCredential();
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var tracing_js_1 = require_tracing();
    exports2.AllSupportedEnvironmentVariables = [
      "AZURE_TENANT_ID",
      "AZURE_CLIENT_ID",
      "AZURE_CLIENT_SECRET",
      "AZURE_CLIENT_CERTIFICATE_PATH",
      "AZURE_CLIENT_CERTIFICATE_PASSWORD",
      "AZURE_USERNAME",
      "AZURE_PASSWORD",
      "AZURE_ADDITIONALLY_ALLOWED_TENANTS",
      "AZURE_CLIENT_SEND_CERTIFICATE_CHAIN"
    ];
    function getAdditionallyAllowedTenants() {
      const additionallyAllowedValues = process.env.AZURE_ADDITIONALLY_ALLOWED_TENANTS ?? "";
      return additionallyAllowedValues.split(";");
    }
    var credentialName = "EnvironmentCredential";
    var logger = (0, logging_js_1.credentialLogger)(credentialName);
    function getSendCertificateChain() {
      const sendCertificateChain = (process.env.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN ?? "").toLowerCase();
      const result = sendCertificateChain === "true" || sendCertificateChain === "1";
      logger.verbose(`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN: ${process.env.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN}; sendCertificateChain: ${result}`);
      return result;
    }
    var EnvironmentCredential = class {
      _credential = void 0;
      /**
       * Creates an instance of the EnvironmentCredential class and decides what credential to use depending on the available environment variables.
       *
       * Required environment variables:
       * - `AZURE_TENANT_ID`: The Microsoft Entra tenant (directory) ID.
       * - `AZURE_CLIENT_ID`: The client (application) ID of an App Registration in the tenant.
       *
       * If setting the AZURE_TENANT_ID, then you can also set the additionally allowed tenants
       * - `AZURE_ADDITIONALLY_ALLOWED_TENANTS`: For multi-tenant applications, specifies additional tenants for which the credential may acquire tokens with a single semicolon delimited string. Use * to allow all tenants.
       *
       * Environment variables used for client credential authentication:
       * - `AZURE_CLIENT_SECRET`: A client secret that was generated for the App Registration.
       * - `AZURE_CLIENT_CERTIFICATE_PATH`: The path to a PEM certificate to use during the authentication, instead of the client secret.
       * - `AZURE_CLIENT_CERTIFICATE_PASSWORD`: (optional) password for the certificate file.
       * - `AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`: (optional) indicates that the certificate chain should be set in x5c header to support subject name / issuer based authentication.
       *
       * Username and password authentication is deprecated, since it doesn't support multifactor authentication (MFA). See https://aka.ms/azsdk/identity/mfa for more details. Users can still provide environment variables for this authentication method:
       * - `AZURE_USERNAME`: Username to authenticate with.
       * - `AZURE_PASSWORD`: Password to authenticate with.
       *
       * If the environment variables required to perform the authentication are missing, a {@link CredentialUnavailableError} will be thrown.
       * If the authentication fails, or if there's an unknown error, an {@link AuthenticationError} will be thrown.
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(options) {
        const assigned = (0, logging_js_1.processEnvVars)(exports2.AllSupportedEnvironmentVariables).assigned.join(", ");
        logger.info(`Found the following environment variables: ${assigned}`);
        const tenantId = process.env.AZURE_TENANT_ID, clientId = process.env.AZURE_CLIENT_ID, clientSecret = process.env.AZURE_CLIENT_SECRET;
        const additionallyAllowedTenantIds = getAdditionallyAllowedTenants();
        const sendCertificateChain = getSendCertificateChain();
        const newOptions = { ...options, additionallyAllowedTenantIds, sendCertificateChain };
        if (tenantId) {
          (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
        }
        if (tenantId && clientId && clientSecret) {
          logger.info(`Invoking ClientSecretCredential with tenant ID: ${tenantId}, clientId: ${clientId} and clientSecret: [REDACTED]`);
          this._credential = new clientSecretCredential_js_1.ClientSecretCredential(tenantId, clientId, clientSecret, newOptions);
          return;
        }
        const certificatePath = process.env.AZURE_CLIENT_CERTIFICATE_PATH;
        const certificatePassword = process.env.AZURE_CLIENT_CERTIFICATE_PASSWORD;
        if (tenantId && clientId && certificatePath) {
          logger.info(`Invoking ClientCertificateCredential with tenant ID: ${tenantId}, clientId: ${clientId} and certificatePath: ${certificatePath}`);
          this._credential = new clientCertificateCredential_js_1.ClientCertificateCredential(tenantId, clientId, { certificatePath, certificatePassword }, newOptions);
          return;
        }
        const username = process.env.AZURE_USERNAME;
        const password = process.env.AZURE_PASSWORD;
        if (tenantId && clientId && username && password) {
          logger.info(`Invoking UsernamePasswordCredential with tenant ID: ${tenantId}, clientId: ${clientId} and username: ${username}`);
          logger.warning("Environment is configured to use username and password authentication. This authentication method is deprecated, as it doesn't support multifactor authentication (MFA). Use a more secure credential. For more details, see https://aka.ms/azsdk/identity/mfa.");
          this._credential = new usernamePasswordCredential_js_1.UsernamePasswordCredential(tenantId, clientId, username, password, newOptions);
        }
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - Optional parameters. See {@link GetTokenOptions}.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${credentialName}.getToken`, options, async (newOptions) => {
          if (this._credential) {
            try {
              const result = await this._credential.getToken(scopes, newOptions);
              logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
              return result;
            } catch (err) {
              const authenticationError = new errors_js_1.AuthenticationError(400, {
                error: `${credentialName} authentication failed. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`,
                error_description: err.message.toString().split("More details:").join("")
              });
              logger.getToken.info((0, logging_js_1.formatError)(scopes, authenticationError));
              throw authenticationError;
            }
          }
          throw new errors_js_1.CredentialUnavailableError(`${credentialName} is unavailable. No underlying credential could be used. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`);
        });
      }
    };
    exports2.EnvironmentCredential = EnvironmentCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/imdsRetryPolicy.js
var require_imdsRetryPolicy = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/imdsRetryPolicy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.imdsRetryPolicy = imdsRetryPolicy;
    var core_rest_pipeline_1 = require_commonjs6();
    var core_util_1 = require_commonjs4();
    var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
    var MIN_DELAY_FOR_410_MS = 3e3;
    function imdsRetryPolicy(msiRetryConfig) {
      return (0, core_rest_pipeline_1.retryPolicy)([
        {
          name: "imdsRetryPolicy",
          retry: ({ retryCount, response }) => {
            if (response?.status !== 404 && response?.status !== 410) {
              return { skipStrategy: true };
            }
            const initialDelayMs = response?.status === 410 ? Math.max(MIN_DELAY_FOR_410_MS, msiRetryConfig.startDelayInMs) : msiRetryConfig.startDelayInMs;
            return (0, core_util_1.calculateRetryDelay)(retryCount, {
              retryDelayInMs: initialDelayMs,
              maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL
            });
          }
        }
      ], {
        maxRetries: msiRetryConfig.maxRetries
      });
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/imdsMsi.js
var require_imdsMsi = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/imdsMsi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.imdsMsi = void 0;
    var core_rest_pipeline_1 = require_commonjs6();
    var core_util_1 = require_commonjs4();
    var logging_js_1 = require_logging();
    var utils_js_1 = require_utils5();
    var tracing_js_1 = require_tracing();
    var msiName = "ManagedIdentityCredential - IMDS";
    var logger = (0, logging_js_1.credentialLogger)(msiName);
    var imdsHost = "http://169.254.169.254";
    var imdsEndpointPath = "/metadata/identity/oauth2/token";
    function prepareInvalidRequestOptions(scopes) {
      const resource = (0, utils_js_1.mapScopesToResource)(scopes);
      if (!resource) {
        throw new Error(`${msiName}: Multiple scopes are not supported.`);
      }
      const url = new URL(imdsEndpointPath, process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST ?? imdsHost);
      const rawHeaders = {
        Accept: "application/json"
        // intentionally leave out the Metadata header to invoke an error from IMDS endpoint.
      };
      return {
        // intentionally not including any query
        url: `${url}`,
        method: "GET",
        headers: (0, core_rest_pipeline_1.createHttpHeaders)(rawHeaders)
      };
    }
    exports2.imdsMsi = {
      name: "imdsMsi",
      async isAvailable(options) {
        const { scopes, identityClient, getTokenOptions } = options;
        const resource = (0, utils_js_1.mapScopesToResource)(scopes);
        if (!resource) {
          logger.info(`${msiName}: Unavailable. Multiple scopes are not supported.`);
          return false;
        }
        if (process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) {
          return true;
        }
        if (!identityClient) {
          throw new Error("Missing IdentityClient");
        }
        const requestOptions = prepareInvalidRequestOptions(resource);
        return tracing_js_1.tracingClient.withSpan("ManagedIdentityCredential-pingImdsEndpoint", getTokenOptions ?? {}, async (updatedOptions) => {
          requestOptions.tracingOptions = updatedOptions.tracingOptions;
          const request = (0, core_rest_pipeline_1.createPipelineRequest)(requestOptions);
          request.timeout = updatedOptions.requestOptions?.timeout || 1e3;
          request.allowInsecureConnection = true;
          let response;
          try {
            logger.info(`${msiName}: Pinging the Azure IMDS endpoint`);
            response = await identityClient.sendRequest(request);
          } catch (err) {
            if ((0, core_util_1.isError)(err)) {
              logger.verbose(`${msiName}: Caught error ${err.name}: ${err.message}`);
            }
            logger.info(`${msiName}: The Azure IMDS endpoint is unavailable`);
            return false;
          }
          if (response.status === 403) {
            if (response.bodyAsText?.includes("unreachable")) {
              logger.info(`${msiName}: The Azure IMDS endpoint is unavailable`);
              logger.info(`${msiName}: ${response.bodyAsText}`);
              return false;
            }
          }
          logger.info(`${msiName}: The Azure IMDS endpoint is available`);
          return true;
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/clientAssertionCredential.js
var require_clientAssertionCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/clientAssertionCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientAssertionCredential = void 0;
    var msalClient_js_1 = require_msalClient();
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var errors_js_1 = require_errors();
    var logging_js_1 = require_logging();
    var tracing_js_1 = require_tracing();
    var logger = (0, logging_js_1.credentialLogger)("ClientAssertionCredential");
    var ClientAssertionCredential = class {
      msalClient;
      tenantId;
      additionallyAllowedTenantIds;
      getAssertion;
      options;
      /**
       * Creates an instance of the ClientAssertionCredential with the details
       * needed to authenticate against Microsoft Entra ID with a client
       * assertion provided by the developer through the `getAssertion` function parameter.
       *
       * @param tenantId - The Microsoft Entra tenant (directory) ID.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param getAssertion - A function that retrieves the assertion for the credential to use.
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, getAssertion, options = {}) {
        if (!tenantId) {
          throw new errors_js_1.CredentialUnavailableError("ClientAssertionCredential: tenantId is a required parameter.");
        }
        if (!clientId) {
          throw new errors_js_1.CredentialUnavailableError("ClientAssertionCredential: clientId is a required parameter.");
        }
        if (!getAssertion) {
          throw new errors_js_1.CredentialUnavailableError("ClientAssertionCredential: clientAssertion is a required parameter.");
        }
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        this.options = options;
        this.getAssertion = getAssertion;
        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
          ...options,
          logger,
          tokenCredentialOptions: this.options
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          return this.msalClient.getTokenByClientAssertion(arrayScopes, this.getAssertion, newOptions);
        });
      }
    };
    exports2.ClientAssertionCredential = ClientAssertionCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/workloadIdentityCredential.js
var require_workloadIdentityCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/workloadIdentityCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkloadIdentityCredential = exports2.SupportedWorkloadEnvironmentVariables = void 0;
    var logging_js_1 = require_logging();
    var clientAssertionCredential_js_1 = require_clientAssertionCredential();
    var errors_js_1 = require_errors();
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var promises_1 = require("node:fs/promises");
    var credentialName = "WorkloadIdentityCredential";
    exports2.SupportedWorkloadEnvironmentVariables = [
      "AZURE_TENANT_ID",
      "AZURE_CLIENT_ID",
      "AZURE_FEDERATED_TOKEN_FILE"
    ];
    var logger = (0, logging_js_1.credentialLogger)(credentialName);
    var WorkloadIdentityCredential = class {
      client;
      azureFederatedTokenFileContent = void 0;
      cacheDate = void 0;
      federatedTokenFilePath;
      /**
       * WorkloadIdentityCredential supports Microsoft Entra Workload ID on Kubernetes.
       *
       * @param options - The identity client options to use for authentication.
       */
      constructor(options) {
        const assignedEnv = (0, logging_js_1.processEnvVars)(exports2.SupportedWorkloadEnvironmentVariables).assigned.join(", ");
        logger.info(`Found the following environment variables: ${assignedEnv}`);
        const workloadIdentityCredentialOptions = options ?? {};
        const tenantId = workloadIdentityCredentialOptions.tenantId || process.env.AZURE_TENANT_ID;
        const clientId = workloadIdentityCredentialOptions.clientId || process.env.AZURE_CLIENT_ID;
        this.federatedTokenFilePath = workloadIdentityCredentialOptions.tokenFilePath || process.env.AZURE_FEDERATED_TOKEN_FILE;
        if (tenantId) {
          (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
        }
        if (!clientId) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. clientId is a required parameter. In DefaultAzureCredential and ManagedIdentityCredential, this can be provided as an environment variable - "AZURE_CLIENT_ID".
        See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/workloadidentitycredential/troubleshoot`);
        }
        if (!tenantId) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. tenantId is a required parameter. In DefaultAzureCredential and ManagedIdentityCredential, this can be provided as an environment variable - "AZURE_TENANT_ID".
        See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/workloadidentitycredential/troubleshoot`);
        }
        if (!this.federatedTokenFilePath) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. federatedTokenFilePath is a required parameter. In DefaultAzureCredential and ManagedIdentityCredential, this can be provided as an environment variable - "AZURE_FEDERATED_TOKEN_FILE".
        See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/workloadidentitycredential/troubleshoot`);
        }
        logger.info(`Invoking ClientAssertionCredential with tenant ID: ${tenantId}, clientId: ${workloadIdentityCredentialOptions.clientId} and federated token path: [REDACTED]`);
        this.client = new clientAssertionCredential_js_1.ClientAssertionCredential(tenantId, clientId, this.readFileContents.bind(this), options);
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options) {
        if (!this.client) {
          const errorMessage = `${credentialName}: is unavailable. tenantId, clientId, and federatedTokenFilePath are required parameters. 
      In DefaultAzureCredential and ManagedIdentityCredential, these can be provided as environment variables - 
      "AZURE_TENANT_ID",
      "AZURE_CLIENT_ID",
      "AZURE_FEDERATED_TOKEN_FILE". See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/workloadidentitycredential/troubleshoot`;
          logger.info(errorMessage);
          throw new errors_js_1.CredentialUnavailableError(errorMessage);
        }
        logger.info("Invoking getToken() of Client Assertion Credential");
        return this.client.getToken(scopes, options);
      }
      async readFileContents() {
        if (this.cacheDate !== void 0 && Date.now() - this.cacheDate >= 1e3 * 60 * 5) {
          this.azureFederatedTokenFileContent = void 0;
        }
        if (!this.federatedTokenFilePath) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. Invalid file path provided ${this.federatedTokenFilePath}.`);
        }
        if (!this.azureFederatedTokenFileContent) {
          const file = await (0, promises_1.readFile)(this.federatedTokenFilePath, "utf8");
          const value = file.trim();
          if (!value) {
            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. No content on the file ${this.federatedTokenFilePath}.`);
          } else {
            this.azureFederatedTokenFileContent = value;
            this.cacheDate = Date.now();
          }
        }
        return this.azureFederatedTokenFileContent;
      }
    };
    exports2.WorkloadIdentityCredential = WorkloadIdentityCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/tokenExchangeMsi.js
var require_tokenExchangeMsi = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/tokenExchangeMsi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenExchangeMsi = void 0;
    var workloadIdentityCredential_js_1 = require_workloadIdentityCredential();
    var logging_js_1 = require_logging();
    var msiName = "ManagedIdentityCredential - Token Exchange";
    var logger = (0, logging_js_1.credentialLogger)(msiName);
    exports2.tokenExchangeMsi = {
      name: "tokenExchangeMsi",
      async isAvailable(clientId) {
        const env = process.env;
        const result = Boolean((clientId || env.AZURE_CLIENT_ID) && env.AZURE_TENANT_ID && process.env.AZURE_FEDERATED_TOKEN_FILE);
        if (!result) {
          logger.info(`${msiName}: Unavailable. The environment variables needed are: AZURE_CLIENT_ID (or the client ID sent through the parameters), AZURE_TENANT_ID and AZURE_FEDERATED_TOKEN_FILE`);
        }
        return result;
      },
      async getToken(configuration, getTokenOptions = {}) {
        const { scopes, clientId } = configuration;
        const identityClientTokenCredentialOptions = {};
        const workloadIdentityCredential = new workloadIdentityCredential_js_1.WorkloadIdentityCredential({
          clientId,
          tenantId: process.env.AZURE_TENANT_ID,
          tokenFilePath: process.env.AZURE_FEDERATED_TOKEN_FILE,
          ...identityClientTokenCredentialOptions,
          disableInstanceDiscovery: true
        });
        return workloadIdentityCredential.getToken(scopes, getTokenOptions);
      }
    };
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/index.js
var require_managedIdentityCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/managedIdentityCredential/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ManagedIdentityCredential = void 0;
    var logger_1 = require_commonjs();
    var msal_node_1 = require_msal_node();
    var identityClient_js_1 = require_identityClient();
    var errors_js_1 = require_errors();
    var utils_js_1 = require_utils3();
    var imdsRetryPolicy_js_1 = require_imdsRetryPolicy();
    var logging_js_1 = require_logging();
    var tracing_js_1 = require_tracing();
    var imdsMsi_js_1 = require_imdsMsi();
    var tokenExchangeMsi_js_1 = require_tokenExchangeMsi();
    var utils_js_2 = require_utils5();
    var logger = (0, logging_js_1.credentialLogger)("ManagedIdentityCredential");
    var ManagedIdentityCredential = class {
      managedIdentityApp;
      identityClient;
      clientId;
      resourceId;
      objectId;
      msiRetryConfig = {
        maxRetries: 5,
        startDelayInMs: 800,
        intervalIncrement: 2
      };
      isAvailableIdentityClient;
      sendProbeRequest;
      /**
       * @internal
       * @hidden
       */
      constructor(clientIdOrOptions, options) {
        let _options;
        if (typeof clientIdOrOptions === "string") {
          this.clientId = clientIdOrOptions;
          _options = options ?? {};
        } else {
          this.clientId = clientIdOrOptions?.clientId;
          _options = clientIdOrOptions ?? {};
        }
        this.resourceId = _options?.resourceId;
        this.objectId = _options?.objectId;
        this.sendProbeRequest = _options?.sendProbeRequest ?? false;
        const providedIds = [
          { key: "clientId", value: this.clientId },
          { key: "resourceId", value: this.resourceId },
          { key: "objectId", value: this.objectId }
        ].filter((id) => id.value);
        if (providedIds.length > 1) {
          throw new Error(`ManagedIdentityCredential: only one of 'clientId', 'resourceId', or 'objectId' can be provided. Received values: ${JSON.stringify({ clientId: this.clientId, resourceId: this.resourceId, objectId: this.objectId })}`);
        }
        _options.allowInsecureConnection = true;
        if (_options.retryOptions?.maxRetries !== void 0) {
          this.msiRetryConfig.maxRetries = _options.retryOptions.maxRetries;
        }
        this.identityClient = new identityClient_js_1.IdentityClient({
          ..._options,
          additionalPolicies: [{ policy: (0, imdsRetryPolicy_js_1.imdsRetryPolicy)(this.msiRetryConfig), position: "perCall" }]
        });
        this.managedIdentityApp = new msal_node_1.ManagedIdentityApplication({
          managedIdentityIdParams: {
            userAssignedClientId: this.clientId,
            userAssignedResourceId: this.resourceId,
            userAssignedObjectId: this.objectId
          },
          system: {
            disableInternalRetries: true,
            networkClient: this.identityClient,
            loggerOptions: {
              logLevel: (0, utils_js_1.getMSALLogLevel)((0, logger_1.getLogLevel)()),
              piiLoggingEnabled: _options.loggingOptions?.enableUnsafeSupportLogging,
              loggerCallback: (0, utils_js_1.defaultLoggerCallback)(logger)
            }
          }
        });
        this.isAvailableIdentityClient = new identityClient_js_1.IdentityClient({
          ..._options,
          retryOptions: {
            maxRetries: 0
          }
        });
        const managedIdentitySource = this.managedIdentityApp.getManagedIdentitySource();
        if (managedIdentitySource === "CloudShell") {
          if (this.clientId || this.resourceId || this.objectId) {
            logger.warning(`CloudShell MSI detected with user-provided IDs - throwing. Received values: ${JSON.stringify({
              clientId: this.clientId,
              resourceId: this.resourceId,
              objectId: this.objectId
            })}.`);
            throw new errors_js_1.CredentialUnavailableError("ManagedIdentityCredential: Specifying a user-assigned managed identity is not supported for CloudShell at runtime. When using Managed Identity in CloudShell, omit the clientId, resourceId, and objectId parameters.");
          }
        }
        if (managedIdentitySource === "ServiceFabric") {
          if (this.clientId || this.resourceId || this.objectId) {
            logger.warning(`Service Fabric detected with user-provided IDs - throwing. Received values: ${JSON.stringify({
              clientId: this.clientId,
              resourceId: this.resourceId,
              objectId: this.objectId
            })}.`);
            throw new errors_js_1.CredentialUnavailableError(`ManagedIdentityCredential: ${utils_js_2.serviceFabricErrorMessage}`);
          }
        }
        logger.info(`Using ${managedIdentitySource} managed identity.`);
        if (providedIds.length === 1) {
          const { key, value } = providedIds[0];
          logger.info(`${managedIdentitySource} with ${key}: ${value}`);
        }
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       * If an unexpected error occurs, an {@link AuthenticationError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        logger.getToken.info("Using the MSAL provider for Managed Identity.");
        const resource = (0, utils_js_2.mapScopesToResource)(scopes);
        if (!resource) {
          throw new errors_js_1.CredentialUnavailableError(`ManagedIdentityCredential: Multiple scopes are not supported. Scopes: ${JSON.stringify(scopes)}`);
        }
        return tracing_js_1.tracingClient.withSpan("ManagedIdentityCredential.getToken", options, async () => {
          try {
            const isTokenExchangeMsi = await tokenExchangeMsi_js_1.tokenExchangeMsi.isAvailable(this.clientId);
            const identitySource = this.managedIdentityApp.getManagedIdentitySource();
            const isImdsMsi = identitySource === "DefaultToImds" || identitySource === "Imds";
            logger.getToken.info(`MSAL Identity source: ${identitySource}`);
            if (isTokenExchangeMsi) {
              logger.getToken.info("Using the token exchange managed identity.");
              const result = await tokenExchangeMsi_js_1.tokenExchangeMsi.getToken({
                scopes,
                clientId: this.clientId,
                identityClient: this.identityClient,
                retryConfig: this.msiRetryConfig,
                resourceId: this.resourceId
              });
              if (result === null) {
                throw new errors_js_1.CredentialUnavailableError("Attempted to use the token exchange managed identity, but received a null response.");
              }
              return result;
            } else if (isImdsMsi && this.sendProbeRequest) {
              logger.getToken.info("Using the IMDS endpoint to probe for availability.");
              const isAvailable = await imdsMsi_js_1.imdsMsi.isAvailable({
                scopes,
                clientId: this.clientId,
                getTokenOptions: options,
                identityClient: this.isAvailableIdentityClient,
                resourceId: this.resourceId
              });
              if (!isAvailable) {
                throw new errors_js_1.CredentialUnavailableError(`Attempted to use the IMDS endpoint, but it is not available.`);
              }
            }
            logger.getToken.info("Calling into MSAL for managed identity token.");
            const token = await this.managedIdentityApp.acquireToken({
              resource
            });
            this.ensureValidMsalToken(scopes, token, options);
            logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
            return {
              expiresOnTimestamp: token.expiresOn.getTime(),
              token: token.accessToken,
              refreshAfterTimestamp: token.refreshOn?.getTime(),
              tokenType: "Bearer"
            };
          } catch (err) {
            logger.getToken.error((0, logging_js_1.formatError)(scopes, err));
            if (err.name === "AuthenticationRequiredError") {
              throw err;
            }
            if (isNetworkError(err)) {
              throw new errors_js_1.CredentialUnavailableError(`ManagedIdentityCredential: Network unreachable. Message: ${err.message}`, { cause: err });
            }
            throw new errors_js_1.CredentialUnavailableError(`ManagedIdentityCredential: Authentication failed. Message ${err.message}`, { cause: err });
          }
        });
      }
      /**
       * Ensures the validity of the MSAL token
       */
      ensureValidMsalToken(scopes, msalToken, getTokenOptions) {
        const createError = (message) => {
          logger.getToken.info(message);
          return new errors_js_1.AuthenticationRequiredError({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            getTokenOptions,
            message
          });
        };
        if (!msalToken) {
          throw createError("No response.");
        }
        if (!msalToken.expiresOn) {
          throw createError(`Response had no "expiresOn" property.`);
        }
        if (!msalToken.accessToken) {
          throw createError(`Response had no "accessToken" property.`);
        }
      }
    };
    exports2.ManagedIdentityCredential = ManagedIdentityCredential;
    function isNetworkError(err) {
      if (err.errorCode === "network_error") {
        return true;
      }
      if (err.code === "ENETUNREACH" || err.code === "EHOSTUNREACH") {
        return true;
      }
      if (err.statusCode === 403 || err.code === 403) {
        if (err.message.includes("unreachable")) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/azureDeveloperCliCredential.js
var require_azureDeveloperCliCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/azureDeveloperCliCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureDeveloperCliCredential = exports2.developerCliCredentialInternals = exports2.azureDeveloperCliPublicErrorMessages = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var logging_js_1 = require_logging();
    var errors_js_1 = require_errors();
    var child_process_1 = tslib_1.__importDefault(require("child_process"));
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var tracing_js_1 = require_tracing();
    var scopeUtils_js_1 = require_scopeUtils();
    var logger = (0, logging_js_1.credentialLogger)("AzureDeveloperCliCredential");
    exports2.azureDeveloperCliPublicErrorMessages = {
      notInstalled: "Azure Developer CLI couldn't be found. To mitigate this issue, see the troubleshooting guidelines at https://aka.ms/azsdk/js/identity/azdevclicredential/troubleshoot.",
      login: "Please run 'azd auth login' from a command prompt to authenticate before using this credential. For more information, see the troubleshooting guidelines at https://aka.ms/azsdk/js/identity/azdevclicredential/troubleshoot.",
      unknown: "Unknown error while trying to retrieve the access token",
      claim: "This credential doesn't support claims challenges. To authenticate with the required claims, please run the following command:"
    };
    exports2.developerCliCredentialInternals = {
      /**
       * @internal
       */
      getSafeWorkingDir() {
        if (process.platform === "win32") {
          let systemRoot = process.env.SystemRoot || process.env["SYSTEMROOT"];
          if (!systemRoot) {
            logger.getToken.warning("The SystemRoot environment variable is not set. This may cause issues when using the Azure Developer CLI credential.");
            systemRoot = "C:\\Windows";
          }
          return systemRoot;
        } else {
          return "/bin";
        }
      },
      /**
       * Gets the access token from Azure Developer CLI
       * @param scopes - The scopes to use when getting the token
       * @internal
       */
      async getAzdAccessToken(scopes, tenantId, timeout, claims) {
        let tenantSection = [];
        if (tenantId) {
          tenantSection = ["--tenant-id", tenantId];
        }
        let claimsSections = [];
        if (claims) {
          const encodedClaims = btoa(claims);
          claimsSections = ["--claims", encodedClaims];
        }
        return new Promise((resolve, reject) => {
          try {
            const args = [
              "auth",
              "token",
              "--output",
              "json",
              "--no-prompt",
              ...scopes.reduce((previous, current) => previous.concat("--scope", current), []),
              ...tenantSection,
              ...claimsSections
            ];
            const command = ["azd", ...args].join(" ");
            child_process_1.default.exec(command, {
              cwd: exports2.developerCliCredentialInternals.getSafeWorkingDir(),
              timeout
            }, (error, stdout, stderr) => {
              resolve({ stdout, stderr, error });
            });
          } catch (err) {
            reject(err);
          }
        });
      }
    };
    var AzureDeveloperCliCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      timeout;
      /**
       * Creates an instance of the {@link AzureDeveloperCliCredential}.
       *
       * To use this credential, ensure that you have already logged
       * in via the 'azd' tool using the command "azd auth login" from the commandline.
       *
       * @param options - Options, to optionally allow multi-tenant requests.
       */
      constructor(options) {
        if (options?.tenantId) {
          (0, tenantIdUtils_js_1.checkTenantId)(logger, options?.tenantId);
          this.tenantId = options?.tenantId;
        }
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        this.timeout = options?.processTimeoutInMs;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, options, this.additionallyAllowedTenantIds);
        if (tenantId) {
          (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
        }
        let scopeList;
        if (typeof scopes === "string") {
          scopeList = [scopes];
        } else {
          scopeList = scopes;
        }
        logger.getToken.info(`Using the scopes ${scopes}`);
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
          try {
            scopeList.forEach((scope) => {
              (0, scopeUtils_js_1.ensureValidScopeForDevTimeCreds)(scope, logger);
            });
            const obj = await exports2.developerCliCredentialInternals.getAzdAccessToken(scopeList, tenantId, this.timeout, options.claims);
            const isMFARequiredError = obj.stderr?.match("must use multi-factor authentication") || obj.stderr?.match("reauthentication required");
            const isNotLoggedInError = obj.stderr?.match("not logged in, run `azd login` to login") || obj.stderr?.match("not logged in, run `azd auth login` to login");
            const isNotInstallError = obj.stderr?.match("azd:(.*)not found") || obj.stderr?.startsWith("'azd' is not recognized");
            if (isNotInstallError || obj.error && obj.error.code === "ENOENT") {
              const error = new errors_js_1.CredentialUnavailableError(exports2.azureDeveloperCliPublicErrorMessages.notInstalled);
              logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
              throw error;
            }
            if (isNotLoggedInError) {
              const error = new errors_js_1.CredentialUnavailableError(exports2.azureDeveloperCliPublicErrorMessages.login);
              logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
              throw error;
            }
            if (isMFARequiredError) {
              const scope = scopeList.reduce((previous, current) => previous.concat("--scope", current), []).join(" ");
              const loginCmd = `azd auth login ${scope}`;
              const error = new errors_js_1.CredentialUnavailableError(`${exports2.azureDeveloperCliPublicErrorMessages.claim} ${loginCmd}`);
              logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
              throw error;
            }
            try {
              const resp = JSON.parse(obj.stdout);
              logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
              return {
                token: resp.token,
                expiresOnTimestamp: new Date(resp.expiresOn).getTime(),
                tokenType: "Bearer"
              };
            } catch (e) {
              if (obj.stderr) {
                throw new errors_js_1.CredentialUnavailableError(obj.stderr);
              }
              throw e;
            }
          } catch (err) {
            const error = err.name === "CredentialUnavailableError" ? err : new errors_js_1.CredentialUnavailableError(err.message || exports2.azureDeveloperCliPublicErrorMessages.unknown);
            logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
            throw error;
          }
        });
      }
    };
    exports2.AzureDeveloperCliCredential = AzureDeveloperCliCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/util/subscriptionUtils.js
var require_subscriptionUtils = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/util/subscriptionUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkSubscription = checkSubscription;
    var logging_js_1 = require_logging();
    function checkSubscription(logger, subscription) {
      if (!subscription.match(/^[0-9a-zA-Z-._ ]+$/)) {
        const error = new Error(`Subscription '${subscription}' contains invalid characters. If this is the name of a subscription, use its ID instead. You can locate your subscription by following the instructions listed here: https://learn.microsoft.com/azure/azure-portal/get-subscription-tenant-id`);
        logger.info((0, logging_js_1.formatError)("", error));
        throw error;
      }
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/azureCliCredential.js
var require_azureCliCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/azureCliCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureCliCredential = exports2.cliCredentialInternals = exports2.azureCliPublicErrorMessages = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var logging_js_1 = require_logging();
    var scopeUtils_js_1 = require_scopeUtils();
    var errors_js_1 = require_errors();
    var child_process_1 = tslib_1.__importDefault(require("child_process"));
    var tracing_js_1 = require_tracing();
    var subscriptionUtils_js_1 = require_subscriptionUtils();
    var logger = (0, logging_js_1.credentialLogger)("AzureCliCredential");
    exports2.azureCliPublicErrorMessages = {
      claim: "This credential doesn't support claims challenges. To authenticate with the required claims, please run the following command:",
      notInstalled: "Azure CLI could not be found. Please visit https://aka.ms/azure-cli for installation instructions and then, once installed, authenticate to your Azure account using 'az login'.",
      login: "Please run 'az login' from a command prompt to authenticate before using this credential.",
      unknown: "Unknown error while trying to retrieve the access token",
      unexpectedResponse: 'Unexpected response from Azure CLI when getting token. Expected "expiresOn" to be a RFC3339 date string. Got:'
    };
    exports2.cliCredentialInternals = {
      /**
       * @internal
       */
      getSafeWorkingDir() {
        if (process.platform === "win32") {
          let systemRoot = process.env.SystemRoot || process.env["SYSTEMROOT"];
          if (!systemRoot) {
            logger.getToken.warning("The SystemRoot environment variable is not set. This may cause issues when using the Azure CLI credential.");
            systemRoot = "C:\\Windows";
          }
          return systemRoot;
        } else {
          return "/bin";
        }
      },
      /**
       * Gets the access token from Azure CLI
       * @param resource - The resource to use when getting the token
       * @internal
       */
      async getAzureCliAccessToken(resource, tenantId, subscription, timeout) {
        let tenantSection = [];
        let subscriptionSection = [];
        if (tenantId) {
          tenantSection = ["--tenant", tenantId];
        }
        if (subscription) {
          subscriptionSection = ["--subscription", `"${subscription}"`];
        }
        return new Promise((resolve, reject) => {
          try {
            const args = [
              "account",
              "get-access-token",
              "--output",
              "json",
              "--resource",
              resource,
              ...tenantSection,
              ...subscriptionSection
            ];
            const command = ["az", ...args].join(" ");
            child_process_1.default.exec(command, { cwd: exports2.cliCredentialInternals.getSafeWorkingDir(), timeout }, (error, stdout, stderr) => {
              resolve({ stdout, stderr, error });
            });
          } catch (err) {
            reject(err);
          }
        });
      }
    };
    var AzureCliCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      timeout;
      subscription;
      /**
       * Creates an instance of the {@link AzureCliCredential}.
       *
       * To use this credential, ensure that you have already logged
       * in via the 'az' tool using the command "az login" from the commandline.
       *
       * @param options - Options, to optionally allow multi-tenant requests.
       */
      constructor(options) {
        if (options?.tenantId) {
          (0, tenantIdUtils_js_1.checkTenantId)(logger, options?.tenantId);
          this.tenantId = options?.tenantId;
        }
        if (options?.subscription) {
          (0, subscriptionUtils_js_1.checkSubscription)(logger, options?.subscription);
          this.subscription = options?.subscription;
        }
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        this.timeout = options?.processTimeoutInMs;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        const scope = typeof scopes === "string" ? scopes : scopes[0];
        const claimsValue = options.claims;
        if (claimsValue && claimsValue.trim()) {
          const encodedClaims = btoa(claimsValue);
          let loginCmd = `az login --claims-challenge ${encodedClaims} --scope ${scope}`;
          const tenantIdFromOptions = options.tenantId;
          if (tenantIdFromOptions) {
            loginCmd += ` --tenant ${tenantIdFromOptions}`;
          }
          const error = new errors_js_1.CredentialUnavailableError(`${exports2.azureCliPublicErrorMessages.claim} ${loginCmd}`);
          logger.getToken.info((0, logging_js_1.formatError)(scope, error));
          throw error;
        }
        const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, options, this.additionallyAllowedTenantIds);
        if (tenantId) {
          (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
        }
        if (this.subscription) {
          (0, subscriptionUtils_js_1.checkSubscription)(logger, this.subscription);
        }
        logger.getToken.info(`Using the scope ${scope}`);
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
          try {
            (0, scopeUtils_js_1.ensureValidScopeForDevTimeCreds)(scope, logger);
            const resource = (0, scopeUtils_js_1.getScopeResource)(scope);
            const obj = await exports2.cliCredentialInternals.getAzureCliAccessToken(resource, tenantId, this.subscription, this.timeout);
            const specificScope = obj.stderr?.match("(.*)az login --scope(.*)");
            const isLoginError = obj.stderr?.match("(.*)az login(.*)") && !specificScope;
            const isNotInstallError = obj.stderr?.match("az:(.*)not found") || obj.stderr?.startsWith("'az' is not recognized");
            if (isNotInstallError) {
              const error = new errors_js_1.CredentialUnavailableError(exports2.azureCliPublicErrorMessages.notInstalled);
              logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
              throw error;
            }
            if (isLoginError) {
              const error = new errors_js_1.CredentialUnavailableError(exports2.azureCliPublicErrorMessages.login);
              logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
              throw error;
            }
            try {
              const responseData = obj.stdout;
              const response = this.parseRawResponse(responseData);
              logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
              return response;
            } catch (e) {
              if (obj.stderr) {
                throw new errors_js_1.CredentialUnavailableError(obj.stderr);
              }
              throw e;
            }
          } catch (err) {
            const error = err.name === "CredentialUnavailableError" ? err : new errors_js_1.CredentialUnavailableError(err.message || exports2.azureCliPublicErrorMessages.unknown);
            logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
            throw error;
          }
        });
      }
      /**
       * Parses the raw JSON response from the Azure CLI into a usable AccessToken object
       *
       * @param rawResponse - The raw JSON response from the Azure CLI
       * @returns An access token with the expiry time parsed from the raw response
       *
       * The expiryTime of the credential's access token, in milliseconds, is calculated as follows:
       *
       * When available, expires_on (introduced in Azure CLI v2.54.0) will be preferred. Otherwise falls back to expiresOn.
       */
      parseRawResponse(rawResponse) {
        const response = JSON.parse(rawResponse);
        const token = response.accessToken;
        let expiresOnTimestamp = Number.parseInt(response.expires_on, 10) * 1e3;
        if (!isNaN(expiresOnTimestamp)) {
          logger.getToken.info("expires_on is available and is valid, using it");
          return {
            token,
            expiresOnTimestamp,
            tokenType: "Bearer"
          };
        }
        expiresOnTimestamp = new Date(response.expiresOn).getTime();
        if (isNaN(expiresOnTimestamp)) {
          throw new errors_js_1.CredentialUnavailableError(`${exports2.azureCliPublicErrorMessages.unexpectedResponse} "${response.expiresOn}"`);
        }
        return {
          token,
          expiresOnTimestamp,
          tokenType: "Bearer"
        };
      }
    };
    exports2.AzureCliCredential = AzureCliCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/util/processUtils.js
var require_processUtils = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/util/processUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processUtils = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var node_child_process_1 = tslib_1.__importDefault(require("node:child_process"));
    exports2.processUtils = {
      /**
       * Promisifying childProcess.execFile
       * @internal
       */
      execFile(file, params, options) {
        return new Promise((resolve, reject) => {
          node_child_process_1.default.execFile(file, params, options, (error, stdout, stderr) => {
            if (Buffer.isBuffer(stdout)) {
              stdout = stdout.toString("utf8");
            }
            if (Buffer.isBuffer(stderr)) {
              stderr = stderr.toString("utf8");
            }
            if (stderr || error) {
              reject(stderr ? new Error(stderr) : error);
            } else {
              resolve(stdout);
            }
          });
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/azurePowerShellCredential.js
var require_azurePowerShellCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/azurePowerShellCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzurePowerShellCredential = exports2.commandStack = exports2.powerShellPublicErrorMessages = exports2.powerShellErrors = void 0;
    exports2.formatCommand = formatCommand;
    exports2.parseJsonToken = parseJsonToken;
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var logging_js_1 = require_logging();
    var scopeUtils_js_1 = require_scopeUtils();
    var errors_js_1 = require_errors();
    var processUtils_js_1 = require_processUtils();
    var tracing_js_1 = require_tracing();
    var logger = (0, logging_js_1.credentialLogger)("AzurePowerShellCredential");
    var isWindows = process.platform === "win32";
    function formatCommand(commandName) {
      if (isWindows) {
        return `${commandName}.exe`;
      } else {
        return commandName;
      }
    }
    async function runCommands(commands2, timeout) {
      const results = [];
      for (const command of commands2) {
        const [file, ...parameters] = command;
        const result = await processUtils_js_1.processUtils.execFile(file, parameters, {
          encoding: "utf8",
          timeout
        });
        results.push(result);
      }
      return results;
    }
    exports2.powerShellErrors = {
      login: "Run Connect-AzAccount to login",
      installed: "The specified module 'Az.Accounts' with version '2.2.0' was not loaded because no valid module file was found in any module directory"
    };
    exports2.powerShellPublicErrorMessages = {
      login: "Please run 'Connect-AzAccount' from PowerShell to authenticate before using this credential.",
      installed: `The 'Az.Account' module >= 2.2.0 is not installed. Install the Azure Az PowerShell module with: "Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force".`,
      claim: "This credential doesn't support claims challenges. To authenticate with the required claims, please run the following command:",
      troubleshoot: `To troubleshoot, visit https://aka.ms/azsdk/js/identity/powershellcredential/troubleshoot.`
    };
    var isLoginError = (err) => err.message.match(`(.*)${exports2.powerShellErrors.login}(.*)`);
    var isNotInstalledError = (err) => err.message.match(exports2.powerShellErrors.installed);
    exports2.commandStack = [formatCommand("pwsh")];
    if (isWindows) {
      exports2.commandStack.push(formatCommand("powershell"));
    }
    var AzurePowerShellCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      timeout;
      /**
       * Creates an instance of the {@link AzurePowerShellCredential}.
       *
       * To use this credential:
       * - Install the Azure Az PowerShell module with:
       *   `Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force`.
       * - You have already logged in to Azure PowerShell using the command
       * `Connect-AzAccount` from the command line.
       *
       * @param options - Options, to optionally allow multi-tenant requests.
       */
      constructor(options) {
        if (options?.tenantId) {
          (0, tenantIdUtils_js_1.checkTenantId)(logger, options?.tenantId);
          this.tenantId = options?.tenantId;
        }
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        this.timeout = options?.processTimeoutInMs;
      }
      /**
       * Gets the access token from Azure PowerShell
       * @param resource - The resource to use when getting the token
       */
      async getAzurePowerShellAccessToken(resource, tenantId, timeout) {
        for (const powerShellCommand of [...exports2.commandStack]) {
          try {
            await runCommands([[powerShellCommand, "/?"]], timeout);
          } catch (e) {
            exports2.commandStack.shift();
            continue;
          }
          const results = await runCommands([
            [
              powerShellCommand,
              "-NoProfile",
              "-NonInteractive",
              "-Command",
              `
          $tenantId = "${tenantId ?? ""}"
          $m = Import-Module Az.Accounts -MinimumVersion 2.2.0 -PassThru
          $useSecureString = $m.Version -ge [version]'2.17.0' -and $m.Version -lt [version]'5.0.0'

          $params = @{
            ResourceUrl = "${resource}"
          }

          if ($tenantId.Length -gt 0) {
            $params["TenantId"] = $tenantId
          }

          if ($useSecureString) {
            $params["AsSecureString"] = $true
          }

          $token = Get-AzAccessToken @params

          $result = New-Object -TypeName PSObject
          $result | Add-Member -MemberType NoteProperty -Name ExpiresOn -Value $token.ExpiresOn

          if ($token.Token -is [System.Security.SecureString]) {
            if ($PSVersionTable.PSVersion.Major -lt 7) {
              $ssPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($token.Token)
              try {
                $result | Add-Member -MemberType NoteProperty -Name Token -Value ([System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($ssPtr))
              }
              finally {
                [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ssPtr)
              }
            }
            else {
              $result | Add-Member -MemberType NoteProperty -Name Token -Value ($token.Token | ConvertFrom-SecureString -AsPlainText)
            }
          }
          else {
            $result | Add-Member -MemberType NoteProperty -Name Token -Value $token.Token
          }

          Write-Output (ConvertTo-Json $result)
          `
            ]
          ]);
          const result = results[0];
          return parseJsonToken(result);
        }
        throw new Error(`Unable to execute PowerShell. Ensure that it is installed in your system`);
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If the authentication cannot be performed through PowerShell, a {@link CredentialUnavailableError} will be thrown.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
          const scope = typeof scopes === "string" ? scopes : scopes[0];
          const claimsValue = options.claims;
          if (claimsValue && claimsValue.trim()) {
            const encodedClaims = btoa(claimsValue);
            let loginCmd = `Connect-AzAccount -ClaimsChallenge ${encodedClaims}`;
            const tenantIdFromOptions = options.tenantId;
            if (tenantIdFromOptions) {
              loginCmd += ` -Tenant ${tenantIdFromOptions}`;
            }
            const error = new errors_js_1.CredentialUnavailableError(`${exports2.powerShellPublicErrorMessages.claim} ${loginCmd}`);
            logger.getToken.info((0, logging_js_1.formatError)(scope, error));
            throw error;
          }
          const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, options, this.additionallyAllowedTenantIds);
          if (tenantId) {
            (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
          }
          try {
            (0, scopeUtils_js_1.ensureValidScopeForDevTimeCreds)(scope, logger);
            logger.getToken.info(`Using the scope ${scope}`);
            const resource = (0, scopeUtils_js_1.getScopeResource)(scope);
            const response = await this.getAzurePowerShellAccessToken(resource, tenantId, this.timeout);
            logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
            return {
              token: response.Token,
              expiresOnTimestamp: new Date(response.ExpiresOn).getTime(),
              tokenType: "Bearer"
            };
          } catch (err) {
            if (isNotInstalledError(err)) {
              const error2 = new errors_js_1.CredentialUnavailableError(exports2.powerShellPublicErrorMessages.installed);
              logger.getToken.info((0, logging_js_1.formatError)(scope, error2));
              throw error2;
            } else if (isLoginError(err)) {
              const error2 = new errors_js_1.CredentialUnavailableError(exports2.powerShellPublicErrorMessages.login);
              logger.getToken.info((0, logging_js_1.formatError)(scope, error2));
              throw error2;
            }
            const error = new errors_js_1.CredentialUnavailableError(`${err}. ${exports2.powerShellPublicErrorMessages.troubleshoot}`);
            logger.getToken.info((0, logging_js_1.formatError)(scope, error));
            throw error;
          }
        });
      }
    };
    exports2.AzurePowerShellCredential = AzurePowerShellCredential;
    async function parseJsonToken(result) {
      const jsonRegex = /{[^{}]*}/g;
      const matches = result.match(jsonRegex);
      let resultWithoutToken = result;
      if (matches) {
        try {
          for (const item of matches) {
            try {
              const jsonContent = JSON.parse(item);
              if (jsonContent?.Token) {
                resultWithoutToken = resultWithoutToken.replace(item, "");
                if (resultWithoutToken) {
                  logger.getToken.warning(resultWithoutToken);
                }
                return jsonContent;
              }
            } catch (e) {
              continue;
            }
          }
        } catch (e) {
          throw new Error(`Unable to parse the output of PowerShell. Received output: ${result}`);
        }
      }
      throw new Error(`No access token found in the output. Received output: ${result}`);
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/visualStudioCodeCredential.js
var require_visualStudioCodeCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/visualStudioCodeCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VisualStudioCodeCredential = void 0;
    var logging_js_1 = require_logging();
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var errors_js_1 = require_errors();
    var tenantIdUtils_js_2 = require_tenantIdUtils();
    var msalClient_js_1 = require_msalClient();
    var scopeUtils_js_1 = require_scopeUtils();
    var msalPlugins_js_1 = require_msalPlugins();
    var utils_js_1 = require_utils3();
    var promises_1 = require("node:fs/promises");
    var CommonTenantId = "common";
    var VSCodeClientId = "aebc6443-996d-45c2-90f0-388ff96faa56";
    var logger = (0, logging_js_1.credentialLogger)("VisualStudioCodeCredential");
    var unsupportedTenantIds = {
      adfs: "The VisualStudioCodeCredential does not support authentication with ADFS tenants."
    };
    function checkUnsupportedTenant(tenantId) {
      const unsupportedTenantError = unsupportedTenantIds[tenantId];
      if (unsupportedTenantError) {
        throw new errors_js_1.CredentialUnavailableError(unsupportedTenantError);
      }
    }
    var VisualStudioCodeCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      msalClient;
      options;
      /**
       * Creates an instance of VisualStudioCodeCredential to use for automatically authenticating via VSCode.
       *
       * **Note**: `VisualStudioCodeCredential` is provided by a plugin package:
       * `@azure/identity-vscode`. If this package is not installed, then authentication using
       * `VisualStudioCodeCredential` will not be available.
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(options) {
        this.options = options || {};
        if (options && options.tenantId) {
          (0, tenantIdUtils_js_2.checkTenantId)(logger, options.tenantId);
          this.tenantId = options.tenantId;
        } else {
          this.tenantId = CommonTenantId;
        }
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        checkUnsupportedTenant(this.tenantId);
      }
      /**
       * Runs preparations for any further getToken request:
       *   - Validates that the plugin is available.
       *   - Loads the authentication record from VSCode if available.
       *   - Creates the MSAL client with the loaded plugin and authentication record.
       */
      async prepare(scopes) {
        const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, this.options, this.additionallyAllowedTenantIds, logger) || this.tenantId;
        if (!(0, msalPlugins_js_1.hasVSCodePlugin)() || !msalPlugins_js_1.vsCodeAuthRecordPath) {
          throw new errors_js_1.CredentialUnavailableError("Visual Studio Code Authentication is not available. Ensure you have have Azure Resources Extension installed in VS Code, signed into Azure via VS Code, installed the @azure/identity-vscode package, and properly configured the extension.");
        }
        const authenticationRecord = await this.loadAuthRecord(msalPlugins_js_1.vsCodeAuthRecordPath, scopes);
        this.msalClient = (0, msalClient_js_1.createMsalClient)(VSCodeClientId, tenantId, {
          ...this.options,
          isVSCodeCredential: true,
          brokerOptions: {
            enabled: true,
            parentWindowHandle: new Uint8Array(0),
            useDefaultBrokerAccount: true
          },
          authenticationRecord
        });
      }
      /**
       * The promise of the single preparation that will be executed at the first getToken request for an instance of this class.
       */
      preparePromise;
      /**
       * Runs preparations for any further getToken, but only once.
       */
      prepareOnce(scopes) {
        if (!this.preparePromise) {
          this.preparePromise = this.prepare(scopes);
        }
        return this.preparePromise;
      }
      /**
       * Returns the token found by searching VSCode's authentication cache or
       * returns null if no token could be found.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                `TokenCredential` implementation might make.
       */
      async getToken(scopes, options) {
        const scopeArray = (0, scopeUtils_js_1.ensureScopes)(scopes);
        await this.prepareOnce(scopeArray);
        if (!this.msalClient) {
          throw new errors_js_1.CredentialUnavailableError("Visual Studio Code Authentication failed to initialize. Ensure you have have Azure Resources Extension installed in VS Code, signed into Azure via VS Code, installed the @azure/identity-vscode package, and properly configured the extension.");
        }
        return this.msalClient.getTokenByInteractiveRequest(scopeArray, {
          ...options,
          disableAutomaticAuthentication: true
        });
      }
      /**
       * Loads the authentication record from the specified path.
       * @param authRecordPath - The path to the authentication record file.
       * @param scopes - The list of scopes for which the token will have access.
       * @returns The authentication record or undefined if loading fails.
       */
      async loadAuthRecord(authRecordPath, scopes) {
        try {
          const authRecordContent = await (0, promises_1.readFile)(authRecordPath, { encoding: "utf8" });
          return (0, utils_js_1.deserializeAuthenticationRecord)(authRecordContent);
        } catch (error) {
          logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
          throw new errors_js_1.CredentialUnavailableError("Cannot load authentication record in Visual Studio Code. Ensure you have have Azure Resources Extension installed in VS Code, signed into Azure via VS Code, installed the @azure/identity-vscode package, and properly configured the extension.");
        }
      }
    };
    exports2.VisualStudioCodeCredential = VisualStudioCodeCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/brokerCredential.js
var require_brokerCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/brokerCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BrokerCredential = void 0;
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var logging_js_1 = require_logging();
    var scopeUtils_js_1 = require_scopeUtils();
    var tracing_js_1 = require_tracing();
    var msalClient_js_1 = require_msalClient();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors();
    var logger = (0, logging_js_1.credentialLogger)("BrokerCredential");
    var BrokerCredential = class {
      brokerMsalClient;
      brokerTenantId;
      brokerAdditionallyAllowedTenantIds;
      /**
       * Creates an instance of BrokerCredential with the required broker options.
       *
       * This credential uses WAM (Web Account Manager) for authentication, which provides
       * better security and user experience on Windows platforms.
       *
       * @param options - Options for configuring the broker credential, including required broker options.
       */
      constructor(options) {
        this.brokerTenantId = (0, tenantIdUtils_js_1.resolveTenantId)(logger, options.tenantId);
        this.brokerAdditionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        const msalClientOptions = {
          ...options,
          tokenCredentialOptions: options,
          logger,
          brokerOptions: {
            enabled: true,
            parentWindowHandle: new Uint8Array(0),
            useDefaultBrokerAccount: true
          }
        };
        this.brokerMsalClient = (0, msalClient_js_1.createMsalClient)(constants_js_1.DeveloperSignOnClientId, this.brokerTenantId, msalClientOptions);
      }
      /**
       * Authenticates with Microsoft Entra ID using WAM broker and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * This method extends the base getToken method to support silentAuthenticationOnly option
       * when using broker authentication.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure the token request, including silentAuthenticationOnly option.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.brokerTenantId, newOptions, this.brokerAdditionallyAllowedTenantIds, logger);
          const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
          try {
            return this.brokerMsalClient.getBrokeredToken(arrayScopes, true, {
              ...newOptions,
              disableAutomaticAuthentication: true
            });
          } catch (e) {
            logger.getToken.info((0, logging_js_1.formatError)(arrayScopes, e));
            throw new errors_js_1.CredentialUnavailableError("Failed to acquire token using broker authentication", { cause: e });
          }
        });
      }
    };
    exports2.BrokerCredential = BrokerCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/defaultAzureCredentialFunctions.js
var require_defaultAzureCredentialFunctions = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/defaultAzureCredentialFunctions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDefaultBrokerCredential = createDefaultBrokerCredential;
    exports2.createDefaultVisualStudioCodeCredential = createDefaultVisualStudioCodeCredential;
    exports2.createDefaultManagedIdentityCredential = createDefaultManagedIdentityCredential;
    exports2.createDefaultWorkloadIdentityCredential = createDefaultWorkloadIdentityCredential;
    exports2.createDefaultAzureDeveloperCliCredential = createDefaultAzureDeveloperCliCredential;
    exports2.createDefaultAzureCliCredential = createDefaultAzureCliCredential;
    exports2.createDefaultAzurePowershellCredential = createDefaultAzurePowershellCredential;
    exports2.createDefaultEnvironmentCredential = createDefaultEnvironmentCredential;
    var environmentCredential_js_1 = require_environmentCredential();
    var index_js_1 = require_managedIdentityCredential();
    var workloadIdentityCredential_js_1 = require_workloadIdentityCredential();
    var azureDeveloperCliCredential_js_1 = require_azureDeveloperCliCredential();
    var azureCliCredential_js_1 = require_azureCliCredential();
    var azurePowerShellCredential_js_1 = require_azurePowerShellCredential();
    var visualStudioCodeCredential_js_1 = require_visualStudioCodeCredential();
    var brokerCredential_js_1 = require_brokerCredential();
    function createDefaultBrokerCredential(options = {}) {
      return new brokerCredential_js_1.BrokerCredential(options);
    }
    function createDefaultVisualStudioCodeCredential(options = {}) {
      return new visualStudioCodeCredential_js_1.VisualStudioCodeCredential(options);
    }
    function createDefaultManagedIdentityCredential(options = {}) {
      options.retryOptions ??= {
        maxRetries: 5,
        retryDelayInMs: 800
      };
      options.sendProbeRequest ??= true;
      const managedIdentityClientId = options?.managedIdentityClientId ?? process.env.AZURE_CLIENT_ID;
      const workloadIdentityClientId = options?.workloadIdentityClientId ?? managedIdentityClientId;
      const managedResourceId = options?.managedIdentityResourceId;
      const workloadFile = process.env.AZURE_FEDERATED_TOKEN_FILE;
      const tenantId = options?.tenantId ?? process.env.AZURE_TENANT_ID;
      if (managedResourceId) {
        const managedIdentityResourceIdOptions = {
          ...options,
          resourceId: managedResourceId
        };
        return new index_js_1.ManagedIdentityCredential(managedIdentityResourceIdOptions);
      }
      if (workloadFile && workloadIdentityClientId) {
        const workloadIdentityCredentialOptions = {
          ...options,
          tenantId
        };
        return new index_js_1.ManagedIdentityCredential(workloadIdentityClientId, workloadIdentityCredentialOptions);
      }
      if (managedIdentityClientId) {
        const managedIdentityClientOptions = {
          ...options,
          clientId: managedIdentityClientId
        };
        return new index_js_1.ManagedIdentityCredential(managedIdentityClientOptions);
      }
      return new index_js_1.ManagedIdentityCredential(options);
    }
    function createDefaultWorkloadIdentityCredential(options) {
      const managedIdentityClientId = options?.managedIdentityClientId ?? process.env.AZURE_CLIENT_ID;
      const workloadIdentityClientId = options?.workloadIdentityClientId ?? managedIdentityClientId;
      const workloadFile = process.env.AZURE_FEDERATED_TOKEN_FILE;
      const tenantId = options?.tenantId ?? process.env.AZURE_TENANT_ID;
      if (workloadFile && workloadIdentityClientId) {
        const workloadIdentityCredentialOptions = {
          ...options,
          tenantId,
          clientId: workloadIdentityClientId,
          tokenFilePath: workloadFile
        };
        return new workloadIdentityCredential_js_1.WorkloadIdentityCredential(workloadIdentityCredentialOptions);
      }
      if (tenantId) {
        const workloadIdentityClientTenantOptions = {
          ...options,
          tenantId
        };
        return new workloadIdentityCredential_js_1.WorkloadIdentityCredential(workloadIdentityClientTenantOptions);
      }
      return new workloadIdentityCredential_js_1.WorkloadIdentityCredential(options);
    }
    function createDefaultAzureDeveloperCliCredential(options = {}) {
      return new azureDeveloperCliCredential_js_1.AzureDeveloperCliCredential(options);
    }
    function createDefaultAzureCliCredential(options = {}) {
      return new azureCliCredential_js_1.AzureCliCredential(options);
    }
    function createDefaultAzurePowershellCredential(options = {}) {
      return new azurePowerShellCredential_js_1.AzurePowerShellCredential(options);
    }
    function createDefaultEnvironmentCredential(options = {}) {
      return new environmentCredential_js_1.EnvironmentCredential(options);
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/defaultAzureCredential.js
var require_defaultAzureCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/defaultAzureCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultAzureCredential = exports2.UnavailableDefaultCredential = void 0;
    var chainedTokenCredential_js_1 = require_chainedTokenCredential();
    var logging_js_1 = require_logging();
    var defaultAzureCredentialFunctions_js_1 = require_defaultAzureCredentialFunctions();
    var logger = (0, logging_js_1.credentialLogger)("DefaultAzureCredential");
    var UnavailableDefaultCredential = class {
      credentialUnavailableErrorMessage;
      credentialName;
      constructor(credentialName, message) {
        this.credentialName = credentialName;
        this.credentialUnavailableErrorMessage = message;
      }
      getToken() {
        logger.getToken.info(`Skipping ${this.credentialName}, reason: ${this.credentialUnavailableErrorMessage}`);
        return Promise.resolve(null);
      }
    };
    exports2.UnavailableDefaultCredential = UnavailableDefaultCredential;
    var DefaultAzureCredential = class extends chainedTokenCredential_js_1.ChainedTokenCredential {
      constructor(options) {
        validateRequiredEnvVars(options);
        const azureTokenCredentials = process.env.AZURE_TOKEN_CREDENTIALS ? process.env.AZURE_TOKEN_CREDENTIALS.trim().toLowerCase() : void 0;
        const devCredentialFunctions = [
          defaultAzureCredentialFunctions_js_1.createDefaultVisualStudioCodeCredential,
          defaultAzureCredentialFunctions_js_1.createDefaultAzureCliCredential,
          defaultAzureCredentialFunctions_js_1.createDefaultAzurePowershellCredential,
          defaultAzureCredentialFunctions_js_1.createDefaultAzureDeveloperCliCredential,
          defaultAzureCredentialFunctions_js_1.createDefaultBrokerCredential
        ];
        const prodCredentialFunctions = [
          defaultAzureCredentialFunctions_js_1.createDefaultEnvironmentCredential,
          defaultAzureCredentialFunctions_js_1.createDefaultWorkloadIdentityCredential,
          defaultAzureCredentialFunctions_js_1.createDefaultManagedIdentityCredential
        ];
        let credentialFunctions = [];
        const validCredentialNames = "EnvironmentCredential, WorkloadIdentityCredential, ManagedIdentityCredential, VisualStudioCodeCredential, AzureCliCredential, AzurePowerShellCredential, AzureDeveloperCliCredential";
        if (azureTokenCredentials) {
          switch (azureTokenCredentials) {
            case "dev":
              credentialFunctions = devCredentialFunctions;
              break;
            case "prod":
              credentialFunctions = prodCredentialFunctions;
              break;
            case "environmentcredential":
              credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultEnvironmentCredential];
              break;
            case "workloadidentitycredential":
              credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultWorkloadIdentityCredential];
              break;
            case "managedidentitycredential":
              credentialFunctions = [
                () => (0, defaultAzureCredentialFunctions_js_1.createDefaultManagedIdentityCredential)({ sendProbeRequest: false })
              ];
              break;
            case "visualstudiocodecredential":
              credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultVisualStudioCodeCredential];
              break;
            case "azureclicredential":
              credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultAzureCliCredential];
              break;
            case "azurepowershellcredential":
              credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultAzurePowershellCredential];
              break;
            case "azuredeveloperclicredential":
              credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultAzureDeveloperCliCredential];
              break;
            default: {
              const errorMessage = `Invalid value for AZURE_TOKEN_CREDENTIALS = ${process.env.AZURE_TOKEN_CREDENTIALS}. Valid values are 'prod' or 'dev' or any of these credentials - ${validCredentialNames}.`;
              logger.warning(errorMessage);
              throw new Error(errorMessage);
            }
          }
        } else {
          credentialFunctions = [...prodCredentialFunctions, ...devCredentialFunctions];
        }
        const credentials = credentialFunctions.map((createCredentialFn) => {
          try {
            return createCredentialFn(options ?? {});
          } catch (err) {
            logger.warning(`Skipped ${createCredentialFn.name} because of an error creating the credential: ${err}`);
            return new UnavailableDefaultCredential(createCredentialFn.name, err.message);
          }
        });
        super(...credentials);
      }
    };
    exports2.DefaultAzureCredential = DefaultAzureCredential;
    function validateRequiredEnvVars(options) {
      if (options?.requiredEnvVars) {
        const requiredVars = Array.isArray(options.requiredEnvVars) ? options.requiredEnvVars : [options.requiredEnvVars];
        const missing = requiredVars.filter((envVar) => !process.env[envVar]);
        if (missing.length > 0) {
          const errorMessage = `Required environment ${missing.length === 1 ? "variable" : "variables"} '${missing.join(", ")}' for DefaultAzureCredential ${missing.length === 1 ? "is" : "are"} not set or empty.`;
          logger.warning(errorMessage);
          throw new Error(errorMessage);
        }
      }
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/interactiveBrowserCredential.js
var require_interactiveBrowserCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/interactiveBrowserCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InteractiveBrowserCredential = void 0;
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var logging_js_1 = require_logging();
    var scopeUtils_js_1 = require_scopeUtils();
    var tracing_js_1 = require_tracing();
    var msalClient_js_1 = require_msalClient();
    var constants_js_1 = require_constants();
    var logger = (0, logging_js_1.credentialLogger)("InteractiveBrowserCredential");
    var InteractiveBrowserCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      msalClient;
      disableAutomaticAuthentication;
      browserCustomizationOptions;
      loginHint;
      /**
       * Creates an instance of InteractiveBrowserCredential with the details needed.
       *
       * This credential uses the [Authorization Code Flow](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-auth-code-flow).
       * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.
       * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.
       *
       * For Node.js, if a `clientId` is provided, the Microsoft Entra application will need to be configured to have a "Mobile and desktop applications" redirect endpoint.
       * Follow our guide on [setting up Redirect URIs for Desktop apps that calls to web APIs](https://learn.microsoft.com/entra/identity-platform/scenario-desktop-app-registration#redirect-uris).
       *
       * @param options - Options for configuring the client which makes the authentication requests.
       */
      constructor(options) {
        this.tenantId = (0, tenantIdUtils_js_1.resolveTenantId)(logger, options.tenantId, options.clientId);
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        const msalClientOptions = {
          ...options,
          tokenCredentialOptions: options,
          logger
        };
        const ibcNodeOptions = options;
        this.browserCustomizationOptions = ibcNodeOptions.browserCustomizationOptions;
        this.loginHint = ibcNodeOptions.loginHint;
        if (ibcNodeOptions?.brokerOptions?.enabled) {
          if (!ibcNodeOptions?.brokerOptions?.parentWindowHandle) {
            throw new Error("In order to do WAM authentication, `parentWindowHandle` under `brokerOptions` is a required parameter");
          } else {
            msalClientOptions.brokerOptions = {
              enabled: true,
              parentWindowHandle: ibcNodeOptions.brokerOptions.parentWindowHandle,
              legacyEnableMsaPassthrough: ibcNodeOptions.brokerOptions?.legacyEnableMsaPassthrough,
              useDefaultBrokerAccount: ibcNodeOptions.brokerOptions?.useDefaultBrokerAccount
            };
          }
        }
        this.msalClient = (0, msalClient_js_1.createMsalClient)(options.clientId ?? constants_js_1.DeveloperSignOnClientId, this.tenantId, msalClientOptions);
        this.disableAutomaticAuthentication = options?.disableAutomaticAuthentication;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
          const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
          return this.msalClient.getTokenByInteractiveRequest(arrayScopes, {
            ...newOptions,
            disableAutomaticAuthentication: this.disableAutomaticAuthentication,
            browserCustomizationOptions: this.browserCustomizationOptions,
            loginHint: this.loginHint
          });
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the token can't be retrieved silently, this method will always generate a challenge for the user.
       *
       * On Node.js, this credential has [Proof Key for Code Exchange (PKCE)](https://datatracker.ietf.org/doc/html/rfc7636) enabled by default.
       * PKCE is a security feature that mitigates authentication code interception attacks.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                  TokenCredential implementation might make.
       */
      async authenticate(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
          const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
          await this.msalClient.getTokenByInteractiveRequest(arrayScopes, {
            ...newOptions,
            disableAutomaticAuthentication: false,
            // this method should always allow user interaction
            browserCustomizationOptions: this.browserCustomizationOptions,
            loginHint: this.loginHint
          });
          return this.msalClient.getActiveAccount();
        });
      }
    };
    exports2.InteractiveBrowserCredential = InteractiveBrowserCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/deviceCodeCredential.js
var require_deviceCodeCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/deviceCodeCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeviceCodeCredential = void 0;
    exports2.defaultDeviceCodePromptCallback = defaultDeviceCodePromptCallback;
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var logging_js_1 = require_logging();
    var scopeUtils_js_1 = require_scopeUtils();
    var tracing_js_1 = require_tracing();
    var msalClient_js_1 = require_msalClient();
    var constants_js_1 = require_constants();
    var logger = (0, logging_js_1.credentialLogger)("DeviceCodeCredential");
    function defaultDeviceCodePromptCallback(deviceCodeInfo) {
      console.log(deviceCodeInfo.message);
    }
    var DeviceCodeCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      disableAutomaticAuthentication;
      msalClient;
      userPromptCallback;
      /**
       * Creates an instance of DeviceCodeCredential with the details needed
       * to initiate the device code authorization flow with Microsoft Entra ID.
       *
       * A message will be logged, giving users a code that they can use to authenticate once they go to https://microsoft.com/devicelogin
       *
       * Developers can configure how this message is shown by passing a custom `userPromptCallback`:
       *
       * ```ts snippet:device_code_credential_example
       * import { DeviceCodeCredential } from "@azure/identity";
       *
       * const credential = new DeviceCodeCredential({
       *   tenantId: process.env.AZURE_TENANT_ID,
       *   clientId: process.env.AZURE_CLIENT_ID,
       *   userPromptCallback: (info) => {
       *     console.log("CUSTOMIZED PROMPT CALLBACK", info.message);
       *   },
       * });
       * ```
       *
       * @param options - Options for configuring the client which makes the authentication requests.
       */
      constructor(options) {
        this.tenantId = options?.tenantId;
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        const clientId = options?.clientId ?? constants_js_1.DeveloperSignOnClientId;
        const tenantId = (0, tenantIdUtils_js_1.resolveTenantId)(logger, options?.tenantId, clientId);
        this.userPromptCallback = options?.userPromptCallback ?? defaultDeviceCodePromptCallback;
        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
          ...options,
          logger,
          tokenCredentialOptions: options || {}
        });
        this.disableAutomaticAuthentication = options?.disableAutomaticAuthentication;
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
          const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
          return this.msalClient.getTokenByDeviceCode(arrayScopes, this.userPromptCallback, {
            ...newOptions,
            disableAutomaticAuthentication: this.disableAutomaticAuthentication
          });
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the token can't be retrieved silently, this method will always generate a challenge for the user.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                  TokenCredential implementation might make.
       */
      async authenticate(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          await this.msalClient.getTokenByDeviceCode(arrayScopes, this.userPromptCallback, {
            ...newOptions,
            disableAutomaticAuthentication: false
            // this method should always allow user interaction
          });
          return this.msalClient.getActiveAccount();
        });
      }
    };
    exports2.DeviceCodeCredential = DeviceCodeCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/azurePipelinesCredential.js
var require_azurePipelinesCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/azurePipelinesCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzurePipelinesCredential = void 0;
    exports2.handleOidcResponse = handleOidcResponse;
    var errors_js_1 = require_errors();
    var core_rest_pipeline_1 = require_commonjs6();
    var clientAssertionCredential_js_1 = require_clientAssertionCredential();
    var identityClient_js_1 = require_identityClient();
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var logging_js_1 = require_logging();
    var credentialName = "AzurePipelinesCredential";
    var logger = (0, logging_js_1.credentialLogger)(credentialName);
    var OIDC_API_VERSION = "7.1";
    var AzurePipelinesCredential = class {
      clientAssertionCredential;
      identityClient;
      /**
       * AzurePipelinesCredential supports Federated Identity on Azure Pipelines through Service Connections.
       * @param tenantId - tenantId associated with the service connection
       * @param clientId - clientId associated with the service connection
       * @param serviceConnectionId - Unique ID for the service connection, as found in the querystring's resourceId key
       * @param systemAccessToken - The pipeline's <see href="https://learn.microsoft.com/azure/devops/pipelines/build/variables?view=azure-devops%26tabs=yaml#systemaccesstoken">System.AccessToken</see> value.
       * @param options - The identity client options to use for authentication.
       */
      constructor(tenantId, clientId, serviceConnectionId, systemAccessToken, options = {}) {
        if (!clientId) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. clientId is a required parameter.`);
        }
        if (!tenantId) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. tenantId is a required parameter.`);
        }
        if (!serviceConnectionId) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. serviceConnectionId is a required parameter.`);
        }
        if (!systemAccessToken) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. systemAccessToken is a required parameter.`);
        }
        options.loggingOptions = {
          ...options?.loggingOptions,
          additionalAllowedHeaderNames: [
            ...options.loggingOptions?.additionalAllowedHeaderNames ?? [],
            "x-vss-e2eid",
            "x-msedge-ref"
          ]
        };
        this.identityClient = new identityClient_js_1.IdentityClient(options);
        (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
        logger.info(`Invoking AzurePipelinesCredential with tenant ID: ${tenantId}, client ID: ${clientId}, and service connection ID: ${serviceConnectionId}`);
        if (!process.env.SYSTEM_OIDCREQUESTURI) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. Ensure that you're running this task in an Azure Pipeline, so that following missing system variable(s) can be defined- "SYSTEM_OIDCREQUESTURI"`);
        }
        const oidcRequestUrl = `${process.env.SYSTEM_OIDCREQUESTURI}?api-version=${OIDC_API_VERSION}&serviceConnectionId=${serviceConnectionId}`;
        logger.info(`Invoking ClientAssertionCredential with tenant ID: ${tenantId}, client ID: ${clientId} and service connection ID: ${serviceConnectionId}`);
        this.clientAssertionCredential = new clientAssertionCredential_js_1.ClientAssertionCredential(tenantId, clientId, this.requestOidcToken.bind(this, oidcRequestUrl, systemAccessToken), options);
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} or {@link AuthenticationError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options) {
        if (!this.clientAssertionCredential) {
          const errorMessage = `${credentialName}: is unavailable. To use Federation Identity in Azure Pipelines, the following parameters are required - 
      tenantId,
      clientId,
      serviceConnectionId,
      systemAccessToken,
      "SYSTEM_OIDCREQUESTURI".      
      See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`;
          logger.error(errorMessage);
          throw new errors_js_1.CredentialUnavailableError(errorMessage);
        }
        logger.info("Invoking getToken() of Client Assertion Credential");
        return this.clientAssertionCredential.getToken(scopes, options);
      }
      /**
       *
       * @param oidcRequestUrl - oidc request url
       * @param systemAccessToken - system access token
       * @returns OIDC token from Azure Pipelines
       */
      async requestOidcToken(oidcRequestUrl, systemAccessToken) {
        logger.info("Requesting OIDC token from Azure Pipelines...");
        logger.info(oidcRequestUrl);
        const request = (0, core_rest_pipeline_1.createPipelineRequest)({
          url: oidcRequestUrl,
          method: "POST",
          headers: (0, core_rest_pipeline_1.createHttpHeaders)({
            "Content-Type": "application/json",
            Authorization: `Bearer ${systemAccessToken}`,
            // Prevents the service from responding with a redirect HTTP status code (useful for automation).
            "X-TFS-FedAuthRedirect": "Suppress"
          })
        });
        const response = await this.identityClient.sendRequest(request);
        return handleOidcResponse(response);
      }
    };
    exports2.AzurePipelinesCredential = AzurePipelinesCredential;
    function handleOidcResponse(response) {
      const text = response.bodyAsText;
      if (!text) {
        logger.error(`${credentialName}: Authentication Failed. Received null token from OIDC request. Response status- ${response.status}. Complete response - ${JSON.stringify(response)}`);
        throw new errors_js_1.AuthenticationError(response.status, {
          error: `${credentialName}: Authentication Failed. Received null token from OIDC request.`,
          error_description: `${JSON.stringify(response)}. See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`
        });
      }
      try {
        const result = JSON.parse(text);
        if (result?.oidcToken) {
          return result.oidcToken;
        } else {
          const errorMessage = `${credentialName}: Authentication Failed. oidcToken field not detected in the response.`;
          let errorDescription = ``;
          if (response.status !== 200) {
            errorDescription = `Response body = ${text}. Response Headers ["x-vss-e2eid"] = ${response.headers.get("x-vss-e2eid")} and ["x-msedge-ref"] = ${response.headers.get("x-msedge-ref")}. See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`;
          }
          logger.error(errorMessage);
          logger.error(errorDescription);
          throw new errors_js_1.AuthenticationError(response.status, {
            error: errorMessage,
            error_description: errorDescription
          });
        }
      } catch (e) {
        const errorDetails = `${credentialName}: Authentication Failed. oidcToken field not detected in the response.`;
        logger.error(`Response from service = ${text}, Response Headers ["x-vss-e2eid"] = ${response.headers.get("x-vss-e2eid")} 
      and ["x-msedge-ref"] = ${response.headers.get("x-msedge-ref")}, error message = ${e.message}`);
        logger.error(errorDetails);
        throw new errors_js_1.AuthenticationError(response.status, {
          error: errorDetails,
          error_description: `Response = ${text}. Response headers ["x-vss-e2eid"] = ${response.headers.get("x-vss-e2eid")} and ["x-msedge-ref"] =  ${response.headers.get("x-msedge-ref")}. See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`
        });
      }
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/authorizationCodeCredential.js
var require_authorizationCodeCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/authorizationCodeCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthorizationCodeCredential = void 0;
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var tenantIdUtils_js_2 = require_tenantIdUtils();
    var logging_js_1 = require_logging();
    var scopeUtils_js_1 = require_scopeUtils();
    var tracing_js_1 = require_tracing();
    var msalClient_js_1 = require_msalClient();
    var logger = (0, logging_js_1.credentialLogger)("AuthorizationCodeCredential");
    var AuthorizationCodeCredential = class {
      msalClient;
      disableAutomaticAuthentication;
      authorizationCode;
      redirectUri;
      tenantId;
      additionallyAllowedTenantIds;
      clientSecret;
      /**
       * @hidden
       * @internal
       */
      constructor(tenantId, clientId, clientSecretOrAuthorizationCode, authorizationCodeOrRedirectUri, redirectUriOrOptions, options) {
        (0, tenantIdUtils_js_2.checkTenantId)(logger, tenantId);
        this.clientSecret = clientSecretOrAuthorizationCode;
        if (typeof redirectUriOrOptions === "string") {
          this.authorizationCode = authorizationCodeOrRedirectUri;
          this.redirectUri = redirectUriOrOptions;
        } else {
          this.authorizationCode = clientSecretOrAuthorizationCode;
          this.redirectUri = authorizationCodeOrRedirectUri;
          this.clientSecret = void 0;
          options = redirectUriOrOptions;
        }
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
          ...options,
          logger,
          tokenCredentialOptions: options ?? {}
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds);
          newOptions.tenantId = tenantId;
          const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
          return this.msalClient.getTokenByAuthorizationCode(arrayScopes, this.redirectUri, this.authorizationCode, this.clientSecret, {
            ...newOptions,
            disableAutomaticAuthentication: this.disableAutomaticAuthentication
          });
        });
      }
    };
    exports2.AuthorizationCodeCredential = AuthorizationCodeCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/credentials/onBehalfOfCredential.js
var require_onBehalfOfCredential = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/credentials/onBehalfOfCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OnBehalfOfCredential = void 0;
    var msalClient_js_1 = require_msalClient();
    var logging_js_1 = require_logging();
    var tenantIdUtils_js_1 = require_tenantIdUtils();
    var errors_js_1 = require_errors();
    var node_crypto_1 = require("node:crypto");
    var scopeUtils_js_1 = require_scopeUtils();
    var promises_1 = require("node:fs/promises");
    var tracing_js_1 = require_tracing();
    var credentialName = "OnBehalfOfCredential";
    var logger = (0, logging_js_1.credentialLogger)(credentialName);
    var OnBehalfOfCredential = class {
      tenantId;
      additionallyAllowedTenantIds;
      msalClient;
      sendCertificateChain;
      certificatePath;
      clientSecret;
      userAssertionToken;
      clientAssertion;
      constructor(options) {
        const { clientSecret } = options;
        const { certificatePath, sendCertificateChain } = options;
        const { getAssertion } = options;
        const { tenantId, clientId, userAssertionToken, additionallyAllowedTenants: additionallyAllowedTenantIds } = options;
        if (!tenantId) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: tenantId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        if (!clientId) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: clientId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        if (!clientSecret && !certificatePath && !getAssertion) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: You must provide one of clientSecret, certificatePath, or a getAssertion callback but none were provided. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        if (!userAssertionToken) {
          throw new errors_js_1.CredentialUnavailableError(`${credentialName}: userAssertionToken is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
        }
        this.certificatePath = certificatePath;
        this.clientSecret = clientSecret;
        this.userAssertionToken = userAssertionToken;
        this.sendCertificateChain = sendCertificateChain;
        this.clientAssertion = getAssertion;
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(additionallyAllowedTenantIds);
        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, this.tenantId, {
          ...options,
          logger,
          tokenCredentialOptions: options
        });
      }
      /**
       * Authenticates with Microsoft Entra ID and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure the underlying network requests.
       */
      async getToken(scopes, options = {}) {
        return tracing_js_1.tracingClient.withSpan(`${credentialName}.getToken`, options, async (newOptions) => {
          newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
          const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
          if (this.certificatePath) {
            const clientCertificate = await this.buildClientCertificate(this.certificatePath);
            return this.msalClient.getTokenOnBehalfOf(arrayScopes, this.userAssertionToken, clientCertificate, newOptions);
          } else if (this.clientSecret) {
            return this.msalClient.getTokenOnBehalfOf(arrayScopes, this.userAssertionToken, this.clientSecret, options);
          } else if (this.clientAssertion) {
            return this.msalClient.getTokenOnBehalfOf(arrayScopes, this.userAssertionToken, this.clientAssertion, options);
          } else {
            throw new Error("Expected either clientSecret or certificatePath or clientAssertion to be defined.");
          }
        });
      }
      async buildClientCertificate(certificatePath) {
        try {
          const parts = await this.parseCertificate({ certificatePath }, this.sendCertificateChain);
          return {
            thumbprint: parts.thumbprint,
            thumbprintSha256: parts.thumbprintSha256,
            privateKey: parts.certificateContents,
            x5c: parts.x5c
          };
        } catch (error) {
          logger.info((0, logging_js_1.formatError)("", error));
          throw error;
        }
      }
      async parseCertificate(configuration, sendCertificateChain) {
        const certificatePath = configuration.certificatePath;
        const certificateContents = await (0, promises_1.readFile)(certificatePath, "utf8");
        const x5c = sendCertificateChain ? certificateContents : void 0;
        const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/g;
        const publicKeys = [];
        let match;
        do {
          match = certificatePattern.exec(certificateContents);
          if (match) {
            publicKeys.push(match[3]);
          }
        } while (match);
        if (publicKeys.length === 0) {
          throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
        }
        const thumbprint = (0, node_crypto_1.createHash)("sha1").update(Buffer.from(publicKeys[0], "base64")).digest("hex").toUpperCase();
        const thumbprintSha256 = (0, node_crypto_1.createHash)("sha256").update(Buffer.from(publicKeys[0], "base64")).digest("hex").toUpperCase();
        return {
          certificateContents,
          thumbprintSha256,
          thumbprint,
          x5c
        };
      }
    };
    exports2.OnBehalfOfCredential = OnBehalfOfCredential;
  }
});

// node_modules/@azure/identity/dist/commonjs/tokenProvider.js
var require_tokenProvider = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/tokenProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBearerTokenProvider = getBearerTokenProvider;
    var core_rest_pipeline_1 = require_commonjs6();
    function getBearerTokenProvider(credential, scopes, options) {
      const { abortSignal, tracingOptions } = options || {};
      const pipeline = (0, core_rest_pipeline_1.createEmptyPipeline)();
      pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({ credential, scopes }));
      async function getRefreshedToken() {
        const res = await pipeline.sendRequest({
          sendRequest: (request) => Promise.resolve({
            request,
            status: 200,
            headers: request.headers
          })
        }, (0, core_rest_pipeline_1.createPipelineRequest)({
          url: "https://example.com",
          abortSignal,
          tracingOptions
        }));
        const accessToken = res.headers.get("authorization")?.split(" ")[1];
        if (!accessToken) {
          throw new Error("Failed to get access token");
        }
        return accessToken;
      }
      return getRefreshedToken;
    }
  }
});

// node_modules/@azure/identity/dist/commonjs/index.js
var require_commonjs8 = __commonJS({
  "node_modules/@azure/identity/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getBearerTokenProvider = exports2.AzureAuthorityHosts = exports2.logger = exports2.WorkloadIdentityCredential = exports2.OnBehalfOfCredential = exports2.VisualStudioCodeCredential = exports2.UsernamePasswordCredential = exports2.AzurePowerShellCredential = exports2.AuthorizationCodeCredential = exports2.AzurePipelinesCredential = exports2.DeviceCodeCredential = exports2.ManagedIdentityCredential = exports2.InteractiveBrowserCredential = exports2.AzureDeveloperCliCredential = exports2.AzureCliCredential = exports2.ClientAssertionCredential = exports2.ClientCertificateCredential = exports2.EnvironmentCredential = exports2.DefaultAzureCredential = exports2.ClientSecretCredential = exports2.ChainedTokenCredential = exports2.deserializeAuthenticationRecord = exports2.serializeAuthenticationRecord = exports2.AuthenticationRequiredError = exports2.CredentialUnavailableErrorName = exports2.CredentialUnavailableError = exports2.AggregateAuthenticationErrorName = exports2.AuthenticationErrorName = exports2.AggregateAuthenticationError = exports2.AuthenticationError = void 0;
    exports2.getDefaultAzureCredential = getDefaultAzureCredential;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_consumer(), exports2);
    var defaultAzureCredential_js_1 = require_defaultAzureCredential();
    var errors_js_1 = require_errors();
    Object.defineProperty(exports2, "AuthenticationError", { enumerable: true, get: function() {
      return errors_js_1.AuthenticationError;
    } });
    Object.defineProperty(exports2, "AggregateAuthenticationError", { enumerable: true, get: function() {
      return errors_js_1.AggregateAuthenticationError;
    } });
    Object.defineProperty(exports2, "AuthenticationErrorName", { enumerable: true, get: function() {
      return errors_js_1.AuthenticationErrorName;
    } });
    Object.defineProperty(exports2, "AggregateAuthenticationErrorName", { enumerable: true, get: function() {
      return errors_js_1.AggregateAuthenticationErrorName;
    } });
    Object.defineProperty(exports2, "CredentialUnavailableError", { enumerable: true, get: function() {
      return errors_js_1.CredentialUnavailableError;
    } });
    Object.defineProperty(exports2, "CredentialUnavailableErrorName", { enumerable: true, get: function() {
      return errors_js_1.CredentialUnavailableErrorName;
    } });
    Object.defineProperty(exports2, "AuthenticationRequiredError", { enumerable: true, get: function() {
      return errors_js_1.AuthenticationRequiredError;
    } });
    var utils_js_1 = require_utils3();
    Object.defineProperty(exports2, "serializeAuthenticationRecord", { enumerable: true, get: function() {
      return utils_js_1.serializeAuthenticationRecord;
    } });
    Object.defineProperty(exports2, "deserializeAuthenticationRecord", { enumerable: true, get: function() {
      return utils_js_1.deserializeAuthenticationRecord;
    } });
    var chainedTokenCredential_js_1 = require_chainedTokenCredential();
    Object.defineProperty(exports2, "ChainedTokenCredential", { enumerable: true, get: function() {
      return chainedTokenCredential_js_1.ChainedTokenCredential;
    } });
    var clientSecretCredential_js_1 = require_clientSecretCredential();
    Object.defineProperty(exports2, "ClientSecretCredential", { enumerable: true, get: function() {
      return clientSecretCredential_js_1.ClientSecretCredential;
    } });
    var defaultAzureCredential_js_2 = require_defaultAzureCredential();
    Object.defineProperty(exports2, "DefaultAzureCredential", { enumerable: true, get: function() {
      return defaultAzureCredential_js_2.DefaultAzureCredential;
    } });
    var environmentCredential_js_1 = require_environmentCredential();
    Object.defineProperty(exports2, "EnvironmentCredential", { enumerable: true, get: function() {
      return environmentCredential_js_1.EnvironmentCredential;
    } });
    var clientCertificateCredential_js_1 = require_clientCertificateCredential();
    Object.defineProperty(exports2, "ClientCertificateCredential", { enumerable: true, get: function() {
      return clientCertificateCredential_js_1.ClientCertificateCredential;
    } });
    var clientAssertionCredential_js_1 = require_clientAssertionCredential();
    Object.defineProperty(exports2, "ClientAssertionCredential", { enumerable: true, get: function() {
      return clientAssertionCredential_js_1.ClientAssertionCredential;
    } });
    var azureCliCredential_js_1 = require_azureCliCredential();
    Object.defineProperty(exports2, "AzureCliCredential", { enumerable: true, get: function() {
      return azureCliCredential_js_1.AzureCliCredential;
    } });
    var azureDeveloperCliCredential_js_1 = require_azureDeveloperCliCredential();
    Object.defineProperty(exports2, "AzureDeveloperCliCredential", { enumerable: true, get: function() {
      return azureDeveloperCliCredential_js_1.AzureDeveloperCliCredential;
    } });
    var interactiveBrowserCredential_js_1 = require_interactiveBrowserCredential();
    Object.defineProperty(exports2, "InteractiveBrowserCredential", { enumerable: true, get: function() {
      return interactiveBrowserCredential_js_1.InteractiveBrowserCredential;
    } });
    var index_js_1 = require_managedIdentityCredential();
    Object.defineProperty(exports2, "ManagedIdentityCredential", { enumerable: true, get: function() {
      return index_js_1.ManagedIdentityCredential;
    } });
    var deviceCodeCredential_js_1 = require_deviceCodeCredential();
    Object.defineProperty(exports2, "DeviceCodeCredential", { enumerable: true, get: function() {
      return deviceCodeCredential_js_1.DeviceCodeCredential;
    } });
    var azurePipelinesCredential_js_1 = require_azurePipelinesCredential();
    Object.defineProperty(exports2, "AzurePipelinesCredential", { enumerable: true, get: function() {
      return azurePipelinesCredential_js_1.AzurePipelinesCredential;
    } });
    var authorizationCodeCredential_js_1 = require_authorizationCodeCredential();
    Object.defineProperty(exports2, "AuthorizationCodeCredential", { enumerable: true, get: function() {
      return authorizationCodeCredential_js_1.AuthorizationCodeCredential;
    } });
    var azurePowerShellCredential_js_1 = require_azurePowerShellCredential();
    Object.defineProperty(exports2, "AzurePowerShellCredential", { enumerable: true, get: function() {
      return azurePowerShellCredential_js_1.AzurePowerShellCredential;
    } });
    var usernamePasswordCredential_js_1 = require_usernamePasswordCredential();
    Object.defineProperty(exports2, "UsernamePasswordCredential", { enumerable: true, get: function() {
      return usernamePasswordCredential_js_1.UsernamePasswordCredential;
    } });
    var visualStudioCodeCredential_js_1 = require_visualStudioCodeCredential();
    Object.defineProperty(exports2, "VisualStudioCodeCredential", { enumerable: true, get: function() {
      return visualStudioCodeCredential_js_1.VisualStudioCodeCredential;
    } });
    var onBehalfOfCredential_js_1 = require_onBehalfOfCredential();
    Object.defineProperty(exports2, "OnBehalfOfCredential", { enumerable: true, get: function() {
      return onBehalfOfCredential_js_1.OnBehalfOfCredential;
    } });
    var workloadIdentityCredential_js_1 = require_workloadIdentityCredential();
    Object.defineProperty(exports2, "WorkloadIdentityCredential", { enumerable: true, get: function() {
      return workloadIdentityCredential_js_1.WorkloadIdentityCredential;
    } });
    var logging_js_1 = require_logging();
    Object.defineProperty(exports2, "logger", { enumerable: true, get: function() {
      return logging_js_1.logger;
    } });
    var constants_js_1 = require_constants();
    Object.defineProperty(exports2, "AzureAuthorityHosts", { enumerable: true, get: function() {
      return constants_js_1.AzureAuthorityHosts;
    } });
    function getDefaultAzureCredential() {
      return new defaultAzureCredential_js_1.DefaultAzureCredential();
    }
    var tokenProvider_js_1 = require_tokenProvider();
    Object.defineProperty(exports2, "getBearerTokenProvider", { enumerable: true, get: function() {
      return tokenProvider_js_1.getBearerTokenProvider;
    } });
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js
var require_azureKeyCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureKeyCredential = void 0;
    var AzureKeyCredential = class {
      _key;
      /**
       * The value of the key to be used in authentication
       */
      get key() {
        return this._key;
      }
      /**
       * Create an instance of an AzureKeyCredential for use
       * with a service client.
       *
       * @param key - The initial value of the key to use in authentication
       */
      constructor(key) {
        if (!key) {
          throw new Error("key must be a non-empty string");
        }
        this._key = key;
      }
      /**
       * Change the value of the key.
       *
       * Updates will take effect upon the next request after
       * updating the key value.
       *
       * @param newKey - The new key value to be used
       */
      update(newKey) {
        this._key = newKey;
      }
    };
    exports2.AzureKeyCredential = AzureKeyCredential;
  }
});

// node_modules/@azure/core-auth/dist/commonjs/keyCredential.js
var require_keyCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/keyCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isKeyCredential = isKeyCredential;
    var core_util_1 = require_commonjs4();
    function isKeyCredential(credential) {
      return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js
var require_azureNamedKeyCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureNamedKeyCredential = void 0;
    exports2.isNamedKeyCredential = isNamedKeyCredential;
    var core_util_1 = require_commonjs4();
    var AzureNamedKeyCredential = class {
      _key;
      _name;
      /**
       * The value of the key to be used in authentication.
       */
      get key() {
        return this._key;
      }
      /**
       * The value of the name to be used in authentication.
       */
      get name() {
        return this._name;
      }
      /**
       * Create an instance of an AzureNamedKeyCredential for use
       * with a service client.
       *
       * @param name - The initial value of the name to use in authentication.
       * @param key - The initial value of the key to use in authentication.
       */
      constructor(name, key) {
        if (!name || !key) {
          throw new TypeError("name and key must be non-empty strings");
        }
        this._name = name;
        this._key = key;
      }
      /**
       * Change the value of the key.
       *
       * Updates will take effect upon the next request after
       * updating the key value.
       *
       * @param newName - The new name value to be used.
       * @param newKey - The new key value to be used.
       */
      update(newName, newKey) {
        if (!newName || !newKey) {
          throw new TypeError("newName and newKey must be non-empty strings");
        }
        this._name = newName;
        this._key = newKey;
      }
    };
    exports2.AzureNamedKeyCredential = AzureNamedKeyCredential;
    function isNamedKeyCredential(credential) {
      return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js
var require_azureSASCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureSASCredential = void 0;
    exports2.isSASCredential = isSASCredential;
    var core_util_1 = require_commonjs4();
    var AzureSASCredential = class {
      _signature;
      /**
       * The value of the shared access signature to be used in authentication
       */
      get signature() {
        return this._signature;
      }
      /**
       * Create an instance of an AzureSASCredential for use
       * with a service client.
       *
       * @param signature - The initial value of the shared access signature to use in authentication
       */
      constructor(signature) {
        if (!signature) {
          throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = signature;
      }
      /**
       * Change the value of the signature.
       *
       * Updates will take effect upon the next request after
       * updating the signature value.
       *
       * @param newSignature - The new shared access signature value to be used
       */
      update(newSignature) {
        if (!newSignature) {
          throw new Error("shared access signature must be a non-empty string");
        }
        this._signature = newSignature;
      }
    };
    exports2.AzureSASCredential = AzureSASCredential;
    function isSASCredential(credential) {
      return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js
var require_tokenCredential = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBearerToken = isBearerToken;
    exports2.isPopToken = isPopToken;
    exports2.isTokenCredential = isTokenCredential;
    function isBearerToken(accessToken) {
      return !accessToken.tokenType || accessToken.tokenType === "Bearer";
    }
    function isPopToken(accessToken) {
      return accessToken.tokenType === "pop";
    }
    function isTokenCredential(credential) {
      const castCredential = credential;
      return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
    }
  }
});

// node_modules/@azure/core-auth/dist/commonjs/index.js
var require_commonjs9 = __commonJS({
  "node_modules/@azure/core-auth/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTokenCredential = exports2.isSASCredential = exports2.AzureSASCredential = exports2.isNamedKeyCredential = exports2.AzureNamedKeyCredential = exports2.isKeyCredential = exports2.AzureKeyCredential = void 0;
    var azureKeyCredential_js_1 = require_azureKeyCredential();
    Object.defineProperty(exports2, "AzureKeyCredential", { enumerable: true, get: function() {
      return azureKeyCredential_js_1.AzureKeyCredential;
    } });
    var keyCredential_js_1 = require_keyCredential();
    Object.defineProperty(exports2, "isKeyCredential", { enumerable: true, get: function() {
      return keyCredential_js_1.isKeyCredential;
    } });
    var azureNamedKeyCredential_js_1 = require_azureNamedKeyCredential();
    Object.defineProperty(exports2, "AzureNamedKeyCredential", { enumerable: true, get: function() {
      return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
    } });
    Object.defineProperty(exports2, "isNamedKeyCredential", { enumerable: true, get: function() {
      return azureNamedKeyCredential_js_1.isNamedKeyCredential;
    } });
    var azureSASCredential_js_1 = require_azureSASCredential();
    Object.defineProperty(exports2, "AzureSASCredential", { enumerable: true, get: function() {
      return azureSASCredential_js_1.AzureSASCredential;
    } });
    Object.defineProperty(exports2, "isSASCredential", { enumerable: true, get: function() {
      return azureSASCredential_js_1.isSASCredential;
    } });
    var tokenCredential_js_1 = require_tokenCredential();
    Object.defineProperty(exports2, "isTokenCredential", { enumerable: true, get: function() {
      return tokenCredential_js_1.isTokenCredential;
    } });
  }
});

// node_modules/mssql/node_modules/tedious/lib/debug.js
var require_debug3 = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/debug.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _events = require("events");
    var util = _interopRequireWildcard(require("util"));
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    var Debug = class extends _events.EventEmitter {
      /*
        @options    Which debug details should be sent.
                    data    - dump of packet data
                    payload - details of decoded payload
      */
      constructor({
        data = false,
        payload = false,
        packet = false,
        token = false
      } = {}) {
        super();
        this.options = {
          data,
          payload,
          packet,
          token
        };
        this.indent = "  ";
      }
      packet(direction, packet) {
        if (this.haveListeners() && this.options.packet) {
          this.log("");
          this.log(direction);
          this.log(packet.headerToString(this.indent));
        }
      }
      data(packet) {
        if (this.haveListeners() && this.options.data) {
          this.log(packet.dataToString(this.indent));
        }
      }
      payload(generatePayloadText) {
        if (this.haveListeners() && this.options.payload) {
          this.log(generatePayloadText());
        }
      }
      token(token) {
        if (this.haveListeners() && this.options.token) {
          this.log(util.inspect(token, {
            showHidden: false,
            depth: 5,
            colors: true
          }));
        }
      }
      haveListeners() {
        return this.listeners("debug").length > 0;
      }
      log(text) {
        this.emit("debug", text);
      }
    };
    var _default = exports2.default = Debug;
    module2.exports = Debug;
  }
});

// node_modules/mssql/node_modules/tedious/lib/errors/abort-error.js
var require_abort_error = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/errors/abort-error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var AbortError = class extends Error {
      constructor() {
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    exports2.default = AbortError;
  }
});

// node_modules/mssql/node_modules/tedious/lib/sender.js
var require_sender = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/sender.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sendInParallel = sendInParallel;
    exports2.sendMessage = sendMessage;
    var _dgram = _interopRequireDefault(require("dgram"));
    var _net = _interopRequireDefault(require("net"));
    var _nodeUrl = _interopRequireDefault(require("node:url"));
    var _abortError = _interopRequireDefault(require_abort_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function sendInParallel(addresses, port, request, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      return await new Promise((resolve, reject) => {
        const sockets = [];
        let errorCount = 0;
        const onError = (err) => {
          errorCount++;
          if (errorCount === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            clearSockets();
            reject(err);
          }
        };
        const onMessage = (message) => {
          signal.removeEventListener("abort", onAbort);
          clearSockets();
          resolve(message);
        };
        const onAbort = () => {
          clearSockets();
          reject(new _abortError.default());
        };
        const clearSockets = () => {
          for (const socket of sockets) {
            socket.removeListener("error", onError);
            socket.removeListener("message", onMessage);
            socket.close();
          }
        };
        signal.addEventListener("abort", onAbort, {
          once: true
        });
        for (let j = 0; j < addresses.length; j++) {
          const udpType = addresses[j].family === 6 ? "udp6" : "udp4";
          const socket = _dgram.default.createSocket(udpType);
          sockets.push(socket);
          socket.on("error", onError);
          socket.on("message", onMessage);
          socket.send(request, 0, request.length, port, addresses[j].address);
        }
      });
    }
    async function sendMessage(host, port, lookup, signal, request) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let addresses;
      if (_net.default.isIP(host)) {
        addresses = [{
          address: host,
          family: _net.default.isIPv6(host) ? 6 : 4
        }];
      } else {
        addresses = await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          const domainInASCII = _nodeUrl.default.domainToASCII(host);
          lookup(domainInASCII === "" ? host : domainInASCII, {
            all: true
          }, (err, addresses2) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses2);
          });
        });
      }
      return await sendInParallel(addresses, port, request, signal);
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/errors/timeout-error.js
var require_timeout_error = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/errors/timeout-error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var TimeoutError = class extends Error {
      constructor() {
        super("The operation was aborted due to timeout");
        this.code = "TIMEOUT_ERR";
        this.name = "TimeoutError";
      }
    };
    exports2.default = TimeoutError;
  }
});

// node_modules/mssql/node_modules/tedious/lib/utils/with-timeout.js
var require_with_timeout = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/utils/with-timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.withTimeout = withTimeout;
    var _timeoutError = _interopRequireDefault(require_timeout_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function withTimeout(timeout, func, signal) {
      const timeoutController = new AbortController();
      const abortCurrentAttempt = () => {
        timeoutController.abort();
      };
      const timer = setTimeout(abortCurrentAttempt, timeout);
      signal?.addEventListener("abort", abortCurrentAttempt, {
        once: true
      });
      try {
        return await func(timeoutController.signal);
      } catch (err) {
        if (err instanceof Error && err.name === "AbortError" && !(signal && signal.aborted)) {
          throw new _timeoutError.default();
        }
        throw err;
      } finally {
        signal?.removeEventListener("abort", abortCurrentAttempt);
        clearTimeout(timer);
      }
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/instance-lookup.js
var require_instance_lookup = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/instance-lookup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.instanceLookup = instanceLookup;
    exports2.parseBrowserResponse = parseBrowserResponse;
    var _dns = _interopRequireDefault(require("dns"));
    var _abortError = _interopRequireDefault(require_abort_error());
    var _sender = require_sender();
    var _withTimeout = require_with_timeout();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SQL_SERVER_BROWSER_PORT = 1434;
    var TIMEOUT = 2 * 1e3;
    var RETRIES = 3;
    var MYSTERY_HEADER_LENGTH = 3;
    async function instanceLookup(options) {
      const server = options.server;
      if (typeof server !== "string") {
        throw new TypeError('Invalid arguments: "server" must be a string');
      }
      const instanceName = options.instanceName;
      if (typeof instanceName !== "string") {
        throw new TypeError('Invalid arguments: "instanceName" must be a string');
      }
      const timeout = options.timeout === void 0 ? TIMEOUT : options.timeout;
      if (typeof timeout !== "number") {
        throw new TypeError('Invalid arguments: "timeout" must be a number');
      }
      const retries = options.retries === void 0 ? RETRIES : options.retries;
      if (typeof retries !== "number") {
        throw new TypeError('Invalid arguments: "retries" must be a number');
      }
      if (options.lookup !== void 0 && typeof options.lookup !== "function") {
        throw new TypeError('Invalid arguments: "lookup" must be a function');
      }
      const lookup = options.lookup ?? _dns.default.lookup;
      if (options.port !== void 0 && typeof options.port !== "number") {
        throw new TypeError('Invalid arguments: "port" must be a number');
      }
      const port = options.port ?? SQL_SERVER_BROWSER_PORT;
      const signal = options.signal;
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let response;
      for (let i = 0; i <= retries; i++) {
        try {
          response = await (0, _withTimeout.withTimeout)(timeout, async (signal2) => {
            const request = Buffer.from([2]);
            return await (0, _sender.sendMessage)(options.server, port, lookup, signal2, request);
          }, signal);
        } catch (err) {
          if (!signal.aborted && err instanceof Error && err.name === "TimeoutError") {
            continue;
          }
          throw err;
        }
      }
      if (!response) {
        throw new Error("Failed to get response from SQL Server Browser on " + server);
      }
      const message = response.toString("ascii", MYSTERY_HEADER_LENGTH);
      const foundPort = parseBrowserResponse(message, instanceName);
      if (!foundPort) {
        throw new Error("Port for " + instanceName + " not found in " + options.server);
      }
      return foundPort;
    }
    function parseBrowserResponse(response, instanceName) {
      let getPort;
      const instances = response.split(";;");
      for (let i = 0, len = instances.length; i < len; i++) {
        const instance = instances[i];
        const parts = instance.split(";");
        for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {
          const name = parts[p];
          const value = parts[p + 1];
          if (name === "tcp" && getPort) {
            const port = parseInt(value, 10);
            return port;
          }
          if (name === "InstanceName") {
            if (value.toUpperCase() === instanceName.toUpperCase()) {
              getPort = true;
            } else {
              getPort = false;
            }
          }
        }
      }
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/transient-error-lookup.js
var require_transient_error_lookup = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/transient-error-lookup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TransientErrorLookup = void 0;
    var TransientErrorLookup = class {
      isTransientError(error) {
        const transientErrors = [4060, 10928, 10929, 40197, 40501, 40613];
        return transientErrors.indexOf(error) !== -1;
      }
    };
    exports2.TransientErrorLookup = TransientErrorLookup;
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports2) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports2 !== "undefined") {
        exports2["sprintf"] = sprintf;
        exports2["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/mssql/node_modules/tedious/lib/packet.js
var require_packet = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/packet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TYPE = exports2.Packet = exports2.OFFSET = exports2.HEADER_LENGTH = void 0;
    exports2.isPacketComplete = isPacketComplete;
    exports2.packetLength = packetLength;
    var _sprintfJs = require_sprintf();
    var HEADER_LENGTH = exports2.HEADER_LENGTH = 8;
    var TYPE = exports2.TYPE = {
      SQL_BATCH: 1,
      RPC_REQUEST: 3,
      TABULAR_RESULT: 4,
      ATTENTION: 6,
      BULK_LOAD: 7,
      TRANSACTION_MANAGER: 14,
      LOGIN7: 16,
      NTLMAUTH_PKT: 17,
      PRELOGIN: 18,
      FEDAUTH_TOKEN: 8
    };
    var typeByValue = {};
    for (const name in TYPE) {
      typeByValue[TYPE[name]] = name;
    }
    var STATUS = {
      NORMAL: 0,
      EOM: 1,
      IGNORE: 2,
      RESETCONNECTION: 8,
      RESETCONNECTIONSKIPTRAN: 16
    };
    var OFFSET = exports2.OFFSET = {
      Type: 0,
      Status: 1,
      Length: 2,
      SPID: 4,
      PacketID: 6,
      Window: 7
    };
    var DEFAULT_SPID = 0;
    var DEFAULT_PACKETID = 1;
    var DEFAULT_WINDOW = 0;
    var NL = "\n";
    var Packet = class {
      constructor(typeOrBuffer) {
        if (typeOrBuffer instanceof Buffer) {
          this.buffer = typeOrBuffer;
        } else {
          const type = typeOrBuffer;
          this.buffer = Buffer.alloc(HEADER_LENGTH, 0);
          this.buffer.writeUInt8(type, OFFSET.Type);
          this.buffer.writeUInt8(STATUS.NORMAL, OFFSET.Status);
          this.buffer.writeUInt16BE(DEFAULT_SPID, OFFSET.SPID);
          this.buffer.writeUInt8(DEFAULT_PACKETID, OFFSET.PacketID);
          this.buffer.writeUInt8(DEFAULT_WINDOW, OFFSET.Window);
          this.setLength();
        }
      }
      setLength() {
        this.buffer.writeUInt16BE(this.buffer.length, OFFSET.Length);
      }
      length() {
        return this.buffer.readUInt16BE(OFFSET.Length);
      }
      resetConnection(reset) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (reset) {
          status |= STATUS.RESETCONNECTION;
        } else {
          status &= 255 - STATUS.RESETCONNECTION;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      last(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (arguments.length > 0) {
          if (last) {
            status |= STATUS.EOM;
          } else {
            status &= 255 - STATUS.EOM;
          }
          this.buffer.writeUInt8(status, OFFSET.Status);
        }
        return this.isLast();
      }
      ignore(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (last) {
          status |= STATUS.IGNORE;
        } else {
          status &= 255 - STATUS.IGNORE;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      isLast() {
        return !!(this.buffer.readUInt8(OFFSET.Status) & STATUS.EOM);
      }
      packetId(packetId) {
        if (packetId) {
          this.buffer.writeUInt8(packetId % 256, OFFSET.PacketID);
        }
        return this.buffer.readUInt8(OFFSET.PacketID);
      }
      addData(data) {
        this.buffer = Buffer.concat([this.buffer, data]);
        this.setLength();
        return this;
      }
      data() {
        return this.buffer.slice(HEADER_LENGTH);
      }
      type() {
        return this.buffer.readUInt8(OFFSET.Type);
      }
      statusAsString() {
        const status = this.buffer.readUInt8(OFFSET.Status);
        const statuses = [];
        for (const name in STATUS) {
          const value = STATUS[name];
          if (status & value) {
            statuses.push(name);
          } else {
            statuses.push(void 0);
          }
        }
        return statuses.join(" ").trim();
      }
      headerToString(indent = "") {
        const text = (0, _sprintfJs.sprintf)("type:0x%02X(%s), status:0x%02X(%s), length:0x%04X, spid:0x%04X, packetId:0x%02X, window:0x%02X", this.buffer.readUInt8(OFFSET.Type), typeByValue[this.buffer.readUInt8(OFFSET.Type)], this.buffer.readUInt8(OFFSET.Status), this.statusAsString(), this.buffer.readUInt16BE(OFFSET.Length), this.buffer.readUInt16BE(OFFSET.SPID), this.buffer.readUInt8(OFFSET.PacketID), this.buffer.readUInt8(OFFSET.Window));
        return indent + text;
      }
      dataToString(indent = "") {
        const BYTES_PER_GROUP = 4;
        const CHARS_PER_GROUP = 8;
        const BYTES_PER_LINE = 32;
        const data = this.data();
        let dataDump = "";
        let chars = "";
        for (let offset = 0; offset < data.length; offset++) {
          if (offset % BYTES_PER_LINE === 0) {
            dataDump += indent;
            dataDump += (0, _sprintfJs.sprintf)("%04X  ", offset);
          }
          if (data[offset] < 32 || data[offset] > 126) {
            chars += ".";
            if ((offset + 1) % CHARS_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
              chars += " ";
            }
          } else {
            chars += String.fromCharCode(data[offset]);
          }
          if (data[offset] != null) {
            dataDump += (0, _sprintfJs.sprintf)("%02X", data[offset]);
          }
          if ((offset + 1) % BYTES_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
            dataDump += " ";
          }
          if ((offset + 1) % BYTES_PER_LINE === 0) {
            dataDump += "  " + chars;
            chars = "";
            if (offset < data.length - 1) {
              dataDump += NL;
            }
          }
        }
        if (chars.length) {
          dataDump += "  " + chars;
        }
        return dataDump;
      }
      toString(indent = "") {
        return this.headerToString(indent) + "\n" + this.dataToString(indent + indent);
      }
      payloadString() {
        return "";
      }
    };
    exports2.Packet = Packet;
    function isPacketComplete(potentialPacketBuffer) {
      if (potentialPacketBuffer.length < HEADER_LENGTH) {
        return false;
      } else {
        return potentialPacketBuffer.length >= potentialPacketBuffer.readUInt16BE(OFFSET.Length);
      }
    }
    function packetLength(potentialPacketBuffer) {
      return potentialPacketBuffer.readUInt16BE(OFFSET.Length);
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/prelogin-payload.js
var require_prelogin_payload = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/prelogin-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _sprintfJs = require_sprintf();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var optionBufferSize = 20;
    var TOKEN = {
      VERSION: 0,
      ENCRYPTION: 1,
      INSTOPT: 2,
      THREADID: 3,
      MARS: 4,
      FEDAUTHREQUIRED: 6,
      TERMINATOR: 255
    };
    var ENCRYPT = {
      OFF: 0,
      ON: 1,
      NOT_SUP: 2,
      REQ: 3
    };
    var encryptByValue = {};
    for (const name in ENCRYPT) {
      const value = ENCRYPT[name];
      encryptByValue[value] = name;
    }
    var MARS = {
      OFF: 0,
      ON: 1
    };
    var marsByValue = {};
    for (const name in MARS) {
      const value = MARS[name];
      marsByValue[value] = name;
    }
    var PreloginPayload = class {
      constructor(bufferOrOptions = {
        encrypt: false,
        version: {
          major: 0,
          minor: 0,
          build: 0,
          subbuild: 0
        }
      }) {
        if (bufferOrOptions instanceof Buffer) {
          this.data = bufferOrOptions;
          this.options = {
            encrypt: false,
            version: {
              major: 0,
              minor: 0,
              build: 0,
              subbuild: 0
            }
          };
        } else {
          this.options = bufferOrOptions;
          this.createOptions();
        }
        this.extractOptions();
      }
      createOptions() {
        const options = [this.createVersionOption(), this.createEncryptionOption(), this.createInstanceOption(), this.createThreadIdOption(), this.createMarsOption(), this.createFedAuthOption()];
        let length = 0;
        for (let i = 0, len = options.length; i < len; i++) {
          const option = options[i];
          length += 5 + option.data.length;
        }
        length++;
        this.data = Buffer.alloc(length, 0);
        let optionOffset = 0;
        let optionDataOffset = 5 * options.length + 1;
        for (let j = 0, len = options.length; j < len; j++) {
          const option = options[j];
          this.data.writeUInt8(option.token, optionOffset + 0);
          this.data.writeUInt16BE(optionDataOffset, optionOffset + 1);
          this.data.writeUInt16BE(option.data.length, optionOffset + 3);
          optionOffset += 5;
          option.data.copy(this.data, optionDataOffset);
          optionDataOffset += option.data.length;
        }
        this.data.writeUInt8(TOKEN.TERMINATOR, optionOffset);
      }
      createVersionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(this.options.version.major);
        buffer.writeUInt8(this.options.version.minor);
        buffer.writeUInt16BE(this.options.version.build);
        buffer.writeUInt16BE(this.options.version.subbuild);
        return {
          token: TOKEN.VERSION,
          data: buffer.data
        };
      }
      createEncryptionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        if (this.options.encrypt) {
          buffer.writeUInt8(ENCRYPT.ON);
        } else {
          buffer.writeUInt8(ENCRYPT.NOT_SUP);
        }
        return {
          token: TOKEN.ENCRYPTION,
          data: buffer.data
        };
      }
      createInstanceOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(0);
        return {
          token: TOKEN.INSTOPT,
          data: buffer.data
        };
      }
      createThreadIdOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt32BE(0);
        return {
          token: TOKEN.THREADID,
          data: buffer.data
        };
      }
      createMarsOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(MARS.OFF);
        return {
          token: TOKEN.MARS,
          data: buffer.data
        };
      }
      createFedAuthOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(1);
        return {
          token: TOKEN.FEDAUTHREQUIRED,
          data: buffer.data
        };
      }
      extractOptions() {
        let offset = 0;
        while (this.data[offset] !== TOKEN.TERMINATOR) {
          let dataOffset = this.data.readUInt16BE(offset + 1);
          const dataLength = this.data.readUInt16BE(offset + 3);
          switch (this.data[offset]) {
            case TOKEN.VERSION:
              this.extractVersion(dataOffset);
              break;
            case TOKEN.ENCRYPTION:
              this.extractEncryption(dataOffset);
              break;
            case TOKEN.INSTOPT:
              this.extractInstance(dataOffset);
              break;
            case TOKEN.THREADID:
              if (dataLength > 0) {
                this.extractThreadId(dataOffset);
              }
              break;
            case TOKEN.MARS:
              this.extractMars(dataOffset);
              break;
            case TOKEN.FEDAUTHREQUIRED:
              this.extractFedAuth(dataOffset);
              break;
          }
          offset += 5;
          dataOffset += dataLength;
        }
      }
      extractVersion(offset) {
        this.version = {
          major: this.data.readUInt8(offset + 0),
          minor: this.data.readUInt8(offset + 1),
          build: this.data.readUInt16BE(offset + 2),
          subbuild: this.data.readUInt16BE(offset + 4)
        };
      }
      extractEncryption(offset) {
        this.encryption = this.data.readUInt8(offset);
        this.encryptionString = encryptByValue[this.encryption];
      }
      extractInstance(offset) {
        this.instance = this.data.readUInt8(offset);
      }
      extractThreadId(offset) {
        this.threadId = this.data.readUInt32BE(offset);
      }
      extractMars(offset) {
        this.mars = this.data.readUInt8(offset);
        this.marsString = marsByValue[this.mars];
      }
      extractFedAuth(offset) {
        this.fedAuthRequired = this.data.readUInt8(offset);
      }
      toString(indent = "") {
        return indent + "PreLogin - " + (0, _sprintfJs.sprintf)("version:%d.%d.%d.%d, encryption:0x%02X(%s), instopt:0x%02X, threadId:0x%08X, mars:0x%02X(%s)", this.version.major, this.version.minor, this.version.build, this.version.subbuild, this.encryption ? this.encryption : 0, this.encryptionString ? this.encryptionString : "", this.instance ? this.instance : 0, this.threadId ? this.threadId : 0, this.mars ? this.mars : 0, this.marsString ? this.marsString : "");
      }
    };
    var _default = exports2.default = PreloginPayload;
    module2.exports = PreloginPayload;
  }
});

// node_modules/mssql/node_modules/tedious/lib/tds-versions.js
var require_tds_versions = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/tds-versions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.versionsByValue = exports2.versions = void 0;
    var versions = exports2.versions = {
      "7_1": 1895825409,
      "7_2": 1913192450,
      "7_3_A": 1930035203,
      "7_3_B": 1930100739,
      "7_4": 1946157060,
      "8_0": 134217728
    };
    var versionsByValue = exports2.versionsByValue = {};
    for (const name in versions) {
      versionsByValue[versions[name]] = name;
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/login7-payload.js
var require_login7_payload = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/login7-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _sprintfJs = require_sprintf();
    var _tdsVersions = require_tds_versions();
    var FLAGS_1 = {
      ENDIAN_LITTLE: 0,
      ENDIAN_BIG: 1,
      CHARSET_ASCII: 0,
      CHARSET_EBCDIC: 2,
      FLOAT_IEEE_754: 0,
      FLOAT_VAX: 4,
      FLOAT_ND5000: 8,
      BCP_DUMPLOAD_ON: 0,
      BCP_DUMPLOAD_OFF: 16,
      USE_DB_ON: 0,
      USE_DB_OFF: 32,
      INIT_DB_WARN: 0,
      INIT_DB_FATAL: 64,
      SET_LANG_WARN_OFF: 0,
      SET_LANG_WARN_ON: 128
    };
    var FLAGS_2 = {
      INIT_LANG_WARN: 0,
      INIT_LANG_FATAL: 1,
      ODBC_OFF: 0,
      ODBC_ON: 2,
      F_TRAN_BOUNDARY: 4,
      F_CACHE_CONNECT: 8,
      USER_NORMAL: 0,
      USER_SERVER: 16,
      USER_REMUSER: 32,
      USER_SQLREPL: 64,
      INTEGRATED_SECURITY_OFF: 0,
      INTEGRATED_SECURITY_ON: 128
    };
    var TYPE_FLAGS = {
      SQL_DFLT: 0,
      SQL_TSQL: 8,
      OLEDB_OFF: 0,
      OLEDB_ON: 16,
      READ_WRITE_INTENT: 0,
      READ_ONLY_INTENT: 32
    };
    var FLAGS_3 = {
      CHANGE_PASSWORD_NO: 0,
      CHANGE_PASSWORD_YES: 1,
      BINARY_XML: 2,
      SPAWN_USER_INSTANCE: 4,
      UNKNOWN_COLLATION_HANDLING: 8,
      EXTENSION_USED: 16
    };
    var FEDAUTH_OPTIONS = {
      FEATURE_ID: 2,
      LIBRARY_SECURITYTOKEN: 1,
      LIBRARY_ADAL: 2,
      FEDAUTH_YES_ECHO: 1,
      FEDAUTH_NO_ECHO: 0,
      ADAL_WORKFLOW_USER_PASS: 1,
      ADAL_WORKFLOW_INTEGRATED: 2
    };
    var FEATURE_EXT_TERMINATOR = 255;
    var Login7Payload = class {
      constructor({
        tdsVersion,
        packetSize,
        clientProgVer,
        clientPid,
        connectionId,
        clientTimeZone,
        clientLcid
      }) {
        this.tdsVersion = tdsVersion;
        this.packetSize = packetSize;
        this.clientProgVer = clientProgVer;
        this.clientPid = clientPid;
        this.connectionId = connectionId;
        this.clientTimeZone = clientTimeZone;
        this.clientLcid = clientLcid;
        this.readOnlyIntent = false;
        this.initDbFatal = false;
        this.fedAuth = void 0;
        this.userName = void 0;
        this.password = void 0;
        this.serverName = void 0;
        this.appName = void 0;
        this.hostname = void 0;
        this.libraryName = void 0;
        this.language = void 0;
        this.database = void 0;
        this.clientId = void 0;
        this.sspi = void 0;
        this.attachDbFile = void 0;
        this.changePassword = void 0;
      }
      toBuffer() {
        const fixedData = Buffer.alloc(94);
        const buffers = [fixedData];
        let offset = 0;
        let dataOffset = fixedData.length;
        offset = fixedData.writeUInt32LE(0, offset);
        offset = fixedData.writeUInt32LE(this.tdsVersion, offset);
        offset = fixedData.writeUInt32LE(this.packetSize, offset);
        offset = fixedData.writeUInt32LE(this.clientProgVer, offset);
        offset = fixedData.writeUInt32LE(this.clientPid, offset);
        offset = fixedData.writeUInt32LE(this.connectionId, offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags1(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags2(), offset);
        offset = fixedData.writeUInt8(this.buildTypeFlags(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags3(), offset);
        offset = fixedData.writeInt32LE(this.clientTimeZone, offset);
        offset = fixedData.writeUInt32LE(this.clientLcid, offset);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.hostname) {
          const buffer = Buffer.from(this.hostname, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(dataOffset, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.userName) {
          const buffer = Buffer.from(this.userName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.password) {
          const buffer = Buffer.from(this.password, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(this.scramblePassword(buffer));
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.appName) {
          const buffer = Buffer.from(this.appName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.serverName) {
          const buffer = Buffer.from(this.serverName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        const extensions = this.buildFeatureExt();
        offset = fixedData.writeUInt16LE(4, offset);
        const extensionOffset = Buffer.alloc(4);
        extensionOffset.writeUInt32LE(dataOffset += 4, 0);
        dataOffset += extensions.length;
        buffers.push(extensionOffset, extensions);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.libraryName) {
          const buffer = Buffer.from(this.libraryName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.language) {
          const buffer = Buffer.from(this.language, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.database) {
          const buffer = Buffer.from(this.database, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.clientId) {
          this.clientId.copy(fixedData, offset, 0, 6);
        }
        offset += 6;
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.sspi) {
          if (this.sspi.length > 65535) {
            offset = fixedData.writeUInt16LE(65535, offset);
          } else {
            offset = fixedData.writeUInt16LE(this.sspi.length, offset);
          }
          buffers.push(this.sspi);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.attachDbFile) {
          const buffer = Buffer.from(this.attachDbFile, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.changePassword) {
          const buffer = Buffer.from(this.changePassword, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.sspi && this.sspi.length > 65535) {
          fixedData.writeUInt32LE(this.sspi.length, offset);
        } else {
          fixedData.writeUInt32LE(0, offset);
        }
        const data = Buffer.concat(buffers);
        data.writeUInt32LE(data.length, 0);
        return data;
      }
      buildOptionFlags1() {
        let flags1 = FLAGS_1.ENDIAN_LITTLE | FLAGS_1.CHARSET_ASCII | FLAGS_1.FLOAT_IEEE_754 | FLAGS_1.BCP_DUMPLOAD_OFF | FLAGS_1.USE_DB_OFF | FLAGS_1.SET_LANG_WARN_ON;
        if (this.initDbFatal) {
          flags1 |= FLAGS_1.INIT_DB_FATAL;
        } else {
          flags1 |= FLAGS_1.INIT_DB_WARN;
        }
        return flags1;
      }
      buildFeatureExt() {
        const buffers = [];
        const fedAuth = this.fedAuth;
        if (fedAuth) {
          switch (fedAuth.type) {
            case "ADAL":
              const buffer = Buffer.alloc(7);
              buffer.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, 0);
              buffer.writeUInt32LE(2, 1);
              buffer.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_ADAL << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), 5);
              buffer.writeUInt8(fedAuth.workflow === "integrated" ? 2 : FEDAUTH_OPTIONS.ADAL_WORKFLOW_USER_PASS, 6);
              buffers.push(buffer);
              break;
            case "SECURITYTOKEN":
              const token = Buffer.from(fedAuth.fedAuthToken, "ucs2");
              const buf = Buffer.alloc(10);
              let offset = 0;
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, offset);
              offset = buf.writeUInt32LE(token.length + 4 + 1, offset);
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_SECURITYTOKEN << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), offset);
              buf.writeInt32LE(token.length, offset);
              buffers.push(buf);
              buffers.push(token);
              break;
          }
        }
        if (this.tdsVersion >= _tdsVersions.versions["7_4"]) {
          const UTF8_SUPPORT_FEATURE_ID = 10;
          const UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8 = 1;
          const buf = Buffer.alloc(6);
          buf.writeUInt8(UTF8_SUPPORT_FEATURE_ID, 0);
          buf.writeUInt32LE(1, 1);
          buf.writeUInt8(UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8, 5);
          buffers.push(buf);
        }
        buffers.push(Buffer.from([FEATURE_EXT_TERMINATOR]));
        return Buffer.concat(buffers);
      }
      buildOptionFlags2() {
        let flags2 = FLAGS_2.INIT_LANG_WARN | FLAGS_2.ODBC_OFF | FLAGS_2.USER_NORMAL;
        if (this.sspi) {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_ON;
        } else {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_OFF;
        }
        return flags2;
      }
      buildTypeFlags() {
        let typeFlags = TYPE_FLAGS.SQL_DFLT | TYPE_FLAGS.OLEDB_OFF;
        if (this.readOnlyIntent) {
          typeFlags |= TYPE_FLAGS.READ_ONLY_INTENT;
        } else {
          typeFlags |= TYPE_FLAGS.READ_WRITE_INTENT;
        }
        return typeFlags;
      }
      buildOptionFlags3() {
        return FLAGS_3.CHANGE_PASSWORD_NO | FLAGS_3.UNKNOWN_COLLATION_HANDLING | FLAGS_3.EXTENSION_USED;
      }
      scramblePassword(password) {
        for (let b = 0, len = password.length; b < len; b++) {
          let byte = password[b];
          const lowNibble = byte & 15;
          const highNibble = byte >> 4;
          byte = lowNibble << 4 | highNibble;
          byte = byte ^ 165;
          password[b] = byte;
        }
        return password;
      }
      toString(indent = "") {
        return indent + "Login7 - " + (0, _sprintfJs.sprintf)("TDS:0x%08X, PacketSize:0x%08X, ClientProgVer:0x%08X, ClientPID:0x%08X, ConnectionID:0x%08X", this.tdsVersion, this.packetSize, this.clientProgVer, this.clientPid, this.connectionId) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Flags1:0x%02X, Flags2:0x%02X, TypeFlags:0x%02X, Flags3:0x%02X, ClientTimezone:%d, ClientLCID:0x%08X", this.buildOptionFlags1(), this.buildOptionFlags2(), this.buildTypeFlags(), this.buildOptionFlags3(), this.clientTimeZone, this.clientLcid) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Hostname:'%s', Username:'%s', Password:'%s', AppName:'%s', ServerName:'%s', LibraryName:'%s'", this.hostname, this.userName, this.password, this.appName, this.serverName, this.libraryName) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Language:'%s', Database:'%s', SSPI:'%s', AttachDbFile:'%s', ChangePassword:'%s'", this.language, this.database, this.sspi, this.attachDbFile, this.changePassword);
      }
    };
    var _default = exports2.default = Login7Payload;
    module2.exports = Login7Payload;
  }
});

// node_modules/js-md4/src/md4.js
var require_md4 = __commonJS({
  "node_modules/js-md4/src/md4.js"(exports2, module2) {
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.JS_MD4_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      }
      var COMMON_JS = !root.JS_MD4_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_MD4_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer"];
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer);
        blocks = new Uint32Array(buffer);
      }
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Md4(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md4();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto5 = require("crypto");
        var Buffer3 = require("buffer").Buffer;
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto5.createHash("md4").update(message, "utf8").digest("hex");
          } else if (ARRAY_BUFFER && message instanceof ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (message.length === void 0) {
            return method(message);
          }
          return crypto5.createHash("md4").update(new Buffer3(message)).digest("hex");
        };
        return nodeMethod;
      };
      function Md4(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer2 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer2);
            this.blocks = new Uint32Array(buffer2);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md4.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString = typeof message !== "string";
        if (notString && ARRAY_BUFFER && message instanceof ArrayBuffer) {
          message = new Uint8Array(message);
        }
        var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                buffer82[i++] = message[index];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  buffer82[i++] = code;
                } else if (code < 2048) {
                  buffer82[i++] = 192 | code >> 6;
                  buffer82[i++] = 128 | code & 63;
                } else if (code < 55296 || code >= 57344) {
                  buffer82[i++] = 224 | code >> 12;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  buffer82[i++] = 240 | code >> 18;
                  buffer82[i++] = 128 | code >> 12 & 63;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                }
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        return this;
      };
      Md4.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        this.hash();
      };
      Md4.prototype.hash = function() {
        var a, b, c, d, ab, bc, cd, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 1;
          a = a << 3 | a >>> 29;
          d = (a & 4023233417 | ~a & 2562383102) + blocks2[1] + 271733878;
          d = d << 7 | d >>> 25;
          c = (d & a | ~d & 4023233417) + blocks2[2] - 1732584194;
          c = c << 11 | c >>> 21;
          b = (c & d | ~c & a) + blocks2[3] - 271733879;
          b = b << 19 | b >>> 13;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (b & c | ~b & d) + blocks2[0];
          a = a << 3 | a >>> 29;
          d += (a & b | ~a & c) + blocks2[1];
          d = d << 7 | d >>> 25;
          c += (d & a | ~d & b) + blocks2[2];
          c = c << 11 | c >>> 21;
          b += (c & d | ~c & a) + blocks2[3];
          b = b << 19 | b >>> 13;
        }
        a += (b & c | ~b & d) + blocks2[4];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[5];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[6];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[7];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[8];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[9];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[10];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[11];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[12];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[13];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[14];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[15];
        b = b << 19 | b >>> 13;
        bc = b & c;
        a += (bc | b & d | c & d) + blocks2[0] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[4] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[8] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[12] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[1] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[5] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[9] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[13] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[2] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[6] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[10] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[14] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[3] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[7] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[11] + 1518500249;
        c = c << 9 | c >>> 23;
        b += (c & d | c & a | da) + blocks2[15] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[0] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[8] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[4] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[12] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[2] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[10] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[6] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[14] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[1] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[9] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[5] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[13] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[3] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[11] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[7] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[15] + 1859775393;
        b = b << 15 | b >>> 17;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md4.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
      };
      Md4.prototype.toString = Md4.prototype.hex;
      Md4.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >> 8 & 255,
          h0 >> 16 & 255,
          h0 >> 24 & 255,
          h1 & 255,
          h1 >> 8 & 255,
          h1 >> 16 & 255,
          h1 >> 24 & 255,
          h2 & 255,
          h2 >> 8 & 255,
          h2 >> 16 & 255,
          h2 >> 24 & 255,
          h3 & 255,
          h3 >> 8 & 255,
          h3 >> 16 & 255,
          h3 >> 24 & 255
        ];
      };
      Md4.prototype.array = Md4.prototype.digest;
      Md4.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer2);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer2;
      };
      Md4.prototype.buffer = Md4.prototype.arrayBuffer;
      var exports3 = createMethod();
      if (COMMON_JS) {
        module2.exports = exports3;
      } else {
        root.md4 = exports3;
        if (AMD) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/mssql/node_modules/tedious/lib/ntlm-payload.js
var require_ntlm_payload = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/ntlm-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var crypto5 = _interopRequireWildcard(require("crypto"));
    var _jsMd = _interopRequireDefault(require_md4());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NTLMResponsePayload = class {
      constructor(loginData) {
        this.data = this.createResponse(loginData);
      }
      toString(indent = "") {
        return indent + "NTLM Auth";
      }
      createResponse(challenge) {
        const client_nonce = this.createClientNonce();
        const lmv2len = 24;
        const ntlmv2len = 16;
        const domain = challenge.domain;
        const username = challenge.userName;
        const password = challenge.password;
        const ntlmData = challenge.ntlmpacket;
        const server_data = ntlmData.target;
        const server_nonce = ntlmData.nonce;
        const bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;
        const data = new _writableTrackingBuffer.default(bufferLength);
        data.position = 0;
        data.writeString("NTLMSSP\0", "utf8");
        data.writeUInt32LE(3);
        const baseIdx = 64;
        const dnIdx = baseIdx;
        const unIdx = dnIdx + domain.length * 2;
        const l2Idx = unIdx + username.length * 2;
        const ntIdx = l2Idx + lmv2len;
        data.writeUInt16LE(lmv2len);
        data.writeUInt16LE(lmv2len);
        data.writeUInt32LE(l2Idx);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt32LE(ntIdx);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt32LE(dnIdx);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt32LE(unIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(33281);
        data.writeUInt16LE(8);
        data.writeString(domain, "ucs2");
        data.writeString(username, "ucs2");
        const lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);
        data.copyFrom(lmv2Data);
        const genTime = (/* @__PURE__ */ new Date()).getTime();
        const ntlmDataBuffer = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);
        data.copyFrom(ntlmDataBuffer);
        data.writeUInt32LE(257);
        data.writeUInt32LE(0);
        const timestamp = this.createTimestamp(genTime);
        data.copyFrom(timestamp);
        data.copyFrom(client_nonce);
        data.writeUInt32LE(0);
        data.copyFrom(server_data);
        data.writeUInt32LE(0);
        return data.data;
      }
      createClientNonce() {
        const client_nonce = Buffer.alloc(8, 0);
        let nidx = 0;
        while (nidx < 8) {
          client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);
          nidx++;
        }
        return client_nonce;
      }
      ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {
        const timestamp = this.createTimestamp(mytime);
        const hash = this.ntv2Hash(domain, user, password);
        const dataLength = 40 + targetInfo.length;
        const data = Buffer.alloc(dataLength, 0);
        serverNonce.copy(data, 0, 0, 8);
        data.writeUInt32LE(257, 8);
        data.writeUInt32LE(0, 12);
        timestamp.copy(data, 16, 0, 8);
        clientNonce.copy(data, 24, 0, 8);
        data.writeUInt32LE(0, 32);
        targetInfo.copy(data, 36, 0, targetInfo.length);
        data.writeUInt32LE(0, 36 + targetInfo.length);
        return this.hmacMD5(data, hash);
      }
      createTimestamp(time) {
        const tenthsOfAMicrosecond = (BigInt(time) + BigInt(11644473600)) * BigInt(1e7);
        const lo = Number(tenthsOfAMicrosecond & BigInt(4294967295));
        const hi = Number(tenthsOfAMicrosecond >> BigInt(32) & BigInt(4294967295));
        const result = Buffer.alloc(8);
        result.writeUInt32LE(lo, 0);
        result.writeUInt32LE(hi, 4);
        return result;
      }
      lmv2Response(domain, user, password, serverNonce, clientNonce) {
        const hash = this.ntv2Hash(domain, user, password);
        const data = Buffer.alloc(serverNonce.length + clientNonce.length, 0);
        serverNonce.copy(data);
        clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);
        const newhash = this.hmacMD5(data, hash);
        const response = Buffer.alloc(newhash.length + clientNonce.length, 0);
        newhash.copy(response);
        clientNonce.copy(response, newhash.length, 0, clientNonce.length);
        return response;
      }
      ntv2Hash(domain, user, password) {
        const hash = this.ntHash(password);
        const identity = Buffer.from(user.toUpperCase() + domain.toUpperCase(), "ucs2");
        return this.hmacMD5(identity, hash);
      }
      ntHash(text) {
        const unicodeString = Buffer.from(text, "ucs2");
        return Buffer.from(_jsMd.default.arrayBuffer(unicodeString));
      }
      hmacMD5(data, key) {
        return crypto5.createHmac("MD5", key).update(data).digest();
      }
    };
    var _default = exports2.default = NTLMResponsePayload;
    module2.exports = NTLMResponsePayload;
  }
});

// node_modules/mssql/node_modules/tedious/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RequestError = exports2.InputError = exports2.ConnectionError = void 0;
    var ConnectionError = class extends Error {
      constructor(message, code, options) {
        super(message, options);
        this.code = code;
      }
    };
    exports2.ConnectionError = ConnectionError;
    var RequestError = class extends Error {
      constructor(message, code, options) {
        super(message, options);
        this.code = code;
      }
    };
    exports2.RequestError = RequestError;
    var InputError = class extends TypeError {
    };
    exports2.InputError = InputError;
  }
});

// node_modules/mssql/node_modules/tedious/lib/always-encrypted/types.js
var require_types = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/always-encrypted/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SQLServerStatementColumnEncryptionSetting = exports2.SQLServerEncryptionType = exports2.DescribeParameterEncryptionResultSet2 = exports2.DescribeParameterEncryptionResultSet1 = void 0;
    var SQLServerEncryptionType = exports2.SQLServerEncryptionType = /* @__PURE__ */ function(SQLServerEncryptionType2) {
      SQLServerEncryptionType2[SQLServerEncryptionType2["Deterministic"] = 1] = "Deterministic";
      SQLServerEncryptionType2[SQLServerEncryptionType2["Randomized"] = 2] = "Randomized";
      SQLServerEncryptionType2[SQLServerEncryptionType2["PlainText"] = 0] = "PlainText";
      return SQLServerEncryptionType2;
    }({});
    var DescribeParameterEncryptionResultSet1 = exports2.DescribeParameterEncryptionResultSet1 = /* @__PURE__ */ function(DescribeParameterEncryptionResultSet12) {
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyOrdinal"] = 0] = "KeyOrdinal";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["DbId"] = 1] = "DbId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyId"] = 2] = "KeyId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyVersion"] = 3] = "KeyVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyMdVersion"] = 4] = "KeyMdVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["EncryptedKey"] = 5] = "EncryptedKey";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["ProviderName"] = 6] = "ProviderName";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyPath"] = 7] = "KeyPath";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyEncryptionAlgorithm"] = 8] = "KeyEncryptionAlgorithm";
      return DescribeParameterEncryptionResultSet12;
    }({});
    var DescribeParameterEncryptionResultSet2 = exports2.DescribeParameterEncryptionResultSet2 = /* @__PURE__ */ function(DescribeParameterEncryptionResultSet22) {
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterOrdinal"] = 0] = "ParameterOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterName"] = 1] = "ParameterName";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionAlgorithm"] = 2] = "ColumnEncryptionAlgorithm";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncrytionType"] = 3] = "ColumnEncrytionType";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionKeyOrdinal"] = 4] = "ColumnEncryptionKeyOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["NormalizationRuleVersion"] = 5] = "NormalizationRuleVersion";
      return DescribeParameterEncryptionResultSet22;
    }({});
    var SQLServerStatementColumnEncryptionSetting = exports2.SQLServerStatementColumnEncryptionSetting = /* @__PURE__ */ function(SQLServerStatementColumnEncryptionSetting2) {
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["UseConnectionSetting"] = 0] = "UseConnectionSetting";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Enabled"] = 1] = "Enabled";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["ResultSetOnly"] = 2] = "ResultSetOnly";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Disabled"] = 3] = "Disabled";
      return SQLServerStatementColumnEncryptionSetting2;
    }({});
  }
});

// node_modules/mssql/node_modules/tedious/lib/request.js
var require_request2 = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/request.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _events = require("events");
    var _errors = require_errors2();
    var _types = require_types();
    var Request = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * This event, describing result set columns, will be emitted before row
       * events are emitted. This event may be emitted multiple times when more
       * than one recordset is produced by the statement.
       *
       * An array like object, where the columns can be accessed either by index
       * or name. Columns with a name that is an integer are not accessible by name,
       * as it would be interpreted as an array index.
       */
      /**
       * The request has been prepared and can be used in subsequent calls to execute and unprepare.
       */
      /**
       * The request encountered an error and has not been prepared.
       */
      /**
       * A row resulting from execution of the SQL statement.
       */
      /**
       * All rows from a result set have been provided (through `row` events).
       *
       * This token is used to indicate the completion of a SQL statement.
       * As multiple SQL statements can be sent to the server in a single SQL batch, multiple `done` can be generated.
       * An `done` event is emitted for each SQL statement in the SQL batch except variable declarations.
       * For execution of SQL statements within stored procedures, `doneProc` and `doneInProc` events are used in place of `done`.
       *
       * If you are using [[Connection.execSql]] then SQL server may treat the multiple calls with the same query as a stored procedure.
       * When this occurs, the `doneProc` and `doneInProc` events may be emitted instead. You must handle both events to ensure complete coverage.
       */
      /**
       * `request.on('doneInProc', function (rowCount, more, rows) { });`
       *
       * Indicates the completion status of a SQL statement within a stored procedure. All rows from a statement
       * in a stored procedure have been provided (through `row` events).
       *
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * Indicates the completion status of a stored procedure. This is also generated for stored procedures
       * executed through SQL statements.\
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * A value for an output parameter (that was added to the request with [[addOutputParameter]]).
       * See also `Using Parameters`.
       */
      /**
       * This event gives the columns by which data is ordered, if `ORDER BY` clause is executed in SQL Server.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * @param sqlTextOrProcedure
       *   The SQL statement to be executed
       *
       * @param callback
       *   The callback to execute once the request has been fully completed.
       */
      constructor(sqlTextOrProcedure, callback, options) {
        super();
        this.sqlTextOrProcedure = sqlTextOrProcedure;
        this.parameters = [];
        this.parametersByName = {};
        this.preparing = false;
        this.handle = void 0;
        this.canceled = false;
        this.paused = false;
        this.error = void 0;
        this.connection = void 0;
        this.timeout = void 0;
        this.userCallback = callback;
        this.statementColumnEncryptionSetting = options && options.statementColumnEncryptionSetting || _types.SQLServerStatementColumnEncryptionSetting.UseConnectionSetting;
        this.cryptoMetadataLoaded = false;
        this.callback = function(err, rowCount, rows) {
          if (this.preparing) {
            this.preparing = false;
            if (err) {
              this.emit("error", err);
            } else {
              this.emit("prepared");
            }
          } else {
            this.userCallback(err, rowCount, rows);
            this.emit("requestCompleted");
          }
        };
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects. The name should not start with `@`.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types.
       *
       * @param options
       *   Additional type options. Optional.
       */
      // TODO: `type` must be a valid TDS value type
      addParameter(name, type, value, options) {
        const {
          output = false,
          length,
          precision,
          scale
        } = options ?? {};
        const parameter = {
          type,
          name,
          value,
          output,
          length,
          precision,
          scale
        };
        this.parameters.push(parameter);
        this.parametersByName[name] = parameter;
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types
       *
       * @param options
       *   Additional type options. Optional.
       */
      addOutputParameter(name, type, value, options) {
        this.addParameter(name, type, value, {
          ...options,
          output: true
        });
      }
      /**
       * @private
       */
      makeParamsParameter(parameters) {
        let paramsParameter = "";
        for (let i = 0, len = parameters.length; i < len; i++) {
          const parameter = parameters[i];
          if (paramsParameter.length > 0) {
            paramsParameter += ", ";
          }
          paramsParameter += "@" + parameter.name + " ";
          paramsParameter += parameter.type.declaration(parameter);
          if (parameter.output) {
            paramsParameter += " OUTPUT";
          }
        }
        return paramsParameter;
      }
      /**
       * @private
       */
      validateParameters(collation) {
        for (let i = 0, len = this.parameters.length; i < len; i++) {
          const parameter = this.parameters[i];
          try {
            parameter.value = parameter.type.validate(parameter.value, collation);
          } catch (error) {
            throw new _errors.RequestError("Validation failed for parameter '" + parameter.name + "'. " + error.message, "EPARAM", {
              cause: error
            });
          }
        }
      }
      /**
       * Temporarily suspends the flow of data from the database. No more `row` events will be emitted until [[resume] is called.
       * If this request is already in a paused state, calling [[pause]] has no effect.
       */
      pause() {
        if (this.paused) {
          return;
        }
        this.emit("pause");
        this.paused = true;
      }
      /**
       * Resumes the flow of data from the database.
       * If this request is not in a paused state, calling [[resume]] has no effect.
       */
      resume() {
        if (!this.paused) {
          return;
        }
        this.paused = false;
        this.emit("resume");
      }
      /**
       * Cancels a request while waiting for a server response.
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
      /**
       * Sets a timeout for this request.
       *
       * @param timeout
       *   The number of milliseconds before the request is considered failed,
       *   or `0` for no timeout. When no timeout is set for the request,
       *   the [[ConnectionOptions.requestTimeout]] of the [[Connection]] is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
    };
    var _default = exports2.default = Request;
    module2.exports = Request;
  }
});

// node_modules/mssql/node_modules/tedious/lib/all-headers.js
var require_all_headers = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/all-headers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.writeToTrackingBuffer = writeToTrackingBuffer;
    var TYPE = {
      QUERY_NOTIFICATIONS: 1,
      TXN_DESCRIPTOR: 2,
      TRACE_ACTIVITY: 3
    };
    var TXNDESCRIPTOR_HEADER_DATA_LEN = 4 + 8;
    var TXNDESCRIPTOR_HEADER_LEN = 4 + 2 + TXNDESCRIPTOR_HEADER_DATA_LEN;
    function writeToTrackingBuffer(buffer, txnDescriptor, outstandingRequestCount) {
      buffer.writeUInt32LE(0);
      buffer.writeUInt32LE(TXNDESCRIPTOR_HEADER_LEN);
      buffer.writeUInt16LE(TYPE.TXN_DESCRIPTOR);
      buffer.writeBuffer(txnDescriptor);
      buffer.writeUInt32LE(outstandingRequestCount);
      const data = buffer.data;
      data.writeUInt32LE(data.length, 0);
      return buffer;
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/rpcrequest-payload.js
var require_rpcrequest_payload = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/rpcrequest-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    var _errors = require_errors2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var STATUS = {
      BY_REF_VALUE: 1,
      DEFAULT_VALUE: 2
    };
    var RpcRequestPayload = class {
      constructor(procedure, parameters, txnDescriptor, options, collation) {
        this.procedure = procedure;
        this.parameters = parameters;
        this.options = options;
        this.txnDescriptor = txnDescriptor;
        this.collation = collation;
      }
      [Symbol.iterator]() {
        return this.generateData();
      }
      *generateData() {
        const buffer = new _writableTrackingBuffer.default(500);
        if (this.options.tdsVersion >= "7_2") {
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
        }
        if (typeof this.procedure === "string") {
          buffer.writeUsVarchar(this.procedure);
        } else {
          buffer.writeUShort(65535);
          buffer.writeUShort(this.procedure);
        }
        const optionFlags = 0;
        buffer.writeUInt16LE(optionFlags);
        yield buffer.data;
        const parametersLength = this.parameters.length;
        for (let i = 0; i < parametersLength; i++) {
          yield* this.generateParameterData(this.parameters[i]);
        }
      }
      toString(indent = "") {
        return indent + ("RPC Request - " + this.procedure);
      }
      *generateParameterData(parameter) {
        const buffer = new _writableTrackingBuffer.default(1 + 2 + Buffer.byteLength(parameter.name, "ucs-2") + 1);
        if (parameter.name) {
          buffer.writeBVarchar("@" + parameter.name);
        } else {
          buffer.writeBVarchar("");
        }
        let statusFlags = 0;
        if (parameter.output) {
          statusFlags |= STATUS.BY_REF_VALUE;
        }
        buffer.writeUInt8(statusFlags);
        yield buffer.data;
        const param = {
          value: parameter.value
        };
        const type = parameter.type;
        if ((type.id & 48) === 32) {
          if (parameter.length) {
            param.length = parameter.length;
          } else if (type.resolveLength) {
            param.length = type.resolveLength(parameter);
          }
        }
        if (parameter.precision) {
          param.precision = parameter.precision;
        } else if (type.resolvePrecision) {
          param.precision = type.resolvePrecision(parameter);
        }
        if (parameter.scale) {
          param.scale = parameter.scale;
        } else if (type.resolveScale) {
          param.scale = type.resolveScale(parameter);
        }
        if (this.collation) {
          param.collation = this.collation;
        }
        yield type.generateTypeInfo(param, this.options);
        yield type.generateParameterLength(param, this.options);
        try {
          yield* type.generateParameterData(param, this.options);
        } catch (error) {
          throw new _errors.InputError(`Input parameter '${parameter.name}' could not be validated`, {
            cause: error
          });
        }
      }
    };
    var _default = exports2.default = RpcRequestPayload;
    module2.exports = RpcRequestPayload;
  }
});

// node_modules/mssql/node_modules/tedious/lib/sqlbatch-payload.js
var require_sqlbatch_payload = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/sqlbatch-payload.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SqlBatchPayload = class {
      constructor(sqlText, txnDescriptor, options) {
        this.sqlText = sqlText;
        this.txnDescriptor = txnDescriptor;
        this.options = options;
      }
      *[Symbol.iterator]() {
        if (this.options.tdsVersion >= "7_2") {
          const buffer = new _writableTrackingBuffer.default(18, "ucs2");
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
          yield buffer.data;
        }
        yield Buffer.from(this.sqlText, "ucs2");
      }
      toString(indent = "") {
        return indent + ("SQL Batch - " + this.sqlText);
      }
    };
    var _default = exports2.default = SqlBatchPayload;
    module2.exports = SqlBatchPayload;
  }
});

// node_modules/native-duplexpair/index.js
var require_native_duplexpair = __commonJS({
  "node_modules/native-duplexpair/index.js"(exports2, module2) {
    "use strict";
    var Duplex = require("stream").Duplex;
    var kCallback = Symbol("Callback");
    var kOtherSide = Symbol("Other");
    var DuplexSocket = class extends Duplex {
      constructor(options) {
        super(options);
        this[kCallback] = null;
        this[kOtherSide] = null;
      }
      _read() {
        const callback = this[kCallback];
        if (callback) {
          this[kCallback] = null;
          callback();
        }
      }
      _write(chunk, encoding, callback) {
        this[kOtherSide][kCallback] = callback;
        this[kOtherSide].push(chunk);
      }
      _final(callback) {
        this[kOtherSide].on("end", callback);
        this[kOtherSide].push(null);
      }
    };
    var DuplexPair = class {
      constructor(options) {
        this.socket1 = new DuplexSocket(options);
        this.socket2 = new DuplexSocket(options);
        this.socket1[kOtherSide] = this.socket2;
        this.socket2[kOtherSide] = this.socket1;
      }
    };
    module2.exports = DuplexPair;
  }
});

// node_modules/mssql/node_modules/tedious/lib/message.js
var require_message = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/message.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _stream = require("stream");
    var Message = class extends _stream.PassThrough {
      constructor({
        type,
        resetConnection = false
      }) {
        super();
        this.type = type;
        this.resetConnection = resetConnection;
        this.ignore = false;
      }
    };
    var _default = exports2.default = Message;
    module2.exports = Message;
  }
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/readable-stream/lib/ours/primordials.js"(exports2, module2) {
    "use strict";
    var AggregateError2 = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module2.exports = {
      AggregateError: AggregateError2,
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect2 = __commonJS({
  "node_modules/readable-stream/lib/ours/util/inspect.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      }
    };
  }
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors3 = __commonJS({
  "node_modules/readable-stream/lib/ours/errors.js"(exports2, module2) {
    "use strict";
    var { format, inspect } = require_inspect2();
    var { AggregateError: CustomAggregateError } = require_primordials();
    var AggregateError2 = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError2([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          const limit = BigInt(2) ** BigInt(32);
          if (input > limit || input < -limit) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/event-target-shim/dist/event-target-shim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types[i] = arguments[i];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/abort-controller/dist/abort-controller.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal2 = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal2.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports2.AbortController = AbortController2;
    exports2.AbortSignal = AbortSignal2;
    exports2.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports["default"] = AbortController2;
    module2.exports.AbortSignal = AbortSignal2;
  }
});

// node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/readable-stream/lib/ours/util.js"(exports2, module2) {
    "use strict";
    var bufferModule = require("buffer");
    var { format, inspect } = require_inspect2();
    var {
      codes: { ERR_INVALID_ARG_TYPE }
    } = require_errors3();
    var { kResistStopPropagation, AggregateError: AggregateError2, SymbolDispose } = require_primordials();
    var AbortSignal2 = globalThis.AbortSignal || require_abort_controller().AbortSignal;
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var validateAbortSignal = (signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name) => {
      if (typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
      }
    };
    module2.exports = {
      AggregateError: AggregateError2,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format,
      inspect,
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: require("events").addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal2.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController2();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/readable-stream/lib/internal/validators.js"(exports2, module2) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors3();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module2.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/process/index.js
var require_process = __commonJS({
  "node_modules/process/index.js"(exports2, module2) {
    module2.exports = global.process;
  }
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils6 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/utils.js"(exports2, module2) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module2.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var process8 = require_process();
    var { AbortError, codes } = require_errors3();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils6();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process8.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process8.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process8.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process8.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process8.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process8.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process8.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process8.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var process8 = require_process();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors3();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils6();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process8.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process8.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process8.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process8.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process8.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process8.nextTick(onConstruct, err);
        });
      } catch (err) {
        process8.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process8.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process8.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process8.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module2.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/legacy.js"(exports2, module2) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require("events");
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports2, module2) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError, codes } = require_errors3();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils6();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer3 } = require("buffer");
    var { inspect } = require_util();
    module2.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer3.alloc(0);
        const ret = Buffer3.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer3.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state3 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors3().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var isEncoding = Buffer3.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    var process8 = require_process();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer3 } = require("buffer");
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors3().codes;
    function from(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer3) {
        return new Readable({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process8.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process8.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/readable.js"(exports2, module2) {
    "use strict";
    var process8 = require_process();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module2.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = require("events");
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer3 } = require("buffer");
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state3();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = require_errors3();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value)
            this.state |= bit;
          else
            this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode)
        this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false)
        this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer3.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if ((state.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0)
          state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process8.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process8.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process8.stdout && dest !== process8.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process8.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process8.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process8.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process8.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process8.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process8.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process8.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable.from = function(iterable, opts) {
      return from(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/writable.js"(exports2, module2) {
    "use strict";
    var process8 = require_process();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require("events");
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer3 } = require("buffer");
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state3();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors3().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer3) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process8.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer3.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process8.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process8.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process8.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process8.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process8.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process8.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports2, module2) {
    var process8 = require_process();
    var bufferModule = require("buffer");
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils6();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors3();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module2.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process8.nextTick(cb, null);
                } catch (err) {
                  process8.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process8.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplex.js"(exports2, module2) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module2.exports = Duplex;
    var Readable = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/transform.js"(exports2, module2) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors3().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state3();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports2, module2) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline4 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    var process8 = require_process();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors3();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils6();
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var PassThrough;
    var Readable;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable) {
        Readable = require_readable();
      }
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || require_util().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process8.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process8.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process8.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process8.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process8.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module2.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/compose.js"(exports2, module2) {
    "use strict";
    var { pipeline } = require_pipeline4();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils6();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors3();
    var eos = require_end_of_stream();
    module2.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/operators.js"(exports2, module2) {
    "use strict";
    var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors3();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils6();
    var { deprecate } = require_util();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return async function* map2() {
        const signal = require_util().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module2.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/readable-stream/lib/stream/promises.js"(exports2, module2) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils6();
    var { pipelineImpl: pl } = require_pipeline4();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module2.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer3 } = require("buffer");
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors3();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state3();
    var { pipeline } = require_pipeline4();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils6();
    var Stream = module2.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS({
  "node_modules/readable-stream/lib/ours/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    if (Stream && process.env.READABLE_STREAM === "disable") {
      const promises = Stream.promises;
      module2.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = Stream._isUint8Array;
      module2.exports.isDisturbed = Stream.isDisturbed;
      module2.exports.isErrored = Stream.isErrored;
      module2.exports.isReadable = Stream.isReadable;
      module2.exports.Readable = Stream.Readable;
      module2.exports.Writable = Stream.Writable;
      module2.exports.Duplex = Stream.Duplex;
      module2.exports.Transform = Stream.Transform;
      module2.exports.PassThrough = Stream.PassThrough;
      module2.exports.addAbortSignal = Stream.addAbortSignal;
      module2.exports.finished = Stream.finished;
      module2.exports.destroy = Stream.destroy;
      module2.exports.pipeline = Stream.pipeline;
      module2.exports.compose = Stream.compose;
      Object.defineProperty(Stream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = Stream.Stream;
    } else {
      const CustomStream = require_stream();
      const promises = require_promises();
      const originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable;
      module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = CustomStream._isUint8Array;
      module2.exports.isDisturbed = CustomStream.isDisturbed;
      module2.exports.isErrored = CustomStream.isErrored;
      module2.exports.isReadable = CustomStream.isReadable;
      module2.exports.Readable = CustomStream.Readable;
      module2.exports.Writable = CustomStream.Writable;
      module2.exports.Duplex = CustomStream.Duplex;
      module2.exports.Transform = CustomStream.Transform;
      module2.exports.PassThrough = CustomStream.PassThrough;
      module2.exports.addAbortSignal = CustomStream.addAbortSignal;
      module2.exports.finished = CustomStream.finished;
      module2.exports.destroy = CustomStream.destroy;
      module2.exports.destroy = originalDestroy;
      module2.exports.pipeline = CustomStream.pipeline;
      module2.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer3 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.getBuffers = function getBuffers() {
      return this._bufs;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer3.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer3.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer3.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer3.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      return this._attach(buf, BufferList.prototype._appendBuffer);
    };
    BufferList.prototype.prepend = function prepend(buf) {
      return this._attach(buf, BufferList.prototype._prependBuffer, true);
    };
    BufferList.prototype._attach = function _attach(buf, attacher, prepend) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        attacher.call(this, Buffer3.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        const [starting, modifier] = prepend ? [buf.length - 1, -1] : [0, 1];
        for (let i = starting; i >= 0 && i < buf.length; i += modifier) {
          this._attach(buf[i], attacher, prepend);
        }
      } else if (this._isBufferList(buf)) {
        const [starting, modifier] = prepend ? [buf._bufs.length - 1, -1] : [0, 1];
        for (let i = starting; i >= 0 && i < buf._bufs.length; i += modifier) {
          this._attach(buf._bufs[i], attacher, prepend);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        attacher.call(this, Buffer3.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._prependBuffer = function prependBuffer(buf) {
      this._bufs.unshift(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer3.from([search]);
      } else if (typeof search === "string") {
        search = Buffer3.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer3.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer3.isBuffer(search)) {
        search = Buffer3.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readBigInt64BE: 8,
        readBigInt64LE: 8,
        readBigUInt64BE: 8,
        readBigUInt64LE: 8,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_ours().Duplex;
    var inherits = require_inherits();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream;
    module2.exports.BufferListStream = BufferListStream;
    module2.exports.BufferList = BufferList;
  }
});

// node_modules/mssql/node_modules/tedious/lib/incoming-message-stream.js
var require_incoming_message_stream = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/incoming-message-stream.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = require("stream");
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _errors = require_errors2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IncomingMessageStream = class extends _stream.Transform {
      constructor(debug) {
        super({
          readableObjectMode: true
        });
        this.debug = debug;
        this.currentMessage = void 0;
        this.bl = new _bl.default();
      }
      pause() {
        super.pause();
        if (this.currentMessage) {
          this.currentMessage.pause();
        }
        return this;
      }
      resume() {
        super.resume();
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
        return this;
      }
      processBufferedData(callback) {
        while (this.bl.length >= _packet.HEADER_LENGTH) {
          const length = this.bl.readUInt16BE(2);
          if (length < _packet.HEADER_LENGTH) {
            return callback(new _errors.ConnectionError("Unable to process incoming packet"));
          }
          if (this.bl.length >= length) {
            const data = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(data);
            this.debug.packet("Received", packet);
            this.debug.data(packet);
            let message = this.currentMessage;
            if (message === void 0) {
              this.currentMessage = message = new _message.default({
                type: packet.type(),
                resetConnection: false
              });
              this.push(message);
            }
            if (packet.isLast()) {
              message.once("end", () => {
                this.currentMessage = void 0;
                this.processBufferedData(callback);
              });
              message.end(packet.data());
              return;
            } else if (!message.write(packet.data())) {
              message.once("drain", () => {
                this.processBufferedData(callback);
              });
              return;
            }
          } else {
            break;
          }
        }
        callback();
      }
      _transform(chunk, _encoding, callback) {
        this.bl.append(chunk);
        this.processBufferedData(callback);
      }
    };
    var _default = exports2.default = IncomingMessageStream;
    module2.exports = IncomingMessageStream;
  }
});

// node_modules/mssql/node_modules/tedious/lib/outgoing-message-stream.js
var require_outgoing_message_stream = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/outgoing-message-stream.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = require("stream");
    var _packet = require_packet();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OutgoingMessageStream = class extends _stream.Duplex {
      constructor(debug, {
        packetSize
      }) {
        super({
          writableObjectMode: true
        });
        this.packetSize = packetSize;
        this.debug = debug;
        this.bl = new _bl.default();
        this.on("finish", () => {
          this.push(null);
        });
      }
      _write(message, _encoding, callback) {
        const length = this.packetSize - _packet.HEADER_LENGTH;
        let packetNumber = 0;
        this.currentMessage = message;
        this.currentMessage.on("data", (data) => {
          if (message.ignore) {
            return;
          }
          this.bl.append(data);
          while (this.bl.length > length) {
            const data2 = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(message.type);
            packet.packetId(packetNumber += 1);
            packet.resetConnection(message.resetConnection);
            packet.addData(data2);
            this.debug.packet("Sent", packet);
            this.debug.data(packet);
            if (this.push(packet.buffer) === false) {
              message.pause();
            }
          }
        });
        this.currentMessage.on("end", () => {
          const data = this.bl.slice();
          this.bl.consume(data.length);
          const packet = new _packet.Packet(message.type);
          packet.packetId(packetNumber += 1);
          packet.resetConnection(message.resetConnection);
          packet.last(true);
          packet.ignore(message.ignore);
          packet.addData(data);
          this.debug.packet("Sent", packet);
          this.debug.data(packet);
          this.push(packet.buffer);
          this.currentMessage = void 0;
          callback();
        });
      }
      _read(_size) {
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
      }
    };
    var _default = exports2.default = OutgoingMessageStream;
    module2.exports = OutgoingMessageStream;
  }
});

// node_modules/mssql/node_modules/tedious/lib/message-io.js
var require_message_io = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/message-io.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _nativeDuplexpair = _interopRequireDefault(require_native_duplexpair());
    var tls = _interopRequireWildcard(require("tls"));
    var _events = require("events");
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _incomingMessageStream = _interopRequireDefault(require_incoming_message_stream());
    var _outgoingMessageStream = _interopRequireDefault(require_outgoing_message_stream());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MessageIO = class extends _events.EventEmitter {
      constructor(socket, packetSize, debug) {
        super();
        this.socket = socket;
        this.debug = debug;
        this.tlsNegotiationComplete = false;
        this.incomingMessageStream = new _incomingMessageStream.default(this.debug);
        this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();
        this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {
          packetSize
        });
        this.socket.pipe(this.incomingMessageStream);
        this.outgoingMessageStream.pipe(this.socket);
      }
      packetSize(...args) {
        if (args.length > 0) {
          const packetSize = args[0];
          this.debug.log("Packet size changed from " + this.outgoingMessageStream.packetSize + " to " + packetSize);
          this.outgoingMessageStream.packetSize = packetSize;
        }
        if (this.securePair) {
          this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
        }
        return this.outgoingMessageStream.packetSize;
      }
      // Negotiate TLS encryption.
      startTls(credentialsDetails, hostname, trustServerCertificate) {
        if (!credentialsDetails.maxVersion || !["TLSv1.2", "TLSv1.1", "TLSv1"].includes(credentialsDetails.maxVersion)) {
          credentialsDetails.maxVersion = "TLSv1.2";
        }
        const secureContext = tls.createSecureContext(credentialsDetails);
        return new Promise((resolve, reject) => {
          const duplexpair = new _nativeDuplexpair.default();
          const securePair = this.securePair = {
            cleartext: tls.connect({
              socket: duplexpair.socket1,
              servername: hostname,
              secureContext,
              rejectUnauthorized: !trustServerCertificate
            }),
            encrypted: duplexpair.socket2
          };
          const onSecureConnect = () => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.once("error", (err) => {
              this.socket.destroy(err);
            });
            const cipher = securePair.cleartext.getCipher();
            if (cipher) {
              this.debug.log("TLS negotiated (" + cipher.name + ", " + cipher.version + ")");
            }
            this.emit("secure", securePair.cleartext);
            securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
            this.outgoingMessageStream.unpipe(this.socket);
            this.socket.unpipe(this.incomingMessageStream);
            this.socket.pipe(securePair.encrypted);
            securePair.encrypted.pipe(this.socket);
            securePair.cleartext.pipe(this.incomingMessageStream);
            this.outgoingMessageStream.pipe(securePair.cleartext);
            this.tlsNegotiationComplete = true;
            resolve();
          };
          const onError = (err) => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.destroy();
            securePair.encrypted.destroy();
            reject(err);
          };
          const onReadable = () => {
            const message = new _message.default({
              type: _packet.TYPE.PRELOGIN,
              resetConnection: false
            });
            let chunk;
            while (chunk = securePair.encrypted.read()) {
              message.write(chunk);
            }
            this.outgoingMessageStream.write(message);
            message.end();
            this.readMessage().then(async (response) => {
              securePair.encrypted.once("readable", onReadable);
              for await (const data of response) {
                securePair.encrypted.write(data);
              }
            }).catch(onError);
          };
          securePair.cleartext.once("error", onError);
          securePair.cleartext.once("secureConnect", onSecureConnect);
          securePair.encrypted.once("readable", onReadable);
        });
      }
      // TODO listen for 'drain' event when socket.write returns false.
      // TODO implement incomplete request cancelation (2.2.1.6)
      sendMessage(packetType, data, resetConnection) {
        const message = new _message.default({
          type: packetType,
          resetConnection
        });
        message.end(data);
        this.outgoingMessageStream.write(message);
        return message;
      }
      /**
       * Read the next incoming message from the socket.
       */
      async readMessage() {
        const result = await this.incomingMessageIterator.next();
        if (result.done) {
          throw new Error("unexpected end of message stream");
        }
        return result.value;
      }
    };
    var _default = exports2.default = MessageIO;
    module2.exports = MessageIO;
  }
});

// node_modules/mssql/node_modules/tedious/lib/collation.js
var require_collation = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/collation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.codepageBySortId = exports2.codepageByLanguageId = exports2.Flags = exports2.Collation = void 0;
    var codepageByLanguageId = exports2.codepageByLanguageId = {
      // Arabic_*
      [1025]: "CP1256",
      // Chinese_Taiwan_Stroke_*
      // Chinese_Traditional_Stroke_Count_*
      // Chinese_Taiwan_Bopomofo_*
      // Chinese_Traditional_Bopomofo_*
      [1028]: "CP950",
      // Czech_*
      [1029]: "CP1250",
      // Danish_Greenlandic_*
      // Danish_Norwegian_*
      [1030]: "CP1252",
      // Greek_*
      [1032]: "CP1253",
      // Latin1_General_*
      [1033]: "CP1252",
      // Traditional_Spanish_*
      [1034]: "CP1252",
      // Finnish_Swedish_*
      [1035]: "CP1252",
      // French_*
      [1036]: "CP1252",
      // Hebrew_*
      [1037]: "CP1255",
      // Hungarian_*
      // Hungarian_Technical_*
      [1038]: "CP1250",
      // Icelandic_*
      [1039]: "CP1252",
      // Japanese_*
      // Japanese_XJIS_*
      // Japanese_Unicode_*
      // Japanese_Bushu_Kakusu_*
      [1041]: "CP932",
      // Korean_*
      // Korean_Wansung_*
      [1042]: "CP949",
      // Norwegian_*
      [1044]: "CP1252",
      // Polish_*
      [1045]: "CP1250",
      // Romansh_*
      [1047]: "CP1252",
      // Romanian_*
      [1048]: "CP1250",
      // Cyrillic_*
      [1049]: "CP1251",
      // Croatian_*
      [1050]: "CP1250",
      // Slovak_*
      [1051]: "CP1250",
      // Albanian_*
      [1052]: "CP1250",
      // Thai_*
      [1054]: "CP874",
      // Turkish_*
      [1055]: "CP1254",
      // Urdu_*
      [1056]: "CP1256",
      // Ukrainian_*
      [1058]: "CP1251",
      // Slovenian_*
      [1060]: "CP1250",
      // Estonian_*
      [1061]: "CP1257",
      // Latvian_*
      [1062]: "CP1257",
      // Lithuanian_*
      [1063]: "CP1257",
      // Persian_*
      [1065]: "CP1256",
      // Vietnamese_*
      [1066]: "CP1258",
      // Azeri_Latin_*
      [1068]: "CP1254",
      // Upper_Sorbian_*
      [1070]: "CP1252",
      // Macedonian_FYROM_*
      [1071]: "CP1251",
      // Sami_Norway_*
      [1083]: "CP1252",
      // Kazakh_*
      [1087]: "CP1251",
      // Turkmen_*
      [1090]: "CP1250",
      // Uzbek_Latin_*
      [1091]: "CP1254",
      // Tatar_*
      [1092]: "CP1251",
      // Welsh_*
      [1106]: "CP1252",
      // Frisian_*
      [1122]: "CP1252",
      // Bashkir_*
      [1133]: "CP1251",
      // Mapudungan_*
      [1146]: "CP1252",
      // Mohawk_*
      [1148]: "CP1252",
      // Breton_*
      [1150]: "CP1252",
      // Uighur_*
      [1152]: "CP1256",
      // Corsican_*
      [1155]: "CP1252",
      // Yakut_*
      [1157]: "CP1251",
      // Dari_*
      [1164]: "CP1256",
      // Chinese_PRC_*
      // Chinese_Simplified_Pinyin_*
      // Chinese_PRC_Stroke_*
      // Chinese_Simplified_Stroke_Order_*
      [2052]: "CP936",
      // Serbian_Latin_*
      [2074]: "CP1250",
      // Azeri_Cyrillic_*
      [2092]: "CP1251",
      // Sami_Sweden_Finland_*
      [2107]: "CP1252",
      // Tamazight_*
      [2143]: "CP1252",
      // Chinese_Hong_Kong_Stroke_*
      [3076]: "CP950",
      // Modern_Spanish_*
      [3082]: "CP1252",
      // Serbian_Cyrillic_*
      [3098]: "CP1251",
      // Chinese_Traditional_Pinyin_*
      // Chinese_Traditional_Stroke_Order_*
      [5124]: "CP950",
      // Bosnian_Latin_*
      [5146]: "CP1250",
      // Bosnian_Cyrillic_*
      [8218]: "CP1251",
      // German
      // German_PhoneBook_*
      [1031]: "CP1252",
      // Georgian_Modern_Sort_*
      [1079]: "CP1252"
    };
    var codepageBySortId = exports2.codepageBySortId = {
      [30]: "CP437",
      // SQL_Latin1_General_CP437_BIN
      [31]: "CP437",
      // SQL_Latin1_General_CP437_CS_AS
      [32]: "CP437",
      // SQL_Latin1_General_CP437_CI_AS
      [33]: "CP437",
      // SQL_Latin1_General_Pref_CP437_CI_AS
      [34]: "CP437",
      // SQL_Latin1_General_CP437_CI_AI
      [40]: "CP850",
      // SQL_Latin1_General_CP850_BIN
      [41]: "CP850",
      // SQL_Latin1_General_CP850_CS_AS
      [42]: "CP850",
      // SQL_Latin1_General_CP850_CI_AS
      [43]: "CP850",
      // SQL_Latin1_General_Pref_CP850_CI_AS
      [44]: "CP850",
      // SQL_Latin1_General_CP850_CI_AI
      [49]: "CP850",
      // SQL_1xCompat_CP850_CI_AS
      [51]: "CP1252",
      // SQL_Latin1_General_Cp1_CS_AS_KI_WI
      [52]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AS_KI_WI
      [53]: "CP1252",
      // SQL_Latin1_General_Pref_Cp1_CI_AS_KI_WI
      [54]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AI_KI_WI
      [55]: "CP850",
      // SQL_AltDiction_CP850_CS_AS
      [56]: "CP850",
      // SQL_AltDiction_Pref_CP850_CI_AS
      [57]: "CP850",
      // SQL_AltDiction_CP850_CI_AI
      [58]: "CP850",
      // SQL_Scandinavian_Pref_CP850_CI_AS
      [59]: "CP850",
      // SQL_Scandinavian_CP850_CS_AS
      [60]: "CP850",
      // SQL_Scandinavian_CP850_CI_AS
      [61]: "CP850",
      // SQL_AltDiction_CP850_CI_AS
      [80]: "CP1250",
      // SQL_Latin1_General_1250_BIN
      [81]: "CP1250",
      // SQL_Latin1_General_CP1250_CS_AS
      [82]: "CP1250",
      // SQL_Latin1_General_Cp1250_CI_AS_KI_WI
      [83]: "CP1250",
      // SQL_Czech_Cp1250_CS_AS_KI_WI
      [84]: "CP1250",
      // SQL_Czech_Cp1250_CI_AS_KI_WI
      [85]: "CP1250",
      // SQL_Hungarian_Cp1250_CS_AS_KI_WI
      [86]: "CP1250",
      // SQL_Hungarian_Cp1250_CI_AS_KI_WI
      [87]: "CP1250",
      // SQL_Polish_Cp1250_CS_AS_KI_WI
      [88]: "CP1250",
      // SQL_Polish_Cp1250_CI_AS_KI_WI
      [89]: "CP1250",
      // SQL_Romanian_Cp1250_CS_AS_KI_WI
      [90]: "CP1250",
      // SQL_Romanian_Cp1250_CI_AS_KI_WI
      [91]: "CP1250",
      // SQL_Croatian_Cp1250_CS_AS_KI_WI
      [92]: "CP1250",
      // SQL_Croatian_Cp1250_CI_AS_KI_WI
      [93]: "CP1250",
      // SQL_Slovak_Cp1250_CS_AS_KI_WI
      [94]: "CP1250",
      // SQL_Slovak_Cp1250_CI_AS_KI_WI
      [95]: "CP1250",
      // SQL_Slovenian_Cp1250_CS_AS_KI_WI
      [96]: "CP1250",
      // SQL_Slovenian_Cp1250_CI_AS_KI_WI
      [104]: "CP1251",
      // SQL_Latin1_General_1251_BIN
      [105]: "CP1251",
      // SQL_Latin1_General_CP1251_CS_AS
      [106]: "CP1251",
      // SQL_Latin1_General_CP1251_CI_AS
      [107]: "CP1251",
      // SQL_Ukrainian_Cp1251_CS_AS_KI_WI
      [108]: "CP1251",
      // SQL_Ukrainian_Cp1251_CI_AS_KI_WI
      [112]: "CP1253",
      // SQL_Latin1_General_1253_BIN
      [113]: "CP1253",
      // SQL_Latin1_General_CP1253_CS_AS
      [114]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AS
      [120]: "CP1253",
      // SQL_MixDiction_CP1253_CS_AS
      [121]: "CP1253",
      // SQL_AltDiction_CP1253_CS_AS
      [122]: "CP1253",
      // SQL_AltDiction2_CP1253_CS_AS
      [124]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AI
      [128]: "CP1254",
      // SQL_Latin1_General_1254_BIN
      [129]: "CP1254",
      // SQL_Latin1_General_Cp1254_CS_AS_KI_WI
      [130]: "CP1254",
      // SQL_Latin1_General_Cp1254_CI_AS_KI_WI
      [136]: "CP1255",
      // SQL_Latin1_General_1255_BIN
      [137]: "CP1255",
      // SQL_Latin1_General_CP1255_CS_AS
      [138]: "CP1255",
      // SQL_Latin1_General_CP1255_CI_AS
      [144]: "CP1256",
      // SQL_Latin1_General_1256_BIN
      [145]: "CP1256",
      // SQL_Latin1_General_CP1256_CS_AS
      [146]: "CP1256",
      // SQL_Latin1_General_CP1256_CI_AS
      [152]: "CP1257",
      // SQL_Latin1_General_1257_BIN
      [153]: "CP1257",
      // SQL_Latin1_General_CP1257_CS_AS
      [154]: "CP1257",
      // SQL_Latin1_General_CP1257_CI_AS
      [155]: "CP1257",
      // SQL_Estonian_Cp1257_CS_AS_KI_WI
      [156]: "CP1257",
      // SQL_Estonian_Cp1257_CI_AS_KI_WI
      [157]: "CP1257",
      // SQL_Latvian_Cp1257_CS_AS_KI_WI
      [158]: "CP1257",
      // SQL_Latvian_Cp1257_CI_AS_KI_WI
      [159]: "CP1257",
      // SQL_Lithuanian_Cp1257_CS_AS_KI_WI
      [160]: "CP1257",
      // SQL_Lithuanian_Cp1257_CI_AS_KI_WI
      [183]: "CP1252",
      // SQL_Danish_Pref_Cp1_CI_AS_KI_WI
      [184]: "CP1252",
      // SQL_SwedishPhone_Pref_Cp1_CI_AS_KI_WI
      [185]: "CP1252",
      // SQL_SwedishStd_Pref_Cp1_CI_AS_KI_WI
      [186]: "CP1252"
      // SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
    };
    var Flags = exports2.Flags = {
      IGNORE_CASE: 1 << 0,
      IGNORE_ACCENT: 1 << 1,
      IGNORE_KANA: 1 << 2,
      IGNORE_WIDTH: 1 << 3,
      BINARY: 1 << 4,
      BINARY2: 1 << 5,
      UTF8: 1 << 6
    };
    var Collation = class {
      static fromBuffer(buffer, offset = 0) {
        let lcid = (buffer[offset + 2] & 15) << 16;
        lcid |= buffer[offset + 1] << 8;
        lcid |= buffer[offset + 0];
        let flags = (buffer[offset + 3] & 15) << 4;
        flags |= (buffer[offset + 2] & 240) >>> 4;
        const version2 = (buffer[offset + 3] & 240) >>> 4;
        const sortId = buffer[offset + 4];
        return new this(lcid, flags, version2, sortId);
      }
      constructor(lcid, flags, version2, sortId) {
        this.buffer = void 0;
        this.lcid = lcid;
        this.flags = flags;
        this.version = version2;
        this.sortId = sortId;
        if (this.flags & Flags.UTF8) {
          this.codepage = "utf-8";
        } else if (this.sortId) {
          this.codepage = codepageBySortId[this.sortId];
        } else {
          const languageId = this.lcid & 65535;
          this.codepage = codepageByLanguageId[languageId];
        }
      }
      toBuffer() {
        if (this.buffer) {
          return this.buffer;
        }
        this.buffer = Buffer.alloc(5);
        this.buffer[0] = this.lcid & 255;
        this.buffer[1] = this.lcid >>> 8 & 255;
        this.buffer[2] = this.lcid >>> 16 & 15 | (this.flags & 15) << 4;
        this.buffer[3] = (this.flags & 240) >>> 4 | (this.version & 15) << 4;
        this.buffer[4] = this.sortId & 255;
        return this.buffer;
      }
    };
    exports2.Collation = Collation;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/null.js
var require_null = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/null.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Null = {
      id: 31,
      type: "NULL",
      name: "Null",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = Null;
    module2.exports = Null;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/intn.js
var require_intn = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/intn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var IntN = {
      id: 38,
      type: "INTN",
      name: "IntN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = IntN;
    module2.exports = IntN;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/tinyint.js
var require_tinyint = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/tinyint.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var TinyInt = {
      id: 48,
      type: "INT1",
      name: "TinyInt",
      declaration: function() {
        return "tinyint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(1);
        buffer.writeUInt8(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < 0 || value > 255) {
          throw new TypeError("Value must be between 0 and 255, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports2.default = TinyInt;
    module2.exports = TinyInt;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/bitn.js
var require_bitn = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/bitn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var BitN = {
      id: 104,
      type: "BITN",
      name: "BitN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      *generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = BitN;
    module2.exports = BitN;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/bit.js
var require_bit = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/bit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _bitn = _interopRequireDefault(require_bitn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var Bit = {
      id: 50,
      type: "BIT",
      name: "Bit",
      declaration: function() {
        return "bit";
      },
      generateTypeInfo() {
        return Buffer.from([_bitn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value ? Buffer.from([1]) : Buffer.from([0]);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (value) {
          return true;
        } else {
          return false;
        }
      }
    };
    var _default = exports2.default = Bit;
    module2.exports = Bit;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/smallint.js
var require_smallint = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/smallint.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([2]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallInt = {
      id: 52,
      type: "INT2",
      name: "SmallInt",
      declaration: function() {
        return "smallint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 2]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeInt16LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -32768 || value > 32767) {
          throw new TypeError("Value must be between -32768 and 32767, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports2.default = SmallInt;
    module2.exports = SmallInt;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/int.js
var require_int = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/int.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Int5 = {
      id: 56,
      type: "INT4",
      name: "Int",
      declaration: function() {
        return "int";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -2147483648 || value > 2147483647) {
          throw new TypeError("Value must be between -2147483648 and 2147483647, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports2.default = Int5;
    module2.exports = Int5;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/datetimen.js
var require_datetimen = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/datetimen.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var DateTimeN = {
      id: 111,
      type: "DATETIMN",
      name: "DateTimeN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = DateTimeN;
    module2.exports = DateTimeN;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/smalldatetime.js
var require_smalldatetime = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/smalldatetime.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = new Date(1900, 0, 1);
    var UTC_EPOCH_DATE = new Date(Date.UTC(1900, 0, 1));
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallDateTime = {
      id: 58,
      type: "DATETIM4",
      name: "SmallDateTime",
      declaration: function() {
        return "smalldatetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        let days, dstDiff, minutes;
        if (options.useUTC) {
          days = Math.floor((parameter.value.getTime() - UTC_EPOCH_DATE.getTime()) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getUTCHours() * 60 + parameter.value.getUTCMinutes();
        } else {
          dstDiff = -(parameter.value.getTimezoneOffset() - EPOCH_DATE.getTimezoneOffset()) * 60 * 1e3;
          days = Math.floor((parameter.value.getTime() - EPOCH_DATE.getTime() + dstDiff) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getHours() * 60 + parameter.value.getMinutes();
        }
        buffer.writeUInt16LE(days, 0);
        buffer.writeUInt16LE(minutes, 2);
        yield buffer;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year, month, date;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
          month = value.getUTCMonth();
          date = value.getUTCDate();
        } else {
          year = value.getFullYear();
          month = value.getMonth();
          date = value.getDate();
        }
        if (year < 1900 || year > 2079) {
          throw new TypeError("Out of range.");
        }
        if (year === 2079) {
          if (month > 5 || month === 5 && date > 6) {
            throw new TypeError("Out of range.");
          }
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = SmallDateTime;
    module2.exports = SmallDateTime;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/floatn.js
var require_floatn = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/floatn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var FloatN = {
      id: 109,
      type: "FLTN",
      name: "FloatN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = FloatN;
    module2.exports = FloatN;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/real.js
var require_real = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/real.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Real = {
      id: 59,
      type: "FLT4",
      name: "Real",
      declaration: function() {
        return "real";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeFloatLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports2.default = Real;
    module2.exports = Real;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/moneyn.js
var require_moneyn = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/moneyn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var MoneyN = {
      id: 110,
      type: "MONEYN",
      name: "MoneyN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = MoneyN;
    module2.exports = MoneyN;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/money.js
var require_money = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/money.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var Money = {
      id: 60,
      type: "MONEY",
      name: "Money",
      declaration: function() {
        return "money";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value * 1e4;
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32), 0);
        buffer.writeInt32LE(value & -1, 4);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -9223372036854776e-1 || value > 9223372036854776e-1) {
          throw new TypeError("Value must be between -922337203685477.5808 and 922337203685477.5807, inclusive.");
        }
        return value;
      }
    };
    var _default = exports2.default = Money;
    module2.exports = Money;
  }
});

// node_modules/@js-joda/core/dist/js-joda.js
var require_js_joda = __commonJS({
  "node_modules/@js-joda/core/dist/js-joda.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.JSJoda = {}));
    })(exports2, function(exports3) {
      "use strict";
      function createErrorType(name, init2, superErrorClass) {
        if (superErrorClass === void 0) {
          superErrorClass = Error;
        }
        function JsJodaException(message) {
          if (!Error.captureStackTrace) {
            this.stack = new Error().stack;
          } else {
            Error.captureStackTrace(this, this.constructor);
          }
          this.message = message;
          init2 && init2.apply(this, arguments);
          this.toString = function() {
            return this.name + ": " + this.message;
          };
        }
        JsJodaException.prototype = Object.create(superErrorClass.prototype);
        JsJodaException.prototype.name = name;
        JsJodaException.prototype.constructor = JsJodaException;
        return JsJodaException;
      }
      var DateTimeException = createErrorType("DateTimeException", messageWithCause);
      var DateTimeParseException = createErrorType("DateTimeParseException", messageForDateTimeParseException);
      var UnsupportedTemporalTypeException = createErrorType("UnsupportedTemporalTypeException", null, DateTimeException);
      var ArithmeticException = createErrorType("ArithmeticException");
      var IllegalArgumentException = createErrorType("IllegalArgumentException");
      var IllegalStateException = createErrorType("IllegalStateException");
      var NullPointerException = createErrorType("NullPointerException");
      function messageWithCause(message, cause) {
        if (cause === void 0) {
          cause = null;
        }
        var msg = message || this.name;
        if (cause !== null && cause instanceof Error) {
          msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
        }
        this.message = msg;
      }
      function messageForDateTimeParseException(message, text, index, cause) {
        if (text === void 0) {
          text = "";
        }
        if (index === void 0) {
          index = 0;
        }
        if (cause === void 0) {
          cause = null;
        }
        var msg = message || this.name;
        msg += ": " + text + ", at index: " + index;
        if (cause !== null && cause instanceof Error) {
          msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
        }
        this.message = msg;
        this.parsedString = function() {
          return text;
        };
        this.errorIndex = function() {
          return index;
        };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function assert(assertion, msg, error) {
        if (!assertion) {
          if (error) {
            throw new error(msg);
          } else {
            throw new Error(msg);
          }
        }
      }
      function requireNonNull(value, parameterName) {
        if (value == null) {
          throw new NullPointerException(parameterName + " must not be null");
        }
        return value;
      }
      function requireInstance(value, _class, parameterName) {
        if (!(value instanceof _class)) {
          throw new IllegalArgumentException(parameterName + " must be an instance of " + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ", but is " + value.constructor.name : ""));
        }
        return value;
      }
      function abstractMethodFail(methodName) {
        throw new TypeError('abstract method "' + methodName + '" is not implemented');
      }
      var assert$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        abstractMethodFail,
        assert,
        requireInstance,
        requireNonNull
      });
      var MAX_SAFE_INTEGER = 9007199254740991;
      var MIN_SAFE_INTEGER = -9007199254740991;
      var MathUtil = function() {
        function MathUtil2() {
        }
        MathUtil2.intDiv = function intDiv(x, y) {
          var r = x / y;
          r = MathUtil2.roundDown(r);
          return MathUtil2.safeZero(r);
        };
        MathUtil2.intMod = function intMod(x, y) {
          var r = x - MathUtil2.intDiv(x, y) * y;
          r = MathUtil2.roundDown(r);
          return MathUtil2.safeZero(r);
        };
        MathUtil2.roundDown = function roundDown(r) {
          if (r < 0) {
            return Math.ceil(r);
          } else {
            return Math.floor(r);
          }
        };
        MathUtil2.floorDiv = function floorDiv(x, y) {
          var r = Math.floor(x / y);
          return MathUtil2.safeZero(r);
        };
        MathUtil2.floorMod = function floorMod(x, y) {
          var r = x - MathUtil2.floorDiv(x, y) * y;
          return MathUtil2.safeZero(r);
        };
        MathUtil2.safeAdd = function safeAdd(x, y) {
          MathUtil2.verifyInt(x);
          MathUtil2.verifyInt(y);
          if (x === 0) {
            return MathUtil2.safeZero(y);
          }
          if (y === 0) {
            return MathUtil2.safeZero(x);
          }
          var r = MathUtil2.safeToInt(x + y);
          if (r === x || r === y) {
            throw new ArithmeticException("Invalid addition beyond MAX_SAFE_INTEGER!");
          }
          return r;
        };
        MathUtil2.safeSubtract = function safeSubtract(x, y) {
          MathUtil2.verifyInt(x);
          MathUtil2.verifyInt(y);
          if (x === 0 && y === 0) {
            return 0;
          } else if (x === 0) {
            return MathUtil2.safeZero(-1 * y);
          } else if (y === 0) {
            return MathUtil2.safeZero(x);
          }
          return MathUtil2.safeToInt(x - y);
        };
        MathUtil2.safeMultiply = function safeMultiply(x, y) {
          MathUtil2.verifyInt(x);
          MathUtil2.verifyInt(y);
          if (x === 1) {
            return MathUtil2.safeZero(y);
          }
          if (y === 1) {
            return MathUtil2.safeZero(x);
          }
          if (x === 0 || y === 0) {
            return 0;
          }
          var r = MathUtil2.safeToInt(x * y);
          if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
            throw new ArithmeticException("Multiplication overflows: " + x + " * " + y);
          }
          return r;
        };
        MathUtil2.parseInt = function(_parseInt) {
          function parseInt2(_x) {
            return _parseInt.apply(this, arguments);
          }
          parseInt2.toString = function() {
            return _parseInt.toString();
          };
          return parseInt2;
        }(function(value) {
          var r = parseInt(value);
          return MathUtil2.safeToInt(r);
        });
        MathUtil2.safeToInt = function safeToInt(value) {
          MathUtil2.verifyInt(value);
          return MathUtil2.safeZero(value);
        };
        MathUtil2.verifyInt = function verifyInt(value) {
          if (value == null) {
            throw new ArithmeticException("Invalid value: '" + value + "', using null or undefined as argument");
          }
          if (isNaN(value)) {
            throw new ArithmeticException("Invalid int value, using NaN as argument");
          }
          if (Number.isInteger) {
            if (!Number.isInteger(Number(value))) {
              throw new ArithmeticException("Invalid value: '" + value + "' is a float");
            }
          } else if (value % 1 !== 0) {
            throw new ArithmeticException("Invalid value: '" + value + "' is a float");
          }
          if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
            throw new ArithmeticException("Calculation overflows an int: " + value);
          }
        };
        MathUtil2.safeZero = function safeZero(value) {
          return value === 0 ? 0 : +value;
        };
        MathUtil2.compareNumbers = function compareNumbers(a, b) {
          if (a < b) {
            return -1;
          }
          if (a > b) {
            return 1;
          }
          return 0;
        };
        MathUtil2.smi = function smi(int) {
          return int >>> 1 & 1073741824 | int & 3221225471;
        };
        MathUtil2.hash = function hash(number) {
          if (number !== number || number === Infinity) {
            return 0;
          }
          var result = number;
          while (number > 4294967295) {
            number /= 4294967295;
            result ^= number;
          }
          return MathUtil2.smi(result);
        };
        MathUtil2.hashCode = function hashCode() {
          var result = 17;
          for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
            numbers[_key] = arguments[_key];
          }
          for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {
            var n = _numbers[_i];
            result = (result << 5) - result + MathUtil2.hash(n);
          }
          return MathUtil2.hash(result);
        };
        return MathUtil2;
      }();
      MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
      MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;
      var Enum = function() {
        function Enum2(name) {
          this._name = name;
        }
        var _proto = Enum2.prototype;
        _proto.equals = function equals(other) {
          return this === other;
        };
        _proto.toString = function toString() {
          return this._name;
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        return Enum2;
      }();
      var TemporalAmount = function() {
        function TemporalAmount2() {
        }
        var _proto = TemporalAmount2.prototype;
        _proto.get = function get(unit) {
          abstractMethodFail("get");
        };
        _proto.units = function units() {
          abstractMethodFail("units");
        };
        _proto.addTo = function addTo(temporal) {
          abstractMethodFail("addTo");
        };
        _proto.subtractFrom = function subtractFrom(temporal) {
          abstractMethodFail("subtractFrom");
        };
        return TemporalAmount2;
      }();
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
        TemporalAmount.prototype[Symbol.toPrimitive] = function(hint) {
          if (hint !== "number") {
            return this.toString();
          }
          throw new TypeError("A conversion from TemporalAmount to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
        };
      }
      var TemporalUnit = function() {
        function TemporalUnit2() {
        }
        var _proto = TemporalUnit2.prototype;
        _proto.duration = function duration() {
          abstractMethodFail("duration");
        };
        _proto.isDurationEstimated = function isDurationEstimated() {
          abstractMethodFail("isDurationEstimated");
        };
        _proto.isDateBased = function isDateBased() {
          abstractMethodFail("isDateBased");
        };
        _proto.isTimeBased = function isTimeBased() {
          abstractMethodFail("isTimeBased");
        };
        _proto.isSupportedBy = function isSupportedBy(temporal) {
          abstractMethodFail("isSupportedBy");
        };
        _proto.addTo = function addTo(dateTime, periodToAdd) {
          abstractMethodFail("addTo");
        };
        _proto.between = function between(temporal1, temporal2) {
          abstractMethodFail("between");
        };
        return TemporalUnit2;
      }();
      var Duration = function(_TemporalAmount) {
        _inheritsLoose(Duration2, _TemporalAmount);
        function Duration2(seconds, nanos) {
          var _this;
          _this = _TemporalAmount.call(this) || this;
          _this._seconds = MathUtil.safeToInt(seconds);
          _this._nanos = MathUtil.safeToInt(nanos);
          return _this;
        }
        Duration2.ofDays = function ofDays(days) {
          return Duration2._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
        };
        Duration2.ofHours = function ofHours(hours) {
          return Duration2._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
        };
        Duration2.ofMinutes = function ofMinutes(minutes) {
          return Duration2._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
        };
        Duration2.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {
          if (nanoAdjustment === void 0) {
            nanoAdjustment = 0;
          }
          var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
          var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
          return Duration2._create(secs, nos);
        };
        Duration2.ofMillis = function ofMillis(millis) {
          var secs = MathUtil.intDiv(millis, 1e3);
          var mos = MathUtil.intMod(millis, 1e3);
          if (mos < 0) {
            mos += 1e3;
            secs--;
          }
          return Duration2._create(secs, mos * 1e6);
        };
        Duration2.ofNanos = function ofNanos(nanos) {
          var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
          var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);
          if (nos < 0) {
            nos += LocalTime.NANOS_PER_SECOND;
            secs--;
          }
          return this._create(secs, nos);
        };
        Duration2.of = function of(amount, unit) {
          return Duration2.ZERO.plus(amount, unit);
        };
        Duration2.from = function from(amount) {
          requireNonNull(amount, "amount");
          requireInstance(amount, TemporalAmount);
          var duration = Duration2.ZERO;
          amount.units().forEach(function(unit) {
            duration = duration.plus(amount.get(unit), unit);
          });
          return duration;
        };
        Duration2.between = function between(startInclusive, endExclusive) {
          requireNonNull(startInclusive, "startInclusive");
          requireNonNull(endExclusive, "endExclusive");
          var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
          var nanos = 0;
          if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
            try {
              var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
              nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;
              if (secs > 0 && nanos < 0) {
                nanos += LocalTime.NANOS_PER_SECOND;
              } else if (secs < 0 && nanos > 0) {
                nanos -= LocalTime.NANOS_PER_SECOND;
              } else if (secs === 0 && nanos !== 0) {
                var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
                secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
              }
            } catch (e) {
            }
          }
          return this.ofSeconds(secs, nanos);
        };
        Duration2.parse = function parse2(text) {
          requireNonNull(text, "text");
          var PATTERN2 = new RegExp("([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?", "i");
          var matches = PATTERN2.exec(text);
          if (matches !== null) {
            if ("T" === matches[3] === false) {
              var negate = "-" === matches[1];
              var dayMatch = matches[2];
              var hourMatch = matches[4];
              var minuteMatch = matches[5];
              var secondMatch = matches[6];
              var fractionMatch = matches[7];
              if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
                var daysAsSecs = Duration2._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, "days");
                var hoursAsSecs = Duration2._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, "hours");
                var minsAsSecs = Duration2._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, "minutes");
                var seconds = Duration2._parseNumber(text, secondMatch, 1, "seconds");
                var negativeSecs = secondMatch != null && secondMatch.charAt(0) === "-";
                var nanos = Duration2._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);
                try {
                  return Duration2._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
                } catch (ex) {
                  throw new DateTimeParseException("Text cannot be parsed to a Duration: overflow", text, 0, ex);
                }
              }
            }
          }
          throw new DateTimeParseException("Text cannot be parsed to a Duration", text, 0);
        };
        Duration2._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {
          if (parsed == null) {
            return 0;
          }
          try {
            if (parsed[0] === "+") {
              parsed = parsed.substring(1);
            }
            return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
          } catch (ex) {
            throw new DateTimeParseException("Text cannot be parsed to a Duration: " + errorText, text, 0, ex);
          }
        };
        Duration2._parseFraction = function _parseFraction(text, parsed, negate) {
          if (parsed == null || parsed.length === 0) {
            return 0;
          }
          parsed = (parsed + "000000000").substring(0, 9);
          return parseFloat(parsed) * negate;
        };
        Duration2._create = function _create() {
          if (arguments.length <= 2) {
            return Duration2._createSecondsNanos(arguments[0], arguments[1]);
          } else {
            return Duration2._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
          }
        };
        Duration2._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
          var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));
          if (negate) {
            return Duration2.ofSeconds(seconds, nanos).negated();
          }
          return Duration2.ofSeconds(seconds, nanos);
        };
        Duration2._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {
          if (seconds === void 0) {
            seconds = 0;
          }
          if (nanoAdjustment === void 0) {
            nanoAdjustment = 0;
          }
          if (seconds === 0 && nanoAdjustment === 0) {
            return Duration2.ZERO;
          }
          return new Duration2(seconds, nanoAdjustment);
        };
        var _proto = Duration2.prototype;
        _proto.get = function get(unit) {
          if (unit === ChronoUnit.SECONDS) {
            return this._seconds;
          } else if (unit === ChronoUnit.NANOS) {
            return this._nanos;
          } else {
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
        };
        _proto.units = function units() {
          return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
        };
        _proto.isZero = function isZero() {
          return this._seconds === 0 && this._nanos === 0;
        };
        _proto.isNegative = function isNegative() {
          return this._seconds < 0;
        };
        _proto.seconds = function seconds() {
          return this._seconds;
        };
        _proto.nano = function nano() {
          return this._nanos;
        };
        _proto.withSeconds = function withSeconds(seconds) {
          return Duration2._create(seconds, this._nanos);
        };
        _proto.withNanos = function withNanos(nanoOfSecond) {
          ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
          return Duration2._create(this._seconds, nanoOfSecond);
        };
        _proto.plusDuration = function plusDuration(duration) {
          requireNonNull(duration, "duration");
          return this.plus(duration.seconds(), duration.nano());
        };
        _proto.plus = function plus(durationOrNumber, unitOrNumber) {
          if (arguments.length === 1) {
            return this.plusDuration(durationOrNumber);
          } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
            return this.plusAmountUnit(durationOrNumber, unitOrNumber);
          } else {
            return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
          }
        };
        _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
          requireNonNull(amountToAdd, "amountToAdd");
          requireNonNull(unit, "unit");
          if (unit === ChronoUnit.DAYS) {
            return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
          }
          if (unit.isDurationEstimated()) {
            throw new UnsupportedTemporalTypeException("Unit must not have an estimated duration");
          }
          if (amountToAdd === 0) {
            return this;
          }
          if (unit instanceof ChronoUnit) {
            switch (unit) {
              case ChronoUnit.NANOS:
                return this.plusNanos(amountToAdd);
              case ChronoUnit.MICROS:
                return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1e6 * 1e3) * 1e3, MathUtil.intMod(amountToAdd, 1e6 * 1e3) * 1e3);
              case ChronoUnit.MILLIS:
                return this.plusMillis(amountToAdd);
              case ChronoUnit.SECONDS:
                return this.plusSeconds(amountToAdd);
            }
            return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
          }
          var duration = unit.duration().multipliedBy(amountToAdd);
          return this.plusSecondsNanos(duration.seconds(), duration.nano());
        };
        _proto.plusDays = function plusDays(daysToAdd) {
          return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
        };
        _proto.plusHours = function plusHours(hoursToAdd) {
          return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
        };
        _proto.plusMinutes = function plusMinutes(minutesToAdd) {
          return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
        };
        _proto.plusSeconds = function plusSeconds(secondsToAdd) {
          return this.plusSecondsNanos(secondsToAdd, 0);
        };
        _proto.plusMillis = function plusMillis(millisToAdd) {
          return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * 1e6);
        };
        _proto.plusNanos = function plusNanos(nanosToAdd) {
          return this.plusSecondsNanos(0, nanosToAdd);
        };
        _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
          requireNonNull(secondsToAdd, "secondsToAdd");
          requireNonNull(nanosToAdd, "nanosToAdd");
          if (secondsToAdd === 0 && nanosToAdd === 0) {
            return this;
          }
          var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
          epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
          nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
          var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
          return Duration2.ofSeconds(epochSec, nanoAdjustment);
        };
        _proto.minus = function minus(durationOrNumber, unit) {
          if (arguments.length === 1) {
            return this.minusDuration(durationOrNumber);
          } else {
            return this.minusAmountUnit(durationOrNumber, unit);
          }
        };
        _proto.minusDuration = function minusDuration(duration) {
          requireNonNull(duration, "duration");
          var secsToSubtract = duration.seconds();
          var nanosToSubtract = duration.nano();
          if (secsToSubtract === MIN_SAFE_INTEGER) {
            return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
          }
          return this.plus(-secsToSubtract, -nanosToSubtract);
        };
        _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
          requireNonNull(amountToSubtract, "amountToSubtract");
          requireNonNull(unit, "unit");
          return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
        };
        _proto.minusDays = function minusDays(daysToSubtract) {
          return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
        };
        _proto.minusHours = function minusHours(hoursToSubtract) {
          return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
        };
        _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
          return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
        };
        _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
          return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
        };
        _proto.minusMillis = function minusMillis(millisToSubtract) {
          return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
        };
        _proto.minusNanos = function minusNanos(nanosToSubtract) {
          return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
        };
        _proto.multipliedBy = function multipliedBy(multiplicand) {
          if (multiplicand === 0) {
            return Duration2.ZERO;
          }
          if (multiplicand === 1) {
            return this;
          }
          var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
          var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
          secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
          nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
          return Duration2.ofSeconds(secs, nos);
        };
        _proto.dividedBy = function dividedBy(divisor) {
          if (divisor === 0) {
            throw new ArithmeticException("Cannot divide by zero");
          }
          if (divisor === 1) {
            return this;
          }
          var secs = MathUtil.intDiv(this._seconds, divisor);
          var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
          var nos = MathUtil.intDiv(this._nanos, divisor);
          nos = secsMod + nos;
          return Duration2.ofSeconds(secs, nos);
        };
        _proto.negated = function negated() {
          return this.multipliedBy(-1);
        };
        _proto.abs = function abs() {
          return this.isNegative() ? this.negated() : this;
        };
        _proto.addTo = function addTo(temporal) {
          requireNonNull(temporal, "temporal");
          if (this._seconds !== 0) {
            temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
          }
          if (this._nanos !== 0) {
            temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
          }
          return temporal;
        };
        _proto.subtractFrom = function subtractFrom(temporal) {
          requireNonNull(temporal, "temporal");
          if (this._seconds !== 0) {
            temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
          }
          if (this._nanos !== 0) {
            temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
          }
          return temporal;
        };
        _proto.toDays = function toDays() {
          return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
        };
        _proto.toHours = function toHours() {
          return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
        };
        _proto.toMinutes = function toMinutes() {
          return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
        };
        _proto.toMillis = function toMillis() {
          var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1e3));
          millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1e6));
          return millis;
        };
        _proto.toNanos = function toNanos() {
          var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
          totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
          return totalNanos;
        };
        _proto.toHoursPart = function toHoursPart() {
          return MathUtil.intMod(this.toHours(), LocalTime.HOURS_PER_DAY);
        };
        _proto.toMinutesPart = function toMinutesPart() {
          return MathUtil.intMod(this.toMinutes(), LocalTime.MINUTES_PER_HOUR);
        };
        _proto.toSecondsPart = function toSecondsPart() {
          return MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
        };
        _proto.toMillisPart = function toMillisPart() {
          return MathUtil.intDiv(this._nanos, 1e6);
        };
        _proto.compareTo = function compareTo(otherDuration) {
          requireNonNull(otherDuration, "otherDuration");
          requireInstance(otherDuration, Duration2, "otherDuration");
          var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());
          if (cmp !== 0) {
            return cmp;
          }
          return this._nanos - otherDuration.nano();
        };
        _proto.equals = function equals(otherDuration) {
          if (this === otherDuration) {
            return true;
          }
          if (otherDuration instanceof Duration2) {
            return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
          }
          return false;
        };
        _proto.toString = function toString() {
          if (this === Duration2.ZERO) {
            return "PT0S";
          }
          var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
          var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
          var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
          var rval = "PT";
          if (hours !== 0) {
            rval += hours + "H";
          }
          if (minutes !== 0) {
            rval += minutes + "M";
          }
          if (secs === 0 && this._nanos === 0 && rval.length > 2) {
            return rval;
          }
          if (secs < 0 && this._nanos > 0) {
            if (secs === -1) {
              rval += "-0";
            } else {
              rval += secs + 1;
            }
          } else {
            rval += secs;
          }
          if (this._nanos > 0) {
            rval += ".";
            var nanoString;
            if (secs < 0) {
              nanoString = "" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
            } else {
              nanoString = "" + (LocalTime.NANOS_PER_SECOND + this._nanos);
            }
            nanoString = nanoString.slice(1, nanoString.length);
            rval += nanoString;
            while (rval.charAt(rval.length - 1) === "0") {
              rval = rval.slice(0, rval.length - 1);
            }
          }
          rval += "S";
          return rval;
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        return Duration2;
      }(TemporalAmount);
      function _init$n() {
        Duration.ZERO = new Duration(0, 0);
      }
      var YearConstants = function YearConstants2() {
      };
      function _init$m() {
        YearConstants.MIN_VALUE = -999999;
        YearConstants.MAX_VALUE = 999999;
      }
      var ChronoUnit = function(_TemporalUnit) {
        _inheritsLoose(ChronoUnit2, _TemporalUnit);
        function ChronoUnit2(name, estimatedDuration) {
          var _this;
          _this = _TemporalUnit.call(this) || this;
          _this._name = name;
          _this._duration = estimatedDuration;
          return _this;
        }
        var _proto = ChronoUnit2.prototype;
        _proto.duration = function duration() {
          return this._duration;
        };
        _proto.isDurationEstimated = function isDurationEstimated() {
          return this.isDateBased() || this === ChronoUnit2.FOREVER;
        };
        _proto.isDateBased = function isDateBased() {
          return this.compareTo(ChronoUnit2.DAYS) >= 0 && this !== ChronoUnit2.FOREVER;
        };
        _proto.isTimeBased = function isTimeBased() {
          return this.compareTo(ChronoUnit2.DAYS) < 0;
        };
        _proto.isSupportedBy = function isSupportedBy(temporal) {
          if (this === ChronoUnit2.FOREVER) {
            return false;
          }
          try {
            temporal.plus(1, this);
            return true;
          } catch (e) {
            try {
              temporal.plus(-1, this);
              return true;
            } catch (e2) {
              return false;
            }
          }
        };
        _proto.addTo = function addTo(temporal, amount) {
          return temporal.plus(amount, this);
        };
        _proto.between = function between(temporal1, temporal2) {
          return temporal1.until(temporal2, this);
        };
        _proto.toString = function toString() {
          return this._name;
        };
        _proto.compareTo = function compareTo(other) {
          return this.duration().compareTo(other.duration());
        };
        return ChronoUnit2;
      }(TemporalUnit);
      function _init$l() {
        ChronoUnit.NANOS = new ChronoUnit("Nanos", Duration.ofNanos(1));
        ChronoUnit.MICROS = new ChronoUnit("Micros", Duration.ofNanos(1e3));
        ChronoUnit.MILLIS = new ChronoUnit("Millis", Duration.ofNanos(1e6));
        ChronoUnit.SECONDS = new ChronoUnit("Seconds", Duration.ofSeconds(1));
        ChronoUnit.MINUTES = new ChronoUnit("Minutes", Duration.ofSeconds(60));
        ChronoUnit.HOURS = new ChronoUnit("Hours", Duration.ofSeconds(3600));
        ChronoUnit.HALF_DAYS = new ChronoUnit("HalfDays", Duration.ofSeconds(43200));
        ChronoUnit.DAYS = new ChronoUnit("Days", Duration.ofSeconds(86400));
        ChronoUnit.WEEKS = new ChronoUnit("Weeks", Duration.ofSeconds(7 * 86400));
        ChronoUnit.MONTHS = new ChronoUnit("Months", Duration.ofSeconds(31556952 / 12));
        ChronoUnit.YEARS = new ChronoUnit("Years", Duration.ofSeconds(31556952));
        ChronoUnit.DECADES = new ChronoUnit("Decades", Duration.ofSeconds(31556952 * 10));
        ChronoUnit.CENTURIES = new ChronoUnit("Centuries", Duration.ofSeconds(31556952 * 100));
        ChronoUnit.MILLENNIA = new ChronoUnit("Millennia", Duration.ofSeconds(31556952 * 1e3));
        ChronoUnit.ERAS = new ChronoUnit("Eras", Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));
        ChronoUnit.FOREVER = new ChronoUnit("Forever", Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
      }
      var TemporalField = function() {
        function TemporalField2() {
        }
        var _proto = TemporalField2.prototype;
        _proto.isDateBased = function isDateBased() {
          abstractMethodFail("isDateBased");
        };
        _proto.isTimeBased = function isTimeBased() {
          abstractMethodFail("isTimeBased");
        };
        _proto.baseUnit = function baseUnit() {
          abstractMethodFail("baseUnit");
        };
        _proto.rangeUnit = function rangeUnit() {
          abstractMethodFail("rangeUnit");
        };
        _proto.range = function range() {
          abstractMethodFail("range");
        };
        _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
          abstractMethodFail("rangeRefinedBy");
        };
        _proto.getFrom = function getFrom(temporal) {
          abstractMethodFail("getFrom");
        };
        _proto.adjustInto = function adjustInto(temporal, newValue) {
          abstractMethodFail("adjustInto");
        };
        _proto.isSupportedBy = function isSupportedBy(temporal) {
          abstractMethodFail("isSupportedBy");
        };
        _proto.displayName = function displayName() {
          abstractMethodFail("displayName");
        };
        _proto.equals = function equals(other) {
          abstractMethodFail("equals");
        };
        _proto.name = function name() {
          abstractMethodFail("name");
        };
        return TemporalField2;
      }();
      var ValueRange = function() {
        function ValueRange2(minSmallest, minLargest, maxSmallest, maxLargest) {
          assert(!(minSmallest > minLargest), "Smallest minimum value '" + minSmallest + "' must be less than largest minimum value '" + minLargest + "'", IllegalArgumentException);
          assert(!(maxSmallest > maxLargest), "Smallest maximum value '" + maxSmallest + "' must be less than largest maximum value '" + maxLargest + "'", IllegalArgumentException);
          assert(!(minLargest > maxLargest), "Minimum value '" + minLargest + "' must be less than maximum value '" + maxLargest + "'", IllegalArgumentException);
          this._minSmallest = minSmallest;
          this._minLargest = minLargest;
          this._maxLargest = maxLargest;
          this._maxSmallest = maxSmallest;
        }
        var _proto = ValueRange2.prototype;
        _proto.isFixed = function isFixed() {
          return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
        };
        _proto.minimum = function minimum() {
          return this._minSmallest;
        };
        _proto.largestMinimum = function largestMinimum() {
          return this._minLargest;
        };
        _proto.maximum = function maximum() {
          return this._maxLargest;
        };
        _proto.smallestMaximum = function smallestMaximum() {
          return this._maxSmallest;
        };
        _proto.isValidValue = function isValidValue(value) {
          return this.minimum() <= value && value <= this.maximum();
        };
        _proto.checkValidValue = function checkValidValue(value, field) {
          var msg;
          if (!this.isValidValue(value)) {
            if (field != null) {
              msg = "Invalid value for " + field + " (valid values " + this.toString() + "): " + value;
            } else {
              msg = "Invalid value (valid values " + this.toString() + "): " + value;
            }
            return assert(false, msg, DateTimeException);
          }
          return value;
        };
        _proto.checkValidIntValue = function checkValidIntValue(value, field) {
          if (this.isValidIntValue(value) === false) {
            throw new DateTimeException("Invalid int value for " + field + ": " + value);
          }
          return value;
        };
        _proto.isValidIntValue = function isValidIntValue(value) {
          return this.isIntValue() && this.isValidValue(value);
        };
        _proto.isIntValue = function isIntValue() {
          return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
        };
        _proto.equals = function equals(other) {
          if (other === this) {
            return true;
          }
          if (other instanceof ValueRange2) {
            return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
        };
        _proto.toString = function toString() {
          var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? "/" + this.largestMinimum() : "");
          str += " - ";
          str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? "/" + this.maximum() : "");
          return str;
        };
        ValueRange2.of = function of() {
          if (arguments.length === 2) {
            return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[1]);
          } else if (arguments.length === 3) {
            return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[2]);
          } else if (arguments.length === 4) {
            return new ValueRange2(arguments[0], arguments[1], arguments[2], arguments[3]);
          } else {
            return assert(false, "Invalid number of arguments " + arguments.length, IllegalArgumentException);
          }
        };
        return ValueRange2;
      }();
      var ChronoField = function(_TemporalField) {
        _inheritsLoose(ChronoField2, _TemporalField);
        ChronoField2.byName = function byName(fieldName) {
          for (var prop in ChronoField2) {
            if (ChronoField2[prop]) {
              if (ChronoField2[prop] instanceof ChronoField2 && ChronoField2[prop].name() === fieldName) {
                return ChronoField2[prop];
              }
            }
          }
        };
        function ChronoField2(name, baseUnit, rangeUnit, range) {
          var _this;
          _this = _TemporalField.call(this) || this;
          _this._name = name;
          _this._baseUnit = baseUnit;
          _this._rangeUnit = rangeUnit;
          _this._range = range;
          return _this;
        }
        var _proto = ChronoField2.prototype;
        _proto.name = function name() {
          return this._name;
        };
        _proto.baseUnit = function baseUnit() {
          return this._baseUnit;
        };
        _proto.rangeUnit = function rangeUnit() {
          return this._rangeUnit;
        };
        _proto.range = function range() {
          return this._range;
        };
        _proto.displayName = function displayName() {
          return this.toString();
        };
        _proto.checkValidValue = function checkValidValue(value) {
          return this.range().checkValidValue(value, this);
        };
        _proto.checkValidIntValue = function checkValidIntValue(value) {
          return this.range().checkValidIntValue(value, this);
        };
        _proto.isDateBased = function isDateBased() {
          var dateBased = this === ChronoField2.DAY_OF_WEEK || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField2.DAY_OF_MONTH || this === ChronoField2.DAY_OF_YEAR || this === ChronoField2.EPOCH_DAY || this === ChronoField2.ALIGNED_WEEK_OF_MONTH || this === ChronoField2.ALIGNED_WEEK_OF_YEAR || this === ChronoField2.MONTH_OF_YEAR || this === ChronoField2.PROLEPTIC_MONTH || this === ChronoField2.YEAR_OF_ERA || this === ChronoField2.YEAR || this === ChronoField2.ERA;
          return dateBased;
        };
        _proto.isTimeBased = function isTimeBased() {
          var timeBased = this === ChronoField2.NANO_OF_SECOND || this === ChronoField2.NANO_OF_DAY || this === ChronoField2.MICRO_OF_SECOND || this === ChronoField2.MICRO_OF_DAY || this === ChronoField2.MILLI_OF_SECOND || this === ChronoField2.MILLI_OF_DAY || this === ChronoField2.SECOND_OF_MINUTE || this === ChronoField2.SECOND_OF_DAY || this === ChronoField2.MINUTE_OF_HOUR || this === ChronoField2.MINUTE_OF_DAY || this === ChronoField2.HOUR_OF_AMPM || this === ChronoField2.CLOCK_HOUR_OF_AMPM || this === ChronoField2.HOUR_OF_DAY || this === ChronoField2.CLOCK_HOUR_OF_DAY || this === ChronoField2.AMPM_OF_DAY;
          return timeBased;
        };
        _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
          return temporal.range(this);
        };
        _proto.getFrom = function getFrom(temporal) {
          return temporal.getLong(this);
        };
        _proto.toString = function toString() {
          return this.name();
        };
        _proto.equals = function equals(other) {
          return this === other;
        };
        _proto.adjustInto = function adjustInto(temporal, newValue) {
          return temporal.with(this, newValue);
        };
        _proto.isSupportedBy = function isSupportedBy(temporal) {
          return temporal.isSupported(this);
        };
        return ChronoField2;
      }(TemporalField);
      function _init$k() {
        ChronoField.NANO_OF_SECOND = new ChronoField("NanoOfSecond", ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));
        ChronoField.NANO_OF_DAY = new ChronoField("NanoOfDay", ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e9 - 1));
        ChronoField.MICRO_OF_SECOND = new ChronoField("MicroOfSecond", ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));
        ChronoField.MICRO_OF_DAY = new ChronoField("MicroOfDay", ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e6 - 1));
        ChronoField.MILLI_OF_SECOND = new ChronoField("MilliOfSecond", ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));
        ChronoField.MILLI_OF_DAY = new ChronoField("MilliOfDay", ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e3 - 1));
        ChronoField.SECOND_OF_MINUTE = new ChronoField("SecondOfMinute", ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));
        ChronoField.SECOND_OF_DAY = new ChronoField("SecondOfDay", ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));
        ChronoField.MINUTE_OF_HOUR = new ChronoField("MinuteOfHour", ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));
        ChronoField.MINUTE_OF_DAY = new ChronoField("MinuteOfDay", ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));
        ChronoField.HOUR_OF_AMPM = new ChronoField("HourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));
        ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField("ClockHourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));
        ChronoField.HOUR_OF_DAY = new ChronoField("HourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));
        ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField("ClockHourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));
        ChronoField.AMPM_OF_DAY = new ChronoField("AmPmOfDay", ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));
        ChronoField.DAY_OF_WEEK = new ChronoField("DayOfWeek", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
        ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField("AlignedDayOfWeekInMonth", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
        ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField("AlignedDayOfWeekInYear", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
        ChronoField.DAY_OF_MONTH = new ChronoField("DayOfMonth", ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), "day");
        ChronoField.DAY_OF_YEAR = new ChronoField("DayOfYear", ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));
        ChronoField.EPOCH_DAY = new ChronoField("EpochDay", ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971));
        ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField("AlignedWeekOfMonth", ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));
        ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField("AlignedWeekOfYear", ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));
        ChronoField.MONTH_OF_YEAR = new ChronoField("MonthOfYear", ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), "month");
        ChronoField.PROLEPTIC_MONTH = new ChronoField("ProlepticMonth", ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));
        ChronoField.YEAR_OF_ERA = new ChronoField("YearOfEra", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));
        ChronoField.YEAR = new ChronoField("Year", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), "year");
        ChronoField.ERA = new ChronoField("Era", ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));
        ChronoField.INSTANT_SECONDS = new ChronoField("InstantSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));
        ChronoField.OFFSET_SECONDS = new ChronoField("OffsetSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
      }
      var TemporalQueries = function() {
        function TemporalQueries2() {
        }
        TemporalQueries2.zoneId = function zoneId() {
          return TemporalQueries2.ZONE_ID;
        };
        TemporalQueries2.chronology = function chronology() {
          return TemporalQueries2.CHRONO;
        };
        TemporalQueries2.precision = function precision() {
          return TemporalQueries2.PRECISION;
        };
        TemporalQueries2.zone = function zone() {
          return TemporalQueries2.ZONE;
        };
        TemporalQueries2.offset = function offset() {
          return TemporalQueries2.OFFSET;
        };
        TemporalQueries2.localDate = function localDate() {
          return TemporalQueries2.LOCAL_DATE;
        };
        TemporalQueries2.localTime = function localTime() {
          return TemporalQueries2.LOCAL_TIME;
        };
        return TemporalQueries2;
      }();
      var TemporalAccessor = function() {
        function TemporalAccessor2() {
        }
        var _proto = TemporalAccessor2.prototype;
        _proto.query = function query(_query) {
          if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
            return null;
          }
          return _query.queryFrom(this);
        };
        _proto.get = function get(field) {
          return this.range(field).checkValidIntValue(this.getLong(field), field);
        };
        _proto.getLong = function getLong(field) {
          abstractMethodFail("getLong");
        };
        _proto.range = function range(field) {
          if (field instanceof ChronoField) {
            if (this.isSupported(field)) {
              return field.range();
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.rangeRefinedBy(this);
        };
        _proto.isSupported = function isSupported(field) {
          abstractMethodFail("isSupported");
        };
        return TemporalAccessor2;
      }();
      var TemporalQuery = function(_Enum) {
        _inheritsLoose(TemporalQuery2, _Enum);
        function TemporalQuery2() {
          return _Enum.apply(this, arguments) || this;
        }
        var _proto = TemporalQuery2.prototype;
        _proto.queryFrom = function queryFrom(temporal) {
          abstractMethodFail("queryFrom");
        };
        return TemporalQuery2;
      }(Enum);
      function createTemporalQuery(name, queryFromFunction) {
        var ExtendedTemporalQuery = function(_TemporalQuery) {
          _inheritsLoose(ExtendedTemporalQuery2, _TemporalQuery);
          function ExtendedTemporalQuery2() {
            return _TemporalQuery.apply(this, arguments) || this;
          }
          return ExtendedTemporalQuery2;
        }(TemporalQuery);
        ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
        return new ExtendedTemporalQuery(name);
      }
      var DayOfWeek = function(_TemporalAccessor) {
        _inheritsLoose(DayOfWeek2, _TemporalAccessor);
        function DayOfWeek2(ordinal, name) {
          var _this;
          _this = _TemporalAccessor.call(this) || this;
          _this._ordinal = ordinal;
          _this._name = name;
          return _this;
        }
        var _proto = DayOfWeek2.prototype;
        _proto.ordinal = function ordinal() {
          return this._ordinal;
        };
        _proto.name = function name() {
          return this._name;
        };
        DayOfWeek2.values = function values() {
          return ENUMS.slice();
        };
        DayOfWeek2.valueOf = function valueOf(name) {
          var ordinal = 0;
          for (ordinal; ordinal < ENUMS.length; ordinal++) {
            if (ENUMS[ordinal].name() === name) {
              break;
            }
          }
          return DayOfWeek2.of(ordinal + 1);
        };
        DayOfWeek2.of = function of(dayOfWeek) {
          if (dayOfWeek < 1 || dayOfWeek > 7) {
            throw new DateTimeException("Invalid value for DayOfWeek: " + dayOfWeek);
          }
          return ENUMS[dayOfWeek - 1];
        };
        DayOfWeek2.from = function from(temporal) {
          assert(temporal != null, "temporal", NullPointerException);
          if (temporal instanceof DayOfWeek2) {
            return temporal;
          }
          try {
            return DayOfWeek2.of(temporal.get(ChronoField.DAY_OF_WEEK));
          } catch (ex) {
            if (ex instanceof DateTimeException) {
              throw new DateTimeException("Unable to obtain DayOfWeek from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""), ex);
            } else {
              throw ex;
            }
          }
        };
        _proto.value = function value() {
          return this._ordinal + 1;
        };
        _proto.displayName = function displayName(style, locale) {
          throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
        };
        _proto.isSupported = function isSupported(field) {
          if (field instanceof ChronoField) {
            return field === ChronoField.DAY_OF_WEEK;
          }
          return field != null && field.isSupportedBy(this);
        };
        _proto.range = function range(field) {
          if (field === ChronoField.DAY_OF_WEEK) {
            return field.range();
          } else if (field instanceof ChronoField) {
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.rangeRefinedBy(this);
        };
        _proto.get = function get(field) {
          if (field === ChronoField.DAY_OF_WEEK) {
            return this.value();
          }
          return this.range(field).checkValidIntValue(this.getLong(field), field);
        };
        _proto.getLong = function getLong(field) {
          if (field === ChronoField.DAY_OF_WEEK) {
            return this.value();
          } else if (field instanceof ChronoField) {
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.getFrom(this);
        };
        _proto.plus = function plus(days) {
          var amount = MathUtil.floorMod(days, 7);
          return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
        };
        _proto.minus = function minus(days) {
          return this.plus(-1 * MathUtil.floorMod(days, 7));
        };
        _proto.query = function query(_query) {
          if (_query === TemporalQueries.precision()) {
            return ChronoUnit.DAYS;
          } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
            return null;
          }
          assert(_query != null, "query", NullPointerException);
          return _query.queryFrom(this);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          requireNonNull(temporal, "temporal");
          return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
        };
        _proto.equals = function equals(other) {
          return this === other;
        };
        _proto.toString = function toString() {
          return this._name;
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, DayOfWeek2, "other");
          return this._ordinal - other._ordinal;
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        return DayOfWeek2;
      }(TemporalAccessor);
      var ENUMS;
      function _init$j() {
        DayOfWeek.MONDAY = new DayOfWeek(0, "MONDAY");
        DayOfWeek.TUESDAY = new DayOfWeek(1, "TUESDAY");
        DayOfWeek.WEDNESDAY = new DayOfWeek(2, "WEDNESDAY");
        DayOfWeek.THURSDAY = new DayOfWeek(3, "THURSDAY");
        DayOfWeek.FRIDAY = new DayOfWeek(4, "FRIDAY");
        DayOfWeek.SATURDAY = new DayOfWeek(5, "SATURDAY");
        DayOfWeek.SUNDAY = new DayOfWeek(6, "SUNDAY");
        DayOfWeek.FROM = createTemporalQuery("DayOfWeek.FROM", function(temporal) {
          return DayOfWeek.from(temporal);
        });
        ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
      }
      var Month = function(_TemporalAccessor) {
        _inheritsLoose(Month2, _TemporalAccessor);
        function Month2(value, name) {
          var _this;
          _this = _TemporalAccessor.call(this) || this;
          _this._value = MathUtil.safeToInt(value);
          _this._name = name;
          return _this;
        }
        var _proto = Month2.prototype;
        _proto.value = function value() {
          return this._value;
        };
        _proto.ordinal = function ordinal() {
          return this._value - 1;
        };
        _proto.name = function name() {
          return this._name;
        };
        _proto.displayName = function displayName(style, locale) {
          throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
        };
        _proto.isSupported = function isSupported(field) {
          if (null === field) {
            return false;
          }
          if (field instanceof ChronoField) {
            return field === ChronoField.MONTH_OF_YEAR;
          }
          return field != null && field.isSupportedBy(this);
        };
        _proto.get = function get(field) {
          if (field === ChronoField.MONTH_OF_YEAR) {
            return this.value();
          }
          return this.range(field).checkValidIntValue(this.getLong(field), field);
        };
        _proto.getLong = function getLong(field) {
          if (field === ChronoField.MONTH_OF_YEAR) {
            return this.value();
          } else if (field instanceof ChronoField) {
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.getFrom(this);
        };
        _proto.plus = function plus(months) {
          var amount = MathUtil.intMod(months, 12) + 12;
          var newMonthVal = MathUtil.intMod(this.value() + amount, 12);
          newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
          return Month2.of(newMonthVal);
        };
        _proto.minus = function minus(months) {
          return this.plus(-1 * MathUtil.intMod(months, 12));
        };
        _proto.length = function length(leapYear) {
          switch (this) {
            case Month2.FEBRUARY:
              return leapYear ? 29 : 28;
            case Month2.APRIL:
            case Month2.JUNE:
            case Month2.SEPTEMBER:
            case Month2.NOVEMBER:
              return 30;
            default:
              return 31;
          }
        };
        _proto.minLength = function minLength() {
          switch (this) {
            case Month2.FEBRUARY:
              return 28;
            case Month2.APRIL:
            case Month2.JUNE:
            case Month2.SEPTEMBER:
            case Month2.NOVEMBER:
              return 30;
            default:
              return 31;
          }
        };
        _proto.maxLength = function maxLength() {
          switch (this) {
            case Month2.FEBRUARY:
              return 29;
            case Month2.APRIL:
            case Month2.JUNE:
            case Month2.SEPTEMBER:
            case Month2.NOVEMBER:
              return 30;
            default:
              return 31;
          }
        };
        _proto.firstDayOfYear = function firstDayOfYear(leapYear) {
          var leap = leapYear ? 1 : 0;
          switch (this) {
            case Month2.JANUARY:
              return 1;
            case Month2.FEBRUARY:
              return 32;
            case Month2.MARCH:
              return 60 + leap;
            case Month2.APRIL:
              return 91 + leap;
            case Month2.MAY:
              return 121 + leap;
            case Month2.JUNE:
              return 152 + leap;
            case Month2.JULY:
              return 182 + leap;
            case Month2.AUGUST:
              return 213 + leap;
            case Month2.SEPTEMBER:
              return 244 + leap;
            case Month2.OCTOBER:
              return 274 + leap;
            case Month2.NOVEMBER:
              return 305 + leap;
            case Month2.DECEMBER:
            default:
              return 335 + leap;
          }
        };
        _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {
          switch (this) {
            case Month2.JANUARY:
            case Month2.FEBRUARY:
            case Month2.MARCH:
              return Month2.JANUARY;
            case Month2.APRIL:
            case Month2.MAY:
            case Month2.JUNE:
              return Month2.APRIL;
            case Month2.JULY:
            case Month2.AUGUST:
            case Month2.SEPTEMBER:
              return Month2.JULY;
            case Month2.OCTOBER:
            case Month2.NOVEMBER:
            case Month2.DECEMBER:
            default:
              return Month2.OCTOBER;
          }
        };
        _proto.query = function query(_query) {
          assert(_query != null, "query() parameter must not be null", DateTimeException);
          if (_query === TemporalQueries.chronology()) {
            return IsoChronology.INSTANCE;
          } else if (_query === TemporalQueries.precision()) {
            return ChronoUnit.MONTHS;
          }
          return _TemporalAccessor.prototype.query.call(this, _query);
        };
        _proto.toString = function toString() {
          switch (this) {
            case Month2.JANUARY:
              return "JANUARY";
            case Month2.FEBRUARY:
              return "FEBRUARY";
            case Month2.MARCH:
              return "MARCH";
            case Month2.APRIL:
              return "APRIL";
            case Month2.MAY:
              return "MAY";
            case Month2.JUNE:
              return "JUNE";
            case Month2.JULY:
              return "JULY";
            case Month2.AUGUST:
              return "AUGUST";
            case Month2.SEPTEMBER:
              return "SEPTEMBER";
            case Month2.OCTOBER:
              return "OCTOBER";
            case Month2.NOVEMBER:
              return "NOVEMBER";
            case Month2.DECEMBER:
              return "DECEMBER";
            default:
              return "unknown Month, value: " + this.value();
          }
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        _proto.adjustInto = function adjustInto(temporal) {
          return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, Month2, "other");
          return this._value - other._value;
        };
        _proto.equals = function equals(other) {
          return this === other;
        };
        Month2.valueOf = function valueOf(name) {
          var ordinal = 0;
          for (ordinal; ordinal < MONTHS.length; ordinal++) {
            if (MONTHS[ordinal].name() === name) {
              break;
            }
          }
          return Month2.of(ordinal + 1);
        };
        Month2.values = function values() {
          return MONTHS.slice();
        };
        Month2.of = function of(month) {
          if (month < 1 || month > 12) {
            assert(false, "Invalid value for MonthOfYear: " + month, DateTimeException);
          }
          return MONTHS[month - 1];
        };
        Month2.from = function from(temporal) {
          if (temporal instanceof Month2) {
            return temporal;
          }
          try {
            return Month2.of(temporal.get(ChronoField.MONTH_OF_YEAR));
          } catch (ex) {
            throw new DateTimeException("Unable to obtain Month from TemporalAccessor: " + temporal + " of type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""), ex);
          }
        };
        return Month2;
      }(TemporalAccessor);
      var MONTHS;
      function _init$i() {
        Month.JANUARY = new Month(1, "JANUARY");
        Month.FEBRUARY = new Month(2, "FEBRUARY");
        Month.MARCH = new Month(3, "MARCH");
        Month.APRIL = new Month(4, "APRIL");
        Month.MAY = new Month(5, "MAY");
        Month.JUNE = new Month(6, "JUNE");
        Month.JULY = new Month(7, "JULY");
        Month.AUGUST = new Month(8, "AUGUST");
        Month.SEPTEMBER = new Month(9, "SEPTEMBER");
        Month.OCTOBER = new Month(10, "OCTOBER");
        Month.NOVEMBER = new Month(11, "NOVEMBER");
        Month.DECEMBER = new Month(12, "DECEMBER");
        MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
      }
      var PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;
      var Period = function(_TemporalAmount) {
        _inheritsLoose(Period2, _TemporalAmount);
        function Period2(years, months, days) {
          var _this;
          _this = _TemporalAmount.call(this) || this;
          var _years = MathUtil.safeToInt(years);
          var _months = MathUtil.safeToInt(months);
          var _days = MathUtil.safeToInt(days);
          if (_years === 0 && _months === 0 && _days === 0) {
            if (!Period2.ZERO) {
              _this._years = _years;
              _this._months = _months;
              _this._days = _days;
              Period2.ZERO = _assertThisInitialized(_this);
            }
            return Period2.ZERO || _assertThisInitialized(_this);
          }
          _this._years = _years;
          _this._months = _months;
          _this._days = _days;
          return _this;
        }
        Period2.ofYears = function ofYears(years) {
          return Period2.create(years, 0, 0);
        };
        Period2.ofMonths = function ofMonths(months) {
          return Period2.create(0, months, 0);
        };
        Period2.ofWeeks = function ofWeeks(weeks) {
          return Period2.create(0, 0, MathUtil.safeMultiply(weeks, 7));
        };
        Period2.ofDays = function ofDays(days) {
          return Period2.create(0, 0, days);
        };
        Period2.of = function of(years, months, days) {
          return Period2.create(years, months, days);
        };
        Period2.from = function from(amount) {
          if (amount instanceof Period2) {
            return amount;
          }
          requireNonNull(amount, "amount");
          var years = 0;
          var months = 0;
          var days = 0;
          var units = amount.units();
          for (var i = 0; i < units.length; i++) {
            var unit = units[i];
            var unitAmount = amount.get(unit);
            if (unit === ChronoUnit.YEARS) {
              years = MathUtil.safeToInt(unitAmount);
            } else if (unit === ChronoUnit.MONTHS) {
              months = MathUtil.safeToInt(unitAmount);
            } else if (unit === ChronoUnit.DAYS) {
              days = MathUtil.safeToInt(unitAmount);
            } else {
              throw new DateTimeException("Unit must be Years, Months or Days, but was " + unit);
            }
          }
          return Period2.create(years, months, days);
        };
        Period2.between = function between(startDate, endDate) {
          requireNonNull(startDate, "startDate");
          requireNonNull(endDate, "endDate");
          requireInstance(startDate, LocalDate, "startDate");
          requireInstance(endDate, LocalDate, "endDate");
          return startDate.until(endDate);
        };
        Period2.parse = function parse2(text) {
          requireNonNull(text, "text");
          try {
            return Period2._parse(text);
          } catch (ex) {
            if (ex instanceof ArithmeticException) {
              throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0, ex);
            } else {
              throw ex;
            }
          }
        };
        Period2._parse = function _parse(text) {
          var matches = PATTERN.exec(text);
          if (matches != null) {
            var negate = "-" === matches[1] ? -1 : 1;
            var yearMatch = matches[2];
            var monthMatch = matches[3];
            var weekMatch = matches[4];
            var dayMatch = matches[5];
            if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
              var years = Period2._parseNumber(text, yearMatch, negate);
              var months = Period2._parseNumber(text, monthMatch, negate);
              var weeks = Period2._parseNumber(text, weekMatch, negate);
              var days = Period2._parseNumber(text, dayMatch, negate);
              days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
              return Period2.create(years, months, days);
            }
          }
          throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0);
        };
        Period2._parseNumber = function _parseNumber(text, str, negate) {
          if (str == null) {
            return 0;
          }
          var val = MathUtil.parseInt(str);
          return MathUtil.safeMultiply(val, negate);
        };
        Period2.create = function create(years, months, days) {
          return new Period2(years, months, days);
        };
        var _proto = Period2.prototype;
        _proto.units = function units() {
          return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
        };
        _proto.chronology = function chronology() {
          return IsoChronology.INSTANCE;
        };
        _proto.get = function get(unit) {
          if (unit === ChronoUnit.YEARS) {
            return this._years;
          }
          if (unit === ChronoUnit.MONTHS) {
            return this._months;
          }
          if (unit === ChronoUnit.DAYS) {
            return this._days;
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        };
        _proto.isZero = function isZero() {
          return this === Period2.ZERO;
        };
        _proto.isNegative = function isNegative() {
          return this._years < 0 || this._months < 0 || this._days < 0;
        };
        _proto.years = function years() {
          return this._years;
        };
        _proto.months = function months() {
          return this._months;
        };
        _proto.days = function days() {
          return this._days;
        };
        _proto.withYears = function withYears(years) {
          if (years === this._years) {
            return this;
          }
          return Period2.create(years, this._months, this._days);
        };
        _proto.withMonths = function withMonths(months) {
          if (months === this._months) {
            return this;
          }
          return Period2.create(this._years, months, this._days);
        };
        _proto.withDays = function withDays(days) {
          if (days === this._days) {
            return this;
          }
          return Period2.create(this._years, this._months, days);
        };
        _proto.plus = function plus(amountToAdd) {
          var amount = Period2.from(amountToAdd);
          return Period2.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
        };
        _proto.plusYears = function plusYears(yearsToAdd) {
          if (yearsToAdd === 0) {
            return this;
          }
          return Period2.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
        };
        _proto.plusMonths = function plusMonths(monthsToAdd) {
          if (monthsToAdd === 0) {
            return this;
          }
          return Period2.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
        };
        _proto.plusDays = function plusDays(daysToAdd) {
          if (daysToAdd === 0) {
            return this;
          }
          return Period2.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
        };
        _proto.minus = function minus(amountToSubtract) {
          var amount = Period2.from(amountToSubtract);
          return Period2.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
        };
        _proto.minusYears = function minusYears(yearsToSubtract) {
          return this.plusYears(-1 * yearsToSubtract);
        };
        _proto.minusMonths = function minusMonths(monthsToSubtract) {
          return this.plusMonths(-1 * monthsToSubtract);
        };
        _proto.minusDays = function minusDays(daysToSubtract) {
          return this.plusDays(-1 * daysToSubtract);
        };
        _proto.multipliedBy = function multipliedBy(scalar) {
          if (this === Period2.ZERO || scalar === 1) {
            return this;
          }
          return Period2.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
        };
        _proto.negated = function negated() {
          return this.multipliedBy(-1);
        };
        _proto.normalized = function normalized() {
          var totalMonths = this.toTotalMonths();
          var splitYears = MathUtil.intDiv(totalMonths, 12);
          var splitMonths = MathUtil.intMod(totalMonths, 12);
          if (splitYears === this._years && splitMonths === this._months) {
            return this;
          }
          return Period2.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
        };
        _proto.toTotalMonths = function toTotalMonths() {
          return this._years * 12 + this._months;
        };
        _proto.addTo = function addTo(temporal) {
          requireNonNull(temporal, "temporal");
          if (this._years !== 0) {
            if (this._months !== 0) {
              temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
            } else {
              temporal = temporal.plus(this._years, ChronoUnit.YEARS);
            }
          } else if (this._months !== 0) {
            temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
          }
          if (this._days !== 0) {
            temporal = temporal.plus(this._days, ChronoUnit.DAYS);
          }
          return temporal;
        };
        _proto.subtractFrom = function subtractFrom(temporal) {
          requireNonNull(temporal, "temporal");
          if (this._years !== 0) {
            if (this._months !== 0) {
              temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
            } else {
              temporal = temporal.minus(this._years, ChronoUnit.YEARS);
            }
          } else if (this._months !== 0) {
            temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
          }
          if (this._days !== 0) {
            temporal = temporal.minus(this._days, ChronoUnit.DAYS);
          }
          return temporal;
        };
        _proto.equals = function equals(obj) {
          if (this === obj) {
            return true;
          }
          if (obj instanceof Period2) {
            var other = obj;
            return this._years === other._years && this._months === other._months && this._days === other._days;
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return MathUtil.hashCode(this._years, this._months, this._days);
        };
        _proto.toString = function toString() {
          if (this === Period2.ZERO) {
            return "P0D";
          } else {
            var buf = "P";
            if (this._years !== 0) {
              buf += this._years + "Y";
            }
            if (this._months !== 0) {
              buf += this._months + "M";
            }
            if (this._days !== 0) {
              buf += this._days + "D";
            }
            return buf;
          }
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        return Period2;
      }(TemporalAmount);
      function _init$h() {
        Period.ofDays(0);
      }
      var ParsePosition = function() {
        function ParsePosition2(index) {
          this._index = index;
          this._errorIndex = -1;
        }
        var _proto = ParsePosition2.prototype;
        _proto.getIndex = function getIndex() {
          return this._index;
        };
        _proto.setIndex = function setIndex(index) {
          this._index = index;
        };
        _proto.getErrorIndex = function getErrorIndex() {
          return this._errorIndex;
        };
        _proto.setErrorIndex = function setErrorIndex(errorIndex) {
          this._errorIndex = errorIndex;
        };
        return ParsePosition2;
      }();
      var EnumMap = function() {
        function EnumMap2() {
          this._map = {};
        }
        var _proto = EnumMap2.prototype;
        _proto.putAll = function putAll(otherMap) {
          for (var key in otherMap._map) {
            this._map[key] = otherMap._map[key];
          }
          return this;
        };
        _proto.containsKey = function containsKey(key) {
          return this._map.hasOwnProperty(key.name()) && this.get(key) !== void 0;
        };
        _proto.get = function get(key) {
          return this._map[key.name()];
        };
        _proto.put = function put(key, val) {
          return this.set(key, val);
        };
        _proto.set = function set(key, val) {
          this._map[key.name()] = val;
          return this;
        };
        _proto.retainAll = function retainAll(keyList) {
          var map = {};
          for (var i = 0; i < keyList.length; i++) {
            var key = keyList[i].name();
            map[key] = this._map[key];
          }
          this._map = map;
          return this;
        };
        _proto.remove = function remove(key) {
          var keyName = key.name();
          var val = this._map[keyName];
          this._map[keyName] = void 0;
          return val;
        };
        _proto.keySet = function keySet() {
          return this._map;
        };
        _proto.clear = function clear() {
          this._map = {};
        };
        return EnumMap2;
      }();
      var ResolverStyle = function(_Enum) {
        _inheritsLoose(ResolverStyle2, _Enum);
        function ResolverStyle2() {
          return _Enum.apply(this, arguments) || this;
        }
        return ResolverStyle2;
      }(Enum);
      ResolverStyle.STRICT = new ResolverStyle("STRICT");
      ResolverStyle.SMART = new ResolverStyle("SMART");
      ResolverStyle.LENIENT = new ResolverStyle("LENIENT");
      var Temporal = function(_TemporalAccessor) {
        _inheritsLoose(Temporal2, _TemporalAccessor);
        function Temporal2() {
          return _TemporalAccessor.apply(this, arguments) || this;
        }
        var _proto = Temporal2.prototype;
        _proto.isSupported = function isSupported(fieldOrUnit) {
          abstractMethodFail("isSupported");
        };
        _proto.minus = function minus(amount, unit) {
          if (arguments.length < 2) {
            return this._minusAmount(amount);
          } else {
            return this._minusUnit(amount, unit);
          }
        };
        _proto._minusAmount = function _minusAmount(amount) {
          requireNonNull(amount, "amount");
          requireInstance(amount, TemporalAmount, "amount");
          return amount.subtractFrom(this);
        };
        _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
          requireNonNull(amountToSubtract, "amountToSubtract");
          requireNonNull(unit, "unit");
          requireInstance(unit, TemporalUnit, "unit");
          return this._plusUnit(-amountToSubtract, unit);
        };
        _proto.plus = function plus(amount, unit) {
          if (arguments.length < 2) {
            return this._plusAmount(amount);
          } else {
            return this._plusUnit(amount, unit);
          }
        };
        _proto._plusAmount = function _plusAmount(amount) {
          requireNonNull(amount, "amount");
          requireInstance(amount, TemporalAmount, "amount");
          return amount.addTo(this);
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          abstractMethodFail("_plusUnit");
        };
        _proto.until = function until(endTemporal, unit) {
          abstractMethodFail("until");
        };
        _proto.with = function _with(adjusterOrField, newValue) {
          if (arguments.length < 2) {
            return this._withAdjuster(adjusterOrField);
          } else {
            return this._withField(adjusterOrField, newValue);
          }
        };
        _proto._withAdjuster = function _withAdjuster(adjuster) {
          requireNonNull(adjuster, "adjuster");
          assert(typeof adjuster.adjustInto === "function", "adjuster must be a TemporalAdjuster", IllegalArgumentException);
          return adjuster.adjustInto(this);
        };
        _proto._withField = function _withField(field, newValue) {
          abstractMethodFail("_withField");
        };
        return Temporal2;
      }(TemporalAccessor);
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
        Temporal.prototype[Symbol.toPrimitive] = function(hint) {
          if (hint !== "number") {
            return this.toString();
          }
          throw new TypeError("A conversion from Temporal to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
        };
      }
      var ChronoLocalDate = function(_Temporal) {
        _inheritsLoose(ChronoLocalDate2, _Temporal);
        function ChronoLocalDate2() {
          return _Temporal.apply(this, arguments) || this;
        }
        var _proto = ChronoLocalDate2.prototype;
        _proto.isSupported = function isSupported(fieldOrUnit) {
          if (fieldOrUnit instanceof ChronoField) {
            return fieldOrUnit.isDateBased();
          } else if (fieldOrUnit instanceof ChronoUnit) {
            return fieldOrUnit.isDateBased();
          }
          return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };
        _proto.query = function query(_query) {
          if (_query === TemporalQueries.chronology()) {
            return this.chronology();
          } else if (_query === TemporalQueries.precision()) {
            return ChronoUnit.DAYS;
          } else if (_query === TemporalQueries.localDate()) {
            return LocalDate.ofEpochDay(this.toEpochDay());
          } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
            return null;
          }
          return _Temporal.prototype.query.call(this, _query);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          requireInstance(formatter, DateTimeFormatter, "formatter");
          return formatter.format(this);
        };
        return ChronoLocalDate2;
      }(Temporal);
      var StringUtil = function() {
        function StringUtil2() {
        }
        StringUtil2.startsWith = function startsWith(text, pattern) {
          return text.indexOf(pattern) === 0;
        };
        StringUtil2.hashCode = function hashCode(text) {
          var len = text.length;
          if (len === 0) {
            return 0;
          }
          var hash = 0;
          for (var i = 0; i < len; i++) {
            var chr = text.charCodeAt(i);
            hash = (hash << 5) - hash + chr;
            hash |= 0;
          }
          return MathUtil.smi(hash);
        };
        return StringUtil2;
      }();
      var ZoneId = function() {
        function ZoneId2() {
        }
        ZoneId2.systemDefault = function systemDefault() {
          throw new DateTimeException("not supported operation");
        };
        ZoneId2.getAvailableZoneIds = function getAvailableZoneIds() {
          throw new DateTimeException("not supported operation");
        };
        ZoneId2.of = function of(zoneId) {
          throw new DateTimeException("not supported operation" + zoneId);
        };
        ZoneId2.ofOffset = function ofOffset(prefix, offset) {
          throw new DateTimeException("not supported operation" + prefix + offset);
        };
        ZoneId2.from = function from(temporal) {
          throw new DateTimeException("not supported operation" + temporal);
        };
        var _proto = ZoneId2.prototype;
        _proto.id = function id() {
          abstractMethodFail("ZoneId.id");
        };
        _proto.rules = function rules() {
          abstractMethodFail("ZoneId.rules");
        };
        _proto.normalized = function normalized() {
          var rules = this.rules();
          if (rules.isFixedOffset()) {
            return rules.offset(Instant.EPOCH);
          }
          return this;
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof ZoneId2) {
            return this.id() === other.id();
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return StringUtil.hashCode(this.id());
        };
        _proto.toString = function toString() {
          return this.id();
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        return ZoneId2;
      }();
      var ZoneRules = function() {
        function ZoneRules2() {
        }
        ZoneRules2.of = function of(offset) {
          requireNonNull(offset, "offset");
          return new Fixed(offset);
        };
        var _proto = ZoneRules2.prototype;
        _proto.isFixedOffset = function isFixedOffset() {
          abstractMethodFail("ZoneRules.isFixedOffset");
        };
        _proto.offset = function offset(instantOrLocalDateTime) {
          if (instantOrLocalDateTime instanceof Instant) {
            return this.offsetOfInstant(instantOrLocalDateTime);
          } else {
            return this.offsetOfLocalDateTime(instantOrLocalDateTime);
          }
        };
        _proto.offsetOfInstant = function offsetOfInstant(instant) {
          abstractMethodFail("ZoneRules.offsetInstant");
        };
        _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
          abstractMethodFail("ZoneRules.offsetOfEpochMilli");
        };
        _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
          abstractMethodFail("ZoneRules.offsetLocalDateTime");
        };
        _proto.validOffsets = function validOffsets(localDateTime) {
          abstractMethodFail("ZoneRules.validOffsets");
        };
        _proto.transition = function transition(localDateTime) {
          abstractMethodFail("ZoneRules.transition");
        };
        _proto.standardOffset = function standardOffset(instant) {
          abstractMethodFail("ZoneRules.standardOffset");
        };
        _proto.daylightSavings = function daylightSavings(instant) {
          abstractMethodFail("ZoneRules.daylightSavings");
        };
        _proto.isDaylightSavings = function isDaylightSavings(instant) {
          abstractMethodFail("ZoneRules.isDaylightSavings");
        };
        _proto.isValidOffset = function isValidOffset(localDateTime, offset) {
          abstractMethodFail("ZoneRules.isValidOffset");
        };
        _proto.nextTransition = function nextTransition(instant) {
          abstractMethodFail("ZoneRules.nextTransition");
        };
        _proto.previousTransition = function previousTransition(instant) {
          abstractMethodFail("ZoneRules.previousTransition");
        };
        _proto.transitions = function transitions() {
          abstractMethodFail("ZoneRules.transitions");
        };
        _proto.transitionRules = function transitionRules() {
          abstractMethodFail("ZoneRules.transitionRules");
        };
        _proto.toString = function toString() {
          abstractMethodFail("ZoneRules.toString");
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        return ZoneRules2;
      }();
      var Fixed = function(_ZoneRules) {
        _inheritsLoose(Fixed2, _ZoneRules);
        function Fixed2(offset) {
          var _this;
          _this = _ZoneRules.call(this) || this;
          _this._offset = offset;
          return _this;
        }
        var _proto2 = Fixed2.prototype;
        _proto2.isFixedOffset = function isFixedOffset() {
          return true;
        };
        _proto2.offsetOfInstant = function offsetOfInstant() {
          return this._offset;
        };
        _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {
          return this._offset;
        };
        _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
          return this._offset;
        };
        _proto2.validOffsets = function validOffsets() {
          return [this._offset];
        };
        _proto2.transition = function transition() {
          return null;
        };
        _proto2.standardOffset = function standardOffset() {
          return this._offset;
        };
        _proto2.daylightSavings = function daylightSavings() {
          return Duration.ZERO;
        };
        _proto2.isDaylightSavings = function isDaylightSavings() {
          return false;
        };
        _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {
          return this._offset.equals(offset);
        };
        _proto2.nextTransition = function nextTransition() {
          return null;
        };
        _proto2.previousTransition = function previousTransition() {
          return null;
        };
        _proto2.transitions = function transitions() {
          return [];
        };
        _proto2.transitionRules = function transitionRules() {
          return [];
        };
        _proto2.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof Fixed2) {
            return this._offset.equals(other._offset);
          }
          return false;
        };
        _proto2.toString = function toString() {
          return "FixedRules:" + this._offset.toString();
        };
        return Fixed2;
      }(ZoneRules);
      var SECONDS_CACHE = {};
      var ID_CACHE = {};
      var ZoneOffset = function(_ZoneId) {
        _inheritsLoose(ZoneOffset2, _ZoneId);
        function ZoneOffset2(totalSeconds) {
          var _this;
          _this = _ZoneId.call(this) || this;
          ZoneOffset2._validateTotalSeconds(totalSeconds);
          _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
          _this._rules = ZoneRules.of(_assertThisInitialized(_this));
          _this._id = ZoneOffset2._buildId(totalSeconds);
          return _this;
        }
        var _proto = ZoneOffset2.prototype;
        _proto.totalSeconds = function totalSeconds() {
          return this._totalSeconds;
        };
        _proto.id = function id() {
          return this._id;
        };
        ZoneOffset2._buildId = function _buildId(totalSeconds) {
          if (totalSeconds === 0) {
            return "Z";
          } else {
            var absTotalSeconds = Math.abs(totalSeconds);
            var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
            var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
            var buf = (totalSeconds < 0 ? "-" : "+") + (absHours < 10 ? "0" : "") + absHours + (absMinutes < 10 ? ":0" : ":") + absMinutes;
            var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);
            if (absSeconds !== 0) {
              buf += (absSeconds < 10 ? ":0" : ":") + absSeconds;
            }
            return buf;
          }
        };
        ZoneOffset2._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
          if (Math.abs(totalSeconds) > ZoneOffset2.MAX_SECONDS) {
            throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
          }
        };
        ZoneOffset2._validate = function _validate(hours, minutes, seconds) {
          if (hours < -18 || hours > 18) {
            throw new DateTimeException("Zone offset hours not in valid range: value " + hours + " is not in the range -18 to 18");
          }
          if (hours > 0) {
            if (minutes < 0 || seconds < 0) {
              throw new DateTimeException("Zone offset minutes and seconds must be positive because hours is positive");
            }
          } else if (hours < 0) {
            if (minutes > 0 || seconds > 0) {
              throw new DateTimeException("Zone offset minutes and seconds must be negative because hours is negative");
            }
          } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
            throw new DateTimeException("Zone offset minutes and seconds must have the same sign");
          }
          if (Math.abs(minutes) > 59) {
            throw new DateTimeException("Zone offset minutes not in valid range: abs(value) " + Math.abs(minutes) + " is not in the range 0 to 59");
          }
          if (Math.abs(seconds) > 59) {
            throw new DateTimeException("Zone offset seconds not in valid range: abs(value) " + Math.abs(seconds) + " is not in the range 0 to 59");
          }
          if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
            throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
          }
        };
        ZoneOffset2.of = function of(offsetId) {
          requireNonNull(offsetId, "offsetId");
          var offset = ID_CACHE[offsetId];
          if (offset != null) {
            return offset;
          }
          var hours, minutes, seconds;
          switch (offsetId.length) {
            case 2:
              offsetId = offsetId[0] + "0" + offsetId[1];
            case 3:
              hours = ZoneOffset2._parseNumber(offsetId, 1, false);
              minutes = 0;
              seconds = 0;
              break;
            case 5:
              hours = ZoneOffset2._parseNumber(offsetId, 1, false);
              minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
              seconds = 0;
              break;
            case 6:
              hours = ZoneOffset2._parseNumber(offsetId, 1, false);
              minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
              seconds = 0;
              break;
            case 7:
              hours = ZoneOffset2._parseNumber(offsetId, 1, false);
              minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
              seconds = ZoneOffset2._parseNumber(offsetId, 5, false);
              break;
            case 9:
              hours = ZoneOffset2._parseNumber(offsetId, 1, false);
              minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
              seconds = ZoneOffset2._parseNumber(offsetId, 7, true);
              break;
            default:
              throw new DateTimeException("Invalid ID for ZoneOffset, invalid format: " + offsetId);
          }
          var first = offsetId[0];
          if (first !== "+" && first !== "-") {
            throw new DateTimeException("Invalid ID for ZoneOffset, plus/minus not found when expected: " + offsetId);
          }
          if (first === "-") {
            return ZoneOffset2.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
          } else {
            return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, seconds);
          }
        };
        ZoneOffset2._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
          if (precededByColon && offsetId[pos - 1] !== ":") {
            throw new DateTimeException("Invalid ID for ZoneOffset, colon not found when expected: " + offsetId);
          }
          var ch1 = offsetId[pos];
          var ch2 = offsetId[pos + 1];
          if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
            throw new DateTimeException("Invalid ID for ZoneOffset, non numeric characters found: " + offsetId);
          }
          return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
        };
        ZoneOffset2.ofHours = function ofHours(hours) {
          return ZoneOffset2.ofHoursMinutesSeconds(hours, 0, 0);
        };
        ZoneOffset2.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
          return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, 0);
        };
        ZoneOffset2.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
          ZoneOffset2._validate(hours, minutes, seconds);
          var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
          return ZoneOffset2.ofTotalSeconds(totalSeconds);
        };
        ZoneOffset2.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
          var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
          return ZoneOffset2.ofTotalSeconds(totalSeconds);
        };
        ZoneOffset2.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
          if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
            var totalSecs = totalSeconds;
            var result = SECONDS_CACHE[totalSecs];
            if (result == null) {
              result = new ZoneOffset2(totalSeconds);
              SECONDS_CACHE[totalSecs] = result;
              ID_CACHE[result.id()] = result;
            }
            return result;
          } else {
            return new ZoneOffset2(totalSeconds);
          }
        };
        _proto.rules = function rules() {
          return this._rules;
        };
        _proto.get = function get(field) {
          return this.getLong(field);
        };
        _proto.getLong = function getLong(field) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return this._totalSeconds;
          } else if (field instanceof ChronoField) {
            throw new DateTimeException("Unsupported field: " + field);
          }
          return field.getFrom(this);
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query");
          if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
            return this;
          } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
            return null;
          }
          return _query.queryFrom(this);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          return other._totalSeconds - this._totalSeconds;
        };
        _proto.equals = function equals(obj) {
          if (this === obj) {
            return true;
          }
          if (obj instanceof ZoneOffset2) {
            return this._totalSeconds === obj._totalSeconds;
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return this._totalSeconds;
        };
        _proto.toString = function toString() {
          return this._id;
        };
        return ZoneOffset2;
      }(ZoneId);
      function _init$g() {
        ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
        ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
        ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
        ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
      }
      var DateTimeBuilder = function(_TemporalAccessor) {
        _inheritsLoose(DateTimeBuilder2, _TemporalAccessor);
        DateTimeBuilder2.create = function create(field, value) {
          var dtb = new DateTimeBuilder2();
          dtb._addFieldValue(field, value);
          return dtb;
        };
        function DateTimeBuilder2() {
          var _this;
          _this = _TemporalAccessor.call(this) || this;
          _this.fieldValues = new EnumMap();
          _this.chrono = null;
          _this.zone = null;
          _this.date = null;
          _this.time = null;
          _this.leapSecond = false;
          _this.excessDays = null;
          return _this;
        }
        var _proto = DateTimeBuilder2.prototype;
        _proto.getFieldValue0 = function getFieldValue0(field) {
          return this.fieldValues.get(field);
        };
        _proto._addFieldValue = function _addFieldValue(field, value) {
          requireNonNull(field, "field");
          var old = this.getFieldValue0(field);
          if (old != null && old !== value) {
            throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value + ": " + this);
          }
          return this._putFieldValue0(field, value);
        };
        _proto._putFieldValue0 = function _putFieldValue0(field, value) {
          this.fieldValues.put(field, value);
          return this;
        };
        _proto.resolve = function resolve(resolverStyle, resolverFields) {
          if (resolverFields != null) {
            this.fieldValues.retainAll(resolverFields);
          }
          this._mergeDate(resolverStyle);
          this._mergeTime(resolverStyle);
          this._resolveTimeInferZeroes(resolverStyle);
          if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
            this.date = this.date.plus(this.excessDays);
            this.excessDays = Period.ZERO;
          }
          this._resolveInstant();
          return this;
        };
        _proto._mergeDate = function _mergeDate(resolverStyle) {
          this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
        };
        _proto._checkDate = function _checkDate(date) {
          if (date != null) {
            this._addObject(date);
            for (var fieldName in this.fieldValues.keySet()) {
              var field = ChronoField.byName(fieldName);
              if (field) {
                if (this.fieldValues.get(field) !== void 0) {
                  if (field.isDateBased()) {
                    var val1 = void 0;
                    try {
                      val1 = date.getLong(field);
                    } catch (ex) {
                      if (ex instanceof DateTimeException) {
                        continue;
                      } else {
                        throw ex;
                      }
                    }
                    var val2 = this.fieldValues.get(field);
                    if (val1 !== val2) {
                      throw new DateTimeException("Conflict found: Field " + field + " " + val1 + " differs from " + field + " " + val2 + " derived from " + date);
                    }
                  }
                }
              }
            }
          }
        };
        _proto._mergeTime = function _mergeTime(resolverStyle) {
          if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
            var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);
            if (resolverStyle !== ResolverStyle.LENIENT) {
              if (resolverStyle === ResolverStyle.SMART && ch === 0)
                ;
              else {
                ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
              }
            }
            this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
          }
          if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
            var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);
            if (resolverStyle !== ResolverStyle.LENIENT) {
              if (resolverStyle === ResolverStyle.SMART && _ch === 0)
                ;
              else {
                ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
              }
            }
            this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
          }
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
              ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
            }
            if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
              ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
            }
          }
          if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
            var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
            var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);
            this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
          }
          if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
            var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);
            if (resolverStyle !== ResolverStyle.LENIENT) {
              ChronoField.NANO_OF_DAY.checkValidValue(nod);
            }
            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1e9));
            this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1e9));
          }
          if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
            var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);
            if (resolverStyle !== ResolverStyle.LENIENT) {
              ChronoField.MICRO_OF_DAY.checkValidValue(cod);
            }
            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1e6));
            this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1e6));
          }
          if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
            var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);
            if (resolverStyle !== ResolverStyle.LENIENT) {
              ChronoField.MILLI_OF_DAY.checkValidValue(lod);
            }
            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1e3));
            this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1e3));
          }
          if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
            var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);
            if (resolverStyle !== ResolverStyle.LENIENT) {
              ChronoField.SECOND_OF_DAY.checkValidValue(sod);
            }
            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));
            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));
            this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
          }
          if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
            var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);
            if (resolverStyle !== ResolverStyle.LENIENT) {
              ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
            }
            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));
            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
          }
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
              ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
            }
            if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
              ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
            }
          }
          if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
            var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
            var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);
            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1e3 + MathUtil.intMod(cos, 1e3));
          }
          if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
            var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1e3));
            this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
          }
          if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
            var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
            this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1e6));
            this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
          }
          if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
            var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
            this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1e3);
          } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
            var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
            this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1e6);
          }
        };
        _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
          var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
          var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
          var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
          var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
          if (hod == null) {
            return;
          }
          if (moh == null && (som != null || nos != null)) {
            return;
          }
          if (moh != null && som == null && nos != null) {
            return;
          }
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (hod != null) {
              if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
                hod = 0;
                this.excessDays = Period.ofDays(1);
              }
              var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);
              if (moh != null) {
                var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);
                if (som != null) {
                  var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);
                  if (nos != null) {
                    var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);
                    this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
                  } else {
                    this._addObject(LocalTime.of(hodVal, mohVal, somVal));
                  }
                } else {
                  if (nos == null) {
                    this._addObject(LocalTime.of(hodVal, mohVal));
                  }
                }
              } else {
                if (som == null && nos == null) {
                  this._addObject(LocalTime.of(hodVal, 0));
                }
              }
            }
          } else {
            if (hod != null) {
              var _hodVal = hod;
              if (moh != null) {
                if (som != null) {
                  if (nos == null) {
                    nos = 0;
                  }
                  var totalNanos = MathUtil.safeMultiply(_hodVal, 36e11);
                  totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 6e10));
                  totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1e9));
                  totalNanos = MathUtil.safeAdd(totalNanos, nos);
                  var excessDays = MathUtil.floorDiv(totalNanos, 864e11);
                  var nod = MathUtil.floorMod(totalNanos, 864e11);
                  this._addObject(LocalTime.ofNanoOfDay(nod));
                  this.excessDays = Period.ofDays(excessDays);
                } else {
                  var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
                  totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));
                  var _excessDays = MathUtil.floorDiv(totalSecs, 86400);
                  var sod = MathUtil.floorMod(totalSecs, 86400);
                  this._addObject(LocalTime.ofSecondOfDay(sod));
                  this.excessDays = Period.ofDays(_excessDays);
                }
              } else {
                var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));
                _hodVal = MathUtil.floorMod(_hodVal, 24);
                this._addObject(LocalTime.of(_hodVal, 0));
                this.excessDays = Period.ofDays(_excessDays2);
              }
            }
          }
          this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
          this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
          this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
          this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
        };
        _proto._addObject = function _addObject(dateOrTime) {
          if (dateOrTime instanceof ChronoLocalDate) {
            this.date = dateOrTime;
          } else if (dateOrTime instanceof LocalTime) {
            this.time = dateOrTime;
          }
        };
        _proto._resolveInstant = function _resolveInstant() {
          if (this.date != null && this.time != null) {
            var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);
            if (offsetSecs != null) {
              var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
              var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
              this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
            } else if (this.zone != null) {
              var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);
              this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
            }
          }
        };
        _proto.build = function build(type) {
          return type.queryFrom(this);
        };
        _proto.isSupported = function isSupported(field) {
          if (field == null) {
            return false;
          }
          return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== void 0 || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
        };
        _proto.getLong = function getLong(field) {
          requireNonNull(field, "field");
          var value = this.getFieldValue0(field);
          if (value == null) {
            if (this.date != null && this.date.isSupported(field)) {
              return this.date.getLong(field);
            }
            if (this.time != null && this.time.isSupported(field)) {
              return this.time.getLong(field);
            }
            throw new DateTimeException("Field not found: " + field);
          }
          return value;
        };
        _proto.query = function query(_query) {
          if (_query === TemporalQueries.zoneId()) {
            return this.zone;
          } else if (_query === TemporalQueries.chronology()) {
            return this.chrono;
          } else if (_query === TemporalQueries.localDate()) {
            return this.date != null ? LocalDate.from(this.date) : null;
          } else if (_query === TemporalQueries.localTime()) {
            return this.time;
          } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
            return _query.queryFrom(this);
          } else if (_query === TemporalQueries.precision()) {
            return null;
          }
          return _query.queryFrom(this);
        };
        return DateTimeBuilder2;
      }(TemporalAccessor);
      var DateTimeParseContext = function() {
        function DateTimeParseContext2() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof DateTimeParseContext2) {
              this._constructorSelf.apply(this, arguments);
              return;
            } else {
              this._constructorFormatter.apply(this, arguments);
            }
          } else {
            this._constructorParam.apply(this, arguments);
          }
          this._caseSensitive = true;
          this._strict = true;
          this._parsed = [new Parsed(this)];
        }
        var _proto = DateTimeParseContext2.prototype;
        _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {
          this._locale = locale;
          this._symbols = symbols;
          this._overrideChronology = chronology;
        };
        _proto._constructorFormatter = function _constructorFormatter(formatter) {
          this._locale = formatter.locale();
          this._symbols = formatter.decimalStyle();
          this._overrideChronology = formatter.chronology();
        };
        _proto._constructorSelf = function _constructorSelf(other) {
          this._locale = other._locale;
          this._symbols = other._symbols;
          this._overrideChronology = other._overrideChronology;
          this._overrideZone = other._overrideZone;
          this._caseSensitive = other._caseSensitive;
          this._strict = other._strict;
          this._parsed = [new Parsed(this)];
        };
        _proto.copy = function copy() {
          return new DateTimeParseContext2(this);
        };
        _proto.symbols = function symbols() {
          return this._symbols;
        };
        _proto.isStrict = function isStrict() {
          return this._strict;
        };
        _proto.setStrict = function setStrict(strict) {
          this._strict = strict;
        };
        _proto.locale = function locale() {
          return this._locale;
        };
        _proto.setLocale = function setLocale(locale) {
          this._locale = locale;
        };
        _proto.startOptional = function startOptional() {
          this._parsed.push(this.currentParsed().copy());
        };
        _proto.endOptional = function endOptional(successful) {
          if (successful) {
            this._parsed.splice(this._parsed.length - 2, 1);
          } else {
            this._parsed.splice(this._parsed.length - 1, 1);
          }
        };
        _proto.isCaseSensitive = function isCaseSensitive() {
          return this._caseSensitive;
        };
        _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {
          this._caseSensitive = caseSensitive;
        };
        _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
          if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
            return false;
          }
          if (!this.isCaseSensitive()) {
            cs1 = cs1.toLowerCase();
            cs2 = cs2.toLowerCase();
          }
          for (var i = 0; i < length; i++) {
            var ch1 = cs1[offset1 + i];
            var ch2 = cs2[offset2 + i];
            if (ch1 !== ch2) {
              return false;
            }
          }
          return true;
        };
        _proto.charEquals = function charEquals(ch1, ch2) {
          if (this.isCaseSensitive()) {
            return ch1 === ch2;
          }
          return this.charEqualsIgnoreCase(ch1, ch2);
        };
        _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
          return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
        };
        _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {
          var currentParsedFieldValues = this.currentParsed().fieldValues;
          var old = currentParsedFieldValues.get(field);
          currentParsedFieldValues.set(field, value);
          return old != null && old !== value ? ~errorPos : successPos;
        };
        _proto.setParsedZone = function setParsedZone(zone) {
          requireNonNull(zone, "zone");
          this.currentParsed().zone = zone;
        };
        _proto.getParsed = function getParsed(field) {
          return this.currentParsed().fieldValues.get(field);
        };
        _proto.toParsed = function toParsed() {
          return this.currentParsed();
        };
        _proto.currentParsed = function currentParsed() {
          return this._parsed[this._parsed.length - 1];
        };
        _proto.setParsedLeapSecond = function setParsedLeapSecond() {
          this.currentParsed().leapSecond = true;
        };
        _proto.getEffectiveChronology = function getEffectiveChronology() {
          var chrono = this.currentParsed().chrono;
          if (chrono == null) {
            chrono = this._overrideChronology;
            if (chrono == null) {
              chrono = IsoChronology.INSTANCE;
            }
          }
          return chrono;
        };
        return DateTimeParseContext2;
      }();
      var Parsed = function(_Temporal) {
        _inheritsLoose(Parsed2, _Temporal);
        function Parsed2(dateTimeParseContext) {
          var _this;
          _this = _Temporal.call(this) || this;
          _this.chrono = null;
          _this.zone = null;
          _this.fieldValues = new EnumMap();
          _this.leapSecond = false;
          _this.dateTimeParseContext = dateTimeParseContext;
          return _this;
        }
        var _proto2 = Parsed2.prototype;
        _proto2.copy = function copy() {
          var cloned = new Parsed2();
          cloned.chrono = this.chrono;
          cloned.zone = this.zone;
          cloned.fieldValues.putAll(this.fieldValues);
          cloned.leapSecond = this.leapSecond;
          cloned.dateTimeParseContext = this.dateTimeParseContext;
          return cloned;
        };
        _proto2.toString = function toString() {
          return this.fieldValues + ", " + this.chrono + ", " + this.zone;
        };
        _proto2.isSupported = function isSupported(field) {
          return this.fieldValues.containsKey(field);
        };
        _proto2.get = function get(field) {
          var val = this.fieldValues.get(field);
          assert(val != null);
          return val;
        };
        _proto2.query = function query(_query) {
          if (_query === TemporalQueries.chronology()) {
            return this.chrono;
          }
          if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
            return this.zone;
          }
          return _Temporal.prototype.query.call(this, _query);
        };
        _proto2.toBuilder = function toBuilder() {
          var builder = new DateTimeBuilder();
          builder.fieldValues.putAll(this.fieldValues);
          builder.chrono = this.dateTimeParseContext.getEffectiveChronology();
          if (this.zone != null) {
            builder.zone = this.zone;
          } else {
            builder.zone = this.overrideZone;
          }
          builder.leapSecond = this.leapSecond;
          builder.excessDays = this.excessDays;
          return builder;
        };
        return Parsed2;
      }(Temporal);
      var DateTimePrintContext = function() {
        function DateTimePrintContext2(temporal, localeOrFormatter, symbols) {
          if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
            this._temporal = DateTimePrintContext2.adjust(temporal, localeOrFormatter);
            this._locale = localeOrFormatter.locale();
            this._symbols = localeOrFormatter.decimalStyle();
          } else {
            this._temporal = temporal;
            this._locale = localeOrFormatter;
            this._symbols = symbols;
          }
          this._optional = 0;
        }
        DateTimePrintContext2.adjust = function adjust(temporal, formatter) {
          return temporal;
        };
        var _proto = DateTimePrintContext2.prototype;
        _proto.symbols = function symbols() {
          return this._symbols;
        };
        _proto.startOptional = function startOptional() {
          this._optional++;
        };
        _proto.endOptional = function endOptional() {
          this._optional--;
        };
        _proto.getValueQuery = function getValueQuery(query) {
          var result = this._temporal.query(query);
          if (result == null && this._optional === 0) {
            throw new DateTimeException("Unable to extract value: " + this._temporal);
          }
          return result;
        };
        _proto.getValue = function getValue(field) {
          try {
            return this._temporal.getLong(field);
          } catch (ex) {
            if (ex instanceof DateTimeException && this._optional > 0) {
              return null;
            }
            throw ex;
          }
        };
        _proto.temporal = function temporal() {
          return this._temporal;
        };
        _proto.locale = function locale() {
          return this._locale;
        };
        _proto.setDateTime = function setDateTime(temporal) {
          this._temporal = temporal;
        };
        _proto.setLocale = function setLocale(locale) {
          this._locale = locale;
        };
        return DateTimePrintContext2;
      }();
      var IsoFields = {};
      var QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];
      var Field = function(_TemporalField) {
        _inheritsLoose(Field2, _TemporalField);
        function Field2() {
          return _TemporalField.apply(this, arguments) || this;
        }
        var _proto = Field2.prototype;
        _proto.isDateBased = function isDateBased() {
          return true;
        };
        _proto.isTimeBased = function isTimeBased() {
          return false;
        };
        _proto._isIso = function _isIso() {
          return true;
        };
        Field2._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {
          var wby = Field2._getWeekBasedYear(date);
          return ValueRange.of(1, Field2._getWeekRangeByYear(wby));
        };
        Field2._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
          var date = LocalDate.of(wby, 1, 1);
          if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {
            return 53;
          }
          return 52;
        };
        Field2._getWeek = function _getWeek(date) {
          var dow0 = date.dayOfWeek().ordinal();
          var doy0 = date.dayOfYear() - 1;
          var doyThu0 = doy0 + (3 - dow0);
          var alignedWeek = MathUtil.intDiv(doyThu0, 7);
          var firstThuDoy0 = doyThu0 - alignedWeek * 7;
          var firstMonDoy0 = firstThuDoy0 - 3;
          if (firstMonDoy0 < -3) {
            firstMonDoy0 += 7;
          }
          if (doy0 < firstMonDoy0) {
            return Field2._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();
          }
          var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;
          if (week === 53) {
            if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {
              week = 1;
            }
          }
          return week;
        };
        Field2._getWeekBasedYear = function _getWeekBasedYear(date) {
          var year = date.year();
          var doy = date.dayOfYear();
          if (doy <= 3) {
            var dow = date.dayOfWeek().ordinal();
            if (doy - dow < -2) {
              year--;
            }
          } else if (doy >= 363) {
            var _dow = date.dayOfWeek().ordinal();
            doy = doy - 363 - (date.isLeapYear() ? 1 : 0);
            if (doy - _dow >= 0) {
              year++;
            }
          }
          return year;
        };
        _proto.displayName = function displayName() {
          return this.toString();
        };
        _proto.resolve = function resolve() {
          return null;
        };
        _proto.name = function name() {
          return this.toString();
        };
        return Field2;
      }(TemporalField);
      var DAY_OF_QUARTER_FIELD = function(_Field) {
        _inheritsLoose(DAY_OF_QUARTER_FIELD2, _Field);
        function DAY_OF_QUARTER_FIELD2() {
          return _Field.apply(this, arguments) || this;
        }
        var _proto2 = DAY_OF_QUARTER_FIELD2.prototype;
        _proto2.toString = function toString() {
          return "DayOfQuarter";
        };
        _proto2.baseUnit = function baseUnit() {
          return ChronoUnit.DAYS;
        };
        _proto2.rangeUnit = function rangeUnit() {
          return QUARTER_YEARS;
        };
        _proto2.range = function range() {
          return ValueRange.of(1, 90, 92);
        };
        _proto2.isSupportedBy = function isSupportedBy(temporal) {
          return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
        };
        _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {
          if (temporal.isSupported(this) === false) {
            throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
          }
          var qoy = temporal.getLong(QUARTER_OF_YEAR);
          if (qoy === 1) {
            var year = temporal.getLong(ChronoField.YEAR);
            return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
          } else if (qoy === 2) {
            return ValueRange.of(1, 91);
          } else if (qoy === 3 || qoy === 4) {
            return ValueRange.of(1, 92);
          }
          return this.range();
        };
        _proto2.getFrom = function getFrom(temporal) {
          if (temporal.isSupported(this) === false) {
            throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
          }
          var doy = temporal.get(ChronoField.DAY_OF_YEAR);
          var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
          var year = temporal.getLong(ChronoField.YEAR);
          return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
        };
        _proto2.adjustInto = function adjustInto(temporal, newValue) {
          var curValue = this.getFrom(temporal);
          this.range().checkValidValue(newValue, this);
          return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
        };
        _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
          var yearLong = fieldValues.get(ChronoField.YEAR);
          var qoyLong = fieldValues.get(QUARTER_OF_YEAR);
          if (yearLong == null || qoyLong == null) {
            return null;
          }
          var y = ChronoField.YEAR.checkValidIntValue(yearLong);
          var doq = fieldValues.get(DAY_OF_QUARTER);
          var date;
          if (resolverStyle === ResolverStyle.LENIENT) {
            var qoy = qoyLong;
            date = LocalDate.of(y, 1, 1);
            date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
            date = date.plusDays(MathUtil.safeSubtract(doq, 1));
          } else {
            var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);
            if (resolverStyle === ResolverStyle.STRICT) {
              var max = 92;
              if (_qoy === 1) {
                max = IsoChronology.isLeapYear(y) ? 91 : 90;
              } else if (_qoy === 2) {
                max = 91;
              }
              ValueRange.of(1, max).checkValidValue(doq, this);
            } else {
              this.range().checkValidValue(doq, this);
            }
            date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
          }
          fieldValues.remove(this);
          fieldValues.remove(ChronoField.YEAR);
          fieldValues.remove(QUARTER_OF_YEAR);
          return date;
        };
        return DAY_OF_QUARTER_FIELD2;
      }(Field);
      var QUARTER_OF_YEAR_FIELD = function(_Field2) {
        _inheritsLoose(QUARTER_OF_YEAR_FIELD2, _Field2);
        function QUARTER_OF_YEAR_FIELD2() {
          return _Field2.apply(this, arguments) || this;
        }
        var _proto3 = QUARTER_OF_YEAR_FIELD2.prototype;
        _proto3.toString = function toString() {
          return "QuarterOfYear";
        };
        _proto3.baseUnit = function baseUnit() {
          return QUARTER_YEARS;
        };
        _proto3.rangeUnit = function rangeUnit() {
          return ChronoUnit.YEARS;
        };
        _proto3.range = function range() {
          return ValueRange.of(1, 4);
        };
        _proto3.isSupportedBy = function isSupportedBy(temporal) {
          return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
        };
        _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {
          return this.range();
        };
        _proto3.getFrom = function getFrom(temporal) {
          if (temporal.isSupported(this) === false) {
            throw new UnsupportedTemporalTypeException("Unsupported field: QuarterOfYear");
          }
          var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
          return MathUtil.intDiv(moy + 2, 3);
        };
        _proto3.adjustInto = function adjustInto(temporal, newValue) {
          var curValue = this.getFrom(temporal);
          this.range().checkValidValue(newValue, this);
          return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
        };
        return QUARTER_OF_YEAR_FIELD2;
      }(Field);
      var WEEK_OF_WEEK_BASED_YEAR_FIELD = function(_Field3) {
        _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD2, _Field3);
        function WEEK_OF_WEEK_BASED_YEAR_FIELD2() {
          return _Field3.apply(this, arguments) || this;
        }
        var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD2.prototype;
        _proto4.toString = function toString() {
          return "WeekOfWeekBasedYear";
        };
        _proto4.baseUnit = function baseUnit() {
          return ChronoUnit.WEEKS;
        };
        _proto4.rangeUnit = function rangeUnit() {
          return WEEK_BASED_YEARS;
        };
        _proto4.range = function range() {
          return ValueRange.of(1, 52, 53);
        };
        _proto4.isSupportedBy = function isSupportedBy(temporal) {
          return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
        };
        _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {
          if (temporal.isSupported(this) === false) {
            throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
          }
          return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
        };
        _proto4.getFrom = function getFrom(temporal) {
          if (temporal.isSupported(this) === false) {
            throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
          }
          return Field._getWeek(LocalDate.from(temporal));
        };
        _proto4.adjustInto = function adjustInto(temporal, newValue) {
          this.range().checkValidValue(newValue, this);
          return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
        };
        _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
          var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
          var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);
          if (wbyLong == null || dowLong == null) {
            return null;
          }
          var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
          var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
          var date;
          if (resolverStyle === ResolverStyle.LENIENT) {
            var dow = dowLong;
            var weeks = 0;
            if (dow > 7) {
              weeks = MathUtil.intDiv(dow - 1, 7);
              dow = MathUtil.intMod(dow - 1, 7) + 1;
            } else if (dow < 1) {
              weeks = MathUtil.intDiv(dow, 7) - 1;
              dow = MathUtil.intMod(dow, 7) + 7;
            }
            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
          } else {
            var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);
            if (resolverStyle === ResolverStyle.STRICT) {
              var temp = LocalDate.of(wby, 1, 4);
              var range = Field._getWeekRangeByLocalDate(temp);
              range.checkValidValue(wowby, this);
            } else {
              this.range().checkValidValue(wowby, this);
            }
            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
          }
          fieldValues.remove(this);
          fieldValues.remove(WEEK_BASED_YEAR);
          fieldValues.remove(ChronoField.DAY_OF_WEEK);
          return date;
        };
        _proto4.displayName = function displayName() {
          return "Week";
        };
        return WEEK_OF_WEEK_BASED_YEAR_FIELD2;
      }(Field);
      var WEEK_BASED_YEAR_FIELD = function(_Field4) {
        _inheritsLoose(WEEK_BASED_YEAR_FIELD2, _Field4);
        function WEEK_BASED_YEAR_FIELD2() {
          return _Field4.apply(this, arguments) || this;
        }
        var _proto5 = WEEK_BASED_YEAR_FIELD2.prototype;
        _proto5.toString = function toString() {
          return "WeekBasedYear";
        };
        _proto5.baseUnit = function baseUnit() {
          return WEEK_BASED_YEARS;
        };
        _proto5.rangeUnit = function rangeUnit() {
          return ChronoUnit.FOREVER;
        };
        _proto5.range = function range() {
          return ChronoField.YEAR.range();
        };
        _proto5.isSupportedBy = function isSupportedBy(temporal) {
          return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
        };
        _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {
          return ChronoField.YEAR.range();
        };
        _proto5.getFrom = function getFrom(temporal) {
          if (temporal.isSupported(this) === false) {
            throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
          }
          return Field._getWeekBasedYear(LocalDate.from(temporal));
        };
        _proto5.adjustInto = function adjustInto(temporal, newValue) {
          if (this.isSupportedBy(temporal) === false) {
            throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
          }
          var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
          var date = LocalDate.from(temporal);
          var dow = date.get(ChronoField.DAY_OF_WEEK);
          var week = Field._getWeek(date);
          if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
            week = 52;
          }
          var resolved = LocalDate.of(newWby, 1, 4);
          var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
          resolved = resolved.plusDays(days);
          return temporal.with(resolved);
        };
        return WEEK_BASED_YEAR_FIELD2;
      }(Field);
      var Unit = function(_TemporalUnit) {
        _inheritsLoose(Unit2, _TemporalUnit);
        function Unit2(name, estimatedDuration) {
          var _this;
          _this = _TemporalUnit.call(this) || this;
          _this._name = name;
          _this._duration = estimatedDuration;
          return _this;
        }
        var _proto6 = Unit2.prototype;
        _proto6.duration = function duration() {
          return this._duration;
        };
        _proto6.isDurationEstimated = function isDurationEstimated() {
          return true;
        };
        _proto6.isDateBased = function isDateBased() {
          return true;
        };
        _proto6.isTimeBased = function isTimeBased() {
          return false;
        };
        _proto6.isSupportedBy = function isSupportedBy(temporal) {
          return temporal.isSupported(ChronoField.EPOCH_DAY);
        };
        _proto6.addTo = function addTo(temporal, periodToAdd) {
          switch (this) {
            case WEEK_BASED_YEARS: {
              var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
              return temporal.with(WEEK_BASED_YEAR, added);
            }
            case QUARTER_YEARS:
              return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);
            default:
              throw new IllegalStateException("Unreachable");
          }
        };
        _proto6.between = function between(temporal1, temporal2) {
          switch (this) {
            case WEEK_BASED_YEARS:
              return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));
            case QUARTER_YEARS:
              return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);
            default:
              throw new IllegalStateException("Unreachable");
          }
        };
        _proto6.toString = function toString() {
          return this._name;
        };
        return Unit2;
      }(TemporalUnit);
      var DAY_OF_QUARTER = null;
      var QUARTER_OF_YEAR = null;
      var WEEK_OF_WEEK_BASED_YEAR = null;
      var WEEK_BASED_YEAR = null;
      var WEEK_BASED_YEARS = null;
      var QUARTER_YEARS = null;
      function _init$f() {
        DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
        QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
        WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
        WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();
        WEEK_BASED_YEARS = new Unit("WeekBasedYears", Duration.ofSeconds(31556952));
        QUARTER_YEARS = new Unit("QuarterYears", Duration.ofSeconds(31556952 / 4));
        IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
        IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
        IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
        IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
        IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
        IsoFields.QUARTER_YEARS = QUARTER_YEARS;
        LocalDate.prototype.isoWeekOfWeekyear = function() {
          return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
        };
        LocalDate.prototype.isoWeekyear = function() {
          return this.get(IsoFields.WEEK_BASED_YEAR);
        };
      }
      var DecimalStyle = function() {
        function DecimalStyle2(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
          this._zeroDigit = zeroChar;
          this._zeroDigitCharCode = zeroChar.charCodeAt(0);
          this._positiveSign = positiveSignChar;
          this._negativeSign = negativeSignChar;
          this._decimalSeparator = decimalPointChar;
        }
        var _proto = DecimalStyle2.prototype;
        _proto.positiveSign = function positiveSign() {
          return this._positiveSign;
        };
        _proto.withPositiveSign = function withPositiveSign(positiveSign) {
          if (positiveSign === this._positiveSign) {
            return this;
          }
          return new DecimalStyle2(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
        };
        _proto.negativeSign = function negativeSign() {
          return this._negativeSign;
        };
        _proto.withNegativeSign = function withNegativeSign(negativeSign) {
          if (negativeSign === this._negativeSign) {
            return this;
          }
          return new DecimalStyle2(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
        };
        _proto.zeroDigit = function zeroDigit() {
          return this._zeroDigit;
        };
        _proto.withZeroDigit = function withZeroDigit(zeroDigit) {
          if (zeroDigit === this._zeroDigit) {
            return this;
          }
          return new DecimalStyle2(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
        };
        _proto.decimalSeparator = function decimalSeparator() {
          return this._decimalSeparator;
        };
        _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
          if (decimalSeparator === this._decimalSeparator) {
            return this;
          }
          return new DecimalStyle2(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
        };
        _proto.convertToDigit = function convertToDigit(char) {
          var val = char.charCodeAt(0) - this._zeroDigitCharCode;
          return val >= 0 && val <= 9 ? val : -1;
        };
        _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {
          if (this._zeroDigit === "0") {
            return numericText;
          }
          var diff = this._zeroDigitCharCode - "0".charCodeAt(0);
          var convertedText = "";
          for (var i = 0; i < numericText.length; i++) {
            convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);
          }
          return convertedText;
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof DecimalStyle2) {
            return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
        };
        _proto.toString = function toString() {
          return "DecimalStyle[" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + "]";
        };
        DecimalStyle2.of = function of() {
          throw new Error("not yet supported");
        };
        DecimalStyle2.availableLocales = function availableLocales() {
          throw new Error("not yet supported");
        };
        return DecimalStyle2;
      }();
      DecimalStyle.STANDARD = new DecimalStyle("0", "+", "-", ".");
      var SignStyle = function(_Enum) {
        _inheritsLoose(SignStyle2, _Enum);
        function SignStyle2() {
          return _Enum.apply(this, arguments) || this;
        }
        var _proto = SignStyle2.prototype;
        _proto.parse = function parse2(positive, strict, fixedWidth) {
          switch (this) {
            case SignStyle2.NORMAL:
              return !positive || !strict;
            case SignStyle2.ALWAYS:
            case SignStyle2.EXCEEDS_PAD:
              return true;
            default:
              return !strict && !fixedWidth;
          }
        };
        return SignStyle2;
      }(Enum);
      SignStyle.NORMAL = new SignStyle("NORMAL");
      SignStyle.NEVER = new SignStyle("NEVER");
      SignStyle.ALWAYS = new SignStyle("ALWAYS");
      SignStyle.EXCEEDS_PAD = new SignStyle("EXCEEDS_PAD");
      SignStyle.NOT_NEGATIVE = new SignStyle("NOT_NEGATIVE");
      var TextStyle = function(_Enum) {
        _inheritsLoose(TextStyle2, _Enum);
        function TextStyle2() {
          return _Enum.apply(this, arguments) || this;
        }
        var _proto = TextStyle2.prototype;
        _proto.isStandalone = function isStandalone() {
          switch (this) {
            case TextStyle2.FULL_STANDALONE:
            case TextStyle2.SHORT_STANDALONE:
            case TextStyle2.NARROW_STANDALONE:
              return true;
            default:
              return false;
          }
        };
        _proto.asStandalone = function asStandalone() {
          switch (this) {
            case TextStyle2.FULL:
              return TextStyle2.FULL_STANDALONE;
            case TextStyle2.SHORT:
              return TextStyle2.SHORT_STANDALONE;
            case TextStyle2.NARROW:
              return TextStyle2.NARROW_STANDALONE;
            default:
              return this;
          }
        };
        _proto.asNormal = function asNormal() {
          switch (this) {
            case TextStyle2.FULL_STANDALONE:
              return TextStyle2.FULL;
            case TextStyle2.SHORT_STANDALONE:
              return TextStyle2.SHORT;
            case TextStyle2.NARROW_STANDALONE:
              return TextStyle2.NARROW;
            default:
              return this;
          }
        };
        return TextStyle2;
      }(Enum);
      TextStyle.FULL = new TextStyle("FULL");
      TextStyle.FULL_STANDALONE = new TextStyle("FULL_STANDALONE");
      TextStyle.SHORT = new TextStyle("SHORT");
      TextStyle.SHORT_STANDALONE = new TextStyle("SHORT_STANDALONE");
      TextStyle.NARROW = new TextStyle("NARROW");
      TextStyle.NARROW_STANDALONE = new TextStyle("NARROW_STANDALONE");
      var CharLiteralPrinterParser = function() {
        function CharLiteralPrinterParser2(literal) {
          if (literal.length > 1) {
            throw new IllegalArgumentException('invalid literal, too long: "' + literal + '"');
          }
          this._literal = literal;
        }
        var _proto = CharLiteralPrinterParser2.prototype;
        _proto.print = function print(context, buf) {
          buf.append(this._literal);
          return true;
        };
        _proto.parse = function parse2(context, text, position) {
          var length = text.length;
          if (position === length) {
            return ~position;
          }
          var ch = text.charAt(position);
          if (context.charEquals(this._literal, ch) === false) {
            return ~position;
          }
          return position + this._literal.length;
        };
        _proto.toString = function toString() {
          if (this._literal === "'") {
            return "''";
          }
          return "'" + this._literal + "'";
        };
        return CharLiteralPrinterParser2;
      }();
      var CompositePrinterParser = function() {
        function CompositePrinterParser2(printerParsers, optional) {
          this._printerParsers = printerParsers;
          this._optional = optional;
        }
        var _proto = CompositePrinterParser2.prototype;
        _proto.withOptional = function withOptional(optional) {
          if (optional === this._optional) {
            return this;
          }
          return new CompositePrinterParser2(this._printerParsers, optional);
        };
        _proto.print = function print(context, buf) {
          var length = buf.length();
          if (this._optional) {
            context.startOptional();
          }
          try {
            for (var i = 0; i < this._printerParsers.length; i++) {
              var pp = this._printerParsers[i];
              if (pp.print(context, buf) === false) {
                buf.setLength(length);
                return true;
              }
            }
          } finally {
            if (this._optional) {
              context.endOptional();
            }
          }
          return true;
        };
        _proto.parse = function parse2(context, text, position) {
          if (this._optional) {
            context.startOptional();
            var pos = position;
            for (var i = 0; i < this._printerParsers.length; i++) {
              var pp = this._printerParsers[i];
              pos = pp.parse(context, text, pos);
              if (pos < 0) {
                context.endOptional(false);
                return position;
              }
            }
            context.endOptional(true);
            return pos;
          } else {
            for (var _i = 0; _i < this._printerParsers.length; _i++) {
              var _pp = this._printerParsers[_i];
              position = _pp.parse(context, text, position);
              if (position < 0) {
                break;
              }
            }
            return position;
          }
        };
        _proto.toString = function toString() {
          var buf = "";
          if (this._printerParsers != null) {
            buf += this._optional ? "[" : "(";
            for (var i = 0; i < this._printerParsers.length; i++) {
              var pp = this._printerParsers[i];
              buf += pp.toString();
            }
            buf += this._optional ? "]" : ")";
          }
          return buf;
        };
        return CompositePrinterParser2;
      }();
      var FractionPrinterParser = function() {
        function FractionPrinterParser2(field, minWidth, maxWidth, decimalPoint) {
          requireNonNull(field, "field");
          if (field.range().isFixed() === false) {
            throw new IllegalArgumentException("Field must have a fixed set of values: " + field);
          }
          if (minWidth < 0 || minWidth > 9) {
            throw new IllegalArgumentException("Minimum width must be from 0 to 9 inclusive but was " + minWidth);
          }
          if (maxWidth < 1 || maxWidth > 9) {
            throw new IllegalArgumentException("Maximum width must be from 1 to 9 inclusive but was " + maxWidth);
          }
          if (maxWidth < minWidth) {
            throw new IllegalArgumentException("Maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
          }
          this.field = field;
          this.minWidth = minWidth;
          this.maxWidth = maxWidth;
          this.decimalPoint = decimalPoint;
        }
        var _proto = FractionPrinterParser2.prototype;
        _proto.print = function print(context, buf) {
          var value = context.getValue(this.field);
          if (value === null) {
            return false;
          }
          var symbols = context.symbols();
          if (value === 0) {
            if (this.minWidth > 0) {
              if (this.decimalPoint) {
                buf.append(symbols.decimalSeparator());
              }
              for (var i = 0; i < this.minWidth; i++) {
                buf.append(symbols.zeroDigit());
              }
            }
          } else {
            var fraction = this.convertToFraction(value, symbols.zeroDigit());
            var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
            fraction = fraction.substr(0, outputScale);
            if (fraction * 1 > 0) {
              while (fraction.length > this.minWidth && fraction[fraction.length - 1] === "0") {
                fraction = fraction.substr(0, fraction.length - 1);
              }
            }
            var str = fraction;
            str = symbols.convertNumberToI18N(str);
            if (this.decimalPoint) {
              buf.append(symbols.decimalSeparator());
            }
            buf.append(str);
          }
          return true;
        };
        _proto.parse = function parse2(context, text, position) {
          var effectiveMin = context.isStrict() ? this.minWidth : 0;
          var effectiveMax = context.isStrict() ? this.maxWidth : 9;
          var length = text.length;
          if (position === length) {
            return effectiveMin > 0 ? ~position : position;
          }
          if (this.decimalPoint) {
            if (text[position] !== context.symbols().decimalSeparator()) {
              return effectiveMin > 0 ? ~position : position;
            }
            position++;
          }
          var minEndPos = position + effectiveMin;
          if (minEndPos > length) {
            return ~position;
          }
          var maxEndPos = Math.min(position + effectiveMax, length);
          var total = 0;
          var pos = position;
          while (pos < maxEndPos) {
            var ch = text.charAt(pos++);
            var digit = context.symbols().convertToDigit(ch);
            if (digit < 0) {
              if (pos < minEndPos) {
                return ~position;
              }
              pos--;
              break;
            }
            total = total * 10 + digit;
          }
          var moveLeft = pos - position;
          var scale = Math.pow(10, moveLeft);
          var value = this.convertFromFraction(total, scale);
          return context.setParsedField(this.field, value, position, pos);
        };
        _proto.convertToFraction = function convertToFraction(value, zeroDigit) {
          var range = this.field.range();
          range.checkValidValue(value, this.field);
          var _min = range.minimum();
          var _range = range.maximum() - _min + 1;
          var _value = value - _min;
          var _scaled = MathUtil.intDiv(_value * 1e9, _range);
          var fraction = "" + _scaled;
          while (fraction.length < 9) {
            fraction = zeroDigit + fraction;
          }
          return fraction;
        };
        _proto.convertFromFraction = function convertFromFraction(total, scale) {
          var range = this.field.range();
          var _min = range.minimum();
          var _range = range.maximum() - _min + 1;
          var _value = MathUtil.intDiv(total * _range, scale);
          return _value;
        };
        _proto.toString = function toString() {
          var decimal = this.decimalPoint ? ",DecimalPoint" : "";
          return "Fraction(" + this.field + "," + this.minWidth + "," + this.maxWidth + decimal + ")";
        };
        return FractionPrinterParser2;
      }();
      var MAX_WIDTH$1 = 15;
      var EXCEED_POINTS = [0, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
      var NumberPrinterParser = function() {
        function NumberPrinterParser2(field, minWidth, maxWidth, signStyle, subsequentWidth) {
          if (subsequentWidth === void 0) {
            subsequentWidth = 0;
          }
          this._field = field;
          this._minWidth = minWidth;
          this._maxWidth = maxWidth;
          this._signStyle = signStyle;
          this._subsequentWidth = subsequentWidth;
        }
        var _proto = NumberPrinterParser2.prototype;
        _proto.field = function field() {
          return this._field;
        };
        _proto.minWidth = function minWidth() {
          return this._minWidth;
        };
        _proto.maxWidth = function maxWidth() {
          return this._maxWidth;
        };
        _proto.signStyle = function signStyle() {
          return this._signStyle;
        };
        _proto.withFixedWidth = function withFixedWidth() {
          if (this._subsequentWidth === -1) {
            return this;
          }
          return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
        };
        _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
          return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
        };
        _proto._isFixedWidth = function _isFixedWidth() {
          return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
        };
        _proto.print = function print(context, buf) {
          var contextValue = context.getValue(this._field);
          if (contextValue == null) {
            return false;
          }
          var value = this._getValue(context, contextValue);
          var symbols = context.symbols();
          var str = "" + Math.abs(value);
          if (str.length > this._maxWidth) {
            throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " exceeds the maximum print width of " + this._maxWidth);
          }
          str = symbols.convertNumberToI18N(str);
          if (value >= 0) {
            switch (this._signStyle) {
              case SignStyle.EXCEEDS_PAD:
                if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {
                  buf.append(symbols.positiveSign());
                }
                break;
              case SignStyle.ALWAYS:
                buf.append(symbols.positiveSign());
                break;
            }
          } else {
            switch (this._signStyle) {
              case SignStyle.NORMAL:
              case SignStyle.EXCEEDS_PAD:
              case SignStyle.ALWAYS:
                buf.append(symbols.negativeSign());
                break;
              case SignStyle.NOT_NEGATIVE:
                throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " cannot be negative according to the SignStyle");
            }
          }
          for (var i = 0; i < this._minWidth - str.length; i++) {
            buf.append(symbols.zeroDigit());
          }
          buf.append(str);
          return true;
        };
        _proto.parse = function parse2(context, text, position) {
          var length = text.length;
          if (position === length) {
            return ~position;
          }
          assert(position >= 0 && position < length);
          var sign = text.charAt(position);
          var negative = false;
          var positive = false;
          if (sign === context.symbols().positiveSign()) {
            if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {
              return ~position;
            }
            positive = true;
            position++;
          } else if (sign === context.symbols().negativeSign()) {
            if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {
              return ~position;
            }
            negative = true;
            position++;
          } else {
            if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {
              return ~position;
            }
          }
          var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
          var minEndPos = position + effMinWidth;
          if (minEndPos > length) {
            return ~position;
          }
          var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
          var total = 0;
          var pos = position;
          for (var pass = 0; pass < 2; pass++) {
            var maxEndPos = Math.min(pos + effMaxWidth, length);
            while (pos < maxEndPos) {
              var ch = text.charAt(pos++);
              var digit = context.symbols().convertToDigit(ch);
              if (digit < 0) {
                pos--;
                if (pos < minEndPos) {
                  return ~position;
                }
                break;
              }
              if (pos - position > MAX_WIDTH$1) {
                throw new ArithmeticException("number text exceeds length");
              } else {
                total = total * 10 + digit;
              }
            }
            if (this._subsequentWidth > 0 && pass === 0) {
              var parseLen = pos - position;
              effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
              pos = position;
              total = 0;
            } else {
              break;
            }
          }
          if (negative) {
            if (total === 0 && context.isStrict()) {
              return ~(position - 1);
            }
            if (total !== 0) {
              total = -total;
            }
          } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {
            var _parseLen = pos - position;
            if (positive) {
              if (_parseLen <= this._minWidth) {
                return ~(position - 1);
              }
            } else {
              if (_parseLen > this._minWidth) {
                return ~position;
              }
            }
          }
          return this._setValue(context, total, position, pos);
        };
        _proto._getValue = function _getValue(context, value) {
          return value;
        };
        _proto._setValue = function _setValue(context, value, errorPos, successPos) {
          return context.setParsedField(this._field, value, errorPos, successPos);
        };
        _proto.toString = function toString() {
          if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {
            return "Value(" + this._field + ")";
          }
          if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
            return "Value(" + this._field + "," + this._minWidth + ")";
          }
          return "Value(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + this._signStyle + ")";
        };
        return NumberPrinterParser2;
      }();
      var ReducedPrinterParser = function(_NumberPrinterParser) {
        _inheritsLoose(ReducedPrinterParser2, _NumberPrinterParser);
        function ReducedPrinterParser2(field, width, maxWidth, baseValue, baseDate) {
          var _this;
          _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;
          if (width < 1 || width > 10) {
            throw new IllegalArgumentException("The width must be from 1 to 10 inclusive but was " + width);
          }
          if (maxWidth < 1 || maxWidth > 10) {
            throw new IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was " + maxWidth);
          }
          if (maxWidth < width) {
            throw new IllegalArgumentException("The maxWidth must be greater than the width");
          }
          if (baseDate === null) {
            if (field.range().isValidValue(baseValue) === false) {
              throw new IllegalArgumentException("The base value must be within the range of the field");
            }
            if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
              throw new DateTimeException("Unable to add printer-parser as the range exceeds the capacity of an int");
            }
          }
          _this._baseValue = baseValue;
          _this._baseDate = baseDate;
          return _this;
        }
        var _proto2 = ReducedPrinterParser2.prototype;
        _proto2._getValue = function _getValue(context, value) {
          var absValue = Math.abs(value);
          var baseValue = this._baseValue;
          if (this._baseDate !== null) {
            context.temporal();
            var chrono = IsoChronology.INSTANCE;
            baseValue = chrono.date(this._baseDate).get(this._field);
          }
          if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
            return absValue % EXCEED_POINTS[this._minWidth];
          }
          return absValue % EXCEED_POINTS[this._maxWidth];
        };
        _proto2._setValue = function _setValue(context, value, errorPos, successPos) {
          var baseValue = this._baseValue;
          if (this._baseDate != null) {
            var chrono = context.getEffectiveChronology();
            baseValue = chrono.date(this._baseDate).get(this._field);
          }
          var parseLen = successPos - errorPos;
          if (parseLen === this._minWidth && value >= 0) {
            var range = EXCEED_POINTS[this._minWidth];
            var lastPart = baseValue % range;
            var basePart = baseValue - lastPart;
            if (baseValue > 0) {
              value = basePart + value;
            } else {
              value = basePart - value;
            }
            if (value < baseValue) {
              value += range;
            }
          }
          return context.setParsedField(this._field, value, errorPos, successPos);
        };
        _proto2.withFixedWidth = function withFixedWidth() {
          if (this._subsequentWidth === -1) {
            return this;
          }
          return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate);
        };
        _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
          return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
        };
        _proto2.isFixedWidth = function isFixedWidth(context) {
          if (context.isStrict() === false) {
            return false;
          }
          return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);
        };
        _proto2.toString = function toString() {
          return "ReducedValue(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + (this._baseDate != null ? this._baseDate : this._baseValue) + ")";
        };
        return ReducedPrinterParser2;
      }(NumberPrinterParser);
      var PATTERNS = ["+HH", "+HHmm", "+HH:mm", "+HHMM", "+HH:MM", "+HHMMss", "+HH:MM:ss", "+HHMMSS", "+HH:MM:SS"];
      var OffsetIdPrinterParser = function() {
        function OffsetIdPrinterParser2(noOffsetText, pattern) {
          requireNonNull(noOffsetText, "noOffsetText");
          requireNonNull(pattern, "pattern");
          this.noOffsetText = noOffsetText;
          this.type = this._checkPattern(pattern);
        }
        var _proto = OffsetIdPrinterParser2.prototype;
        _proto._checkPattern = function _checkPattern(pattern) {
          for (var i = 0; i < PATTERNS.length; i++) {
            if (PATTERNS[i] === pattern) {
              return i;
            }
          }
          throw new IllegalArgumentException("Invalid zone offset pattern: " + pattern);
        };
        _proto.print = function print(context, buf) {
          var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);
          if (offsetSecs == null) {
            return false;
          }
          var totalSecs = MathUtil.safeToInt(offsetSecs);
          if (totalSecs === 0) {
            buf.append(this.noOffsetText);
          } else {
            var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
            var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
            var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
            var bufPos = buf.length();
            var output = absHours;
            buf.append(totalSecs < 0 ? "-" : "+").appendChar(MathUtil.intDiv(absHours, 10) + "0").appendChar(MathUtil.intMod(absHours, 10) + "0");
            if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
              buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absMinutes, 10) + "0").appendChar(absMinutes % 10 + "0");
              output += absMinutes;
              if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
                buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absSeconds, 10) + "0").appendChar(absSeconds % 10 + "0");
                output += absSeconds;
              }
            }
            if (output === 0) {
              buf.setLength(bufPos);
              buf.append(this.noOffsetText);
            }
          }
          return true;
        };
        _proto.parse = function parse2(context, text, position) {
          var length = text.length;
          var noOffsetLen = this.noOffsetText.length;
          if (noOffsetLen === 0) {
            if (position === length) {
              return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
            }
          } else {
            if (position === length) {
              return ~position;
            }
            if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
              return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
            }
          }
          var sign = text[position];
          if (sign === "+" || sign === "-") {
            var negative = sign === "-" ? -1 : 1;
            var array = [0, 0, 0, 0];
            array[0] = position + 1;
            if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {
              var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
              return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
            }
          }
          if (noOffsetLen === 0) {
            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
          }
          return ~position;
        };
        _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
          if ((this.type + 3) / 2 < arrayIndex) {
            return false;
          }
          var pos = array[0];
          if (this.type % 2 === 0 && arrayIndex > 1) {
            if (pos + 1 > parseText.length || parseText[pos] !== ":") {
              return required;
            }
            pos++;
          }
          if (pos + 2 > parseText.length) {
            return required;
          }
          var ch1 = parseText[pos++];
          var ch2 = parseText[pos++];
          if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
            return required;
          }
          var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
          if (value < 0 || value > 59) {
            return required;
          }
          array[arrayIndex] = value;
          array[0] = pos;
          return false;
        };
        _proto.toString = function toString() {
          var converted = this.noOffsetText.replace("'", "''");
          return "Offset(" + PATTERNS[this.type] + ",'" + converted + "')";
        };
        return OffsetIdPrinterParser2;
      }();
      OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser("Z", "+HH:MM:ss");
      OffsetIdPrinterParser.PATTERNS = PATTERNS;
      var PadPrinterParserDecorator = function() {
        function PadPrinterParserDecorator2(printerParser, padWidth, padChar) {
          this._printerParser = printerParser;
          this._padWidth = padWidth;
          this._padChar = padChar;
        }
        var _proto = PadPrinterParserDecorator2.prototype;
        _proto.print = function print(context, buf) {
          var preLen = buf.length();
          if (this._printerParser.print(context, buf) === false) {
            return false;
          }
          var len = buf.length() - preLen;
          if (len > this._padWidth) {
            throw new DateTimeException("Cannot print as output of " + len + " characters exceeds pad width of " + this._padWidth);
          }
          for (var i = 0; i < this._padWidth - len; i++) {
            buf.insert(preLen, this._padChar);
          }
          return true;
        };
        _proto.parse = function parse2(context, text, position) {
          var strict = context.isStrict();
          var caseSensitive = context.isCaseSensitive();
          assert(!(position > text.length));
          assert(position >= 0);
          if (position === text.length) {
            return ~position;
          }
          var endPos = position + this._padWidth;
          if (endPos > text.length) {
            if (strict) {
              return ~position;
            }
            endPos = text.length;
          }
          var pos = position;
          while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {
            pos++;
          }
          text = text.substring(0, endPos);
          var resultPos = this._printerParser.parse(context, text, pos);
          if (resultPos !== endPos && strict) {
            return ~(position + pos);
          }
          return resultPos;
        };
        _proto.toString = function toString() {
          return "Pad(" + this._printerParser + "," + this._padWidth + (this._padChar === " " ? ")" : ",'" + this._padChar + "')");
        };
        return PadPrinterParserDecorator2;
      }();
      var SettingsParser = function(_Enum) {
        _inheritsLoose(SettingsParser2, _Enum);
        function SettingsParser2() {
          return _Enum.apply(this, arguments) || this;
        }
        var _proto = SettingsParser2.prototype;
        _proto.print = function print() {
          return true;
        };
        _proto.parse = function parse2(context, text, position) {
          switch (this) {
            case SettingsParser2.SENSITIVE:
              context.setCaseSensitive(true);
              break;
            case SettingsParser2.INSENSITIVE:
              context.setCaseSensitive(false);
              break;
            case SettingsParser2.STRICT:
              context.setStrict(true);
              break;
            case SettingsParser2.LENIENT:
              context.setStrict(false);
              break;
          }
          return position;
        };
        _proto.toString = function toString() {
          switch (this) {
            case SettingsParser2.SENSITIVE:
              return "ParseCaseSensitive(true)";
            case SettingsParser2.INSENSITIVE:
              return "ParseCaseSensitive(false)";
            case SettingsParser2.STRICT:
              return "ParseStrict(true)";
            case SettingsParser2.LENIENT:
              return "ParseStrict(false)";
          }
        };
        return SettingsParser2;
      }(Enum);
      SettingsParser.SENSITIVE = new SettingsParser("SENSITIVE");
      SettingsParser.INSENSITIVE = new SettingsParser("INSENSITIVE");
      SettingsParser.STRICT = new SettingsParser("STRICT");
      SettingsParser.LENIENT = new SettingsParser("LENIENT");
      var StringLiteralPrinterParser = function() {
        function StringLiteralPrinterParser2(literal) {
          this._literal = literal;
        }
        var _proto = StringLiteralPrinterParser2.prototype;
        _proto.print = function print(context, buf) {
          buf.append(this._literal);
          return true;
        };
        _proto.parse = function parse2(context, text, position) {
          var length = text.length;
          assert(!(position > length || position < 0));
          if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
            return ~position;
          }
          return position + this._literal.length;
        };
        _proto.toString = function toString() {
          var converted = this._literal.replace("'", "''");
          return "'" + converted + "'";
        };
        return StringLiteralPrinterParser2;
      }();
      var ZoneRulesProvider = function() {
        function ZoneRulesProvider2() {
        }
        ZoneRulesProvider2.getRules = function getRules(_zoneId) {
          throw new DateTimeException("@js-joda/timezone not imported");
        };
        ZoneRulesProvider2.getAvailableZoneIds = function getAvailableZoneIds() {
          return [];
        };
        return ZoneRulesProvider2;
      }();
      var ZoneRegion = function(_ZoneId) {
        _inheritsLoose(ZoneRegion2, _ZoneId);
        ZoneRegion2.ofId = function ofId(zoneId) {
          var rules = ZoneRulesProvider.getRules(zoneId);
          return new ZoneRegion2(zoneId, rules);
        };
        function ZoneRegion2(id, rules) {
          var _this;
          _this = _ZoneId.call(this) || this;
          _this._id = id;
          _this._rules = rules;
          return _this;
        }
        var _proto = ZoneRegion2.prototype;
        _proto.id = function id() {
          return this._id;
        };
        _proto.rules = function rules() {
          return this._rules;
        };
        return ZoneRegion2;
      }(ZoneId);
      var ZoneIdPrinterParser = function() {
        function ZoneIdPrinterParser2(query, description) {
          this.query = query;
          this.description = description;
        }
        var _proto = ZoneIdPrinterParser2.prototype;
        _proto.print = function print(context, buf) {
          var zone = context.getValueQuery(this.query);
          if (zone == null) {
            return false;
          }
          buf.append(zone.id());
          return true;
        };
        _proto.parse = function parse2(context, text, position) {
          var length = text.length;
          if (position > length) {
            return ~position;
          }
          if (position === length) {
            return ~position;
          }
          var nextChar = text.charAt(position);
          if (nextChar === "+" || nextChar === "-") {
            var newContext = context.copy();
            var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
            if (endPos < 0) {
              return endPos;
            }
            var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
            var zone = ZoneOffset.ofTotalSeconds(offset);
            context.setParsedZone(zone);
            return endPos;
          } else if (length >= position + 2) {
            var nextNextChar = text.charAt(position + 1);
            if (context.charEquals(nextChar, "U") && context.charEquals(nextNextChar, "T")) {
              if (length >= position + 3 && context.charEquals(text.charAt(position + 2), "C")) {
                return this._parsePrefixedOffset(context, text, position, position + 3);
              }
              return this._parsePrefixedOffset(context, text, position, position + 2);
            } else if (context.charEquals(nextChar, "G") && length >= position + 3 && context.charEquals(nextNextChar, "M") && context.charEquals(text.charAt(position + 2), "T")) {
              return this._parsePrefixedOffset(context, text, position, position + 3);
            }
          }
          if (text.substr(position, 6) === "SYSTEM") {
            context.setParsedZone(ZoneId.systemDefault());
            return position + 6;
          }
          if (context.charEquals(nextChar, "Z")) {
            context.setParsedZone(ZoneOffset.UTC);
            return position + 1;
          }
          var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
          if (zoneIdTree.size !== availableZoneIds.length) {
            zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
          }
          var maxParseLength = length - position;
          var treeMap = zoneIdTree.treeMap;
          var parsedZoneId = null;
          var parseLength = 0;
          while (treeMap != null) {
            var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));
            treeMap = treeMap.get(parsedSubZoneId);
            if (treeMap != null && treeMap.isLeaf) {
              parsedZoneId = parsedSubZoneId;
              parseLength = treeMap.length;
            }
          }
          if (parsedZoneId != null) {
            context.setParsedZone(ZoneRegion.ofId(parsedZoneId));
            return position + parseLength;
          }
          return ~position;
        };
        _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {
          var prefix = text.substring(prefixPos, position).toUpperCase();
          var newContext = context.copy();
          if (position < text.length && context.charEquals(text.charAt(position), "Z")) {
            context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
            return position;
          }
          var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
          if (endPos < 0) {
            context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
            return position;
          }
          var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
          var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
          context.setParsedZone(ZoneId.ofOffset(prefix, offset));
          return endPos;
        };
        _proto.toString = function toString() {
          return this.description;
        };
        return ZoneIdPrinterParser2;
      }();
      var ZoneIdTree = function() {
        ZoneIdTree2.createTreeMap = function createTreeMap(availableZoneIds) {
          var sortedZoneIds = availableZoneIds.sort(function(a, b) {
            return a.length - b.length;
          });
          var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);
          for (var i = 0; i < sortedZoneIds.length; i++) {
            treeMap.add(sortedZoneIds[i]);
          }
          return new ZoneIdTree2(sortedZoneIds.length, treeMap);
        };
        function ZoneIdTree2(size, treeMap) {
          this.size = size;
          this.treeMap = treeMap;
        }
        return ZoneIdTree2;
      }();
      var ZoneIdTreeMap = function() {
        function ZoneIdTreeMap2(length, isLeaf) {
          if (length === void 0) {
            length = 0;
          }
          if (isLeaf === void 0) {
            isLeaf = false;
          }
          this.length = length;
          this.isLeaf = isLeaf;
          this._treeMap = {};
        }
        var _proto2 = ZoneIdTreeMap2.prototype;
        _proto2.add = function add(zoneId) {
          var idLength = zoneId.length;
          if (idLength === this.length) {
            this._treeMap[zoneId] = new ZoneIdTreeMap2(idLength, true);
          } else if (idLength > this.length) {
            var subZoneId = zoneId.substr(0, this.length);
            var subTreeMap = this._treeMap[subZoneId];
            if (subTreeMap == null) {
              subTreeMap = new ZoneIdTreeMap2(idLength, false);
              this._treeMap[subZoneId] = subTreeMap;
            }
            subTreeMap.add(zoneId);
          }
        };
        _proto2.get = function get(zoneId) {
          return this._treeMap[zoneId];
        };
        return ZoneIdTreeMap2;
      }();
      var zoneIdTree = new ZoneIdTree([]);
      var MAX_WIDTH = 15;
      var DateTimeFormatterBuilder = function() {
        function DateTimeFormatterBuilder2() {
          this._active = this;
          this._parent = null;
          this._printerParsers = [];
          this._optional = false;
          this._padNextWidth = 0;
          this._padNextChar = null;
          this._valueParserIndex = -1;
        }
        DateTimeFormatterBuilder2._of = function _of(parent, optional) {
          requireNonNull(parent, "parent");
          requireNonNull(optional, "optional");
          var dtFormatterBuilder = new DateTimeFormatterBuilder2();
          dtFormatterBuilder._parent = parent;
          dtFormatterBuilder._optional = optional;
          return dtFormatterBuilder;
        };
        var _proto = DateTimeFormatterBuilder2.prototype;
        _proto.parseCaseSensitive = function parseCaseSensitive() {
          this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
          return this;
        };
        _proto.parseCaseInsensitive = function parseCaseInsensitive() {
          this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
          return this;
        };
        _proto.parseStrict = function parseStrict() {
          this._appendInternalPrinterParser(SettingsParser.STRICT);
          return this;
        };
        _proto.parseLenient = function parseLenient() {
          this._appendInternalPrinterParser(SettingsParser.LENIENT);
          return this;
        };
        _proto.parseDefaulting = function parseDefaulting(field, value) {
          requireNonNull(field);
          this._appendInternal(new DefaultingParser(field, value));
          return this;
        };
        _proto.appendValue = function appendValue() {
          if (arguments.length === 1) {
            return this._appendValue1.apply(this, arguments);
          } else if (arguments.length === 2) {
            return this._appendValue2.apply(this, arguments);
          } else {
            return this._appendValue4.apply(this, arguments);
          }
        };
        _proto._appendValue1 = function _appendValue1(field) {
          requireNonNull(field);
          this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));
          return this;
        };
        _proto._appendValue2 = function _appendValue2(field, width) {
          requireNonNull(field);
          if (width < 1 || width > MAX_WIDTH) {
            throw new IllegalArgumentException("The width must be from 1 to " + MAX_WIDTH + " inclusive but was " + width);
          }
          var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
          this._appendValuePrinterParser(pp);
          return this;
        };
        _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
          requireNonNull(field);
          requireNonNull(signStyle);
          if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
            return this._appendValue2(field, maxWidth);
          }
          if (minWidth < 1 || minWidth > MAX_WIDTH) {
            throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + minWidth);
          }
          if (maxWidth < 1 || maxWidth > MAX_WIDTH) {
            throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + maxWidth);
          }
          if (maxWidth < minWidth) {
            throw new IllegalArgumentException("The maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
          }
          var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
          this._appendValuePrinterParser(pp);
          return this;
        };
        _proto.appendValueReduced = function appendValueReduced() {
          if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
            return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
          } else {
            return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
          }
        };
        _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
          requireNonNull(field, "field");
          var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
          this._appendValuePrinterParser(pp);
          return this;
        };
        _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
          requireNonNull(field, "field");
          requireNonNull(baseDate, "baseDate");
          requireInstance(baseDate, ChronoLocalDate, "baseDate");
          var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
          this._appendValuePrinterParser(pp);
          return this;
        };
        _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
          assert(pp != null);
          if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
            var activeValueParser = this._active._valueParserIndex;
            var basePP = this._active._printerParsers[activeValueParser];
            if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
              basePP = basePP.withSubsequentWidth(pp.maxWidth());
              this._appendInternal(pp.withFixedWidth());
              this._active._valueParserIndex = activeValueParser;
            } else {
              basePP = basePP.withFixedWidth();
              this._active._valueParserIndex = this._appendInternal(pp);
            }
            this._active._printerParsers[activeValueParser] = basePP;
          } else {
            this._active._valueParserIndex = this._appendInternal(pp);
          }
          return this;
        };
        _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
          this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
          return this;
        };
        _proto.appendInstant = function appendInstant(fractionalDigits) {
          if (fractionalDigits === void 0) {
            fractionalDigits = -2;
          }
          if (fractionalDigits < -2 || fractionalDigits > 9) {
            throw new IllegalArgumentException("Invalid fractional digits: " + fractionalDigits);
          }
          this._appendInternal(new InstantPrinterParser(fractionalDigits));
          return this;
        };
        _proto.appendOffsetId = function appendOffsetId() {
          this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
          return this;
        };
        _proto.appendOffset = function appendOffset(pattern, noOffsetText) {
          this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
          return this;
        };
        _proto.appendZoneId = function appendZoneId() {
          this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), "ZoneId()"));
          return this;
        };
        _proto.appendPattern = function appendPattern(pattern) {
          requireNonNull(pattern, "pattern");
          this._parsePattern(pattern);
          return this;
        };
        _proto.appendZoneText = function appendZoneText() {
          throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
        };
        _proto.appendText = function appendText() {
          throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
        };
        _proto.appendLocalizedOffset = function appendLocalizedOffset() {
          throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
        };
        _proto.appendWeekField = function appendWeekField() {
          throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
        };
        _proto._parsePattern = function _parsePattern(pattern) {
          var FIELD_MAP = {
            "G": ChronoField.ERA,
            "y": ChronoField.YEAR_OF_ERA,
            "u": ChronoField.YEAR,
            "Q": IsoFields.QUARTER_OF_YEAR,
            "q": IsoFields.QUARTER_OF_YEAR,
            "M": ChronoField.MONTH_OF_YEAR,
            "L": ChronoField.MONTH_OF_YEAR,
            "D": ChronoField.DAY_OF_YEAR,
            "d": ChronoField.DAY_OF_MONTH,
            "F": ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
            "E": ChronoField.DAY_OF_WEEK,
            "c": ChronoField.DAY_OF_WEEK,
            "e": ChronoField.DAY_OF_WEEK,
            "a": ChronoField.AMPM_OF_DAY,
            "H": ChronoField.HOUR_OF_DAY,
            "k": ChronoField.CLOCK_HOUR_OF_DAY,
            "K": ChronoField.HOUR_OF_AMPM,
            "h": ChronoField.CLOCK_HOUR_OF_AMPM,
            "m": ChronoField.MINUTE_OF_HOUR,
            "s": ChronoField.SECOND_OF_MINUTE,
            "S": ChronoField.NANO_OF_SECOND,
            "A": ChronoField.MILLI_OF_DAY,
            "n": ChronoField.NANO_OF_SECOND,
            "N": ChronoField.NANO_OF_DAY
          };
          for (var pos = 0; pos < pattern.length; pos++) {
            var cur = pattern.charAt(pos);
            if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
              var start = pos++;
              for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++)
                ;
              var count = pos - start;
              if (cur === "p") {
                var pad = 0;
                if (pos < pattern.length) {
                  cur = pattern.charAt(pos);
                  if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
                    pad = count;
                    start = pos++;
                    for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++)
                      ;
                    count = pos - start;
                  }
                }
                if (pad === 0) {
                  throw new IllegalArgumentException("Pad letter 'p' must be followed by valid pad pattern: " + pattern);
                }
                this.padNext(pad);
              }
              var field = FIELD_MAP[cur];
              if (field != null) {
                this._parseField(cur, count, field);
              } else if (cur === "z") {
                if (count > 4) {
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
                } else if (count === 4) {
                  this.appendZoneText(TextStyle.FULL);
                } else {
                  this.appendZoneText(TextStyle.SHORT);
                }
              } else if (cur === "V") {
                if (count !== 2) {
                  throw new IllegalArgumentException("Pattern letter count must be 2: " + cur);
                }
                this.appendZoneId();
              } else if (cur === "Z") {
                if (count < 4) {
                  this.appendOffset("+HHMM", "+0000");
                } else if (count === 4) {
                  this.appendLocalizedOffset(TextStyle.FULL);
                } else if (count === 5) {
                  this.appendOffset("+HH:MM:ss", "Z");
                } else {
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
                }
              } else if (cur === "O") {
                if (count === 1) {
                  this.appendLocalizedOffset(TextStyle.SHORT);
                } else if (count === 4) {
                  this.appendLocalizedOffset(TextStyle.FULL);
                } else {
                  throw new IllegalArgumentException("Pattern letter count must be 1 or 4: " + cur);
                }
              } else if (cur === "X") {
                if (count > 5) {
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
                }
                this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], "Z");
              } else if (cur === "x") {
                if (count > 5) {
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
                }
                var zero = count === 1 ? "+00" : count % 2 === 0 ? "+0000" : "+00:00";
                this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
              } else if (cur === "W") {
                if (count > 1) {
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
                }
                this.appendWeekField("W", count);
              } else if (cur === "w") {
                if (count > 2) {
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
                }
                this.appendWeekField("w", count);
              } else if (cur === "Y") {
                this.appendWeekField("Y", count);
              } else {
                throw new IllegalArgumentException("Unknown pattern letter: " + cur);
              }
              pos--;
            } else if (cur === "'") {
              var _start = pos++;
              for (; pos < pattern.length; pos++) {
                if (pattern.charAt(pos) === "'") {
                  if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === "'") {
                    pos++;
                  } else {
                    break;
                  }
                }
              }
              if (pos >= pattern.length) {
                throw new IllegalArgumentException("Pattern ends with an incomplete string literal: " + pattern);
              }
              var str = pattern.substring(_start + 1, pos);
              if (str.length === 0) {
                this.appendLiteral("'");
              } else {
                this.appendLiteral(str.replace("''", "'"));
              }
            } else if (cur === "[") {
              this.optionalStart();
            } else if (cur === "]") {
              if (this._active._parent === null) {
                throw new IllegalArgumentException("Pattern invalid as it contains ] without previous [");
              }
              this.optionalEnd();
            } else if (cur === "{" || cur === "}" || cur === "#") {
              throw new IllegalArgumentException("Pattern includes reserved character: '" + cur + "'");
            } else {
              this.appendLiteral(cur);
            }
          }
        };
        _proto._parseField = function _parseField(cur, count, field) {
          switch (cur) {
            case "u":
            case "y":
              if (count === 2) {
                this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
              } else if (count < 4) {
                this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
              } else {
                this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
              }
              break;
            case "M":
            case "Q":
              switch (count) {
                case 1:
                  this.appendValue(field);
                  break;
                case 2:
                  this.appendValue(field, 2);
                  break;
                case 3:
                  this.appendText(field, TextStyle.SHORT);
                  break;
                case 4:
                  this.appendText(field, TextStyle.FULL);
                  break;
                case 5:
                  this.appendText(field, TextStyle.NARROW);
                  break;
                default:
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              break;
            case "L":
            case "q":
              switch (count) {
                case 1:
                  this.appendValue(field);
                  break;
                case 2:
                  this.appendValue(field, 2);
                  break;
                case 3:
                  this.appendText(field, TextStyle.SHORT_STANDALONE);
                  break;
                case 4:
                  this.appendText(field, TextStyle.FULL_STANDALONE);
                  break;
                case 5:
                  this.appendText(field, TextStyle.NARROW_STANDALONE);
                  break;
                default:
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              break;
            case "e":
              switch (count) {
                case 1:
                case 2:
                  this.appendWeekField("e", count);
                  break;
                case 3:
                  this.appendText(field, TextStyle.SHORT);
                  break;
                case 4:
                  this.appendText(field, TextStyle.FULL);
                  break;
                case 5:
                  this.appendText(field, TextStyle.NARROW);
                  break;
                default:
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              break;
            case "c":
              switch (count) {
                case 1:
                  this.appendWeekField("c", count);
                  break;
                case 2:
                  throw new IllegalArgumentException("Invalid number of pattern letters: " + cur);
                case 3:
                  this.appendText(field, TextStyle.SHORT_STANDALONE);
                  break;
                case 4:
                  this.appendText(field, TextStyle.FULL_STANDALONE);
                  break;
                case 5:
                  this.appendText(field, TextStyle.NARROW_STANDALONE);
                  break;
                default:
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              break;
            case "a":
              if (count === 1) {
                this.appendText(field, TextStyle.SHORT);
              } else {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              break;
            case "E":
            case "G":
              switch (count) {
                case 1:
                case 2:
                case 3:
                  this.appendText(field, TextStyle.SHORT);
                  break;
                case 4:
                  this.appendText(field, TextStyle.FULL);
                  break;
                case 5:
                  this.appendText(field, TextStyle.NARROW);
                  break;
                default:
                  throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              break;
            case "S":
              this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
              break;
            case "F":
              if (count === 1) {
                this.appendValue(field);
              } else {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              break;
            case "d":
            case "h":
            case "H":
            case "k":
            case "K":
            case "m":
            case "s":
              if (count === 1) {
                this.appendValue(field);
              } else if (count === 2) {
                this.appendValue(field, count);
              } else {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              break;
            case "D":
              if (count === 1) {
                this.appendValue(field);
              } else if (count <= 3) {
                this.appendValue(field, count);
              } else {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              break;
            default:
              if (count === 1) {
                this.appendValue(field);
              } else {
                this.appendValue(field, count);
              }
              break;
          }
        };
        _proto.padNext = function padNext() {
          if (arguments.length === 1) {
            return this._padNext1.apply(this, arguments);
          } else {
            return this._padNext2.apply(this, arguments);
          }
        };
        _proto._padNext1 = function _padNext1(padWidth) {
          return this._padNext2(padWidth, " ");
        };
        _proto._padNext2 = function _padNext2(padWidth, padChar) {
          if (padWidth < 1) {
            throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
          }
          this._active._padNextWidth = padWidth;
          this._active._padNextChar = padChar;
          this._active._valueParserIndex = -1;
          return this;
        };
        _proto.optionalStart = function optionalStart() {
          this._active._valueParserIndex = -1;
          this._active = DateTimeFormatterBuilder2._of(this._active, true);
          return this;
        };
        _proto.optionalEnd = function optionalEnd() {
          if (this._active._parent == null) {
            throw new IllegalStateException("Cannot call optionalEnd() as there was no previous call to optionalStart()");
          }
          if (this._active._printerParsers.length > 0) {
            var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
            this._active = this._active._parent;
            this._appendInternal(cpp);
          } else {
            this._active = this._active._parent;
          }
          return this;
        };
        _proto._appendInternal = function _appendInternal(pp) {
          assert(pp != null);
          if (this._active._padNextWidth > 0) {
            if (pp != null) {
              pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
            }
            this._active._padNextWidth = 0;
            this._active._padNextChar = 0;
          }
          this._active._printerParsers.push(pp);
          this._active._valueParserIndex = -1;
          return this._active._printerParsers.length - 1;
        };
        _proto.appendLiteral = function appendLiteral(literal) {
          assert(literal != null);
          if (literal.length > 0) {
            if (literal.length === 1) {
              this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
            } else {
              this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
            }
          }
          return this;
        };
        _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
          assert(pp != null);
          if (this._active._padNextWidth > 0) {
            if (pp != null) {
              pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
            }
            this._active._padNextWidth = 0;
            this._active._padNextChar = 0;
          }
          this._active._printerParsers.push(pp);
          this._active._valueParserIndex = -1;
          return this._active._printerParsers.length - 1;
        };
        _proto.append = function append(formatter) {
          requireNonNull(formatter, "formatter");
          this._appendInternal(formatter._toPrinterParser(false));
          return this;
        };
        _proto.toFormatter = function toFormatter(resolverStyle) {
          if (resolverStyle === void 0) {
            resolverStyle = ResolverStyle.SMART;
          }
          while (this._active._parent != null) {
            this.optionalEnd();
          }
          var pp = new CompositePrinterParser(this._printerParsers, false);
          return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
        };
        return DateTimeFormatterBuilder2;
      }();
      var SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
      var SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;
      var InstantPrinterParser = function() {
        function InstantPrinterParser2(fractionalDigits) {
          this.fractionalDigits = fractionalDigits;
        }
        var _proto2 = InstantPrinterParser2.prototype;
        _proto2.print = function print(context, buf) {
          var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);
          var inNanos = 0;
          if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
            inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);
          }
          if (inSecs == null) {
            return false;
          }
          var inSec = inSecs;
          var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
          if (inSec >= -SECONDS_0000_TO_1970) {
            var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
            var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
            var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
            var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
            if (hi > 0) {
              buf.append("+").append(hi);
            }
            buf.append(ldt.toString());
            if (ldt.second() === 0) {
              buf.append(":00");
            }
          } else {
            var _zeroSecs = inSec + SECONDS_0000_TO_1970;
            var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);
            var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);
            var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
            var pos = buf.length();
            buf.append(_ldt.toString());
            if (_ldt.second() === 0) {
              buf.append(":00");
            }
            if (_hi < 0) {
              if (_ldt.year() === -1e4) {
                buf.replace(pos, pos + 2, "" + (_hi - 1));
              } else if (_lo === 0) {
                buf.insert(pos, _hi);
              } else {
                buf.insert(pos + 1, Math.abs(_hi));
              }
            }
          }
          if (this.fractionalDigits === -2) {
            if (inNano !== 0) {
              buf.append(".");
              if (MathUtil.intMod(inNano, 1e6) === 0) {
                buf.append(("" + (MathUtil.intDiv(inNano, 1e6) + 1e3)).substring(1));
              } else if (MathUtil.intMod(inNano, 1e3) === 0) {
                buf.append(("" + (MathUtil.intDiv(inNano, 1e3) + 1e6)).substring(1));
              } else {
                buf.append(("" + (inNano + 1e9)).substring(1));
              }
            }
          } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
            buf.append(".");
            var div = 1e8;
            for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
              var digit = MathUtil.intDiv(inNano, div);
              buf.append(digit);
              inNano = inNano - digit * div;
              div = MathUtil.intDiv(div, 10);
            }
          }
          buf.append("Z");
          return true;
        };
        _proto2.parse = function parse2(context, text, position) {
          var newContext = context.copy();
          var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
          var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;
          var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral("Z").toFormatter()._toPrinterParser(false);
          var pos = parser.parse(newContext, text, position);
          if (pos < 0) {
            return pos;
          }
          var yearParsed = newContext.getParsed(ChronoField.YEAR);
          var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
          var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
          var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
          var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
          var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
          var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
          var sec = secVal != null ? secVal : 0;
          var nano = nanoVal != null ? nanoVal : 0;
          var year = MathUtil.intMod(yearParsed, 1e4);
          var days = 0;
          if (hour === 24 && min === 0 && sec === 0 && nano === 0) {
            hour = 0;
            days = 1;
          } else if (hour === 23 && min === 59 && sec === 60) {
            context.setParsedLeapSecond();
            sec = 59;
          }
          var instantSecs;
          try {
            var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
            instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
            instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 1e4), SECONDS_PER_10000_YEARS);
          } catch (ex) {
            return ~position;
          }
          var successPos = pos;
          successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
          return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
        };
        _proto2.toString = function toString() {
          return "Instant()";
        };
        return InstantPrinterParser2;
      }();
      var DefaultingParser = function() {
        function DefaultingParser2(field, value) {
          this._field = field;
          this._value = value;
        }
        var _proto3 = DefaultingParser2.prototype;
        _proto3.print = function print() {
          return true;
        };
        _proto3.parse = function parse2(context, text, position) {
          if (context.getParsed(this._field) == null) {
            context.setParsedField(this._field, this._value, position, position);
          }
          return position;
        };
        return DefaultingParser2;
      }();
      function _init$e() {
        ReducedPrinterParser.BASE_DATE = LocalDate.of(2e3, 1, 1);
        DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
        DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
        DateTimeFormatterBuilder.SettingsParser = SettingsParser;
        DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
        DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
        DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
        DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
        DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
        DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
        DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
        DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
      }
      var StringBuilder = function() {
        function StringBuilder2() {
          this._str = "";
        }
        var _proto = StringBuilder2.prototype;
        _proto.append = function append(str) {
          this._str += str;
          return this;
        };
        _proto.appendChar = function appendChar(str) {
          this._str += str[0];
          return this;
        };
        _proto.insert = function insert(offset, str) {
          this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
          return this;
        };
        _proto.replace = function replace(start, end, str) {
          this._str = this._str.slice(0, start) + str + this._str.slice(end);
          return this;
        };
        _proto.length = function length() {
          return this._str.length;
        };
        _proto.setLength = function setLength(length) {
          this._str = this._str.slice(0, length);
          return this;
        };
        _proto.toString = function toString() {
          return this._str;
        };
        return StringBuilder2;
      }();
      var DateTimeFormatter = function() {
        DateTimeFormatter2.parsedExcessDays = function parsedExcessDays() {
          return DateTimeFormatter2.PARSED_EXCESS_DAYS;
        };
        DateTimeFormatter2.parsedLeapSecond = function parsedLeapSecond() {
          return DateTimeFormatter2.PARSED_LEAP_SECOND;
        };
        DateTimeFormatter2.ofPattern = function ofPattern(pattern) {
          return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
        };
        function DateTimeFormatter2(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {
          if (chrono === void 0) {
            chrono = IsoChronology.INSTANCE;
          }
          assert(printerParser != null);
          assert(decimalStyle != null);
          assert(resolverStyle != null);
          this._printerParser = printerParser;
          this._locale = locale;
          this._decimalStyle = decimalStyle;
          this._resolverStyle = resolverStyle;
          this._resolverFields = resolverFields;
          this._chrono = chrono;
          this._zone = zone;
        }
        var _proto = DateTimeFormatter2.prototype;
        _proto.locale = function locale() {
          return this._locale;
        };
        _proto.decimalStyle = function decimalStyle() {
          return this._decimalStyle;
        };
        _proto.chronology = function chronology() {
          return this._chrono;
        };
        _proto.withChronology = function withChronology(chrono) {
          if (this._chrono != null && this._chrono.equals(chrono)) {
            return this;
          }
          return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
        };
        _proto.withLocale = function withLocale() {
          return this;
        };
        _proto.withResolverStyle = function withResolverStyle(resolverStyle) {
          requireNonNull(resolverStyle, "resolverStyle");
          if (resolverStyle.equals(this._resolverStyle)) {
            return this;
          }
          return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
        };
        _proto.format = function format(temporal) {
          var buf = new StringBuilder(32);
          this._formatTo(temporal, buf);
          return buf.toString();
        };
        _proto._formatTo = function _formatTo(temporal, appendable) {
          requireNonNull(temporal, "temporal");
          requireNonNull(appendable, "appendable");
          var context = new DateTimePrintContext(temporal, this);
          this._printerParser.print(context, appendable);
        };
        _proto.parse = function parse2(text, type) {
          if (arguments.length === 1) {
            return this.parse1(text);
          } else {
            return this.parse2(text, type);
          }
        };
        _proto.parse1 = function parse1(text) {
          requireNonNull(text, "text");
          try {
            return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
          } catch (ex) {
            if (ex instanceof DateTimeParseException) {
              throw ex;
            } else {
              throw this._createError(text, ex);
            }
          }
        };
        _proto.parse2 = function parse2(text, type) {
          requireNonNull(text, "text");
          requireNonNull(type, "type");
          try {
            var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
            return builder.build(type);
          } catch (ex) {
            if (ex instanceof DateTimeParseException) {
              throw ex;
            } else {
              throw this._createError(text, ex);
            }
          }
        };
        _proto._createError = function _createError(text, ex) {
          var abbr = "";
          if (text.length > 64) {
            abbr = text.substring(0, 64) + "...";
          } else {
            abbr = text;
          }
          return new DateTimeParseException("Text '" + abbr + "' could not be parsed: " + ex.message, text, 0, ex);
        };
        _proto._parseToBuilder = function _parseToBuilder(text, position) {
          var pos = position != null ? position : new ParsePosition(0);
          var result = this._parseUnresolved0(text, pos);
          if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {
            var abbr = "";
            if (text.length > 64) {
              abbr = text.substr(0, 64).toString() + "...";
            } else {
              abbr = text;
            }
            if (pos.getErrorIndex() >= 0) {
              throw new DateTimeParseException("Text '" + abbr + "' could not be parsed at index " + pos.getErrorIndex(), text, pos.getErrorIndex());
            } else {
              throw new DateTimeParseException("Text '" + abbr + "' could not be parsed, unparsed text found at index " + pos.getIndex(), text, pos.getIndex());
            }
          }
          return result.toBuilder();
        };
        _proto.parseUnresolved = function parseUnresolved(text, position) {
          return this._parseUnresolved0(text, position);
        };
        _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {
          assert(text != null, "text", NullPointerException);
          assert(position != null, "position", NullPointerException);
          var context = new DateTimeParseContext(this);
          var pos = position.getIndex();
          pos = this._printerParser.parse(context, text, pos);
          if (pos < 0) {
            position.setErrorIndex(~pos);
            return null;
          }
          position.setIndex(pos);
          return context.toParsed();
        };
        _proto._toPrinterParser = function _toPrinterParser(optional) {
          return this._printerParser.withOptional(optional);
        };
        _proto.toString = function toString() {
          var pattern = this._printerParser.toString();
          return pattern.indexOf("[") === 0 ? pattern : pattern.substring(1, pattern.length - 1);
        };
        return DateTimeFormatter2;
      }();
      function _init$d() {
        DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
        DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);
        DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
        DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);
        DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
        DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral("[").parseCaseSensitive().appendZoneId().appendLiteral("]").toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
        DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
        DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
        DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
        DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);
        DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-W").appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral("-").appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);
        DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
        DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);
        DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
        DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery("PARSED_EXCESS_DAYS", function(temporal) {
          if (temporal instanceof DateTimeBuilder) {
            return temporal.excessDays;
          } else {
            return Period.ZERO;
          }
        });
        DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery("PARSED_LEAP_SECOND", function(temporal) {
          if (temporal instanceof DateTimeBuilder) {
            return temporal.leapSecond;
          } else {
            return false;
          }
        });
      }
      var MonthDay = function(_TemporalAccessor) {
        _inheritsLoose(MonthDay2, _TemporalAccessor);
        MonthDay2.now = function now(zoneIdOrClock) {
          if (arguments.length === 0) {
            return MonthDay2.now0();
          } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
            return MonthDay2.nowZoneId(zoneIdOrClock);
          } else {
            return MonthDay2.nowClock(zoneIdOrClock);
          }
        };
        MonthDay2.now0 = function now0() {
          return this.nowClock(Clock.systemDefaultZone());
        };
        MonthDay2.nowZoneId = function nowZoneId(zone) {
          requireNonNull(zone, "zone");
          return this.nowClock(Clock.system(zone));
        };
        MonthDay2.nowClock = function nowClock(clock) {
          requireNonNull(clock, "clock");
          var now = LocalDate.now(clock);
          return MonthDay2.of(now.month(), now.dayOfMonth());
        };
        MonthDay2.of = function of(monthOrNumber, number) {
          if (arguments.length === 2 && monthOrNumber instanceof Month) {
            return MonthDay2.ofMonthNumber(monthOrNumber, number);
          } else {
            return MonthDay2.ofNumberNumber(monthOrNumber, number);
          }
        };
        MonthDay2.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
          requireNonNull(month, "month");
          ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
          if (dayOfMonth > month.maxLength()) {
            throw new DateTimeException("Illegal value for DayOfMonth field, value " + dayOfMonth + " is not valid for month " + month.toString());
          }
          return new MonthDay2(month.value(), dayOfMonth);
        };
        MonthDay2.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
          requireNonNull(month, "month");
          requireNonNull(dayOfMonth, "dayOfMonth");
          return MonthDay2.of(Month.of(month), dayOfMonth);
        };
        MonthDay2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          requireInstance(temporal, TemporalAccessor, "temporal");
          if (temporal instanceof MonthDay2) {
            return temporal;
          }
          try {
            return MonthDay2.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
          } catch (ex) {
            throw new DateTimeException("Unable to obtain MonthDay from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
          }
        };
        MonthDay2.parse = function parse2(text, formatter) {
          if (arguments.length === 1) {
            return MonthDay2.parseString(text);
          } else {
            return MonthDay2.parseStringFormatter(text, formatter);
          }
        };
        MonthDay2.parseString = function parseString(text) {
          return MonthDay2.parseStringFormatter(text, PARSER$2);
        };
        MonthDay2.parseStringFormatter = function parseStringFormatter(text, formatter) {
          requireNonNull(text, "text");
          requireNonNull(formatter, "formatter");
          requireInstance(formatter, DateTimeFormatter, "formatter");
          return formatter.parse(text, MonthDay2.FROM);
        };
        function MonthDay2(month, dayOfMonth) {
          var _this;
          _this = _TemporalAccessor.call(this) || this;
          _this._month = MathUtil.safeToInt(month);
          _this._day = MathUtil.safeToInt(dayOfMonth);
          return _this;
        }
        var _proto = MonthDay2.prototype;
        _proto.monthValue = function monthValue() {
          return this._month;
        };
        _proto.month = function month() {
          return Month.of(this._month);
        };
        _proto.dayOfMonth = function dayOfMonth() {
          return this._day;
        };
        _proto.isSupported = function isSupported(field) {
          if (field instanceof ChronoField) {
            return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
          }
          return field != null && field.isSupportedBy(this);
        };
        _proto.range = function range(field) {
          if (field === ChronoField.MONTH_OF_YEAR) {
            return field.range();
          } else if (field === ChronoField.DAY_OF_MONTH) {
            return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
          }
          return _TemporalAccessor.prototype.range.call(this, field);
        };
        _proto.get = function get(field) {
          return this.range(field).checkValidIntValue(this.getLong(field), field);
        };
        _proto.getLong = function getLong(field) {
          requireNonNull(field, "field");
          if (field instanceof ChronoField) {
            switch (field) {
              case ChronoField.DAY_OF_MONTH:
                return this._day;
              case ChronoField.MONTH_OF_YEAR:
                return this._month;
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.getFrom(this);
        };
        _proto.isValidYear = function isValidYear(year) {
          return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
        };
        _proto.withMonth = function withMonth(month) {
          return this.with(Month.of(month));
        };
        _proto.with = function _with(month) {
          requireNonNull(month, "month");
          if (month.value() === this._month) {
            return this;
          }
          var day = Math.min(this._day, month.maxLength());
          return new MonthDay2(month.value(), day);
        };
        _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
          if (dayOfMonth === this._day) {
            return this;
          }
          return MonthDay2.of(this._month, dayOfMonth);
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query");
          requireInstance(_query, TemporalQuery, "query");
          if (_query === TemporalQueries.chronology()) {
            return IsoChronology.INSTANCE;
          }
          return _TemporalAccessor.prototype.query.call(this, _query);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          requireNonNull(temporal, "temporal");
          temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
          return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
        };
        _proto.atYear = function atYear(year) {
          return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, MonthDay2, "other");
          var cmp = this._month - other.monthValue();
          if (cmp === 0) {
            cmp = this._day - other.dayOfMonth();
          }
          return cmp;
        };
        _proto.isAfter = function isAfter(other) {
          requireNonNull(other, "other");
          requireInstance(other, MonthDay2, "other");
          return this.compareTo(other) > 0;
        };
        _proto.isBefore = function isBefore(other) {
          requireNonNull(other, "other");
          requireInstance(other, MonthDay2, "other");
          return this.compareTo(other) < 0;
        };
        _proto.equals = function equals(obj) {
          if (this === obj) {
            return true;
          }
          if (obj instanceof MonthDay2) {
            var other = obj;
            return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
          }
          return false;
        };
        _proto.toString = function toString() {
          return "--" + (this._month < 10 ? "0" : "") + this._month + (this._day < 10 ? "-0" : "-") + this._day;
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          requireInstance(formatter, DateTimeFormatter, "formatter");
          return formatter.format(this);
        };
        return MonthDay2;
      }(TemporalAccessor);
      var PARSER$2;
      function _init$c() {
        PARSER$2 = new DateTimeFormatterBuilder().appendLiteral("--").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();
        MonthDay.FROM = createTemporalQuery("MonthDay.FROM", function(temporal) {
          return MonthDay.from(temporal);
        });
      }
      var YearMonth = function(_Temporal) {
        _inheritsLoose(YearMonth2, _Temporal);
        YearMonth2.now = function now(zoneIdOrClock) {
          if (arguments.length === 0) {
            return YearMonth2.now0();
          } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
            return YearMonth2.nowZoneId(zoneIdOrClock);
          } else {
            return YearMonth2.nowClock(zoneIdOrClock);
          }
        };
        YearMonth2.now0 = function now0() {
          return YearMonth2.nowClock(Clock.systemDefaultZone());
        };
        YearMonth2.nowZoneId = function nowZoneId(zone) {
          return YearMonth2.nowClock(Clock.system(zone));
        };
        YearMonth2.nowClock = function nowClock(clock) {
          var now = LocalDate.now(clock);
          return YearMonth2.of(now.year(), now.month());
        };
        YearMonth2.of = function of(year, monthOrNumber) {
          if (arguments.length === 2 && monthOrNumber instanceof Month) {
            return YearMonth2.ofNumberMonth(year, monthOrNumber);
          } else {
            return YearMonth2.ofNumberNumber(year, monthOrNumber);
          }
        };
        YearMonth2.ofNumberMonth = function ofNumberMonth(year, month) {
          requireNonNull(month, "month");
          requireInstance(month, Month, "month");
          return YearMonth2.ofNumberNumber(year, month.value());
        };
        YearMonth2.ofNumberNumber = function ofNumberNumber(year, month) {
          requireNonNull(year, "year");
          requireNonNull(month, "month");
          ChronoField.YEAR.checkValidValue(year);
          ChronoField.MONTH_OF_YEAR.checkValidValue(month);
          return new YearMonth2(year, month);
        };
        YearMonth2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          if (temporal instanceof YearMonth2) {
            return temporal;
          }
          try {
            return YearMonth2.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
          } catch (ex) {
            throw new DateTimeException("Unable to obtain YearMonth from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
          }
        };
        YearMonth2.parse = function parse2(text, formatter) {
          if (arguments.length === 1) {
            return YearMonth2.parseString(text);
          } else {
            return YearMonth2.parseStringFormatter(text, formatter);
          }
        };
        YearMonth2.parseString = function parseString(text) {
          return YearMonth2.parseStringFormatter(text, PARSER$1);
        };
        YearMonth2.parseStringFormatter = function parseStringFormatter(text, formatter) {
          requireNonNull(formatter, "formatter");
          return formatter.parse(text, YearMonth2.FROM);
        };
        function YearMonth2(year, month) {
          var _this;
          _this = _Temporal.call(this) || this;
          _this._year = MathUtil.safeToInt(year);
          _this._month = MathUtil.safeToInt(month);
          return _this;
        }
        var _proto = YearMonth2.prototype;
        _proto.isSupported = function isSupported(fieldOrUnit) {
          if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
            return this.isSupportedField(fieldOrUnit);
          } else {
            return this.isSupportedUnit(fieldOrUnit);
          }
        };
        _proto.isSupportedField = function isSupportedField(field) {
          if (field instanceof ChronoField) {
            return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
          }
          return field != null && field.isSupportedBy(this);
        };
        _proto.isSupportedUnit = function isSupportedUnit(unit) {
          if (unit instanceof ChronoUnit) {
            return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
          }
          return unit != null && unit.isSupportedBy(this);
        };
        _proto.range = function range(field) {
          if (field === ChronoField.YEAR_OF_ERA) {
            return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
          }
          return _Temporal.prototype.range.call(this, field);
        };
        _proto.get = function get(field) {
          requireNonNull(field, "field");
          requireInstance(field, TemporalField, "field");
          return this.range(field).checkValidIntValue(this.getLong(field), field);
        };
        _proto.getLong = function getLong(field) {
          requireNonNull(field, "field");
          requireInstance(field, TemporalField, "field");
          if (field instanceof ChronoField) {
            switch (field) {
              case ChronoField.MONTH_OF_YEAR:
                return this._month;
              case ChronoField.PROLEPTIC_MONTH:
                return this._getProlepticMonth();
              case ChronoField.YEAR_OF_ERA:
                return this._year < 1 ? 1 - this._year : this._year;
              case ChronoField.YEAR:
                return this._year;
              case ChronoField.ERA:
                return this._year < 1 ? 0 : 1;
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.getFrom(this);
        };
        _proto._getProlepticMonth = function _getProlepticMonth() {
          return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
        };
        _proto.year = function year() {
          return this._year;
        };
        _proto.monthValue = function monthValue() {
          return this._month;
        };
        _proto.month = function month() {
          return Month.of(this._month);
        };
        _proto.isLeapYear = function isLeapYear() {
          return IsoChronology.isLeapYear(this._year);
        };
        _proto.isValidDay = function isValidDay(dayOfMonth) {
          return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
        };
        _proto.lengthOfMonth = function lengthOfMonth() {
          return this.month().length(this.isLeapYear());
        };
        _proto.lengthOfYear = function lengthOfYear() {
          return this.isLeapYear() ? 366 : 365;
        };
        _proto.with = function _with(adjusterOrField, value) {
          if (arguments.length === 1) {
            return this._withAdjuster(adjusterOrField);
          } else {
            return this._withField(adjusterOrField, value);
          }
        };
        _proto._withField = function _withField(field, newValue) {
          requireNonNull(field, "field");
          requireInstance(field, TemporalField, "field");
          if (field instanceof ChronoField) {
            var f = field;
            f.checkValidValue(newValue);
            switch (f) {
              case ChronoField.MONTH_OF_YEAR:
                return this.withMonth(newValue);
              case ChronoField.PROLEPTIC_MONTH:
                return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
              case ChronoField.YEAR_OF_ERA:
                return this.withYear(this._year < 1 ? 1 - newValue : newValue);
              case ChronoField.YEAR:
                return this.withYear(newValue);
              case ChronoField.ERA:
                return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.adjustInto(this, newValue);
        };
        _proto.withYear = function withYear(year) {
          ChronoField.YEAR.checkValidValue(year);
          return new YearMonth2(year, this._month);
        };
        _proto.withMonth = function withMonth(month) {
          ChronoField.MONTH_OF_YEAR.checkValidValue(month);
          return new YearMonth2(this._year, month);
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          requireNonNull(unit, "unit");
          requireInstance(unit, TemporalUnit, "unit");
          if (unit instanceof ChronoUnit) {
            switch (unit) {
              case ChronoUnit.MONTHS:
                return this.plusMonths(amountToAdd);
              case ChronoUnit.YEARS:
                return this.plusYears(amountToAdd);
              case ChronoUnit.DECADES:
                return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
              case ChronoUnit.CENTURIES:
                return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
              case ChronoUnit.MILLENNIA:
                return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
              case ChronoUnit.ERAS:
                return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.addTo(this, amountToAdd);
        };
        _proto.plusYears = function plusYears(yearsToAdd) {
          if (yearsToAdd === 0) {
            return this;
          }
          var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
          return this.withYear(newYear);
        };
        _proto.plusMonths = function plusMonths(monthsToAdd) {
          if (monthsToAdd === 0) {
            return this;
          }
          var monthCount = this._year * 12 + (this._month - 1);
          var calcMonths = monthCount + monthsToAdd;
          var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
          var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
          return new YearMonth2(newYear, newMonth);
        };
        _proto.minusYears = function minusYears(yearsToSubtract) {
          return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
        };
        _proto.minusMonths = function minusMonths(monthsToSubtract) {
          return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query");
          requireInstance(_query, TemporalQuery, "query");
          if (_query === TemporalQueries.chronology()) {
            return IsoChronology.INSTANCE;
          } else if (_query === TemporalQueries.precision()) {
            return ChronoUnit.MONTHS;
          } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
            return null;
          }
          return _Temporal.prototype.query.call(this, _query);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          requireNonNull(temporal, "temporal");
          requireInstance(temporal, Temporal, "temporal");
          return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
        };
        _proto.until = function until(endExclusive, unit) {
          requireNonNull(endExclusive, "endExclusive");
          requireNonNull(unit, "unit");
          requireInstance(endExclusive, Temporal, "endExclusive");
          requireInstance(unit, TemporalUnit, "unit");
          var end = YearMonth2.from(endExclusive);
          if (unit instanceof ChronoUnit) {
            var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();
            switch (unit) {
              case ChronoUnit.MONTHS:
                return monthsUntil;
              case ChronoUnit.YEARS:
                return MathUtil.intDiv(monthsUntil, 12);
              case ChronoUnit.DECADES:
                return MathUtil.intDiv(monthsUntil, 120);
              case ChronoUnit.CENTURIES:
                return MathUtil.intDiv(monthsUntil, 1200);
              case ChronoUnit.MILLENNIA:
                return MathUtil.intDiv(monthsUntil, 12e3);
              case ChronoUnit.ERAS:
                return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.between(this, end);
        };
        _proto.atDay = function atDay(dayOfMonth) {
          requireNonNull(dayOfMonth, "dayOfMonth");
          return LocalDate.of(this._year, this._month, dayOfMonth);
        };
        _proto.atEndOfMonth = function atEndOfMonth() {
          return LocalDate.of(this._year, this._month, this.lengthOfMonth());
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, YearMonth2, "other");
          var cmp = this._year - other.year();
          if (cmp === 0) {
            cmp = this._month - other.monthValue();
          }
          return cmp;
        };
        _proto.isAfter = function isAfter(other) {
          return this.compareTo(other) > 0;
        };
        _proto.isBefore = function isBefore(other) {
          return this.compareTo(other) < 0;
        };
        _proto.equals = function equals(obj) {
          if (this === obj) {
            return true;
          }
          if (obj instanceof YearMonth2) {
            var other = obj;
            return this.year() === other.year() && this.monthValue() === other.monthValue();
          }
          return false;
        };
        _proto.toString = function toString() {
          return PARSER$1.format(this);
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          return formatter.format(this);
        };
        return YearMonth2;
      }(Temporal);
      var PARSER$1;
      function _init$b() {
        PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();
        YearMonth.FROM = createTemporalQuery("YearMonth.FROM", function(temporal) {
          return YearMonth.from(temporal);
        });
      }
      var Year = function(_Temporal) {
        _inheritsLoose(Year2, _Temporal);
        function Year2(value) {
          var _this;
          _this = _Temporal.call(this) || this;
          _this._year = MathUtil.safeToInt(value);
          return _this;
        }
        var _proto = Year2.prototype;
        _proto.value = function value() {
          return this._year;
        };
        Year2.now = function now(zoneIdOrClock) {
          if (zoneIdOrClock === void 0) {
            zoneIdOrClock = void 0;
          }
          if (zoneIdOrClock === void 0) {
            return Year2.now0();
          } else if (zoneIdOrClock instanceof ZoneId) {
            return Year2.nowZoneId(zoneIdOrClock);
          } else {
            return Year2.nowClock(zoneIdOrClock);
          }
        };
        Year2.now0 = function now0() {
          return Year2.nowClock(Clock.systemDefaultZone());
        };
        Year2.nowZoneId = function nowZoneId(zone) {
          requireNonNull(zone, "zone");
          requireInstance(zone, ZoneId, "zone");
          return Year2.nowClock(Clock.system(zone));
        };
        Year2.nowClock = function nowClock(clock) {
          requireNonNull(clock, "clock");
          requireInstance(clock, Clock, "clock");
          var now = LocalDate.now(clock);
          return Year2.of(now.year());
        };
        Year2.of = function of(isoYear) {
          requireNonNull(isoYear, "isoYear");
          ChronoField.YEAR.checkValidValue(isoYear);
          return new Year2(isoYear);
        };
        Year2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          requireInstance(temporal, TemporalAccessor, "temporal");
          if (temporal instanceof Year2) {
            return temporal;
          }
          try {
            return Year2.of(temporal.get(ChronoField.YEAR));
          } catch (ex) {
            throw new DateTimeException("Unable to obtain Year from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
          }
        };
        Year2.parse = function parse2(text, formatter) {
          if (arguments.length <= 1) {
            return Year2.parseText(text);
          } else {
            return Year2.parseTextFormatter(text, formatter);
          }
        };
        Year2.parseText = function parseText(text) {
          requireNonNull(text, "text");
          return Year2.parse(text, PARSER);
        };
        Year2.parseTextFormatter = function parseTextFormatter(text, formatter) {
          if (formatter === void 0) {
            formatter = PARSER;
          }
          requireNonNull(text, "text");
          requireNonNull(formatter, "formatter");
          requireInstance(formatter, DateTimeFormatter, "formatter");
          return formatter.parse(text, Year2.FROM);
        };
        Year2.isLeap = function isLeap(year) {
          return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
        };
        _proto.isSupported = function isSupported(fieldOrUnit) {
          if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
            return this.isSupportedField(fieldOrUnit);
          } else {
            return this.isSupportedUnit(fieldOrUnit);
          }
        };
        _proto.isSupportedField = function isSupportedField(field) {
          if (field instanceof ChronoField) {
            return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
          }
          return field != null && field.isSupportedBy(this);
        };
        _proto.isSupportedUnit = function isSupportedUnit(unit) {
          if (unit instanceof ChronoUnit) {
            return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
          }
          return unit != null && unit.isSupportedBy(this);
        };
        _proto.range = function range(field) {
          if (this.isSupported(field)) {
            return field.range();
          } else if (field instanceof ChronoField) {
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return _Temporal.prototype.range.call(this, field);
        };
        _proto.get = function get(field) {
          return this.range(field).checkValidIntValue(this.getLong(field), field);
        };
        _proto.getLong = function getLong(field) {
          requireNonNull(field, "field");
          if (field instanceof ChronoField) {
            switch (field) {
              case ChronoField.YEAR_OF_ERA:
                return this._year < 1 ? 1 - this._year : this._year;
              case ChronoField.YEAR:
                return this._year;
              case ChronoField.ERA:
                return this._year < 1 ? 0 : 1;
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.getFrom(this);
        };
        _proto.isLeap = function isLeap() {
          return Year2.isLeap(this._year);
        };
        _proto._withField = function _withField(field, newValue) {
          requireNonNull(field, "field");
          requireInstance(field, TemporalField, "field");
          if (field instanceof ChronoField) {
            field.checkValidValue(newValue);
            switch (field) {
              case ChronoField.YEAR_OF_ERA:
                return Year2.of(this._year < 1 ? 1 - newValue : newValue);
              case ChronoField.YEAR:
                return Year2.of(newValue);
              case ChronoField.ERA:
                return this.getLong(ChronoField.ERA) === newValue ? this : Year2.of(1 - this._year);
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.adjustInto(this, newValue);
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          requireNonNull(amountToAdd, "amountToAdd");
          requireNonNull(unit, "unit");
          requireInstance(unit, TemporalUnit, "unit");
          if (unit instanceof ChronoUnit) {
            switch (unit) {
              case ChronoUnit.YEARS:
                return this.plusYears(amountToAdd);
              case ChronoUnit.DECADES:
                return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
              case ChronoUnit.CENTURIES:
                return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
              case ChronoUnit.MILLENNIA:
                return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
              case ChronoUnit.ERAS:
                return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.addTo(this, amountToAdd);
        };
        _proto.plusYears = function plusYears(yearsToAdd) {
          if (yearsToAdd === 0) {
            return this;
          }
          return Year2.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
        };
        _proto.minusYears = function minusYears(yearsToSubtract) {
          return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          requireNonNull(temporal, "temporal");
          return temporal.with(ChronoField.YEAR, this._year);
        };
        _proto.isValidMonthDay = function isValidMonthDay(monthDay) {
          return monthDay != null && monthDay.isValidYear(this._year);
        };
        _proto.length = function length() {
          return this.isLeap() ? 366 : 365;
        };
        _proto.atDay = function atDay(dayOfYear) {
          return LocalDate.ofYearDay(this._year, dayOfYear);
        };
        _proto.atMonth = function atMonth(monthOrNumber) {
          if (arguments.length === 1 && monthOrNumber instanceof Month) {
            return this.atMonthMonth(monthOrNumber);
          } else {
            return this.atMonthNumber(monthOrNumber);
          }
        };
        _proto.atMonthMonth = function atMonthMonth(month) {
          requireNonNull(month, "month");
          requireInstance(month, Month, "month");
          return YearMonth.of(this._year, month);
        };
        _proto.atMonthNumber = function atMonthNumber(month) {
          requireNonNull(month, "month");
          return YearMonth.of(this._year, month);
        };
        _proto.atMonthDay = function atMonthDay(monthDay) {
          requireNonNull(monthDay, "monthDay");
          requireInstance(monthDay, MonthDay, "monthDay");
          return monthDay.atYear(this._year);
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query()");
          requireInstance(_query, TemporalQuery, "query()");
          if (_query === TemporalQueries.chronology()) {
            return IsoChronology.INSTANCE;
          } else if (_query === TemporalQueries.precision()) {
            return ChronoUnit.YEARS;
          } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
            return null;
          }
          return _Temporal.prototype.query.call(this, _query);
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, Year2, "other");
          return this._year - other._year;
        };
        _proto.isAfter = function isAfter(other) {
          requireNonNull(other, "other");
          requireInstance(other, Year2, "other");
          return this._year > other._year;
        };
        _proto.isBefore = function isBefore(other) {
          requireNonNull(other, "other");
          requireInstance(other, Year2, "other");
          return this._year < other._year;
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          requireInstance(formatter, DateTimeFormatter, "formatter");
          return formatter.format(this);
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof Year2) {
            return this.value() === other.value();
          }
          return false;
        };
        _proto.toString = function toString() {
          return "" + this._year;
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        _proto.until = function until(endExclusive, unit) {
          var end = Year2.from(endExclusive);
          if (unit instanceof ChronoUnit) {
            var yearsUntil = end.value() - this.value();
            switch (unit) {
              case ChronoUnit.YEARS:
                return yearsUntil;
              case ChronoUnit.DECADES:
                return MathUtil.intDiv(yearsUntil, 10);
              case ChronoUnit.CENTURIES:
                return MathUtil.intDiv(yearsUntil, 100);
              case ChronoUnit.MILLENNIA:
                return MathUtil.intDiv(yearsUntil, 1e3);
              case ChronoUnit.ERAS:
                return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.between(this, end);
        };
        return Year2;
      }(Temporal);
      var PARSER;
      function _init$a() {
        Year.MIN_VALUE = YearConstants.MIN_VALUE;
        Year.MAX_VALUE = YearConstants.MAX_VALUE;
        PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();
        Year.FROM = createTemporalQuery("Year.FROM", function(temporal) {
          return Year.from(temporal);
        });
      }
      var TemporalAdjuster = function() {
        function TemporalAdjuster2() {
        }
        var _proto = TemporalAdjuster2.prototype;
        _proto.adjustInto = function adjustInto(temporal) {
          abstractMethodFail("adjustInto");
        };
        return TemporalAdjuster2;
      }();
      var TemporalAdjusters = function() {
        function TemporalAdjusters2() {
        }
        TemporalAdjusters2.firstDayOfMonth = function firstDayOfMonth() {
          return Impl.FIRST_DAY_OF_MONTH;
        };
        TemporalAdjusters2.lastDayOfMonth = function lastDayOfMonth() {
          return Impl.LAST_DAY_OF_MONTH;
        };
        TemporalAdjusters2.firstDayOfNextMonth = function firstDayOfNextMonth() {
          return Impl.FIRST_DAY_OF_NEXT_MONTH;
        };
        TemporalAdjusters2.firstDayOfYear = function firstDayOfYear() {
          return Impl.FIRST_DAY_OF_YEAR;
        };
        TemporalAdjusters2.lastDayOfYear = function lastDayOfYear() {
          return Impl.LAST_DAY_OF_YEAR;
        };
        TemporalAdjusters2.firstDayOfNextYear = function firstDayOfNextYear() {
          return Impl.FIRST_DAY_OF_NEXT_YEAR;
        };
        TemporalAdjusters2.firstInMonth = function firstInMonth(dayOfWeek) {
          requireNonNull(dayOfWeek, "dayOfWeek");
          return new DayOfWeekInMonth(1, dayOfWeek);
        };
        TemporalAdjusters2.lastInMonth = function lastInMonth(dayOfWeek) {
          requireNonNull(dayOfWeek, "dayOfWeek");
          return new DayOfWeekInMonth(-1, dayOfWeek);
        };
        TemporalAdjusters2.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
          requireNonNull(dayOfWeek, "dayOfWeek");
          return new DayOfWeekInMonth(ordinal, dayOfWeek);
        };
        TemporalAdjusters2.next = function next(dayOfWeek) {
          return new RelativeDayOfWeek(2, dayOfWeek);
        };
        TemporalAdjusters2.nextOrSame = function nextOrSame(dayOfWeek) {
          return new RelativeDayOfWeek(0, dayOfWeek);
        };
        TemporalAdjusters2.previous = function previous(dayOfWeek) {
          return new RelativeDayOfWeek(3, dayOfWeek);
        };
        TemporalAdjusters2.previousOrSame = function previousOrSame(dayOfWeek) {
          return new RelativeDayOfWeek(1, dayOfWeek);
        };
        return TemporalAdjusters2;
      }();
      var Impl = function(_TemporalAdjuster) {
        _inheritsLoose(Impl2, _TemporalAdjuster);
        function Impl2(ordinal) {
          var _this;
          _this = _TemporalAdjuster.call(this) || this;
          _this._ordinal = ordinal;
          return _this;
        }
        var _proto = Impl2.prototype;
        _proto.adjustInto = function adjustInto(temporal) {
          switch (this._ordinal) {
            case 0:
              return temporal.with(ChronoField.DAY_OF_MONTH, 1);
            case 1:
              return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
            case 2:
              return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);
            case 3:
              return temporal.with(ChronoField.DAY_OF_YEAR, 1);
            case 4:
              return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());
            case 5:
              return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
          }
          throw new IllegalStateException("Unreachable");
        };
        return Impl2;
      }(TemporalAdjuster);
      Impl.FIRST_DAY_OF_MONTH = new Impl(0);
      Impl.LAST_DAY_OF_MONTH = new Impl(1);
      Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);
      Impl.FIRST_DAY_OF_YEAR = new Impl(3);
      Impl.LAST_DAY_OF_YEAR = new Impl(4);
      Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);
      var DayOfWeekInMonth = function(_TemporalAdjuster2) {
        _inheritsLoose(DayOfWeekInMonth2, _TemporalAdjuster2);
        function DayOfWeekInMonth2(ordinal, dow) {
          var _this2;
          _this2 = _TemporalAdjuster2.call(this) || this;
          _this2._ordinal = ordinal;
          _this2._dowValue = dow.value();
          return _this2;
        }
        var _proto2 = DayOfWeekInMonth2.prototype;
        _proto2.adjustInto = function adjustInto(temporal) {
          if (this._ordinal >= 0) {
            var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
            var curDow = temp.get(ChronoField.DAY_OF_WEEK);
            var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
            dowDiff += (this._ordinal - 1) * 7;
            return temp.plus(dowDiff, ChronoUnit.DAYS);
          } else {
            var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
            var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);
            var daysDiff = this._dowValue - _curDow;
            daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
            daysDiff -= (-this._ordinal - 1) * 7;
            return _temp.plus(daysDiff, ChronoUnit.DAYS);
          }
        };
        return DayOfWeekInMonth2;
      }(TemporalAdjuster);
      var RelativeDayOfWeek = function(_TemporalAdjuster3) {
        _inheritsLoose(RelativeDayOfWeek2, _TemporalAdjuster3);
        function RelativeDayOfWeek2(relative, dayOfWeek) {
          var _this3;
          _this3 = _TemporalAdjuster3.call(this) || this;
          requireNonNull(dayOfWeek, "dayOfWeek");
          _this3._relative = relative;
          _this3._dowValue = dayOfWeek.value();
          return _this3;
        }
        var _proto3 = RelativeDayOfWeek2.prototype;
        _proto3.adjustInto = function adjustInto(temporal) {
          var calDow = temporal.get(ChronoField.DAY_OF_WEEK);
          if (this._relative < 2 && calDow === this._dowValue) {
            return temporal;
          }
          if ((this._relative & 1) === 0) {
            var daysDiff = calDow - this._dowValue;
            return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
          } else {
            var _daysDiff = this._dowValue - calDow;
            return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
          }
        };
        return RelativeDayOfWeek2;
      }(TemporalAdjuster);
      var IsoChronology = function(_Enum) {
        _inheritsLoose(IsoChronology2, _Enum);
        function IsoChronology2() {
          return _Enum.apply(this, arguments) || this;
        }
        IsoChronology2.isLeapYear = function isLeapYear(prolepticYear) {
          return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
        };
        var _proto = IsoChronology2.prototype;
        _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
          requireNonNull(fieldValues, "fieldValues");
          requireNonNull(field, "field");
          var current = fieldValues.get(field);
          if (current != null && current !== value) {
            throw new DateTimeException("Invalid state, field: " + field + " " + current + " conflicts with " + field + " " + value);
          }
          fieldValues.put(field, value);
        };
        _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {
          if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
            return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
          }
          var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);
          if (prolepticMonth != null) {
            if (resolverStyle !== ResolverStyle.LENIENT) {
              ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
            }
            this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);
            this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
          }
          var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);
          if (yoeLong != null) {
            if (resolverStyle !== ResolverStyle.LENIENT) {
              ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
            }
            var era = fieldValues.remove(ChronoField.ERA);
            if (era == null) {
              var year = fieldValues.get(ChronoField.YEAR);
              if (resolverStyle === ResolverStyle.STRICT) {
                if (year != null) {
                  this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
                } else {
                  fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
                }
              } else {
                this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
              }
            } else if (era === 1) {
              this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
            } else if (era === 0) {
              this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
            } else {
              throw new DateTimeException("Invalid value for era: " + era);
            }
          } else if (fieldValues.containsKey(ChronoField.ERA)) {
            ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
          }
          if (fieldValues.containsKey(ChronoField.YEAR)) {
            if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
              if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
                var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
                var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
                var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);
                if (resolverStyle === ResolverStyle.LENIENT) {
                  var months = moy - 1;
                  var days = dom - 1;
                  return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
                } else if (resolverStyle === ResolverStyle.SMART) {
                  ChronoField.DAY_OF_MONTH.checkValidValue(dom);
                  if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
                    dom = Math.min(dom, 30);
                  } else if (moy === 2) {
                    dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
                  }
                  return LocalDate.of(y, moy, dom);
                } else {
                  return LocalDate.of(y, moy, dom);
                }
              }
            }
            if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
              var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              if (resolverStyle === ResolverStyle.LENIENT) {
                var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);
                return LocalDate.ofYearDay(_y, 1).plusDays(_days);
              }
              var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
              return LocalDate.ofYearDay(_y, doy);
            }
            if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
              if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
                var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
                if (resolverStyle === ResolverStyle.LENIENT) {
                  var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                  var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
                  return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
                }
                var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
                var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
                var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));
                if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {
                  throw new DateTimeException("Strict mode rejected date parsed to a different year");
                }
                return date;
              }
              if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
                var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
                if (resolverStyle === ResolverStyle.LENIENT) {
                  var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                  var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);
                  return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
                }
                var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
                var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));
                var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));
                if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {
                  throw new DateTimeException("Strict mode rejected date parsed to a different month");
                }
                return _date;
              }
            }
          }
          return null;
        };
        _proto.date = function date(temporal) {
          return LocalDate.from(temporal);
        };
        return IsoChronology2;
      }(Enum);
      function _init$9() {
        IsoChronology.INSTANCE = new IsoChronology("IsoChronology");
      }
      var OffsetTime = function(_Temporal) {
        _inheritsLoose(OffsetTime2, _Temporal);
        OffsetTime2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          if (temporal instanceof OffsetTime2) {
            return temporal;
          } else if (temporal instanceof OffsetDateTime) {
            return temporal.toOffsetTime();
          }
          try {
            var time = LocalTime.from(temporal);
            var offset = ZoneOffset.from(temporal);
            return new OffsetTime2(time, offset);
          } catch (ex) {
            throw new DateTimeException("Unable to obtain OffsetTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
          }
        };
        OffsetTime2.now = function now(clockOrZone) {
          if (arguments.length === 0) {
            return OffsetTime2._now(Clock.systemDefaultZone());
          } else if (clockOrZone instanceof Clock) {
            return OffsetTime2._now(clockOrZone);
          } else {
            return OffsetTime2._now(Clock.system(clockOrZone));
          }
        };
        OffsetTime2._now = function _now(clock) {
          requireNonNull(clock, "clock");
          var now = clock.instant();
          return OffsetTime2.ofInstant(now, clock.zone().rules().offset(now));
        };
        OffsetTime2.of = function of() {
          if (arguments.length <= 2) {
            return OffsetTime2.ofTimeAndOffset.apply(this, arguments);
          } else {
            return OffsetTime2.ofNumbers.apply(this, arguments);
          }
        };
        OffsetTime2.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {
          var time = LocalTime.of(hour, minute, second, nanoOfSecond);
          return new OffsetTime2(time, offset);
        };
        OffsetTime2.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {
          return new OffsetTime2(time, offset);
        };
        OffsetTime2.ofInstant = function ofInstant(instant, zone) {
          requireNonNull(instant, "instant");
          requireInstance(instant, Instant, "instant");
          requireNonNull(zone, "zone");
          requireInstance(zone, ZoneId, "zone");
          var rules = zone.rules();
          var offset = rules.offset(instant);
          var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;
          secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;
          if (secsOfDay < 0) {
            secsOfDay += LocalTime.SECONDS_PER_DAY;
          }
          var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
          return new OffsetTime2(time, offset);
        };
        OffsetTime2.parse = function parse2(text, formatter) {
          if (formatter === void 0) {
            formatter = DateTimeFormatter.ISO_OFFSET_TIME;
          }
          requireNonNull(formatter, "formatter");
          return formatter.parse(text, OffsetTime2.FROM);
        };
        function OffsetTime2(time, offset) {
          var _this;
          _this = _Temporal.call(this) || this;
          requireNonNull(time, "time");
          requireInstance(time, LocalTime, "time");
          requireNonNull(offset, "offset");
          requireInstance(offset, ZoneOffset, "offset");
          _this._time = time;
          _this._offset = offset;
          return _this;
        }
        var _proto = OffsetTime2.prototype;
        _proto.adjustInto = function adjustInto(temporal) {
          return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
        };
        _proto.atDate = function atDate(date) {
          return OffsetDateTime.of(date, this._time, this._offset);
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          return formatter.format(this, OffsetTime2.FROM);
        };
        _proto.get = function get(field) {
          return _Temporal.prototype.get.call(this, field);
        };
        _proto.getLong = function getLong(field) {
          if (field instanceof ChronoField) {
            if (field === ChronoField.OFFSET_SECONDS) {
              return this._offset.totalSeconds();
            }
            return this._time.getLong(field);
          }
          return field.getFrom(this);
        };
        _proto.hour = function hour() {
          return this._time.hour();
        };
        _proto.minute = function minute() {
          return this._time.minute();
        };
        _proto.second = function second() {
          return this._time.second();
        };
        _proto.nano = function nano() {
          return this._time.nano();
        };
        _proto.offset = function offset() {
          return this._offset;
        };
        _proto.isAfter = function isAfter(other) {
          requireNonNull(other, "other");
          return this._toEpochNano() > other._toEpochNano();
        };
        _proto.isBefore = function isBefore(other) {
          requireNonNull(other, "other");
          return this._toEpochNano() < other._toEpochNano();
        };
        _proto.isEqual = function isEqual(other) {
          requireNonNull(other, "other");
          return this._toEpochNano() === other._toEpochNano();
        };
        _proto.isSupported = function isSupported(fieldOrUnit) {
          if (fieldOrUnit instanceof ChronoField) {
            return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;
          } else if (fieldOrUnit instanceof ChronoUnit) {
            return fieldOrUnit.isTimeBased();
          }
          return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };
        _proto.minusHours = function minusHours(hours) {
          return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);
        };
        _proto.minusMinutes = function minusMinutes(minutes) {
          return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);
        };
        _proto.minusSeconds = function minusSeconds(seconds) {
          return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);
        };
        _proto.minusNanos = function minusNanos(nanos) {
          return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);
        };
        _proto._minusAmount = function _minusAmount(amount) {
          requireNonNull(amount);
          return amount.subtractFrom(this);
        };
        _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
          return this.plus(-1 * amountToSubtract, unit);
        };
        _proto._plusAmount = function _plusAmount(amount) {
          requireNonNull(amount);
          return amount.addTo(this);
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          if (unit instanceof ChronoUnit) {
            return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);
          }
          return unit.addTo(this, amountToAdd);
        };
        _proto.plusHours = function plusHours(hours) {
          return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);
        };
        _proto.plusMinutes = function plusMinutes(minutes) {
          return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);
        };
        _proto.plusSeconds = function plusSeconds(seconds) {
          return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);
        };
        _proto.plusNanos = function plusNanos(nanos) {
          return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query");
          if (_query === TemporalQueries.precision()) {
            return ChronoUnit.NANOS;
          } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
            return this.offset();
          } else if (_query === TemporalQueries.localTime()) {
            return this._time;
          } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {
            return null;
          }
          return _Temporal.prototype.query.call(this, _query);
        };
        _proto.range = function range(field) {
          if (field instanceof ChronoField) {
            if (field === ChronoField.OFFSET_SECONDS) {
              return field.range();
            }
            return this._time.range(field);
          }
          return field.rangeRefinedBy(this);
        };
        _proto.toLocalTime = function toLocalTime() {
          return this._time;
        };
        _proto.truncatedTo = function truncatedTo(unit) {
          return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);
        };
        _proto.until = function until(endExclusive, unit) {
          requireNonNull(endExclusive, "endExclusive");
          requireNonNull(unit, "unit");
          var end = OffsetTime2.from(endExclusive);
          if (unit instanceof ChronoUnit) {
            var nanosUntil = end._toEpochNano() - this._toEpochNano();
            switch (unit) {
              case ChronoUnit.NANOS:
                return nanosUntil;
              case ChronoUnit.MICROS:
                return MathUtil.intDiv(nanosUntil, 1e3);
              case ChronoUnit.MILLIS:
                return MathUtil.intDiv(nanosUntil, 1e6);
              case ChronoUnit.SECONDS:
                return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
              case ChronoUnit.MINUTES:
                return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
              case ChronoUnit.HOURS:
                return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
              case ChronoUnit.HALF_DAYS:
                return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.between(this, end);
        };
        _proto.withHour = function withHour(hour) {
          return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);
        };
        _proto.withMinute = function withMinute(minute) {
          return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);
        };
        _proto.withSecond = function withSecond(second) {
          return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);
        };
        _proto.withNano = function withNano(nano) {
          return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);
        };
        _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
          requireNonNull(offset, "offset");
          if (offset.equals(this._offset)) {
            return this;
          }
          var difference = offset.totalSeconds() - this._offset.totalSeconds();
          var adjusted = this._time.plusSeconds(difference);
          return new OffsetTime2(adjusted, offset);
        };
        _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
          return offset != null && offset.equals(this._offset) ? this : new OffsetTime2(this._time, offset);
        };
        _proto._toEpochNano = function _toEpochNano() {
          var nod = this._time.toNanoOfDay();
          var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;
          return nod - offsetNanos;
        };
        _proto._withAdjuster = function _withAdjuster(adjuster) {
          requireNonNull(adjuster, "adjuster");
          if (adjuster instanceof LocalTime) {
            return this._withLocalTimeOffset(adjuster, this._offset);
          } else if (adjuster instanceof ZoneOffset) {
            return this._withLocalTimeOffset(this._time, adjuster);
          } else if (adjuster instanceof OffsetTime2) {
            return adjuster;
          }
          return adjuster.adjustInto(this);
        };
        _proto._withField = function _withField(field, newValue) {
          requireNonNull(field, "field");
          if (field instanceof ChronoField) {
            if (field === ChronoField.OFFSET_SECONDS) {
              return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));
            }
            return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);
          }
          return field.adjustInto(this, newValue);
        };
        _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {
          if (this._time === time && this._offset.equals(offset)) {
            return this;
          }
          return new OffsetTime2(time, offset);
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, OffsetTime2, "other");
          if (this._offset.equals(other._offset)) {
            return this._time.compareTo(other._time);
          }
          var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());
          if (compare === 0) {
            return this._time.compareTo(other._time);
          }
          return compare;
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof OffsetTime2) {
            return this._time.equals(other._time) && this._offset.equals(other._offset);
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return this._time.hashCode() ^ this._offset.hashCode();
        };
        _proto.toString = function toString() {
          return this._time.toString() + this._offset.toString();
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        return OffsetTime2;
      }(Temporal);
      function _init$8() {
        OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);
        OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);
        OffsetTime.FROM = createTemporalQuery("OffsetTime.FROM", function(temporal) {
          return OffsetTime.from(temporal);
        });
      }
      var ChronoZonedDateTime = function(_Temporal) {
        _inheritsLoose(ChronoZonedDateTime2, _Temporal);
        function ChronoZonedDateTime2() {
          return _Temporal.apply(this, arguments) || this;
        }
        var _proto = ChronoZonedDateTime2.prototype;
        _proto.query = function query(_query) {
          if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
            return this.zone();
          } else if (_query === TemporalQueries.chronology()) {
            return this.toLocalDate().chronology();
          } else if (_query === TemporalQueries.precision()) {
            return ChronoUnit.NANOS;
          } else if (_query === TemporalQueries.offset()) {
            return this.offset();
          } else if (_query === TemporalQueries.localDate()) {
            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
          } else if (_query === TemporalQueries.localTime()) {
            return this.toLocalTime();
          }
          return _Temporal.prototype.query.call(this, _query);
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          return formatter.format(this);
        };
        _proto.toInstant = function toInstant() {
          return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
        };
        _proto.toEpochSecond = function toEpochSecond() {
          var epochDay = this.toLocalDate().toEpochDay();
          var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
          secs -= this.offset().totalSeconds();
          return secs;
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
          if (cmp === 0) {
            cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
            if (cmp === 0) {
              cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
              if (cmp === 0) {
                cmp = strcmp(this.zone().id(), other.zone().id());
              }
            }
          }
          return cmp;
        };
        _proto.isAfter = function isAfter(other) {
          requireNonNull(other, "other");
          var thisEpochSec = this.toEpochSecond();
          var otherEpochSec = other.toEpochSecond();
          return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
        };
        _proto.isBefore = function isBefore(other) {
          requireNonNull(other, "other");
          var thisEpochSec = this.toEpochSecond();
          var otherEpochSec = other.toEpochSecond();
          return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
        };
        _proto.isEqual = function isEqual(other) {
          requireNonNull(other, "other");
          return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof ChronoZonedDateTime2) {
            return this.compareTo(other) === 0;
          }
          return false;
        };
        return ChronoZonedDateTime2;
      }(Temporal);
      function strcmp(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      }
      var ZonedDateTime = function(_ChronoZonedDateTime) {
        _inheritsLoose(ZonedDateTime2, _ChronoZonedDateTime);
        ZonedDateTime2.now = function now(clockOrZone) {
          var clock;
          if (clockOrZone instanceof ZoneId) {
            clock = Clock.system(clockOrZone);
          } else {
            clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
          }
          return ZonedDateTime2.ofInstant(clock.instant(), clock.zone());
        };
        ZonedDateTime2.of = function of() {
          if (arguments.length <= 2) {
            return ZonedDateTime2.of2.apply(this, arguments);
          } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
            return ZonedDateTime2.of3.apply(this, arguments);
          } else {
            return ZonedDateTime2.of8.apply(this, arguments);
          }
        };
        ZonedDateTime2.of3 = function of3(date, time, zone) {
          return ZonedDateTime2.of2(LocalDateTime.of(date, time), zone);
        };
        ZonedDateTime2.of2 = function of2(localDateTime, zone) {
          return ZonedDateTime2.ofLocal(localDateTime, zone, null);
        };
        ZonedDateTime2.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
          var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
          return ZonedDateTime2.ofLocal(dt, zone, null);
        };
        ZonedDateTime2.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
          requireNonNull(localDateTime, "localDateTime");
          requireNonNull(zone, "zone");
          if (zone instanceof ZoneOffset) {
            return new ZonedDateTime2(localDateTime, zone, zone);
          }
          var offset = null;
          var rules = zone.rules();
          var validOffsets = rules.validOffsets(localDateTime);
          if (validOffsets.length === 1) {
            offset = validOffsets[0];
          } else if (validOffsets.length === 0) {
            var trans = rules.transition(localDateTime);
            localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
            offset = trans.offsetAfter();
          } else {
            if (preferredOffset != null && validOffsets.some(function(validOffset) {
              return validOffset.equals(preferredOffset);
            })) {
              offset = preferredOffset;
            } else {
              offset = requireNonNull(validOffsets[0], "offset");
            }
          }
          return new ZonedDateTime2(localDateTime, offset, zone);
        };
        ZonedDateTime2.ofInstant = function ofInstant() {
          if (arguments.length === 2) {
            return ZonedDateTime2.ofInstant2.apply(this, arguments);
          } else {
            return ZonedDateTime2.ofInstant3.apply(this, arguments);
          }
        };
        ZonedDateTime2.ofInstant2 = function ofInstant2(instant, zone) {
          requireNonNull(instant, "instant");
          requireNonNull(zone, "zone");
          return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), zone);
        };
        ZonedDateTime2.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
          requireNonNull(localDateTime, "localDateTime");
          requireNonNull(offset, "offset");
          requireNonNull(zone, "zone");
          return ZonedDateTime2._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
        };
        ZonedDateTime2._create = function _create(epochSecond, nanoOfSecond, zone) {
          var rules = zone.rules();
          var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
          var offset = rules.offset(instant);
          var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
          return new ZonedDateTime2(ldt, offset, zone);
        };
        ZonedDateTime2.ofStrict = function ofStrict(localDateTime, offset, zone) {
          requireNonNull(localDateTime, "localDateTime");
          requireNonNull(offset, "offset");
          requireNonNull(zone, "zone");
          var rules = zone.rules();
          if (rules.isValidOffset(localDateTime, offset) === false) {
            var trans = rules.transition(localDateTime);
            if (trans != null && trans.isGap()) {
              throw new DateTimeException("LocalDateTime " + localDateTime + " does not exist in zone " + zone + " due to a gap in the local time-line, typically caused by daylight savings");
            }
            throw new DateTimeException('ZoneOffset "' + offset + '" is not valid for LocalDateTime "' + localDateTime + '" in zone "' + zone + '"');
          }
          return new ZonedDateTime2(localDateTime, offset, zone);
        };
        ZonedDateTime2.ofLenient = function ofLenient(localDateTime, offset, zone) {
          requireNonNull(localDateTime, "localDateTime");
          requireNonNull(offset, "offset");
          requireNonNull(zone, "zone");
          if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
            throw new IllegalArgumentException("ZoneId must match ZoneOffset");
          }
          return new ZonedDateTime2(localDateTime, offset, zone);
        };
        ZonedDateTime2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          if (temporal instanceof ZonedDateTime2) {
            return temporal;
          }
          var zone = ZoneId.from(temporal);
          if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
            var zdt = ZonedDateTime2._from(temporal, zone);
            if (zdt != null)
              return zdt;
          }
          var ldt = LocalDateTime.from(temporal);
          return ZonedDateTime2.of2(ldt, zone);
        };
        ZonedDateTime2._from = function _from(temporal, zone) {
          try {
            return ZonedDateTime2.__from(temporal, zone);
          } catch (ex) {
            if (!(ex instanceof DateTimeException))
              throw ex;
          }
        };
        ZonedDateTime2.__from = function __from(temporal, zone) {
          var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
          var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
          return ZonedDateTime2._create(epochSecond, nanoOfSecond, zone);
        };
        ZonedDateTime2.parse = function parse2(text, formatter) {
          if (formatter === void 0) {
            formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;
          }
          requireNonNull(formatter, "formatter");
          return formatter.parse(text, ZonedDateTime2.FROM);
        };
        function ZonedDateTime2(dateTime, offset, zone) {
          var _this;
          requireNonNull(dateTime, "dateTime");
          requireNonNull(offset, "offset");
          requireNonNull(zone, "zone");
          _this = _ChronoZonedDateTime.call(this) || this;
          _this._dateTime = dateTime;
          _this._offset = offset;
          _this._zone = zone;
          return _this;
        }
        var _proto = ZonedDateTime2.prototype;
        _proto._resolveLocal = function _resolveLocal(newDateTime) {
          requireNonNull(newDateTime, "newDateTime");
          return ZonedDateTime2.ofLocal(newDateTime, this._zone, this._offset);
        };
        _proto._resolveInstant = function _resolveInstant(newDateTime) {
          return ZonedDateTime2.ofInstant3(newDateTime, this._offset, this._zone);
        };
        _proto._resolveOffset = function _resolveOffset(offset) {
          if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
            return new ZonedDateTime2(this._dateTime, offset, this._zone);
          }
          return this;
        };
        _proto.isSupported = function isSupported(fieldOrUnit) {
          if (fieldOrUnit instanceof ChronoField) {
            return true;
          } else if (fieldOrUnit instanceof ChronoUnit) {
            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
          }
          return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };
        _proto.range = function range(field) {
          if (field instanceof ChronoField) {
            if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
              return field.range();
            }
            return this._dateTime.range(field);
          }
          return field.rangeRefinedBy(this);
        };
        _proto.get = function get(field) {
          return this.getLong(field);
        };
        _proto.getLong = function getLong(field) {
          if (field instanceof ChronoField) {
            switch (field) {
              case ChronoField.INSTANT_SECONDS:
                return this.toEpochSecond();
              case ChronoField.OFFSET_SECONDS:
                return this._offset.totalSeconds();
            }
            return this._dateTime.getLong(field);
          }
          requireNonNull(field, "field");
          return field.getFrom(this);
        };
        _proto.offset = function offset() {
          return this._offset;
        };
        _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
          var trans = this._zone.rules().transition(this._dateTime);
          if (trans != null && trans.isOverlap()) {
            var earlierOffset = trans.offsetBefore();
            if (earlierOffset.equals(this._offset) === false) {
              return new ZonedDateTime2(this._dateTime, earlierOffset, this._zone);
            }
          }
          return this;
        };
        _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
          var trans = this._zone.rules().transition(this.toLocalDateTime());
          if (trans != null) {
            var laterOffset = trans.offsetAfter();
            if (laterOffset.equals(this._offset) === false) {
              return new ZonedDateTime2(this._dateTime, laterOffset, this._zone);
            }
          }
          return this;
        };
        _proto.zone = function zone() {
          return this._zone;
        };
        _proto.withZoneSameLocal = function withZoneSameLocal(zone) {
          requireNonNull(zone, "zone");
          return this._zone.equals(zone) ? this : ZonedDateTime2.ofLocal(this._dateTime, zone, this._offset);
        };
        _proto.withZoneSameInstant = function withZoneSameInstant(zone) {
          requireNonNull(zone, "zone");
          return this._zone.equals(zone) ? this : ZonedDateTime2._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
        };
        _proto.withFixedOffsetZone = function withFixedOffsetZone() {
          return this._zone.equals(this._offset) ? this : new ZonedDateTime2(this._dateTime, this._offset, this._offset);
        };
        _proto.year = function year() {
          return this._dateTime.year();
        };
        _proto.monthValue = function monthValue() {
          return this._dateTime.monthValue();
        };
        _proto.month = function month() {
          return this._dateTime.month();
        };
        _proto.dayOfMonth = function dayOfMonth() {
          return this._dateTime.dayOfMonth();
        };
        _proto.dayOfYear = function dayOfYear() {
          return this._dateTime.dayOfYear();
        };
        _proto.dayOfWeek = function dayOfWeek() {
          return this._dateTime.dayOfWeek();
        };
        _proto.hour = function hour() {
          return this._dateTime.hour();
        };
        _proto.minute = function minute() {
          return this._dateTime.minute();
        };
        _proto.second = function second() {
          return this._dateTime.second();
        };
        _proto.nano = function nano() {
          return this._dateTime.nano();
        };
        _proto._withAdjuster = function _withAdjuster(adjuster) {
          if (adjuster instanceof LocalDate) {
            return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
          } else if (adjuster instanceof LocalTime) {
            return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
          } else if (adjuster instanceof LocalDateTime) {
            return this._resolveLocal(adjuster);
          } else if (adjuster instanceof Instant) {
            var instant = adjuster;
            return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), this._zone);
          } else if (adjuster instanceof ZoneOffset) {
            return this._resolveOffset(adjuster);
          }
          return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);
        };
        _proto._withField = function _withField(field, newValue) {
          if (field instanceof ChronoField) {
            switch (field) {
              case ChronoField.INSTANT_SECONDS:
                return ZonedDateTime2._create(newValue, this.nano(), this._zone);
              case ChronoField.OFFSET_SECONDS: {
                var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
                return this._resolveOffset(offset);
              }
            }
            return this._resolveLocal(this._dateTime.with(field, newValue));
          }
          return field.adjustInto(this, newValue);
        };
        _proto.withYear = function withYear(year) {
          return this._resolveLocal(this._dateTime.withYear(year));
        };
        _proto.withMonth = function withMonth(month) {
          return this._resolveLocal(this._dateTime.withMonth(month));
        };
        _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
          return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
        };
        _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
          return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
        };
        _proto.withHour = function withHour(hour) {
          return this._resolveLocal(this._dateTime.withHour(hour));
        };
        _proto.withMinute = function withMinute(minute) {
          return this._resolveLocal(this._dateTime.withMinute(minute));
        };
        _proto.withSecond = function withSecond(second) {
          return this._resolveLocal(this._dateTime.withSecond(second));
        };
        _proto.withNano = function withNano(nanoOfSecond) {
          return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
        };
        _proto.truncatedTo = function truncatedTo(unit) {
          return this._resolveLocal(this._dateTime.truncatedTo(unit));
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          if (unit instanceof ChronoUnit) {
            if (unit.isDateBased()) {
              return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
            } else {
              return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
            }
          }
          requireNonNull(unit, "unit");
          return unit.addTo(this, amountToAdd);
        };
        _proto.plusYears = function plusYears(years) {
          return this._resolveLocal(this._dateTime.plusYears(years));
        };
        _proto.plusMonths = function plusMonths(months) {
          return this._resolveLocal(this._dateTime.plusMonths(months));
        };
        _proto.plusWeeks = function plusWeeks(weeks) {
          return this._resolveLocal(this._dateTime.plusWeeks(weeks));
        };
        _proto.plusDays = function plusDays(days) {
          return this._resolveLocal(this._dateTime.plusDays(days));
        };
        _proto.plusHours = function plusHours(hours) {
          return this._resolveInstant(this._dateTime.plusHours(hours));
        };
        _proto.plusMinutes = function plusMinutes(minutes) {
          return this._resolveInstant(this._dateTime.plusMinutes(minutes));
        };
        _proto.plusSeconds = function plusSeconds(seconds) {
          return this._resolveInstant(this._dateTime.plusSeconds(seconds));
        };
        _proto.plusNanos = function plusNanos(nanos) {
          return this._resolveInstant(this._dateTime.plusNanos(nanos));
        };
        _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
          return this._plusUnit(-1 * amountToSubtract, unit);
        };
        _proto.minusYears = function minusYears(years) {
          return this.plusYears(-1 * years);
        };
        _proto.minusMonths = function minusMonths(months) {
          return this.plusMonths(-1 * months);
        };
        _proto.minusWeeks = function minusWeeks(weeks) {
          return this.plusWeeks(-1 * weeks);
        };
        _proto.minusDays = function minusDays(days) {
          return this.plusDays(-1 * days);
        };
        _proto.minusHours = function minusHours(hours) {
          return this.plusHours(-1 * hours);
        };
        _proto.minusMinutes = function minusMinutes(minutes) {
          return this.plusMinutes(-1 * minutes);
        };
        _proto.minusSeconds = function minusSeconds(seconds) {
          return this.plusSeconds(-1 * seconds);
        };
        _proto.minusNanos = function minusNanos(nanos) {
          return this.plusNanos(-1 * nanos);
        };
        _proto.query = function query(_query) {
          if (_query === TemporalQueries.localDate()) {
            return this.toLocalDate();
          }
          requireNonNull(_query, "query");
          return _ChronoZonedDateTime.prototype.query.call(this, _query);
        };
        _proto.until = function until(endExclusive, unit) {
          var end = ZonedDateTime2.from(endExclusive);
          if (unit instanceof ChronoUnit) {
            end = end.withZoneSameInstant(this._zone);
            if (unit.isDateBased()) {
              return this._dateTime.until(end._dateTime, unit);
            } else {
              var difference = this._offset.totalSeconds() - end._offset.totalSeconds();
              var adjustedEnd = end._dateTime.plusSeconds(difference);
              return this._dateTime.until(adjustedEnd, unit);
            }
          }
          return unit.between(this, end);
        };
        _proto.toLocalDateTime = function toLocalDateTime() {
          return this._dateTime;
        };
        _proto.toLocalDate = function toLocalDate() {
          return this._dateTime.toLocalDate();
        };
        _proto.toLocalTime = function toLocalTime() {
          return this._dateTime.toLocalTime();
        };
        _proto.toOffsetDateTime = function toOffsetDateTime() {
          return OffsetDateTime.of(this._dateTime, this._offset);
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof ZonedDateTime2) {
            return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
        };
        _proto.toString = function toString() {
          var str = this._dateTime.toString() + this._offset.toString();
          if (this._offset !== this._zone) {
            str += "[" + this._zone.toString() + "]";
          }
          return str;
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        _proto.format = function format(formatter) {
          return _ChronoZonedDateTime.prototype.format.call(this, formatter);
        };
        return ZonedDateTime2;
      }(ChronoZonedDateTime);
      function _init$7() {
        ZonedDateTime.FROM = createTemporalQuery("ZonedDateTime.FROM", function(temporal) {
          return ZonedDateTime.from(temporal);
        });
      }
      var OffsetDateTime = function(_Temporal) {
        _inheritsLoose(OffsetDateTime2, _Temporal);
        OffsetDateTime2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          if (temporal instanceof OffsetDateTime2) {
            return temporal;
          }
          try {
            var offset = ZoneOffset.from(temporal);
            try {
              var ldt = LocalDateTime.from(temporal);
              return OffsetDateTime2.of(ldt, offset);
            } catch (_2) {
              var instant = Instant.from(temporal);
              return OffsetDateTime2.ofInstant(instant, offset);
            }
          } catch (ex) {
            throw new DateTimeException("Unable to obtain OffsetDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
          }
        };
        OffsetDateTime2.now = function now(clockOrZone) {
          if (arguments.length === 0) {
            return OffsetDateTime2.now(Clock.systemDefaultZone());
          } else {
            requireNonNull(clockOrZone, "clockOrZone");
            if (clockOrZone instanceof ZoneId) {
              return OffsetDateTime2.now(Clock.system(clockOrZone));
            } else if (clockOrZone instanceof Clock) {
              var now2 = clockOrZone.instant();
              return OffsetDateTime2.ofInstant(now2, clockOrZone.zone().rules().offset(now2));
            } else {
              throw new IllegalArgumentException("clockOrZone must be an instance of ZoneId or Clock");
            }
          }
        };
        OffsetDateTime2.of = function of() {
          if (arguments.length <= 2) {
            return OffsetDateTime2.ofDateTime.apply(this, arguments);
          } else if (arguments.length === 3) {
            return OffsetDateTime2.ofDateAndTime.apply(this, arguments);
          } else {
            return OffsetDateTime2.ofNumbers.apply(this, arguments);
          }
        };
        OffsetDateTime2.ofDateTime = function ofDateTime(dateTime, offset) {
          return new OffsetDateTime2(dateTime, offset);
        };
        OffsetDateTime2.ofDateAndTime = function ofDateAndTime(date, time, offset) {
          var dt = LocalDateTime.of(date, time);
          return new OffsetDateTime2(dt, offset);
        };
        OffsetDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {
          if (hour === void 0) {
            hour = 0;
          }
          if (minute === void 0) {
            minute = 0;
          }
          if (second === void 0) {
            second = 0;
          }
          if (nanoOfSecond === void 0) {
            nanoOfSecond = 0;
          }
          var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
          return new OffsetDateTime2(dt, offset);
        };
        OffsetDateTime2.ofInstant = function ofInstant(instant, zone) {
          requireNonNull(instant, "instant");
          requireNonNull(zone, "zone");
          var rules = zone.rules();
          var offset = rules.offset(instant);
          var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
          return new OffsetDateTime2(ldt, offset);
        };
        OffsetDateTime2.parse = function parse2(text, formatter) {
          if (formatter === void 0) {
            formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
          }
          requireNonNull(formatter, "formatter");
          return formatter.parse(text, OffsetDateTime2.FROM);
        };
        function OffsetDateTime2(dateTime, offset) {
          var _this;
          _this = _Temporal.call(this) || this;
          requireNonNull(dateTime, "dateTime");
          requireInstance(dateTime, LocalDateTime, "dateTime");
          requireNonNull(offset, "offset");
          requireInstance(offset, ZoneOffset, "offset");
          _this._dateTime = dateTime;
          _this._offset = offset;
          return _this;
        }
        var _proto = OffsetDateTime2.prototype;
        _proto.adjustInto = function adjustInto(temporal) {
          return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
        };
        _proto.until = function until(endExclusive, unit) {
          var end = OffsetDateTime2.from(endExclusive);
          if (unit instanceof ChronoUnit) {
            end = end.withOffsetSameInstant(this._offset);
            return this._dateTime.until(end._dateTime, unit);
          }
          return unit.between(this, end);
        };
        _proto.atZoneSameInstant = function atZoneSameInstant(zone) {
          return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);
        };
        _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {
          return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query");
          if (_query === TemporalQueries.chronology()) {
            return IsoChronology.INSTANCE;
          } else if (_query === TemporalQueries.precision()) {
            return ChronoUnit.NANOS;
          } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
            return this.offset();
          } else if (_query === TemporalQueries.localDate()) {
            return this.toLocalDate();
          } else if (_query === TemporalQueries.localTime()) {
            return this.toLocalTime();
          } else if (_query === TemporalQueries.zoneId()) {
            return null;
          }
          return _Temporal.prototype.query.call(this, _query);
        };
        _proto.get = function get(field) {
          if (field instanceof ChronoField) {
            switch (field) {
              case ChronoField.INSTANT_SECONDS:
                throw new DateTimeException("Field too large for an int: " + field);
              case ChronoField.OFFSET_SECONDS:
                return this.offset().totalSeconds();
            }
            return this._dateTime.get(field);
          }
          return _Temporal.prototype.get.call(this, field);
        };
        _proto.getLong = function getLong(field) {
          if (field instanceof ChronoField) {
            switch (field) {
              case ChronoField.INSTANT_SECONDS:
                return this.toEpochSecond();
              case ChronoField.OFFSET_SECONDS:
                return this.offset().totalSeconds();
            }
            return this._dateTime.getLong(field);
          }
          return field.getFrom(this);
        };
        _proto.offset = function offset() {
          return this._offset;
        };
        _proto.year = function year() {
          return this._dateTime.year();
        };
        _proto.monthValue = function monthValue() {
          return this._dateTime.monthValue();
        };
        _proto.month = function month() {
          return this._dateTime.month();
        };
        _proto.dayOfMonth = function dayOfMonth() {
          return this._dateTime.dayOfMonth();
        };
        _proto.dayOfYear = function dayOfYear() {
          return this._dateTime.dayOfYear();
        };
        _proto.dayOfWeek = function dayOfWeek() {
          return this._dateTime.dayOfWeek();
        };
        _proto.hour = function hour() {
          return this._dateTime.hour();
        };
        _proto.minute = function minute() {
          return this._dateTime.minute();
        };
        _proto.second = function second() {
          return this._dateTime.second();
        };
        _proto.nano = function nano() {
          return this._dateTime.nano();
        };
        _proto.toLocalDateTime = function toLocalDateTime() {
          return this._dateTime;
        };
        _proto.toLocalDate = function toLocalDate() {
          return this._dateTime.toLocalDate();
        };
        _proto.toLocalTime = function toLocalTime() {
          return this._dateTime.toLocalTime();
        };
        _proto.toOffsetTime = function toOffsetTime() {
          return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);
        };
        _proto.toZonedDateTime = function toZonedDateTime() {
          return ZonedDateTime.of(this._dateTime, this._offset);
        };
        _proto.toInstant = function toInstant() {
          return this._dateTime.toInstant(this._offset);
        };
        _proto.toEpochSecond = function toEpochSecond() {
          return this._dateTime.toEpochSecond(this._offset);
        };
        _proto.isSupported = function isSupported(fieldOrUnit) {
          if (fieldOrUnit instanceof ChronoField) {
            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
          }
          if (fieldOrUnit instanceof ChronoUnit) {
            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
          }
          return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };
        _proto.range = function range(field) {
          if (field instanceof ChronoField) {
            if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
              return field.range();
            }
            return this._dateTime.range(field);
          }
          return field.rangeRefinedBy(this);
        };
        _proto._withAdjuster = function _withAdjuster(adjuster) {
          requireNonNull(adjuster);
          if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
            return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);
          } else if (adjuster instanceof Instant) {
            return OffsetDateTime2.ofInstant(adjuster, this._offset);
          } else if (adjuster instanceof ZoneOffset) {
            return this._withDateTimeOffset(this._dateTime, adjuster);
          } else if (adjuster instanceof OffsetDateTime2) {
            return adjuster;
          }
          return adjuster.adjustInto(this);
        };
        _proto._withField = function _withField(field, newValue) {
          requireNonNull(field);
          if (field instanceof ChronoField) {
            var f = field;
            switch (f) {
              case ChronoField.INSTANT_SECONDS:
                return OffsetDateTime2.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);
              case ChronoField.OFFSET_SECONDS: {
                return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
              }
            }
            return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);
          }
          return field.adjustInto(this, newValue);
        };
        _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {
          if (this._dateTime === dateTime && this._offset.equals(offset)) {
            return this;
          }
          return new OffsetDateTime2(dateTime, offset);
        };
        _proto.withYear = function withYear(year) {
          return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);
        };
        _proto.withMonth = function withMonth(month) {
          return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);
        };
        _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
          return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);
        };
        _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
          return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);
        };
        _proto.withHour = function withHour(hour) {
          return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);
        };
        _proto.withMinute = function withMinute(minute) {
          return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);
        };
        _proto.withSecond = function withSecond(second) {
          return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);
        };
        _proto.withNano = function withNano(nanoOfSecond) {
          return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);
        };
        _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
          requireNonNull(offset, "offset");
          return this._withDateTimeOffset(this._dateTime, offset);
        };
        _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
          requireNonNull(offset, "offset");
          if (offset.equals(this._offset)) {
            return this;
          }
          var difference = offset.totalSeconds() - this._offset.totalSeconds();
          var adjusted = this._dateTime.plusSeconds(difference);
          return new OffsetDateTime2(adjusted, offset);
        };
        _proto.truncatedTo = function truncatedTo(unit) {
          return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);
        };
        _proto._plusAmount = function _plusAmount(amount) {
          requireNonNull(amount, "amount");
          return amount.addTo(this);
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          if (unit instanceof ChronoUnit) {
            return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);
          }
          return unit.addTo(this, amountToAdd);
        };
        _proto.plusYears = function plusYears(years) {
          return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);
        };
        _proto.plusMonths = function plusMonths(months) {
          return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);
        };
        _proto.plusWeeks = function plusWeeks(weeks) {
          return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);
        };
        _proto.plusDays = function plusDays(days) {
          return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);
        };
        _proto.plusHours = function plusHours(hours) {
          return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);
        };
        _proto.plusMinutes = function plusMinutes(minutes) {
          return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);
        };
        _proto.plusSeconds = function plusSeconds(seconds) {
          return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);
        };
        _proto.plusNanos = function plusNanos(nanos) {
          return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);
        };
        _proto._minusAmount = function _minusAmount(amount) {
          requireNonNull(amount);
          return amount.subtractFrom(this);
        };
        _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
          return this.plus(-1 * amountToSubtract, unit);
        };
        _proto.minusYears = function minusYears(years) {
          return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);
        };
        _proto.minusMonths = function minusMonths(months) {
          return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);
        };
        _proto.minusWeeks = function minusWeeks(weeks) {
          return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);
        };
        _proto.minusDays = function minusDays(days) {
          return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);
        };
        _proto.minusHours = function minusHours(hours) {
          return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);
        };
        _proto.minusMinutes = function minusMinutes(minutes) {
          return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);
        };
        _proto.minusSeconds = function minusSeconds(seconds) {
          return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);
        };
        _proto.minusNanos = function minusNanos(nanos) {
          return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, OffsetDateTime2, "other");
          if (this.offset().equals(other.offset())) {
            return this.toLocalDateTime().compareTo(other.toLocalDateTime());
          }
          var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
          if (cmp === 0) {
            cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
            if (cmp === 0) {
              cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
            }
          }
          return cmp;
        };
        _proto.isAfter = function isAfter(other) {
          requireNonNull(other, "other");
          var thisEpochSec = this.toEpochSecond();
          var otherEpochSec = other.toEpochSecond();
          return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
        };
        _proto.isBefore = function isBefore(other) {
          requireNonNull(other, "other");
          var thisEpochSec = this.toEpochSecond();
          var otherEpochSec = other.toEpochSecond();
          return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
        };
        _proto.isEqual = function isEqual(other) {
          requireNonNull(other, "other");
          return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof OffsetDateTime2) {
            return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return this._dateTime.hashCode() ^ this._offset.hashCode();
        };
        _proto.toString = function toString() {
          return this._dateTime.toString() + this._offset.toString();
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          return formatter.format(this);
        };
        return OffsetDateTime2;
      }(Temporal);
      function _init$6() {
        OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
        OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
        OffsetDateTime.FROM = createTemporalQuery("OffsetDateTime.FROM", function(temporal) {
          return OffsetDateTime.from(temporal);
        });
      }
      var DAYS_PER_CYCLE = 146097;
      var DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);
      var LocalDate = function(_ChronoLocalDate) {
        _inheritsLoose(LocalDate2, _ChronoLocalDate);
        LocalDate2.now = function now(clockOrZone) {
          var clock;
          if (clockOrZone == null) {
            clock = Clock.systemDefaultZone();
          } else if (clockOrZone instanceof ZoneId) {
            clock = Clock.system(clockOrZone);
          } else {
            clock = clockOrZone;
          }
          return LocalDate2.ofInstant(clock.instant(), clock.zone());
        };
        LocalDate2.ofInstant = function ofInstant(instant, zone) {
          if (zone === void 0) {
            zone = ZoneId.systemDefault();
          }
          requireNonNull(instant, "instant");
          var offset = zone.rules().offset(instant);
          var epochSec = instant.epochSecond() + offset.totalSeconds();
          var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
          return LocalDate2.ofEpochDay(epochDay);
        };
        LocalDate2.of = function of(year, month, dayOfMonth) {
          return new LocalDate2(year, month, dayOfMonth);
        };
        LocalDate2.ofYearDay = function ofYearDay(year, dayOfYear) {
          ChronoField.YEAR.checkValidValue(year);
          var leap = IsoChronology.isLeapYear(year);
          if (dayOfYear === 366 && leap === false) {
            assert(false, "Invalid date 'DayOfYear 366' as '" + year + "' is not a leap year", DateTimeException);
          }
          var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
          var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;
          if (dayOfYear > monthEnd) {
            moy = moy.plus(1);
          }
          var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
          return new LocalDate2(year, moy.value(), dom);
        };
        LocalDate2.ofEpochDay = function ofEpochDay(epochDay) {
          if (epochDay === void 0) {
            epochDay = 0;
          }
          var adjust, adjustCycles, doyEst, yearEst, zeroDay;
          zeroDay = epochDay + DAYS_0000_TO_1970;
          zeroDay -= 60;
          adjust = 0;
          if (zeroDay < 0) {
            adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
            adjust = adjustCycles * 400;
            zeroDay += -adjustCycles * DAYS_PER_CYCLE;
          }
          yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
          doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
          if (doyEst < 0) {
            yearEst--;
            doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
          }
          yearEst += adjust;
          var marchDoy0 = doyEst;
          var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
          var month = (marchMonth0 + 2) % 12 + 1;
          var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
          yearEst += MathUtil.intDiv(marchMonth0, 10);
          var year = yearEst;
          return new LocalDate2(year, month, dom);
        };
        LocalDate2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          var date = temporal.query(TemporalQueries.localDate());
          if (date == null) {
            throw new DateTimeException("Unable to obtain LocalDate from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
          }
          return date;
        };
        LocalDate2.parse = function parse2(text, formatter) {
          if (formatter === void 0) {
            formatter = DateTimeFormatter.ISO_LOCAL_DATE;
          }
          assert(formatter != null, "formatter", NullPointerException);
          return formatter.parse(text, LocalDate2.FROM);
        };
        LocalDate2._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
          switch (month) {
            case 2:
              day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
              break;
            case 4:
            case 6:
            case 9:
            case 11:
              day = Math.min(day, 30);
              break;
          }
          return LocalDate2.of(year, month, day);
        };
        function LocalDate2(year, month, dayOfMonth) {
          var _this;
          _this = _ChronoLocalDate.call(this) || this;
          requireNonNull(year, "year");
          requireNonNull(month, "month");
          requireNonNull(dayOfMonth, "dayOfMonth");
          if (month instanceof Month) {
            month = month.value();
          }
          _this._year = MathUtil.safeToInt(year);
          _this._month = MathUtil.safeToInt(month);
          _this._day = MathUtil.safeToInt(dayOfMonth);
          LocalDate2._validate(_this._year, _this._month, _this._day);
          return _this;
        }
        LocalDate2._validate = function _validate(year, month, dayOfMonth) {
          var dom;
          ChronoField.YEAR.checkValidValue(year);
          ChronoField.MONTH_OF_YEAR.checkValidValue(month);
          ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
          if (dayOfMonth > 28) {
            dom = 31;
            switch (month) {
              case 2:
                dom = IsoChronology.isLeapYear(year) ? 29 : 28;
                break;
              case 4:
              case 6:
              case 9:
              case 11:
                dom = 30;
            }
            if (dayOfMonth > dom) {
              if (dayOfMonth === 29) {
                assert(false, "Invalid date 'February 29' as '" + year + "' is not a leap year", DateTimeException);
              } else {
                assert(false, "Invalid date '" + year + "' '" + month + "' '" + dayOfMonth + "'", DateTimeException);
              }
            }
          }
        };
        var _proto = LocalDate2.prototype;
        _proto.isSupported = function isSupported(field) {
          return _ChronoLocalDate.prototype.isSupported.call(this, field);
        };
        _proto.range = function range(field) {
          if (field instanceof ChronoField) {
            if (field.isDateBased()) {
              switch (field) {
                case ChronoField.DAY_OF_MONTH:
                  return ValueRange.of(1, this.lengthOfMonth());
                case ChronoField.DAY_OF_YEAR:
                  return ValueRange.of(1, this.lengthOfYear());
                case ChronoField.ALIGNED_WEEK_OF_MONTH:
                  return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);
                case ChronoField.YEAR_OF_ERA:
                  return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
              }
              return field.range();
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.rangeRefinedBy(this);
        };
        _proto.get = function get(field) {
          return this.getLong(field);
        };
        _proto.getLong = function getLong(field) {
          assert(field != null, "", NullPointerException);
          if (field instanceof ChronoField) {
            return this._get0(field);
          }
          return field.getFrom(this);
        };
        _proto._get0 = function _get0(field) {
          switch (field) {
            case ChronoField.DAY_OF_WEEK:
              return this.dayOfWeek().value();
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
              return MathUtil.intMod(this._day - 1, 7) + 1;
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
              return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;
            case ChronoField.DAY_OF_MONTH:
              return this._day;
            case ChronoField.DAY_OF_YEAR:
              return this.dayOfYear();
            case ChronoField.EPOCH_DAY:
              return this.toEpochDay();
            case ChronoField.ALIGNED_WEEK_OF_MONTH:
              return MathUtil.intDiv(this._day - 1, 7) + 1;
            case ChronoField.ALIGNED_WEEK_OF_YEAR:
              return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;
            case ChronoField.MONTH_OF_YEAR:
              return this._month;
            case ChronoField.PROLEPTIC_MONTH:
              return this._prolepticMonth();
            case ChronoField.YEAR_OF_ERA:
              return this._year >= 1 ? this._year : 1 - this._year;
            case ChronoField.YEAR:
              return this._year;
            case ChronoField.ERA:
              return this._year >= 1 ? 1 : 0;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        };
        _proto._prolepticMonth = function _prolepticMonth() {
          return this._year * 12 + (this._month - 1);
        };
        _proto.chronology = function chronology() {
          return IsoChronology.INSTANCE;
        };
        _proto.year = function year() {
          return this._year;
        };
        _proto.monthValue = function monthValue() {
          return this._month;
        };
        _proto.month = function month() {
          return Month.of(this._month);
        };
        _proto.dayOfMonth = function dayOfMonth() {
          return this._day;
        };
        _proto.dayOfYear = function dayOfYear() {
          return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
        };
        _proto.dayOfWeek = function dayOfWeek() {
          var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
          return DayOfWeek.of(dow0 + 1);
        };
        _proto.isLeapYear = function isLeapYear() {
          return IsoChronology.isLeapYear(this._year);
        };
        _proto.lengthOfMonth = function lengthOfMonth() {
          switch (this._month) {
            case 2:
              return this.isLeapYear() ? 29 : 28;
            case 4:
            case 6:
            case 9:
            case 11:
              return 30;
            default:
              return 31;
          }
        };
        _proto.lengthOfYear = function lengthOfYear() {
          return this.isLeapYear() ? 366 : 365;
        };
        _proto._withAdjuster = function _withAdjuster(adjuster) {
          requireNonNull(adjuster, "adjuster");
          if (adjuster instanceof LocalDate2) {
            return adjuster;
          }
          return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);
        };
        _proto._withField = function _withField(field, newValue) {
          assert(field != null, "field", NullPointerException);
          if (field instanceof ChronoField) {
            var f = field;
            f.checkValidValue(newValue);
            switch (f) {
              case ChronoField.DAY_OF_WEEK:
                return this.plusDays(newValue - this.dayOfWeek().value());
              case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
                return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));
              case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
                return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
              case ChronoField.DAY_OF_MONTH:
                return this.withDayOfMonth(newValue);
              case ChronoField.DAY_OF_YEAR:
                return this.withDayOfYear(newValue);
              case ChronoField.EPOCH_DAY:
                return LocalDate2.ofEpochDay(newValue);
              case ChronoField.ALIGNED_WEEK_OF_MONTH:
                return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));
              case ChronoField.ALIGNED_WEEK_OF_YEAR:
                return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));
              case ChronoField.MONTH_OF_YEAR:
                return this.withMonth(newValue);
              case ChronoField.PROLEPTIC_MONTH:
                return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
              case ChronoField.YEAR_OF_ERA:
                return this.withYear(this._year >= 1 ? newValue : 1 - newValue);
              case ChronoField.YEAR:
                return this.withYear(newValue);
              case ChronoField.ERA:
                return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.adjustInto(this, newValue);
        };
        _proto.withYear = function withYear(year) {
          if (this._year === year) {
            return this;
          }
          ChronoField.YEAR.checkValidValue(year);
          return LocalDate2._resolvePreviousValid(year, this._month, this._day);
        };
        _proto.withMonth = function withMonth(month) {
          var m = month instanceof Month ? month.value() : month;
          if (this._month === m) {
            return this;
          }
          ChronoField.MONTH_OF_YEAR.checkValidValue(m);
          return LocalDate2._resolvePreviousValid(this._year, m, this._day);
        };
        _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
          if (this._day === dayOfMonth) {
            return this;
          }
          return LocalDate2.of(this._year, this._month, dayOfMonth);
        };
        _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
          if (this.dayOfYear() === dayOfYear) {
            return this;
          }
          return LocalDate2.ofYearDay(this._year, dayOfYear);
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          requireNonNull(amountToAdd, "amountToAdd");
          requireNonNull(unit, "unit");
          if (unit instanceof ChronoUnit) {
            switch (unit) {
              case ChronoUnit.DAYS:
                return this.plusDays(amountToAdd);
              case ChronoUnit.WEEKS:
                return this.plusWeeks(amountToAdd);
              case ChronoUnit.MONTHS:
                return this.plusMonths(amountToAdd);
              case ChronoUnit.YEARS:
                return this.plusYears(amountToAdd);
              case ChronoUnit.DECADES:
                return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
              case ChronoUnit.CENTURIES:
                return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
              case ChronoUnit.MILLENNIA:
                return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
              case ChronoUnit.ERAS:
                return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.addTo(this, amountToAdd);
        };
        _proto.plusYears = function plusYears(yearsToAdd) {
          if (yearsToAdd === 0) {
            return this;
          }
          var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
          return LocalDate2._resolvePreviousValid(newYear, this._month, this._day);
        };
        _proto.plusMonths = function plusMonths(monthsToAdd) {
          if (monthsToAdd === 0) {
            return this;
          }
          var monthCount = this._year * 12 + (this._month - 1);
          var calcMonths = monthCount + monthsToAdd;
          var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
          var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
          return LocalDate2._resolvePreviousValid(newYear, newMonth, this._day);
        };
        _proto.plusWeeks = function plusWeeks(weeksToAdd) {
          return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
        };
        _proto.plusDays = function plusDays(daysToAdd) {
          if (daysToAdd === 0) {
            return this;
          }
          var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
          return LocalDate2.ofEpochDay(mjDay);
        };
        _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
          requireNonNull(amountToSubtract, "amountToSubtract");
          requireNonNull(unit, "unit");
          return this._plusUnit(-1 * amountToSubtract, unit);
        };
        _proto.minusYears = function minusYears(yearsToSubtract) {
          return this.plusYears(yearsToSubtract * -1);
        };
        _proto.minusMonths = function minusMonths(monthsToSubtract) {
          return this.plusMonths(monthsToSubtract * -1);
        };
        _proto.minusWeeks = function minusWeeks(weeksToSubtract) {
          return this.plusWeeks(weeksToSubtract * -1);
        };
        _proto.minusDays = function minusDays(daysToSubtract) {
          return this.plusDays(daysToSubtract * -1);
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query");
          if (_query === TemporalQueries.localDate()) {
            return this;
          }
          return _ChronoLocalDate.prototype.query.call(this, _query);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
        };
        _proto.until = function until(p1, p2) {
          if (arguments.length < 2) {
            return this.until1(p1);
          } else {
            return this.until2(p1, p2);
          }
        };
        _proto.until2 = function until2(endExclusive, unit) {
          var end = LocalDate2.from(endExclusive);
          if (unit instanceof ChronoUnit) {
            switch (unit) {
              case ChronoUnit.DAYS:
                return this.daysUntil(end);
              case ChronoUnit.WEEKS:
                return MathUtil.intDiv(this.daysUntil(end), 7);
              case ChronoUnit.MONTHS:
                return this._monthsUntil(end);
              case ChronoUnit.YEARS:
                return MathUtil.intDiv(this._monthsUntil(end), 12);
              case ChronoUnit.DECADES:
                return MathUtil.intDiv(this._monthsUntil(end), 120);
              case ChronoUnit.CENTURIES:
                return MathUtil.intDiv(this._monthsUntil(end), 1200);
              case ChronoUnit.MILLENNIA:
                return MathUtil.intDiv(this._monthsUntil(end), 12e3);
              case ChronoUnit.ERAS:
                return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.between(this, end);
        };
        _proto.daysUntil = function daysUntil(end) {
          return end.toEpochDay() - this.toEpochDay();
        };
        _proto._monthsUntil = function _monthsUntil(end) {
          var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
          var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();
          return MathUtil.intDiv(packed2 - packed1, 32);
        };
        _proto.until1 = function until1(endDate) {
          var end = LocalDate2.from(endDate);
          var totalMonths = end._prolepticMonth() - this._prolepticMonth();
          var days = end._day - this._day;
          if (totalMonths > 0 && days < 0) {
            totalMonths--;
            var calcDate = this.plusMonths(totalMonths);
            days = end.toEpochDay() - calcDate.toEpochDay();
          } else if (totalMonths < 0 && days > 0) {
            totalMonths++;
            days -= end.lengthOfMonth();
          }
          var years = MathUtil.intDiv(totalMonths, 12);
          var months = MathUtil.intMod(totalMonths, 12);
          return Period.of(years, months, days);
        };
        _proto.atTime = function atTime() {
          if (arguments.length === 1) {
            return this.atTime1.apply(this, arguments);
          } else {
            return this.atTime4.apply(this, arguments);
          }
        };
        _proto.atTime1 = function atTime1(time) {
          requireNonNull(time, "time");
          if (time instanceof LocalTime) {
            return LocalDateTime.of(this, time);
          } else if (time instanceof OffsetTime) {
            return this._atTimeOffsetTime(time);
          } else {
            throw new IllegalArgumentException("time must be an instance of LocalTime or OffsetTime" + (time && time.constructor && time.constructor.name ? ", but is " + time.constructor.name : ""));
          }
        };
        _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {
          if (second === void 0) {
            second = 0;
          }
          if (nanoOfSecond === void 0) {
            nanoOfSecond = 0;
          }
          return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
        };
        _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {
          return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());
        };
        _proto.atStartOfDay = function atStartOfDay(zone) {
          if (zone != null) {
            return this._atStartOfDayWithZone(zone);
          } else {
            return LocalDateTime.of(this, LocalTime.MIDNIGHT);
          }
        };
        _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {
          requireNonNull(zone, "zone");
          var ldt = this.atTime(LocalTime.MIDNIGHT);
          if (zone instanceof ZoneOffset === false) {
            var trans = zone.rules().transition(ldt);
            if (trans != null && trans.isGap()) {
              ldt = trans.dateTimeAfter();
            }
          }
          return ZonedDateTime.of(ldt, zone);
        };
        _proto.toEpochDay = function toEpochDay() {
          var y = this._year;
          var m = this._month;
          var total = 0;
          total += 365 * y;
          if (y >= 0) {
            total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
          } else {
            total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
          }
          total += MathUtil.intDiv(367 * m - 362, 12);
          total += this.dayOfMonth() - 1;
          if (m > 2) {
            total--;
            if (!IsoChronology.isLeapYear(y)) {
              total--;
            }
          }
          return total - DAYS_0000_TO_1970;
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, LocalDate2, "other");
          return this._compareTo0(other);
        };
        _proto._compareTo0 = function _compareTo0(otherDate) {
          var cmp = this._year - otherDate._year;
          if (cmp === 0) {
            cmp = this._month - otherDate._month;
            if (cmp === 0) {
              cmp = this._day - otherDate._day;
            }
          }
          return cmp;
        };
        _proto.isAfter = function isAfter(other) {
          return this.compareTo(other) > 0;
        };
        _proto.isBefore = function isBefore(other) {
          return this.compareTo(other) < 0;
        };
        _proto.isEqual = function isEqual(other) {
          return this.compareTo(other) === 0;
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof LocalDate2) {
            return this._compareTo0(other) === 0;
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          var yearValue = this._year;
          var monthValue = this._month;
          var dayValue = this._day;
          return MathUtil.hash(yearValue & 4294965248 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
        };
        _proto.toString = function toString() {
          var dayString, monthString, yearString;
          var yearValue = this._year;
          var monthValue = this._month;
          var dayValue = this._day;
          var absYear = Math.abs(yearValue);
          if (absYear < 1e3) {
            if (yearValue < 0) {
              yearString = "-" + ("" + (yearValue - 1e4)).slice(-4);
            } else {
              yearString = ("" + (yearValue + 1e4)).slice(-4);
            }
          } else {
            if (yearValue > 9999) {
              yearString = "+" + yearValue;
            } else {
              yearString = "" + yearValue;
            }
          }
          if (monthValue < 10) {
            monthString = "-0" + monthValue;
          } else {
            monthString = "-" + monthValue;
          }
          if (dayValue < 10) {
            dayString = "-0" + dayValue;
          } else {
            dayString = "-" + dayValue;
          }
          return yearString + monthString + dayString;
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          requireInstance(formatter, DateTimeFormatter, "formatter");
          return _ChronoLocalDate.prototype.format.call(this, formatter);
        };
        return LocalDate2;
      }(ChronoLocalDate);
      function _init$5() {
        LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);
        LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);
        LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);
        LocalDate.FROM = createTemporalQuery("LocalDate.FROM", function(temporal) {
          return LocalDate.from(temporal);
        });
      }
      var ChronoLocalDateTime = function(_Temporal) {
        _inheritsLoose(ChronoLocalDateTime2, _Temporal);
        function ChronoLocalDateTime2() {
          return _Temporal.apply(this, arguments) || this;
        }
        var _proto = ChronoLocalDateTime2.prototype;
        _proto.chronology = function chronology() {
          return this.toLocalDate().chronology();
        };
        _proto.query = function query(_query) {
          if (_query === TemporalQueries.chronology()) {
            return this.chronology();
          } else if (_query === TemporalQueries.precision()) {
            return ChronoUnit.NANOS;
          } else if (_query === TemporalQueries.localDate()) {
            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
          } else if (_query === TemporalQueries.localTime()) {
            return this.toLocalTime();
          } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
            return null;
          }
          return _Temporal.prototype.query.call(this, _query);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
        };
        _proto.toInstant = function toInstant(offset) {
          requireInstance(offset, ZoneOffset, "zoneId");
          return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
        };
        _proto.toEpochSecond = function toEpochSecond(offset) {
          requireNonNull(offset, "offset");
          var epochDay = this.toLocalDate().toEpochDay();
          var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
          secs -= offset.totalSeconds();
          return MathUtil.safeToInt(secs);
        };
        return ChronoLocalDateTime2;
      }(Temporal);
      var LocalDateTime = function(_ChronoLocalDateTime) {
        _inheritsLoose(LocalDateTime2, _ChronoLocalDateTime);
        LocalDateTime2.now = function now(clockOrZone) {
          if (clockOrZone == null) {
            return LocalDateTime2._now(Clock.systemDefaultZone());
          } else if (clockOrZone instanceof Clock) {
            return LocalDateTime2._now(clockOrZone);
          } else {
            return LocalDateTime2._now(Clock.system(clockOrZone));
          }
        };
        LocalDateTime2._now = function _now(clock) {
          requireNonNull(clock, "clock");
          return LocalDateTime2.ofInstant(clock.instant(), clock.zone());
        };
        LocalDateTime2._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
          var localSecond = MathUtil.floorDiv(epochMilli, 1e3) + offset.totalSeconds();
          var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
          var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
          var nanoOfSecond = MathUtil.floorMod(epochMilli, 1e3) * 1e6;
          var date = LocalDate.ofEpochDay(localEpochDay);
          var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
          return new LocalDateTime2(date, time);
        };
        LocalDateTime2.of = function of() {
          if (arguments.length <= 2) {
            return LocalDateTime2.ofDateAndTime.apply(this, arguments);
          } else {
            return LocalDateTime2.ofNumbers.apply(this, arguments);
          }
        };
        LocalDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {
          if (hour === void 0) {
            hour = 0;
          }
          if (minute === void 0) {
            minute = 0;
          }
          if (second === void 0) {
            second = 0;
          }
          if (nanoOfSecond === void 0) {
            nanoOfSecond = 0;
          }
          var date = LocalDate.of(year, month, dayOfMonth);
          var time = LocalTime.of(hour, minute, second, nanoOfSecond);
          return new LocalDateTime2(date, time);
        };
        LocalDateTime2.ofDateAndTime = function ofDateAndTime(date, time) {
          requireNonNull(date, "date");
          requireNonNull(time, "time");
          return new LocalDateTime2(date, time);
        };
        LocalDateTime2.ofInstant = function ofInstant(instant, zone) {
          if (zone === void 0) {
            zone = ZoneId.systemDefault();
          }
          requireNonNull(instant, "instant");
          requireInstance(instant, Instant, "instant");
          requireNonNull(zone, "zone");
          var offset = zone.rules().offset(instant);
          return LocalDateTime2.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
        };
        LocalDateTime2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {
          if (epochSecond === void 0) {
            epochSecond = 0;
          }
          if (nanoOfSecond === void 0) {
            nanoOfSecond = 0;
          }
          if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
            offset = nanoOfSecond;
            nanoOfSecond = 0;
          }
          requireNonNull(offset, "offset");
          var localSecond = epochSecond + offset.totalSeconds();
          var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
          var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
          var date = LocalDate.ofEpochDay(localEpochDay);
          var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
          return new LocalDateTime2(date, time);
        };
        LocalDateTime2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          if (temporal instanceof LocalDateTime2) {
            return temporal;
          } else if (temporal instanceof ZonedDateTime) {
            return temporal.toLocalDateTime();
          }
          try {
            var date = LocalDate.from(temporal);
            var time = LocalTime.from(temporal);
            return new LocalDateTime2(date, time);
          } catch (ex) {
            throw new DateTimeException("Unable to obtain LocalDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
          }
        };
        LocalDateTime2.parse = function parse2(text, formatter) {
          if (formatter === void 0) {
            formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
          }
          requireNonNull(formatter, "formatter");
          return formatter.parse(text, LocalDateTime2.FROM);
        };
        function LocalDateTime2(date, time) {
          var _this;
          _this = _ChronoLocalDateTime.call(this) || this;
          requireInstance(date, LocalDate, "date");
          requireInstance(time, LocalTime, "time");
          _this._date = date;
          _this._time = time;
          return _this;
        }
        var _proto = LocalDateTime2.prototype;
        _proto._withDateTime = function _withDateTime(newDate, newTime) {
          if (this._date.equals(newDate) && this._time.equals(newTime)) {
            return this;
          }
          return new LocalDateTime2(newDate, newTime);
        };
        _proto.isSupported = function isSupported(fieldOrUnit) {
          if (fieldOrUnit instanceof ChronoField) {
            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
          } else if (fieldOrUnit instanceof ChronoUnit) {
            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
          }
          return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };
        _proto.range = function range(field) {
          if (field instanceof ChronoField) {
            return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
          }
          return field.rangeRefinedBy(this);
        };
        _proto.get = function get(field) {
          if (field instanceof ChronoField) {
            return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
          }
          return _ChronoLocalDateTime.prototype.get.call(this, field);
        };
        _proto.getLong = function getLong(field) {
          requireNonNull(field, "field");
          if (field instanceof ChronoField) {
            return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
          }
          return field.getFrom(this);
        };
        _proto.year = function year() {
          return this._date.year();
        };
        _proto.monthValue = function monthValue() {
          return this._date.monthValue();
        };
        _proto.month = function month() {
          return this._date.month();
        };
        _proto.dayOfMonth = function dayOfMonth() {
          return this._date.dayOfMonth();
        };
        _proto.dayOfYear = function dayOfYear() {
          return this._date.dayOfYear();
        };
        _proto.dayOfWeek = function dayOfWeek() {
          return this._date.dayOfWeek();
        };
        _proto.hour = function hour() {
          return this._time.hour();
        };
        _proto.minute = function minute() {
          return this._time.minute();
        };
        _proto.second = function second() {
          return this._time.second();
        };
        _proto.nano = function nano() {
          return this._time.nano();
        };
        _proto._withAdjuster = function _withAdjuster(adjuster) {
          requireNonNull(adjuster, "adjuster");
          if (adjuster instanceof LocalDate) {
            return this._withDateTime(adjuster, this._time);
          } else if (adjuster instanceof LocalTime) {
            return this._withDateTime(this._date, adjuster);
          } else if (adjuster instanceof LocalDateTime2) {
            return adjuster;
          }
          return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);
        };
        _proto._withField = function _withField(field, newValue) {
          requireNonNull(field, "field");
          if (field instanceof ChronoField) {
            if (field.isTimeBased()) {
              return this._withDateTime(this._date, this._time.with(field, newValue));
            } else {
              return this._withDateTime(this._date.with(field, newValue), this._time);
            }
          }
          return field.adjustInto(this, newValue);
        };
        _proto.withYear = function withYear(year) {
          return this._withDateTime(this._date.withYear(year), this._time);
        };
        _proto.withMonth = function withMonth(month) {
          return this._withDateTime(this._date.withMonth(month), this._time);
        };
        _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
          return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
        };
        _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
          return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
        };
        _proto.withHour = function withHour(hour) {
          var newTime = this._time.withHour(hour);
          return this._withDateTime(this._date, newTime);
        };
        _proto.withMinute = function withMinute(minute) {
          var newTime = this._time.withMinute(minute);
          return this._withDateTime(this._date, newTime);
        };
        _proto.withSecond = function withSecond(second) {
          var newTime = this._time.withSecond(second);
          return this._withDateTime(this._date, newTime);
        };
        _proto.withNano = function withNano(nanoOfSecond) {
          var newTime = this._time.withNano(nanoOfSecond);
          return this._withDateTime(this._date, newTime);
        };
        _proto.truncatedTo = function truncatedTo(unit) {
          return this._withDateTime(this._date, this._time.truncatedTo(unit));
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          requireNonNull(unit, "unit");
          if (unit instanceof ChronoUnit) {
            switch (unit) {
              case ChronoUnit.NANOS:
                return this.plusNanos(amountToAdd);
              case ChronoUnit.MICROS:
                return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1e3);
              case ChronoUnit.MILLIS:
                return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1e6);
              case ChronoUnit.SECONDS:
                return this.plusSeconds(amountToAdd);
              case ChronoUnit.MINUTES:
                return this.plusMinutes(amountToAdd);
              case ChronoUnit.HOURS:
                return this.plusHours(amountToAdd);
              case ChronoUnit.HALF_DAYS:
                return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);
            }
            return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
          }
          return unit.addTo(this, amountToAdd);
        };
        _proto.plusYears = function plusYears(years) {
          var newDate = this._date.plusYears(years);
          return this._withDateTime(newDate, this._time);
        };
        _proto.plusMonths = function plusMonths(months) {
          var newDate = this._date.plusMonths(months);
          return this._withDateTime(newDate, this._time);
        };
        _proto.plusWeeks = function plusWeeks(weeks) {
          var newDate = this._date.plusWeeks(weeks);
          return this._withDateTime(newDate, this._time);
        };
        _proto.plusDays = function plusDays(days) {
          var newDate = this._date.plusDays(days);
          return this._withDateTime(newDate, this._time);
        };
        _proto.plusHours = function plusHours(hours) {
          return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
        };
        _proto.plusMinutes = function plusMinutes(minutes) {
          return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
        };
        _proto.plusSeconds = function plusSeconds(seconds) {
          return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
        };
        _proto.plusNanos = function plusNanos(nanos) {
          return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
        };
        _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
          requireNonNull(unit, "unit");
          return this._plusUnit(-1 * amountToSubtract, unit);
        };
        _proto.minusYears = function minusYears(years) {
          return this.plusYears(-1 * years);
        };
        _proto.minusMonths = function minusMonths(months) {
          return this.plusMonths(-1 * months);
        };
        _proto.minusWeeks = function minusWeeks(weeks) {
          return this.plusWeeks(-1 * weeks);
        };
        _proto.minusDays = function minusDays(days) {
          return this.plusDays(-1 * days);
        };
        _proto.minusHours = function minusHours(hours) {
          return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
        };
        _proto.minusMinutes = function minusMinutes(minutes) {
          return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
        };
        _proto.minusSeconds = function minusSeconds(seconds) {
          return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
        };
        _proto.minusNanos = function minusNanos(nanos) {
          return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
        };
        _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {
          if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {
            return this._withDateTime(newDate, this._time);
          }
          var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
          totDays *= sign;
          var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;
          var curNoD = this._time.toNanoOfDay();
          totNanos = totNanos * sign + curNoD;
          totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
          var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
          var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
          return this._withDateTime(newDate.plusDays(totDays), newTime);
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query");
          if (_query === TemporalQueries.localDate()) {
            return this.toLocalDate();
          }
          return _ChronoLocalDateTime.prototype.query.call(this, _query);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
        };
        _proto.until = function until(endExclusive, unit) {
          requireNonNull(endExclusive, "endExclusive");
          requireNonNull(unit, "unit");
          var end = LocalDateTime2.from(endExclusive);
          if (unit instanceof ChronoUnit) {
            if (unit.isTimeBased()) {
              var daysUntil = this._date.daysUntil(end._date);
              var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();
              if (daysUntil > 0 && timeUntil < 0) {
                daysUntil--;
                timeUntil += LocalTime.NANOS_PER_DAY;
              } else if (daysUntil < 0 && timeUntil > 0) {
                daysUntil++;
                timeUntil -= LocalTime.NANOS_PER_DAY;
              }
              var amount = daysUntil;
              switch (unit) {
                case ChronoUnit.NANOS:
                  amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
                  return MathUtil.safeAdd(amount, timeUntil);
                case ChronoUnit.MICROS:
                  amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
                  return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e3));
                case ChronoUnit.MILLIS:
                  amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
                  return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e6));
                case ChronoUnit.SECONDS:
                  amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
                  return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));
                case ChronoUnit.MINUTES:
                  amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
                  return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));
                case ChronoUnit.HOURS:
                  amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
                  return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));
                case ChronoUnit.HALF_DAYS:
                  amount = MathUtil.safeMultiply(amount, 2);
                  return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
              }
              throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
            }
            var endDate = end._date;
            var endTime = end._time;
            if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
              endDate = endDate.minusDays(1);
            } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
              endDate = endDate.plusDays(1);
            }
            return this._date.until(endDate, unit);
          }
          return unit.between(this, end);
        };
        _proto.atOffset = function atOffset(offset) {
          return OffsetDateTime.of(this, offset);
        };
        _proto.atZone = function atZone(zone) {
          return ZonedDateTime.of(this, zone);
        };
        _proto.toLocalDate = function toLocalDate() {
          return this._date;
        };
        _proto.toLocalTime = function toLocalTime() {
          return this._time;
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, LocalDateTime2, "other");
          return this._compareTo0(other);
        };
        _proto._compareTo0 = function _compareTo0(other) {
          var cmp = this._date.compareTo(other.toLocalDate());
          if (cmp === 0) {
            cmp = this._time.compareTo(other.toLocalTime());
          }
          return cmp;
        };
        _proto.isAfter = function isAfter(other) {
          return this.compareTo(other) > 0;
        };
        _proto.isBefore = function isBefore(other) {
          return this.compareTo(other) < 0;
        };
        _proto.isEqual = function isEqual(other) {
          return this.compareTo(other) === 0;
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof LocalDateTime2) {
            return this._date.equals(other._date) && this._time.equals(other._time);
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return this._date.hashCode() ^ this._time.hashCode();
        };
        _proto.toString = function toString() {
          return this._date.toString() + "T" + this._time.toString();
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          return formatter.format(this);
        };
        return LocalDateTime2;
      }(ChronoLocalDateTime);
      function _init$4() {
        LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);
        LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);
        LocalDateTime.FROM = createTemporalQuery("LocalDateTime.FROM", function(temporal) {
          return LocalDateTime.from(temporal);
        });
      }
      var LocalTime = function(_Temporal) {
        _inheritsLoose(LocalTime2, _Temporal);
        LocalTime2.now = function now(clockOrZone) {
          if (clockOrZone == null) {
            return LocalTime2._now(Clock.systemDefaultZone());
          } else if (clockOrZone instanceof Clock) {
            return LocalTime2._now(clockOrZone);
          } else {
            return LocalTime2._now(Clock.system(clockOrZone));
          }
        };
        LocalTime2._now = function _now(clock) {
          if (clock === void 0) {
            clock = Clock.systemDefaultZone();
          }
          requireNonNull(clock, "clock");
          return LocalTime2.ofInstant(clock.instant(), clock.zone());
        };
        LocalTime2.ofInstant = function ofInstant(instant, zone) {
          if (zone === void 0) {
            zone = ZoneId.systemDefault();
          }
          var offset = zone.rules().offset(instant);
          var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime2.SECONDS_PER_DAY);
          secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime2.SECONDS_PER_DAY);
          if (secsOfDay < 0) {
            secsOfDay += LocalTime2.SECONDS_PER_DAY;
          }
          return LocalTime2.ofSecondOfDay(secsOfDay, instant.nano());
        };
        LocalTime2.of = function of(hour, minute, second, nanoOfSecond) {
          return new LocalTime2(hour, minute, second, nanoOfSecond);
        };
        LocalTime2.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {
          if (secondOfDay === void 0) {
            secondOfDay = 0;
          }
          if (nanoOfSecond === void 0) {
            nanoOfSecond = 0;
          }
          ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
          ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
          var hours = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_HOUR);
          secondOfDay -= hours * LocalTime2.SECONDS_PER_HOUR;
          var minutes = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_MINUTE);
          secondOfDay -= minutes * LocalTime2.SECONDS_PER_MINUTE;
          return new LocalTime2(hours, minutes, secondOfDay, nanoOfSecond);
        };
        LocalTime2.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {
          if (nanoOfDay === void 0) {
            nanoOfDay = 0;
          }
          ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
          var hours = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_HOUR);
          nanoOfDay -= hours * LocalTime2.NANOS_PER_HOUR;
          var minutes = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_MINUTE);
          nanoOfDay -= minutes * LocalTime2.NANOS_PER_MINUTE;
          var seconds = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_SECOND);
          nanoOfDay -= seconds * LocalTime2.NANOS_PER_SECOND;
          return new LocalTime2(hours, minutes, seconds, nanoOfDay);
        };
        LocalTime2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          var time = temporal.query(TemporalQueries.localTime());
          if (time == null) {
            throw new DateTimeException("Unable to obtain LocalTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
          }
          return time;
        };
        LocalTime2.parse = function parse2(text, formatter) {
          if (formatter === void 0) {
            formatter = DateTimeFormatter.ISO_LOCAL_TIME;
          }
          requireNonNull(formatter, "formatter");
          return formatter.parse(text, LocalTime2.FROM);
        };
        function LocalTime2(hour, minute, second, nanoOfSecond) {
          var _this;
          if (hour === void 0) {
            hour = 0;
          }
          if (minute === void 0) {
            minute = 0;
          }
          if (second === void 0) {
            second = 0;
          }
          if (nanoOfSecond === void 0) {
            nanoOfSecond = 0;
          }
          _this = _Temporal.call(this) || this;
          var _hour = MathUtil.safeToInt(hour);
          var _minute = MathUtil.safeToInt(minute);
          var _second = MathUtil.safeToInt(second);
          var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);
          LocalTime2._validate(_hour, _minute, _second, _nanoOfSecond);
          if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {
            if (!LocalTime2.HOURS[_hour]) {
              _this._hour = _hour;
              _this._minute = _minute;
              _this._second = _second;
              _this._nano = _nanoOfSecond;
              LocalTime2.HOURS[_hour] = _assertThisInitialized(_this);
            }
            return LocalTime2.HOURS[_hour] || _assertThisInitialized(_this);
          }
          _this._hour = _hour;
          _this._minute = _minute;
          _this._second = _second;
          _this._nano = _nanoOfSecond;
          return _this;
        }
        LocalTime2._validate = function _validate(hour, minute, second, nanoOfSecond) {
          ChronoField.HOUR_OF_DAY.checkValidValue(hour);
          ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
          ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
          ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
        };
        var _proto = LocalTime2.prototype;
        _proto.isSupported = function isSupported(fieldOrUnit) {
          if (fieldOrUnit instanceof ChronoField) {
            return fieldOrUnit.isTimeBased();
          } else if (fieldOrUnit instanceof ChronoUnit) {
            return fieldOrUnit.isTimeBased();
          }
          return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };
        _proto.range = function range(field) {
          requireNonNull(field);
          return _Temporal.prototype.range.call(this, field);
        };
        _proto.get = function get(field) {
          return this.getLong(field);
        };
        _proto.getLong = function getLong(field) {
          requireNonNull(field, "field");
          if (field instanceof ChronoField) {
            return this._get0(field);
          }
          return field.getFrom(this);
        };
        _proto._get0 = function _get0(field) {
          switch (field) {
            case ChronoField.NANO_OF_SECOND:
              return this._nano;
            case ChronoField.NANO_OF_DAY:
              return this.toNanoOfDay();
            case ChronoField.MICRO_OF_SECOND:
              return MathUtil.intDiv(this._nano, 1e3);
            case ChronoField.MICRO_OF_DAY:
              return MathUtil.intDiv(this.toNanoOfDay(), 1e3);
            case ChronoField.MILLI_OF_SECOND:
              return MathUtil.intDiv(this._nano, 1e6);
            case ChronoField.MILLI_OF_DAY:
              return MathUtil.intDiv(this.toNanoOfDay(), 1e6);
            case ChronoField.SECOND_OF_MINUTE:
              return this._second;
            case ChronoField.SECOND_OF_DAY:
              return this.toSecondOfDay();
            case ChronoField.MINUTE_OF_HOUR:
              return this._minute;
            case ChronoField.MINUTE_OF_DAY:
              return this._hour * 60 + this._minute;
            case ChronoField.HOUR_OF_AMPM:
              return MathUtil.intMod(this._hour, 12);
            case ChronoField.CLOCK_HOUR_OF_AMPM: {
              var ham = MathUtil.intMod(this._hour, 12);
              return ham % 12 === 0 ? 12 : ham;
            }
            case ChronoField.HOUR_OF_DAY:
              return this._hour;
            case ChronoField.CLOCK_HOUR_OF_DAY:
              return this._hour === 0 ? 24 : this._hour;
            case ChronoField.AMPM_OF_DAY:
              return MathUtil.intDiv(this._hour, 12);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        };
        _proto.hour = function hour() {
          return this._hour;
        };
        _proto.minute = function minute() {
          return this._minute;
        };
        _proto.second = function second() {
          return this._second;
        };
        _proto.nano = function nano() {
          return this._nano;
        };
        _proto._withAdjuster = function _withAdjuster(adjuster) {
          requireNonNull(adjuster, "adjuster");
          if (adjuster instanceof LocalTime2) {
            return adjuster;
          }
          return _Temporal.prototype._withAdjuster.call(this, adjuster);
        };
        _proto._withField = function _withField(field, newValue) {
          requireNonNull(field, "field");
          requireInstance(field, TemporalField, "field");
          if (field instanceof ChronoField) {
            field.checkValidValue(newValue);
            switch (field) {
              case ChronoField.NANO_OF_SECOND:
                return this.withNano(newValue);
              case ChronoField.NANO_OF_DAY:
                return LocalTime2.ofNanoOfDay(newValue);
              case ChronoField.MICRO_OF_SECOND:
                return this.withNano(newValue * 1e3);
              case ChronoField.MICRO_OF_DAY:
                return LocalTime2.ofNanoOfDay(newValue * 1e3);
              case ChronoField.MILLI_OF_SECOND:
                return this.withNano(newValue * 1e6);
              case ChronoField.MILLI_OF_DAY:
                return LocalTime2.ofNanoOfDay(newValue * 1e6);
              case ChronoField.SECOND_OF_MINUTE:
                return this.withSecond(newValue);
              case ChronoField.SECOND_OF_DAY:
                return this.plusSeconds(newValue - this.toSecondOfDay());
              case ChronoField.MINUTE_OF_HOUR:
                return this.withMinute(newValue);
              case ChronoField.MINUTE_OF_DAY:
                return this.plusMinutes(newValue - (this._hour * 60 + this._minute));
              case ChronoField.HOUR_OF_AMPM:
                return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));
              case ChronoField.CLOCK_HOUR_OF_AMPM:
                return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));
              case ChronoField.HOUR_OF_DAY:
                return this.withHour(newValue);
              case ChronoField.CLOCK_HOUR_OF_DAY:
                return this.withHour(newValue === 24 ? 0 : newValue);
              case ChronoField.AMPM_OF_DAY:
                return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.adjustInto(this, newValue);
        };
        _proto.withHour = function withHour(hour) {
          if (hour === void 0) {
            hour = 0;
          }
          if (this._hour === hour) {
            return this;
          }
          return new LocalTime2(hour, this._minute, this._second, this._nano);
        };
        _proto.withMinute = function withMinute(minute) {
          if (minute === void 0) {
            minute = 0;
          }
          if (this._minute === minute) {
            return this;
          }
          return new LocalTime2(this._hour, minute, this._second, this._nano);
        };
        _proto.withSecond = function withSecond(second) {
          if (second === void 0) {
            second = 0;
          }
          if (this._second === second) {
            return this;
          }
          return new LocalTime2(this._hour, this._minute, second, this._nano);
        };
        _proto.withNano = function withNano(nanoOfSecond) {
          if (nanoOfSecond === void 0) {
            nanoOfSecond = 0;
          }
          if (this._nano === nanoOfSecond) {
            return this;
          }
          return new LocalTime2(this._hour, this._minute, this._second, nanoOfSecond);
        };
        _proto.truncatedTo = function truncatedTo(unit) {
          requireNonNull(unit, "unit");
          if (unit === ChronoUnit.NANOS) {
            return this;
          }
          var unitDur = unit.duration();
          if (unitDur.seconds() > LocalTime2.SECONDS_PER_DAY) {
            throw new DateTimeException("Unit is too large to be used for truncation");
          }
          var dur = unitDur.toNanos();
          if (MathUtil.intMod(LocalTime2.NANOS_PER_DAY, dur) !== 0) {
            throw new DateTimeException("Unit must divide into a standard day without remainder");
          }
          var nod = this.toNanoOfDay();
          return LocalTime2.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          requireNonNull(unit, "unit");
          if (unit instanceof ChronoUnit) {
            switch (unit) {
              case ChronoUnit.NANOS:
                return this.plusNanos(amountToAdd);
              case ChronoUnit.MICROS:
                return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MICROS_PER_DAY) * 1e3);
              case ChronoUnit.MILLIS:
                return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MILLIS_PER_DAY) * 1e6);
              case ChronoUnit.SECONDS:
                return this.plusSeconds(amountToAdd);
              case ChronoUnit.MINUTES:
                return this.plusMinutes(amountToAdd);
              case ChronoUnit.HOURS:
                return this.plusHours(amountToAdd);
              case ChronoUnit.HALF_DAYS:
                return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.addTo(this, amountToAdd);
        };
        _proto.plusHours = function plusHours(hoursToAdd) {
          if (hoursToAdd === 0) {
            return this;
          }
          var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime2.HOURS_PER_DAY) + this._hour + LocalTime2.HOURS_PER_DAY, LocalTime2.HOURS_PER_DAY);
          return new LocalTime2(newHour, this._minute, this._second, this._nano);
        };
        _proto.plusMinutes = function plusMinutes(minutesToAdd) {
          if (minutesToAdd === 0) {
            return this;
          }
          var mofd = this._hour * LocalTime2.MINUTES_PER_HOUR + this._minute;
          var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime2.MINUTES_PER_DAY) + mofd + LocalTime2.MINUTES_PER_DAY, LocalTime2.MINUTES_PER_DAY);
          if (mofd === newMofd) {
            return this;
          }
          var newHour = MathUtil.intDiv(newMofd, LocalTime2.MINUTES_PER_HOUR);
          var newMinute = MathUtil.intMod(newMofd, LocalTime2.MINUTES_PER_HOUR);
          return new LocalTime2(newHour, newMinute, this._second, this._nano);
        };
        _proto.plusSeconds = function plusSeconds(secondsToAdd) {
          if (secondsToAdd === 0) {
            return this;
          }
          var sofd = this._hour * LocalTime2.SECONDS_PER_HOUR + this._minute * LocalTime2.SECONDS_PER_MINUTE + this._second;
          var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime2.SECONDS_PER_DAY) + sofd + LocalTime2.SECONDS_PER_DAY, LocalTime2.SECONDS_PER_DAY);
          if (sofd === newSofd) {
            return this;
          }
          var newHour = MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_HOUR);
          var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
          var newSecond = MathUtil.intMod(newSofd, LocalTime2.SECONDS_PER_MINUTE);
          return new LocalTime2(newHour, newMinute, newSecond, this._nano);
        };
        _proto.plusNanos = function plusNanos(nanosToAdd) {
          if (nanosToAdd === 0) {
            return this;
          }
          var nofd = this.toNanoOfDay();
          var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime2.NANOS_PER_DAY) + nofd + LocalTime2.NANOS_PER_DAY, LocalTime2.NANOS_PER_DAY);
          if (nofd === newNofd) {
            return this;
          }
          var newHour = MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_HOUR);
          var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
          var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_SECOND), LocalTime2.SECONDS_PER_MINUTE);
          var newNano = MathUtil.intMod(newNofd, LocalTime2.NANOS_PER_SECOND);
          return new LocalTime2(newHour, newMinute, newSecond, newNano);
        };
        _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
          requireNonNull(unit, "unit");
          return this._plusUnit(-1 * amountToSubtract, unit);
        };
        _proto.minusHours = function minusHours(hoursToSubtract) {
          return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime2.HOURS_PER_DAY));
        };
        _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
          return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime2.MINUTES_PER_DAY));
        };
        _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
          return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime2.SECONDS_PER_DAY));
        };
        _proto.minusNanos = function minusNanos(nanosToSubtract) {
          return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime2.NANOS_PER_DAY));
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query");
          if (_query === TemporalQueries.precision()) {
            return ChronoUnit.NANOS;
          } else if (_query === TemporalQueries.localTime()) {
            return this;
          }
          if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
            return null;
          }
          return _query.queryFrom(this);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          return temporal.with(LocalTime2.NANO_OF_DAY, this.toNanoOfDay());
        };
        _proto.until = function until(endExclusive, unit) {
          requireNonNull(endExclusive, "endExclusive");
          requireNonNull(unit, "unit");
          var end = LocalTime2.from(endExclusive);
          if (unit instanceof ChronoUnit) {
            var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();
            switch (unit) {
              case ChronoUnit.NANOS:
                return nanosUntil;
              case ChronoUnit.MICROS:
                return MathUtil.intDiv(nanosUntil, 1e3);
              case ChronoUnit.MILLIS:
                return MathUtil.intDiv(nanosUntil, 1e6);
              case ChronoUnit.SECONDS:
                return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_SECOND);
              case ChronoUnit.MINUTES:
                return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_MINUTE);
              case ChronoUnit.HOURS:
                return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_HOUR);
              case ChronoUnit.HALF_DAYS:
                return MathUtil.intDiv(nanosUntil, 12 * LocalTime2.NANOS_PER_HOUR);
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.between(this, end);
        };
        _proto.atDate = function atDate(date) {
          return LocalDateTime.of(date, this);
        };
        _proto.atOffset = function atOffset(offset) {
          return OffsetTime.of(this, offset);
        };
        _proto.toSecondOfDay = function toSecondOfDay() {
          var total = this._hour * LocalTime2.SECONDS_PER_HOUR;
          total += this._minute * LocalTime2.SECONDS_PER_MINUTE;
          total += this._second;
          return total;
        };
        _proto.toNanoOfDay = function toNanoOfDay() {
          var total = this._hour * LocalTime2.NANOS_PER_HOUR;
          total += this._minute * LocalTime2.NANOS_PER_MINUTE;
          total += this._second * LocalTime2.NANOS_PER_SECOND;
          total += this._nano;
          return total;
        };
        _proto.compareTo = function compareTo(other) {
          requireNonNull(other, "other");
          requireInstance(other, LocalTime2, "other");
          var cmp = MathUtil.compareNumbers(this._hour, other._hour);
          if (cmp === 0) {
            cmp = MathUtil.compareNumbers(this._minute, other._minute);
            if (cmp === 0) {
              cmp = MathUtil.compareNumbers(this._second, other._second);
              if (cmp === 0) {
                cmp = MathUtil.compareNumbers(this._nano, other._nano);
              }
            }
          }
          return cmp;
        };
        _proto.isAfter = function isAfter(other) {
          return this.compareTo(other) > 0;
        };
        _proto.isBefore = function isBefore(other) {
          return this.compareTo(other) < 0;
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof LocalTime2) {
            return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          var nod = this.toNanoOfDay();
          return MathUtil.hash(nod);
        };
        _proto.toString = function toString() {
          var buf = "";
          var hourValue = this._hour;
          var minuteValue = this._minute;
          var secondValue = this._second;
          var nanoValue = this._nano;
          buf += hourValue < 10 ? "0" : "";
          buf += hourValue;
          buf += minuteValue < 10 ? ":0" : ":";
          buf += minuteValue;
          if (secondValue > 0 || nanoValue > 0) {
            buf += secondValue < 10 ? ":0" : ":";
            buf += secondValue;
            if (nanoValue > 0) {
              buf += ".";
              if (MathUtil.intMod(nanoValue, 1e6) === 0) {
                buf += ("" + (MathUtil.intDiv(nanoValue, 1e6) + 1e3)).substring(1);
              } else if (MathUtil.intMod(nanoValue, 1e3) === 0) {
                buf += ("" + (MathUtil.intDiv(nanoValue, 1e3) + 1e6)).substring(1);
              } else {
                buf += ("" + (nanoValue + 1e9)).substring(1);
              }
            }
          }
          return buf;
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        _proto.format = function format(formatter) {
          requireNonNull(formatter, "formatter");
          return formatter.format(this);
        };
        return LocalTime2;
      }(Temporal);
      function _init$3() {
        LocalTime.HOURS = [];
        for (var hour = 0; hour < 24; hour++) {
          LocalTime.of(hour, 0, 0, 0);
        }
        LocalTime.MIN = LocalTime.HOURS[0];
        LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);
        LocalTime.MIDNIGHT = LocalTime.HOURS[0];
        LocalTime.NOON = LocalTime.HOURS[12];
        LocalTime.FROM = createTemporalQuery("LocalTime.FROM", function(temporal) {
          return LocalTime.from(temporal);
        });
      }
      LocalTime.HOURS_PER_DAY = 24;
      LocalTime.MINUTES_PER_HOUR = 60;
      LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;
      LocalTime.SECONDS_PER_MINUTE = 60;
      LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
      LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;
      LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e3;
      LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e6;
      LocalTime.NANOS_PER_SECOND = 1e9;
      LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;
      LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
      LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;
      var NANOS_PER_MILLI = 1e6;
      var Instant = function(_Temporal) {
        _inheritsLoose(Instant2, _Temporal);
        Instant2.now = function now(clock) {
          if (clock === void 0) {
            clock = Clock.systemUTC();
          }
          return clock.instant();
        };
        Instant2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {
          if (nanoAdjustment === void 0) {
            nanoAdjustment = 0;
          }
          var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
          var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
          return Instant2._create(secs, nos);
        };
        Instant2.ofEpochMilli = function ofEpochMilli(epochMilli) {
          var secs = MathUtil.floorDiv(epochMilli, 1e3);
          var mos = MathUtil.floorMod(epochMilli, 1e3);
          return Instant2._create(secs, mos * 1e6);
        };
        Instant2.ofEpochMicro = function ofEpochMicro(epochMicro) {
          var secs = MathUtil.floorDiv(epochMicro, 1e6);
          var mos = MathUtil.floorMod(epochMicro, 1e6);
          return Instant2._create(secs, mos * 1e3);
        };
        Instant2.from = function from(temporal) {
          try {
            var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
            var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
            return Instant2.ofEpochSecond(instantSecs, nanoOfSecond);
          } catch (ex) {
            throw new DateTimeException("Unable to obtain Instant from TemporalAccessor: " + temporal + ", type " + typeof temporal, ex);
          }
        };
        Instant2.parse = function parse2(text) {
          return DateTimeFormatter.ISO_INSTANT.parse(text, Instant2.FROM);
        };
        Instant2._create = function _create(seconds, nanoOfSecond) {
          if (seconds === 0 && nanoOfSecond === 0) {
            return Instant2.EPOCH;
          }
          return new Instant2(seconds, nanoOfSecond);
        };
        Instant2._validate = function _validate(seconds, nanoOfSecond) {
          if (seconds < Instant2.MIN_SECONDS || seconds > Instant2.MAX_SECONDS) {
            throw new DateTimeException("Instant exceeds minimum or maximum instant");
          }
          if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
            throw new DateTimeException("Instant exceeds minimum or maximum instant");
          }
        };
        function Instant2(seconds, nanoOfSecond) {
          var _this;
          _this = _Temporal.call(this) || this;
          Instant2._validate(seconds, nanoOfSecond);
          _this._seconds = MathUtil.safeToInt(seconds);
          _this._nanos = MathUtil.safeToInt(nanoOfSecond);
          return _this;
        }
        var _proto = Instant2.prototype;
        _proto.isSupported = function isSupported(fieldOrUnit) {
          if (fieldOrUnit instanceof ChronoField) {
            return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
          }
          if (fieldOrUnit instanceof ChronoUnit) {
            return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
          }
          return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };
        _proto.range = function range(field) {
          return _Temporal.prototype.range.call(this, field);
        };
        _proto.get = function get(field) {
          return this.getLong(field);
        };
        _proto.getLong = function getLong(field) {
          if (field instanceof ChronoField) {
            switch (field) {
              case ChronoField.NANO_OF_SECOND:
                return this._nanos;
              case ChronoField.MICRO_OF_SECOND:
                return MathUtil.intDiv(this._nanos, 1e3);
              case ChronoField.MILLI_OF_SECOND:
                return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
              case ChronoField.INSTANT_SECONDS:
                return this._seconds;
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.getFrom(this);
        };
        _proto.epochSecond = function epochSecond() {
          return this._seconds;
        };
        _proto.nano = function nano() {
          return this._nanos;
        };
        _proto._withField = function _withField(field, newValue) {
          requireNonNull(field, "field");
          if (field instanceof ChronoField) {
            field.checkValidValue(newValue);
            switch (field) {
              case ChronoField.MILLI_OF_SECOND: {
                var nval = newValue * NANOS_PER_MILLI;
                return nval !== this._nanos ? Instant2._create(this._seconds, nval) : this;
              }
              case ChronoField.MICRO_OF_SECOND: {
                var _nval = newValue * 1e3;
                return _nval !== this._nanos ? Instant2._create(this._seconds, _nval) : this;
              }
              case ChronoField.NANO_OF_SECOND:
                return newValue !== this._nanos ? Instant2._create(this._seconds, newValue) : this;
              case ChronoField.INSTANT_SECONDS:
                return newValue !== this._seconds ? Instant2._create(newValue, this._nanos) : this;
            }
            throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
          }
          return field.adjustInto(this, newValue);
        };
        _proto.truncatedTo = function truncatedTo(unit) {
          requireNonNull(unit, "unit");
          if (unit === ChronoUnit.NANOS) {
            return this;
          }
          var unitDur = unit.duration();
          if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
            throw new DateTimeException("Unit is too large to be used for truncation");
          }
          var dur = unitDur.toNanos();
          if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
            throw new DateTimeException("Unit must divide into a standard day without remainder");
          }
          var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;
          var result = MathUtil.intDiv(nod, dur) * dur;
          return this.plusNanos(result - nod);
        };
        _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
          requireNonNull(amountToAdd, "amountToAdd");
          requireNonNull(unit, "unit");
          requireInstance(unit, TemporalUnit);
          if (unit instanceof ChronoUnit) {
            switch (unit) {
              case ChronoUnit.NANOS:
                return this.plusNanos(amountToAdd);
              case ChronoUnit.MICROS:
                return this.plusMicros(amountToAdd);
              case ChronoUnit.MILLIS:
                return this.plusMillis(amountToAdd);
              case ChronoUnit.SECONDS:
                return this.plusSeconds(amountToAdd);
              case ChronoUnit.MINUTES:
                return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));
              case ChronoUnit.HOURS:
                return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));
              case ChronoUnit.HALF_DAYS:
                return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));
              case ChronoUnit.DAYS:
                return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.addTo(this, amountToAdd);
        };
        _proto.plusSeconds = function plusSeconds(secondsToAdd) {
          return this._plus(secondsToAdd, 0);
        };
        _proto.plusMillis = function plusMillis(millisToAdd) {
          return this._plus(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * NANOS_PER_MILLI);
        };
        _proto.plusNanos = function plusNanos(nanosToAdd) {
          return this._plus(0, nanosToAdd);
        };
        _proto.plusMicros = function plusMicros(microsToAdd) {
          return this._plus(MathUtil.intDiv(microsToAdd, 1e6), MathUtil.intMod(microsToAdd, 1e6) * 1e3);
        };
        _proto._plus = function _plus(secondsToAdd, nanosToAdd) {
          if (secondsToAdd === 0 && nanosToAdd === 0) {
            return this;
          }
          var epochSec = this._seconds + secondsToAdd;
          epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
          var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
          return Instant2.ofEpochSecond(epochSec, nanoAdjustment);
        };
        _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
          return this._plusUnit(-1 * amountToSubtract, unit);
        };
        _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
          return this.plusSeconds(secondsToSubtract * -1);
        };
        _proto.minusMillis = function minusMillis(millisToSubtract) {
          return this.plusMillis(-1 * millisToSubtract);
        };
        _proto.minusNanos = function minusNanos(nanosToSubtract) {
          return this.plusNanos(-1 * nanosToSubtract);
        };
        _proto.minusMicros = function minusMicros(microsToSubtract) {
          return this.plusMicros(-1 * microsToSubtract);
        };
        _proto.query = function query(_query) {
          requireNonNull(_query, "query");
          if (_query === TemporalQueries.precision()) {
            return ChronoUnit.NANOS;
          }
          if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
            return null;
          }
          return _query.queryFrom(this);
        };
        _proto.adjustInto = function adjustInto(temporal) {
          requireNonNull(temporal, "temporal");
          return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
        };
        _proto.until = function until(endExclusive, unit) {
          requireNonNull(endExclusive, "endExclusive");
          requireNonNull(unit, "unit");
          var end = Instant2.from(endExclusive);
          if (unit instanceof ChronoUnit) {
            switch (unit) {
              case ChronoUnit.NANOS:
                return this._nanosUntil(end);
              case ChronoUnit.MICROS:
                return this._microsUntil(end);
              case ChronoUnit.MILLIS:
                return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());
              case ChronoUnit.SECONDS:
                return this._secondsUntil(end);
              case ChronoUnit.MINUTES:
                return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);
              case ChronoUnit.HOURS:
                return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);
              case ChronoUnit.HALF_DAYS:
                return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);
              case ChronoUnit.DAYS:
                return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          return unit.between(this, end);
        };
        _proto._microsUntil = function _microsUntil(end) {
          var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
          var totalMicros = MathUtil.safeMultiply(secsDiff, 1e6);
          return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1e3));
        };
        _proto._nanosUntil = function _nanosUntil(end) {
          var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
          var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
          return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());
        };
        _proto._secondsUntil = function _secondsUntil(end) {
          var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
          var nanosDiff = end.nano() - this.nano();
          if (secsDiff > 0 && nanosDiff < 0) {
            secsDiff--;
          } else if (secsDiff < 0 && nanosDiff > 0) {
            secsDiff++;
          }
          return secsDiff;
        };
        _proto.atOffset = function atOffset(offset) {
          return OffsetDateTime.ofInstant(this, offset);
        };
        _proto.atZone = function atZone(zone) {
          return ZonedDateTime.ofInstant(this, zone);
        };
        _proto.toEpochMilli = function toEpochMilli() {
          var millis = MathUtil.safeMultiply(this._seconds, 1e3);
          return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
        };
        _proto.compareTo = function compareTo(otherInstant) {
          requireNonNull(otherInstant, "otherInstant");
          requireInstance(otherInstant, Instant2, "otherInstant");
          var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);
          if (cmp !== 0) {
            return cmp;
          }
          return this._nanos - otherInstant._nanos;
        };
        _proto.isAfter = function isAfter(otherInstant) {
          return this.compareTo(otherInstant) > 0;
        };
        _proto.isBefore = function isBefore(otherInstant) {
          return this.compareTo(otherInstant) < 0;
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          if (other instanceof Instant2) {
            return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return MathUtil.hashCode(this._seconds, this._nanos);
        };
        _proto.toString = function toString() {
          return DateTimeFormatter.ISO_INSTANT.format(this);
        };
        _proto.toJSON = function toJSON() {
          return this.toString();
        };
        return Instant2;
      }(Temporal);
      function _init$2() {
        Instant.MIN_SECONDS = -31619119219200;
        Instant.MAX_SECONDS = 31494816403199;
        Instant.EPOCH = new Instant(0, 0);
        Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
        Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
        Instant.FROM = createTemporalQuery("Instant.FROM", function(temporal) {
          return Instant.from(temporal);
        });
      }
      var Clock = function() {
        function Clock2() {
        }
        Clock2.systemUTC = function systemUTC() {
          return new SystemClock(ZoneOffset.UTC);
        };
        Clock2.systemDefaultZone = function systemDefaultZone() {
          return new SystemClock(ZoneId.systemDefault());
        };
        Clock2.system = function system(zone) {
          return new SystemClock(zone);
        };
        Clock2.fixed = function fixed(fixedInstant, zoneId) {
          return new FixedClock(fixedInstant, zoneId);
        };
        Clock2.offset = function offset(baseClock, duration) {
          return new OffsetClock(baseClock, duration);
        };
        var _proto = Clock2.prototype;
        _proto.millis = function millis() {
          abstractMethodFail("Clock.millis");
        };
        _proto.instant = function instant() {
          abstractMethodFail("Clock.instant");
        };
        _proto.zone = function zone() {
          abstractMethodFail("Clock.zone");
        };
        _proto.withZone = function withZone() {
          abstractMethodFail("Clock.withZone");
        };
        return Clock2;
      }();
      var SystemClock = function(_Clock) {
        _inheritsLoose(SystemClock2, _Clock);
        function SystemClock2(zone) {
          var _this;
          requireNonNull(zone, "zone");
          _this = _Clock.call(this) || this;
          _this._zone = zone;
          return _this;
        }
        var _proto2 = SystemClock2.prototype;
        _proto2.zone = function zone() {
          return this._zone;
        };
        _proto2.millis = function millis() {
          return (/* @__PURE__ */ new Date()).getTime();
        };
        _proto2.instant = function instant() {
          return Instant.ofEpochMilli(this.millis());
        };
        _proto2.equals = function equals(obj) {
          if (obj instanceof SystemClock2) {
            return this._zone.equals(obj._zone);
          }
          return false;
        };
        _proto2.withZone = function withZone(zone) {
          if (zone.equals(this._zone)) {
            return this;
          }
          return new SystemClock2(zone);
        };
        _proto2.toString = function toString() {
          return "SystemClock[" + this._zone.toString() + "]";
        };
        return SystemClock2;
      }(Clock);
      var FixedClock = function(_Clock2) {
        _inheritsLoose(FixedClock2, _Clock2);
        function FixedClock2(fixedInstant, zoneId) {
          var _this2;
          _this2 = _Clock2.call(this) || this;
          _this2._instant = fixedInstant;
          _this2._zoneId = zoneId;
          return _this2;
        }
        var _proto3 = FixedClock2.prototype;
        _proto3.instant = function instant() {
          return this._instant;
        };
        _proto3.millis = function millis() {
          return this._instant.toEpochMilli();
        };
        _proto3.zone = function zone() {
          return this._zoneId;
        };
        _proto3.toString = function toString() {
          return "FixedClock[]";
        };
        _proto3.equals = function equals(obj) {
          if (obj instanceof FixedClock2) {
            return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);
          }
          return false;
        };
        _proto3.withZone = function withZone(zone) {
          if (zone.equals(this._zoneId)) {
            return this;
          }
          return new FixedClock2(this._instant, zone);
        };
        return FixedClock2;
      }(Clock);
      var OffsetClock = function(_Clock3) {
        _inheritsLoose(OffsetClock2, _Clock3);
        function OffsetClock2(baseClock, offset) {
          var _this3;
          _this3 = _Clock3.call(this) || this;
          _this3._baseClock = baseClock;
          _this3._offset = offset;
          return _this3;
        }
        var _proto4 = OffsetClock2.prototype;
        _proto4.zone = function zone() {
          return this._baseClock.zone();
        };
        _proto4.withZone = function withZone(zone) {
          if (zone.equals(this._baseClock.zone())) {
            return this;
          }
          return new OffsetClock2(this._baseClock.withZone(zone), this._offset);
        };
        _proto4.millis = function millis() {
          return this._baseClock.millis() + this._offset.toMillis();
        };
        _proto4.instant = function instant() {
          return this._baseClock.instant().plus(this._offset);
        };
        _proto4.equals = function equals(obj) {
          if (obj instanceof OffsetClock2) {
            return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);
          }
          return false;
        };
        _proto4.toString = function toString() {
          return "OffsetClock[" + this._baseClock + "," + this._offset + "]";
        };
        return OffsetClock2;
      }(Clock);
      var ZoneOffsetTransition = function() {
        ZoneOffsetTransition2.of = function of(transition, offsetBefore, offsetAfter) {
          return new ZoneOffsetTransition2(transition, offsetBefore, offsetAfter);
        };
        function ZoneOffsetTransition2(transition, offsetBefore, offsetAfter) {
          requireNonNull(transition, "transition");
          requireNonNull(offsetBefore, "offsetBefore");
          requireNonNull(offsetAfter, "offsetAfter");
          if (offsetBefore.equals(offsetAfter)) {
            throw new IllegalArgumentException("Offsets must not be equal");
          }
          if (transition.nano() !== 0) {
            throw new IllegalArgumentException("Nano-of-second must be zero");
          }
          if (transition instanceof LocalDateTime) {
            this._transition = transition;
          } else {
            this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
          }
          this._offsetBefore = offsetBefore;
          this._offsetAfter = offsetAfter;
        }
        var _proto = ZoneOffsetTransition2.prototype;
        _proto.instant = function instant() {
          return this._transition.toInstant(this._offsetBefore);
        };
        _proto.toEpochSecond = function toEpochSecond() {
          return this._transition.toEpochSecond(this._offsetBefore);
        };
        _proto.dateTimeBefore = function dateTimeBefore() {
          return this._transition;
        };
        _proto.dateTimeAfter = function dateTimeAfter() {
          return this._transition.plusSeconds(this.durationSeconds());
        };
        _proto.offsetBefore = function offsetBefore() {
          return this._offsetBefore;
        };
        _proto.offsetAfter = function offsetAfter() {
          return this._offsetAfter;
        };
        _proto.duration = function duration() {
          return Duration.ofSeconds(this.durationSeconds());
        };
        _proto.durationSeconds = function durationSeconds() {
          return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
        };
        _proto.isGap = function isGap() {
          return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
        };
        _proto.isOverlap = function isOverlap() {
          return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
        };
        _proto.isValidOffset = function isValidOffset(offset) {
          return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
        };
        _proto.validOffsets = function validOffsets() {
          if (this.isGap()) {
            return [];
          } else {
            return [this._offsetBefore, this._offsetAfter];
          }
        };
        _proto.compareTo = function compareTo(transition) {
          return this.instant().compareTo(transition.instant());
        };
        _proto.equals = function equals(other) {
          if (other === this) {
            return true;
          }
          if (other instanceof ZoneOffsetTransition2) {
            var d = other;
            return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
          }
          return false;
        };
        _proto.hashCode = function hashCode() {
          return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
        };
        _proto.toString = function toString() {
          return "Transition[" + (this.isGap() ? "Gap" : "Overlap") + " at " + this._transition.toString() + this._offsetBefore.toString() + " to " + this._offsetAfter + "]";
        };
        return ZoneOffsetTransition2;
      }();
      function _init$1() {
        TemporalQueries.ZONE_ID = createTemporalQuery("ZONE_ID", function(temporal) {
          return temporal.query(TemporalQueries.ZONE_ID);
        });
        TemporalQueries.CHRONO = createTemporalQuery("CHRONO", function(temporal) {
          return temporal.query(TemporalQueries.CHRONO);
        });
        TemporalQueries.PRECISION = createTemporalQuery("PRECISION", function(temporal) {
          return temporal.query(TemporalQueries.PRECISION);
        });
        TemporalQueries.OFFSET = createTemporalQuery("OFFSET", function(temporal) {
          if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
            return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
          }
          return null;
        });
        TemporalQueries.ZONE = createTemporalQuery("ZONE", function(temporal) {
          var zone = temporal.query(TemporalQueries.ZONE_ID);
          return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
        });
        TemporalQueries.LOCAL_DATE = createTemporalQuery("LOCAL_DATE", function(temporal) {
          if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
            return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
          }
          return null;
        });
        TemporalQueries.LOCAL_TIME = createTemporalQuery("LOCAL_TIME", function(temporal) {
          if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
            return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
          }
          return null;
        });
      }
      var SystemDefaultZoneRules = function(_ZoneRules) {
        _inheritsLoose(SystemDefaultZoneRules2, _ZoneRules);
        function SystemDefaultZoneRules2() {
          return _ZoneRules.apply(this, arguments) || this;
        }
        var _proto = SystemDefaultZoneRules2.prototype;
        _proto.isFixedOffset = function isFixedOffset() {
          return false;
        };
        _proto.offsetOfInstant = function offsetOfInstant(instant) {
          var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
          return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
        };
        _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
          var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
          return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
        };
        _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
          var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1e3;
          var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
          var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 6e4;
          var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
          return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
        };
        _proto.validOffsets = function validOffsets(localDateTime) {
          return [this.offsetOfLocalDateTime(localDateTime)];
        };
        _proto.transition = function transition() {
          return null;
        };
        _proto.standardOffset = function standardOffset(instant) {
          return this.offsetOfInstant(instant);
        };
        _proto.daylightSavings = function daylightSavings() {
          this._throwNotSupported();
        };
        _proto.isDaylightSavings = function isDaylightSavings() {
          this._throwNotSupported();
        };
        _proto.isValidOffset = function isValidOffset(dateTime, offset) {
          return this.offsetOfLocalDateTime(dateTime).equals(offset);
        };
        _proto.nextTransition = function nextTransition() {
          this._throwNotSupported();
        };
        _proto.previousTransition = function previousTransition() {
          this._throwNotSupported();
        };
        _proto.transitions = function transitions() {
          this._throwNotSupported();
        };
        _proto.transitionRules = function transitionRules() {
          this._throwNotSupported();
        };
        _proto._throwNotSupported = function _throwNotSupported() {
          throw new DateTimeException("not supported operation");
        };
        _proto.equals = function equals(other) {
          if (this === other || other instanceof SystemDefaultZoneRules2) {
            return true;
          } else {
            return false;
          }
        };
        _proto.toString = function toString() {
          return "SYSTEM";
        };
        return SystemDefaultZoneRules2;
      }(ZoneRules);
      var SystemDefaultZoneId = function(_ZoneId) {
        _inheritsLoose(SystemDefaultZoneId2, _ZoneId);
        function SystemDefaultZoneId2() {
          var _this;
          _this = _ZoneId.call(this) || this;
          _this._rules = new SystemDefaultZoneRules();
          return _this;
        }
        var _proto = SystemDefaultZoneId2.prototype;
        _proto.rules = function rules() {
          return this._rules;
        };
        _proto.equals = function equals(other) {
          if (this === other) {
            return true;
          }
          return false;
        };
        _proto.id = function id() {
          return "SYSTEM";
        };
        return SystemDefaultZoneId2;
      }(ZoneId);
      var ZoneIdFactory = function() {
        function ZoneIdFactory2() {
        }
        ZoneIdFactory2.systemDefault = function systemDefault() {
          return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
        };
        ZoneIdFactory2.getAvailableZoneIds = function getAvailableZoneIds() {
          return ZoneRulesProvider.getAvailableZoneIds();
        };
        ZoneIdFactory2.of = function of(zoneId) {
          requireNonNull(zoneId, "zoneId");
          if (zoneId === "Z") {
            return ZoneOffset.UTC;
          }
          if (zoneId.length === 1) {
            throw new DateTimeException("Invalid zone: " + zoneId);
          }
          if (StringUtil.startsWith(zoneId, "+") || StringUtil.startsWith(zoneId, "-")) {
            return ZoneOffset.of(zoneId);
          }
          if (zoneId === "UTC" || zoneId === "GMT" || zoneId === "GMT0" || zoneId === "UT") {
            return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
          }
          if (StringUtil.startsWith(zoneId, "UTC+") || StringUtil.startsWith(zoneId, "GMT+") || StringUtil.startsWith(zoneId, "UTC-") || StringUtil.startsWith(zoneId, "GMT-")) {
            var offset = ZoneOffset.of(zoneId.substring(3));
            if (offset.totalSeconds() === 0) {
              return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
            }
            return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
          }
          if (StringUtil.startsWith(zoneId, "UT+") || StringUtil.startsWith(zoneId, "UT-")) {
            var _offset = ZoneOffset.of(zoneId.substring(2));
            if (_offset.totalSeconds() === 0) {
              return new ZoneRegion("UT", _offset.rules());
            }
            return new ZoneRegion("UT" + _offset.id(), _offset.rules());
          }
          if (zoneId === "SYSTEM") {
            return ZoneId.systemDefault();
          }
          return ZoneRegion.ofId(zoneId);
        };
        ZoneIdFactory2.ofOffset = function ofOffset(prefix, offset) {
          requireNonNull(prefix, "prefix");
          requireNonNull(offset, "offset");
          if (prefix.length === 0) {
            return offset;
          }
          if (prefix === "GMT" || prefix === "UTC" || prefix === "UT") {
            if (offset.totalSeconds() === 0) {
              return new ZoneRegion(prefix, offset.rules());
            }
            return new ZoneRegion(prefix + offset.id(), offset.rules());
          }
          throw new IllegalArgumentException("Invalid prefix, must be GMT, UTC or UT: " + prefix);
        };
        ZoneIdFactory2.from = function from(temporal) {
          requireNonNull(temporal, "temporal");
          var obj = temporal.query(TemporalQueries.zone());
          if (obj == null) {
            throw new DateTimeException("Unable to obtain ZoneId from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
          }
          return obj;
        };
        return ZoneIdFactory2;
      }();
      var SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;
      function _init() {
        SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();
        ZoneId.systemDefault = ZoneIdFactory.systemDefault;
        ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
        ZoneId.of = ZoneIdFactory.of;
        ZoneId.ofOffset = ZoneIdFactory.ofOffset;
        ZoneId.from = ZoneIdFactory.from;
        ZoneOffset.from = ZoneIdFactory.from;
        ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
        ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
      }
      var isInit = false;
      function init() {
        if (isInit) {
          return;
        }
        isInit = true;
        _init$m();
        _init$n();
        _init$l();
        _init$k();
        _init$3();
        _init$f();
        _init$1();
        _init$j();
        _init$2();
        _init$5();
        _init$4();
        _init$a();
        _init$i();
        _init$b();
        _init$c();
        _init$h();
        _init$g();
        _init$7();
        _init();
        _init$9();
        _init$d();
        _init$e();
        _init$6();
        _init$8();
      }
      init();
      var ToNativeJsConverter = function() {
        function ToNativeJsConverter2(temporal, zone) {
          var zonedDateTime;
          if (temporal instanceof Instant) {
            this.instant = temporal;
            return;
          } else if (temporal instanceof LocalDate) {
            zone = zone == null ? ZoneId.systemDefault() : zone;
            zonedDateTime = temporal.atStartOfDay(zone);
          } else if (temporal instanceof LocalDateTime) {
            zone = zone == null ? ZoneId.systemDefault() : zone;
            zonedDateTime = temporal.atZone(zone);
          } else if (temporal instanceof ZonedDateTime) {
            if (zone == null) {
              zonedDateTime = temporal;
            } else {
              zonedDateTime = temporal.withZoneSameInstant(zone);
            }
          } else {
            throw new IllegalArgumentException("unsupported instance for convert operation:" + temporal);
          }
          this.instant = zonedDateTime.toInstant();
        }
        var _proto = ToNativeJsConverter2.prototype;
        _proto.toDate = function toDate() {
          return new Date(this.instant.toEpochMilli());
        };
        _proto.toEpochMilli = function toEpochMilli() {
          return this.instant.toEpochMilli();
        };
        return ToNativeJsConverter2;
      }();
      function convert(temporal, zone) {
        return new ToNativeJsConverter(temporal, zone);
      }
      function nativeJs(date, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        requireNonNull(date, "date");
        requireNonNull(zone, "zone");
        if (date instanceof Date) {
          return Instant.ofEpochMilli(date.getTime()).atZone(zone);
        } else if (typeof date.toDate === "function" && date.toDate() instanceof Date) {
          return Instant.ofEpochMilli(date.toDate().getTime()).atZone(zone);
        }
        throw new IllegalArgumentException("date must be a javascript Date or a moment instance");
      }
      function bindUse(jsJoda) {
        var used = [];
        return function use2(fn) {
          if (!~used.indexOf(fn)) {
            fn(jsJoda);
            used.push(fn);
          }
          return jsJoda;
        };
      }
      var _ = {
        assert: assert$1,
        DateTimeBuilder,
        DateTimeParseContext,
        DateTimePrintContext,
        MathUtil,
        StringUtil,
        StringBuilder
      };
      var jsJodaExports = {
        _,
        convert,
        nativeJs,
        ArithmeticException,
        DateTimeException,
        DateTimeParseException,
        IllegalArgumentException,
        IllegalStateException,
        UnsupportedTemporalTypeException,
        NullPointerException,
        Clock,
        DayOfWeek,
        Duration,
        Instant,
        LocalDate,
        LocalTime,
        LocalDateTime,
        OffsetTime,
        OffsetDateTime,
        Month,
        MonthDay,
        ParsePosition,
        Period,
        Year,
        YearConstants,
        YearMonth,
        ZonedDateTime,
        ZoneOffset,
        ZoneId,
        ZoneRegion,
        ZoneOffsetTransition,
        ZoneRules,
        ZoneRulesProvider,
        ChronoLocalDate,
        ChronoLocalDateTime,
        ChronoZonedDateTime,
        IsoChronology,
        ChronoField,
        ChronoUnit,
        IsoFields,
        Temporal,
        TemporalAccessor,
        TemporalAdjuster,
        TemporalAdjusters,
        TemporalAmount,
        TemporalField,
        TemporalQueries,
        TemporalQuery,
        TemporalUnit,
        ValueRange,
        DateTimeFormatter,
        DateTimeFormatterBuilder,
        DecimalStyle,
        ResolverStyle,
        SignStyle,
        TextStyle
      };
      var use = bindUse(jsJodaExports);
      jsJodaExports.use = use;
      exports3.ArithmeticException = ArithmeticException;
      exports3.ChronoField = ChronoField;
      exports3.ChronoLocalDate = ChronoLocalDate;
      exports3.ChronoLocalDateTime = ChronoLocalDateTime;
      exports3.ChronoUnit = ChronoUnit;
      exports3.ChronoZonedDateTime = ChronoZonedDateTime;
      exports3.Clock = Clock;
      exports3.DateTimeException = DateTimeException;
      exports3.DateTimeFormatter = DateTimeFormatter;
      exports3.DateTimeFormatterBuilder = DateTimeFormatterBuilder;
      exports3.DateTimeParseException = DateTimeParseException;
      exports3.DayOfWeek = DayOfWeek;
      exports3.DecimalStyle = DecimalStyle;
      exports3.Duration = Duration;
      exports3.IllegalArgumentException = IllegalArgumentException;
      exports3.IllegalStateException = IllegalStateException;
      exports3.Instant = Instant;
      exports3.IsoChronology = IsoChronology;
      exports3.IsoFields = IsoFields;
      exports3.LocalDate = LocalDate;
      exports3.LocalDateTime = LocalDateTime;
      exports3.LocalTime = LocalTime;
      exports3.Month = Month;
      exports3.MonthDay = MonthDay;
      exports3.NullPointerException = NullPointerException;
      exports3.OffsetDateTime = OffsetDateTime;
      exports3.OffsetTime = OffsetTime;
      exports3.ParsePosition = ParsePosition;
      exports3.Period = Period;
      exports3.ResolverStyle = ResolverStyle;
      exports3.SignStyle = SignStyle;
      exports3.Temporal = Temporal;
      exports3.TemporalAccessor = TemporalAccessor;
      exports3.TemporalAdjuster = TemporalAdjuster;
      exports3.TemporalAdjusters = TemporalAdjusters;
      exports3.TemporalAmount = TemporalAmount;
      exports3.TemporalField = TemporalField;
      exports3.TemporalQueries = TemporalQueries;
      exports3.TemporalQuery = TemporalQuery;
      exports3.TemporalUnit = TemporalUnit;
      exports3.TextStyle = TextStyle;
      exports3.UnsupportedTemporalTypeException = UnsupportedTemporalTypeException;
      exports3.ValueRange = ValueRange;
      exports3.Year = Year;
      exports3.YearConstants = YearConstants;
      exports3.YearMonth = YearMonth;
      exports3.ZoneId = ZoneId;
      exports3.ZoneOffset = ZoneOffset;
      exports3.ZoneOffsetTransition = ZoneOffsetTransition;
      exports3.ZoneRegion = ZoneRegion;
      exports3.ZoneRules = ZoneRules;
      exports3.ZoneRulesProvider = ZoneRulesProvider;
      exports3.ZonedDateTime = ZonedDateTime;
      exports3._ = _;
      exports3.convert = convert;
      exports3.nativeJs = nativeJs;
      exports3.use = use;
    });
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/datetime.js
var require_datetime = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/datetime.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _core = require_js_joda();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1900, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var DateTime = {
      id: 61,
      type: "DATETIME",
      name: "DateTime",
      declaration: function() {
        return "datetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        let days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        let milliseconds, threeHundredthsOfSecond;
        if (options.useUTC) {
          let seconds = value.getUTCHours() * 60 * 60;
          seconds += value.getUTCMinutes() * 60;
          seconds += value.getUTCSeconds();
          milliseconds = seconds * 1e3 + value.getUTCMilliseconds();
        } else {
          let seconds = value.getHours() * 60 * 60;
          seconds += value.getMinutes() * 60;
          seconds += value.getSeconds();
          milliseconds = seconds * 1e3 + value.getMilliseconds();
        }
        threeHundredthsOfSecond = milliseconds / (3 + 1 / 3);
        threeHundredthsOfSecond = Math.round(threeHundredthsOfSecond);
        if (threeHundredthsOfSecond === 2592e4) {
          days += 1;
          threeHundredthsOfSecond = 0;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(days, 0);
        buffer.writeUInt32LE(threeHundredthsOfSecond, 4);
        yield buffer;
      },
      // TODO: type 'any' needs to be revisited.
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1753 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = DateTime;
    module2.exports = DateTime;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/float.js
var require_float = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/float.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Float = {
      id: 62,
      type: "FLT8",
      name: "Float",
      declaration: function() {
        return "float";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return Buffer.from([8]);
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeDoubleLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports2.default = Float;
    module2.exports = Float;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/decimaln.js
var require_decimaln = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/decimaln.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var DecimalN = {
      id: 106,
      type: "DECIMALN",
      name: "DecimalN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = DecimalN;
    module2.exports = DecimalN;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/decimal.js
var require_decimal = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/decimal.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Decimal = {
      id: 55,
      type: "DECIMAL",
      name: "Decimal",
      declaration: function(parameter) {
        return "decimal(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter, _options) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_decimaln.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        const precision = parameter.precision;
        if (precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(9);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(13);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(17);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports2.default = Decimal;
    module2.exports = Decimal;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/numericn.js
var require_numericn = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/numericn.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NumericN = {
      id: 108,
      type: "NUMERICN",
      name: "NumericN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = NumericN;
    module2.exports = NumericN;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/numeric.js
var require_numeric = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/numeric.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _numericn = _interopRequireDefault(require_numericn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Numeric = {
      id: 63,
      type: "NUMERIC",
      name: "Numeric",
      declaration: function(parameter) {
        return "numeric(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_numericn.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        if (parameter.precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (parameter.precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(10);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (parameter.precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(14);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(18);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports2.default = Numeric;
    module2.exports = Numeric;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/smallmoney.js
var require_smallmoney = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/smallmoney.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallMoney = {
      id: 122,
      type: "MONEY4",
      name: "SmallMoney",
      declaration: function() {
        return "smallmoney";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value * 1e4, 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -214748.3648 || value > 214748.3647) {
          throw new TypeError("Value must be between -214748.3648 and 214748.3647.");
        }
        return value;
      }
    };
    var _default = exports2.default = SmallMoney;
    module2.exports = SmallMoney;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/bigint.js
var require_bigint = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/bigint.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([8]);
    var NULL_LENGTH = Buffer.from([0]);
    var MAX_SAFE_BIGINT = 9223372036854775807n;
    var MIN_SAFE_BIGINT = -9223372036854775808n;
    var BigInt10 = {
      id: 127,
      type: "INT8",
      name: "BigInt",
      declaration: function() {
        return "bigint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(8);
        buffer.writeBigInt64LE(typeof parameter.value === "bigint" ? parameter.value : globalThis.BigInt(parameter.value));
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "bigint") {
          value = globalThis.BigInt(value);
        }
        if (value < MIN_SAFE_BIGINT || value > MAX_SAFE_BIGINT) {
          throw new TypeError(`Value must be between ${MIN_SAFE_BIGINT} and ${MAX_SAFE_BIGINT}, inclusive.`);
        }
        return value;
      }
    };
    var _default = exports2.default = BigInt10;
    module2.exports = BigInt10;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/image.js
var require_image = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/image.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Image = {
      id: 34,
      type: "IMAGE",
      name: "Image",
      hasTableName: true,
      declaration: function() {
        return "image";
      },
      resolveLength: function(parameter) {
        if (parameter.value != null) {
          const value = parameter.value;
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(5);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports2.default = Image;
    module2.exports = Image;
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer3 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer3) {
      if (!Buffer3.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer3[key];
    }
    safer.Buffer.prototype = Buffer3.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer3(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer3(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// node_modules/mssql/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/lib/bom-handling.js"(exports2) {
    "use strict";
    var BOMChar = "\uFEFF";
    exports2.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports2.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res)
        return res;
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function")
          this.options.stripBOM();
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/internal.js
var require_internal4 = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/internal.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    module2.exports = {
      // Encodings
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      // Codec.
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
      else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer3.from("eda0bdedb2a9", "hex").toString() !== "\u{1F4A9}") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require("string_decoder").StringDecoder;
    if (!StringDecoder.prototype.end)
      StringDecoder.prototype.end = function() {
      };
    function InternalDecoder(options, codec) {
      this.decoder = new StringDecoder(codec.enc);
    }
    InternalDecoder.prototype.write = function(buf) {
      if (!Buffer3.isBuffer(buf)) {
        buf = Buffer3.from(buf);
      }
      return this.decoder.write(buf);
    };
    InternalDecoder.prototype.end = function() {
      return this.decoder.end();
    };
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer3.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer3.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer3.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer3.alloc(str.length * 3), bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128)
          buf[bufIdx++] = charCode;
        else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0)
                res += this.defaultCharUnicode;
              else if (accBytes === 3 && acc < 2048)
                res += this.defaultCharUnicode;
              else
                res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0)
        res += this.defaultCharUnicode;
      return res;
    };
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/utf32.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2._utf32 = Utf32Codec;
    function Utf32Codec(codecOptions, iconv) {
      this.iconv = iconv;
      this.bomAware = true;
      this.isLE = codecOptions.isLE;
    }
    exports2.utf32le = { type: "_utf32", isLE: true };
    exports2.utf32be = { type: "_utf32", isLE: false };
    exports2.ucs4le = "utf32le";
    exports2.ucs4be = "utf32be";
    Utf32Codec.prototype.encoder = Utf32Encoder;
    Utf32Codec.prototype.decoder = Utf32Decoder;
    function Utf32Encoder(options, codec) {
      this.isLE = codec.isLE;
      this.highSurrogate = 0;
    }
    Utf32Encoder.prototype.write = function(str) {
      var src = Buffer3.from(str, "ucs2");
      var dst = Buffer3.alloc(src.length * 2);
      var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
      var offset = 0;
      for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate = 55296 <= code && code < 56320;
        var isLowSurrogate = 56320 <= code && code < 57344;
        if (this.highSurrogate) {
          if (isHighSurrogate || !isLowSurrogate) {
            write32.call(dst, this.highSurrogate, offset);
            offset += 4;
          } else {
            var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
            write32.call(dst, codepoint, offset);
            offset += 4;
            this.highSurrogate = 0;
            continue;
          }
        }
        if (isHighSurrogate)
          this.highSurrogate = code;
        else {
          write32.call(dst, code, offset);
          offset += 4;
          this.highSurrogate = 0;
        }
      }
      if (offset < dst.length)
        dst = dst.slice(0, offset);
      return dst;
    };
    Utf32Encoder.prototype.end = function() {
      if (!this.highSurrogate)
        return;
      var buf = Buffer3.alloc(4);
      if (this.isLE)
        buf.writeUInt32LE(this.highSurrogate, 0);
      else
        buf.writeUInt32BE(this.highSurrogate, 0);
      this.highSurrogate = 0;
      return buf;
    };
    function Utf32Decoder(options, codec) {
      this.isLE = codec.isLE;
      this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
      this.overflow = [];
    }
    Utf32Decoder.prototype.write = function(src) {
      if (src.length === 0)
        return "";
      var i = 0;
      var codepoint = 0;
      var dst = Buffer3.alloc(src.length + 4);
      var offset = 0;
      var isLE = this.isLE;
      var overflow = this.overflow;
      var badChar = this.badChar;
      if (overflow.length > 0) {
        for (; i < src.length && overflow.length < 4; i++)
          overflow.push(src[i]);
        if (overflow.length === 4) {
          if (isLE) {
            codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
          } else {
            codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
          }
          overflow.length = 0;
          offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
      }
      for (; i < src.length - 3; i += 4) {
        if (isLE) {
          codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
        } else {
          codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
        }
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
      for (; i < src.length; i++) {
        overflow.push(src[i]);
      }
      return dst.slice(0, offset).toString("ucs2");
    };
    function _writeCodepoint(dst, offset, codepoint, badChar) {
      if (codepoint < 0 || codepoint > 1114111) {
        codepoint = badChar;
      }
      if (codepoint >= 65536) {
        codepoint -= 65536;
        var high = 55296 | codepoint >> 10;
        dst[offset++] = high & 255;
        dst[offset++] = high >> 8;
        var codepoint = 56320 | codepoint & 1023;
      }
      dst[offset++] = codepoint & 255;
      dst[offset++] = codepoint >> 8;
      return offset;
    }
    Utf32Decoder.prototype.end = function() {
      this.overflow.length = 0;
    };
    exports2.utf32 = Utf32AutoCodec;
    exports2.ucs4 = "utf32";
    function Utf32AutoCodec(options, iconv) {
      this.iconv = iconv;
    }
    Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
    Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
    function Utf32AutoEncoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
    }
    Utf32AutoEncoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf32AutoEncoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf32AutoDecoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf32AutoDecoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 32)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf32AutoDecoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var invalidLE = 0, invalidBE = 0;
      var bmpCharsLE = 0, bmpCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                  return "utf-32le";
                }
                if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                  return "utf-32be";
                }
              }
              if (b[0] !== 0 || b[1] > 16)
                invalidBE++;
              if (b[3] !== 0 || b[2] > 16)
                invalidLE++;
              if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0))
                bmpCharsBE++;
              if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0)
                bmpCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)
        return "utf-32be";
      if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)
        return "utf-32le";
      return defaultEncoding || "utf-32le";
    }
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/utf16.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer3.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0)
        return "";
      var buf2 = Buffer3.alloc(buf.length + 1), i = 0, j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
      this.overflowByte = -1;
    };
    exports2.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder("utf-16le", options);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 16)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var asciiCharsLE = 0, asciiCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254)
                  return "utf-16le";
                if (b[0] === 254 && b[1] === 255)
                  return "utf-16be";
              }
              if (b[0] === 0 && b[1] !== 0)
                asciiCharsBE++;
              if (b[0] !== 0 && b[1] === 0)
                asciiCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (asciiCharsBE > asciiCharsLE)
        return "utf-16be";
      if (asciiCharsBE < asciiCharsLE)
        return "utf-16le";
      return defaultEncoding || "utf-16le";
    }
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/utf7.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2.utf7 = Utf7Codec;
    exports2.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer3.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }.bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (i = 0; i < 256; i++)
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var i;
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
              res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer3.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports2.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer3.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer3.alloc(str.length * 5 + 10), bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (32 <= uChar && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar)
              buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer3.alloc(10), bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
              res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer3.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/sbcs-codec.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions)
        throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
          asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer3.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer3.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer3.alloc(str.length);
      for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer3.alloc(buf.length * 2);
      var idx1 = 0, idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/sbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Not supported by iconv, not sure why.
      "10029": "maccenteuro",
      "maccenteuro": {
        "type": "_sbcs",
        "chars": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
      },
      "808": "cp808",
      "ibm808": "cp808",
      "cp808": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\u20AC\u25A0\xA0"
      },
      "mik": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2514\u2534\u252C\u251C\u2500\u253C\u2563\u2551\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2510\u2591\u2592\u2593\u2502\u2524\u2116\xA7\u2557\u255D\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "cp720": {
        "type": "_sbcs",
        "chars": "\x80\x81\xE9\xE2\x84\xE0\x86\xE7\xEA\xEB\xE8\xEF\xEE\x8D\x8E\x8F\x90\u0651\u0652\xF4\xA4\u0640\xFB\xF9\u0621\u0622\u0623\u0624\xA3\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0636\u0637\u0638\u0639\u063A\u0641\xB5\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u2261\u064B\u064C\u064D\u064E\u064F\u0650\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      // Aliases of generated encodings.
      "ascii8bit": "ascii",
      "usascii": "ascii",
      "ansix34": "ascii",
      "ansix341968": "ascii",
      "ansix341986": "ascii",
      "csascii": "ascii",
      "cp367": "ascii",
      "ibm367": "ascii",
      "isoir6": "ascii",
      "iso646us": "ascii",
      "iso646irv": "ascii",
      "us": "ascii",
      "latin1": "iso88591",
      "latin2": "iso88592",
      "latin3": "iso88593",
      "latin4": "iso88594",
      "latin5": "iso88599",
      "latin6": "iso885910",
      "latin7": "iso885913",
      "latin8": "iso885914",
      "latin9": "iso885915",
      "latin10": "iso885916",
      "csisolatin1": "iso88591",
      "csisolatin2": "iso88592",
      "csisolatin3": "iso88593",
      "csisolatin4": "iso88594",
      "csisolatincyrillic": "iso88595",
      "csisolatinarabic": "iso88596",
      "csisolatingreek": "iso88597",
      "csisolatinhebrew": "iso88598",
      "csisolatin5": "iso88599",
      "csisolatin6": "iso885910",
      "l1": "iso88591",
      "l2": "iso88592",
      "l3": "iso88593",
      "l4": "iso88594",
      "l5": "iso88599",
      "l6": "iso885910",
      "l7": "iso885913",
      "l8": "iso885914",
      "l9": "iso885915",
      "l10": "iso885916",
      "isoir14": "iso646jp",
      "isoir57": "iso646cn",
      "isoir100": "iso88591",
      "isoir101": "iso88592",
      "isoir109": "iso88593",
      "isoir110": "iso88594",
      "isoir144": "iso88595",
      "isoir127": "iso88596",
      "isoir126": "iso88597",
      "isoir138": "iso88598",
      "isoir148": "iso88599",
      "isoir157": "iso885910",
      "isoir166": "tis620",
      "isoir179": "iso885913",
      "isoir199": "iso885914",
      "isoir203": "iso885915",
      "isoir226": "iso885916",
      "cp819": "iso88591",
      "ibm819": "iso88591",
      "cyrillic": "iso88595",
      "arabic": "iso88596",
      "arabic8": "iso88596",
      "ecma114": "iso88596",
      "asmo708": "iso88596",
      "greek": "iso88597",
      "greek8": "iso88597",
      "ecma118": "iso88597",
      "elot928": "iso88597",
      "hebrew": "iso88598",
      "hebrew8": "iso88598",
      "turkish": "iso88599",
      "turkish8": "iso88599",
      "thai": "iso885911",
      "thai8": "iso885911",
      "celtic": "iso885914",
      "celtic8": "iso885914",
      "isoceltic": "iso885914",
      "tis6200": "tis620",
      "tis62025291": "tis620",
      "tis62025330": "tis620",
      "10000": "macroman",
      "10006": "macgreek",
      "10007": "maccyrillic",
      "10079": "maciceland",
      "10081": "macturkish",
      "cspc8codepage437": "cp437",
      "cspc775baltic": "cp775",
      "cspc850multilingual": "cp850",
      "cspcp852": "cp852",
      "cspc862latinhebrew": "cp862",
      "cpgr": "cp869",
      "msee": "cp1250",
      "mscyrl": "cp1251",
      "msansi": "cp1252",
      "msgreek": "cp1253",
      "msturk": "cp1254",
      "mshebr": "cp1255",
      "msarab": "cp1256",
      "winbaltrim": "cp1257",
      "cp20866": "koi8r",
      "20866": "koi8r",
      "ibm878": "koi8r",
      "cskoi8r": "koi8r",
      "cp21866": "koi8u",
      "21866": "koi8u",
      "ibm1168": "koi8u",
      "strk10482002": "rk1048",
      "tcvn5712": "tcvn",
      "tcvn57121": "tcvn",
      "gb198880": "iso646cn",
      "cn": "iso646cn",
      "csiso14jisc6220ro": "iso646jp",
      "jisc62201969ro": "iso646jp",
      "jp": "iso646jp",
      "cshproman8": "hproman8",
      "r8": "hproman8",
      "roman8": "hproman8",
      "xroman8": "hproman8",
      "ibm1051": "hproman8",
      "mac": "macintosh",
      "csmacintosh": "macintosh"
    };
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\uFFFD\uFFFD\uFFFD\u2026\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A\xA0\u02C7\u02D8\u0141\xA4\u0104\xA6\xA7\xA8\xA9\u015E\xAB\xAC\xAD\xAE\u017B\xB0\xB1\u02DB\u0142\xB4\xB5\xB6\xB7\xB8\u0105\u015F\xBB\u013D\u02DD\u013E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F\xA0\u040E\u045E\u0408\xA4\u0490\xA6\xA7\u0401\xA9\u0404\xAB\xAC\xAD\xAE\u0407\xB0\xB1\u0406\u0456\u0491\xB5\xB6\xB7\u0451\u2116\u0454\xBB\u0458\u0405\u0455\u0457\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0385\u0386\xA3\xA4\xA5\xA6\xA7\xA8\xA9\uFFFD\xAB\xAC\xAD\xAE\u2015\xB0\xB1\xB2\xB3\u0384\xB5\xB6\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\xA1\xA2\xA3\u20AA\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\xBF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BE\u05BF\u05C0\u05C1\u05C2\u05C3\u05F0\u05F1\u05F2\u05F3\u05F4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": "\u20AC\u067E\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0679\u2039\u0152\u0686\u0698\u0688\u06AF\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u06A9\u2122\u0691\u203A\u0153\u200C\u200D\u06BA\xA0\u060C\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\u06BE\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\u061B\xBB\xBC\xBD\xBE\u061F\u06C1\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\xD7\u0637\u0638\u0639\u063A\u0640\u0641\u0642\u0643\xE0\u0644\xE2\u0645\u0646\u0647\u0648\xE7\xE8\xE9\xEA\xEB\u0649\u064A\xEE\xEF\u064B\u064C\u064D\u064E\xF4\u064F\u0650\xF7\u0651\xF9\u0652\xFB\xFC\u200E\u200F\u06D2"
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\xA8\u02C7\xB8\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\xAF\u02DB\uFFFD\xA0\uFFFD\xA2\xA3\xA4\uFFFD\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u02D9"
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u02D8\u0141\xA4\u013D\u015A\xA7\xA8\u0160\u015E\u0164\u0179\xAD\u017D\u017B\xB0\u0105\u02DB\u0142\xB4\u013E\u015B\u02C7\xB8\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0126\u02D8\xA3\xA4\uFFFD\u0124\xA7\xA8\u0130\u015E\u011E\u0134\xAD\uFFFD\u017B\xB0\u0127\xB2\xB3\xB4\xB5\u0125\xB7\xB8\u0131\u015F\u011F\u0135\xBD\uFFFD\u017C\xC0\xC1\xC2\uFFFD\xC4\u010A\u0108\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\uFFFD\xD1\xD2\xD3\xD4\u0120\xD6\xD7\u011C\xD9\xDA\xDB\xDC\u016C\u015C\xDF\xE0\xE1\xE2\uFFFD\xE4\u010B\u0109\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\uFFFD\xF1\xF2\xF3\xF4\u0121\xF6\xF7\u011D\xF9\xFA\xFB\xFC\u016D\u015D\u02D9"
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0138\u0156\xA4\u0128\u013B\xA7\xA8\u0160\u0112\u0122\u0166\xAD\u017D\xAF\xB0\u0105\u02DB\u0157\xB4\u0129\u013C\u02C7\xB8\u0161\u0113\u0123\u0167\u014A\u017E\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\u012A\u0110\u0145\u014C\u0136\xD4\xD5\xD6\xD7\xD8\u0172\xDA\xDB\xDC\u0168\u016A\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\u012B\u0111\u0146\u014D\u0137\xF4\xF5\xF6\xF7\xF8\u0173\xFA\xFB\xFC\u0169\u016B\u02D9"
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\uFFFD\uFFFD\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u060C\xAD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u061B\uFFFD\uFFFD\uFFFD\u061F\uFFFD\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u2018\u2019\xA3\u20AC\u20AF\xA6\xA7\xA8\xA9\u037A\xAB\xAC\xAD\uFFFD\u2015\xB0\xB1\xB2\xB3\u0384\u0385\u0386\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2017\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0112\u0122\u012A\u0128\u0136\xA7\u013B\u0110\u0160\u0166\u017D\xAD\u016A\u014A\xB0\u0105\u0113\u0123\u012B\u0129\u0137\xB7\u013C\u0111\u0161\u0167\u017E\u2015\u016B\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\xCF\xD0\u0145\u014C\xD3\xD4\xD5\xD6\u0168\xD8\u0172\xDA\xDB\xDC\xDD\xDE\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\xEF\xF0\u0146\u014D\xF3\xF4\xF5\xF6\u0169\xF8\u0173\xFA\xFB\xFC\xFD\xFE\u0138"
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u201D\xA2\xA3\xA4\u201E\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\u201C\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u2019"
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u1E02\u1E03\xA3\u010A\u010B\u1E0A\xA7\u1E80\xA9\u1E82\u1E0B\u1EF2\xAD\xAE\u0178\u1E1E\u1E1F\u0120\u0121\u1E40\u1E41\xB6\u1E56\u1E81\u1E57\u1E83\u1E60\u1EF3\u1E84\u1E85\u1E61\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0174\xD1\xD2\xD3\xD4\xD5\xD6\u1E6A\xD8\xD9\xDA\xDB\xDC\xDD\u0176\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0175\xF1\xF2\xF3\xF4\xF5\xF6\u1E6B\xF8\xF9\xFA\xFB\xFC\xFD\u0177\xFF"
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\u0160\xA7\u0161\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u017D\xB5\xB6\xB7\u017E\xB9\xBA\xBB\u0152\u0153\u0178\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0105\u0141\u20AC\u201E\u0160\xA7\u0161\xA9\u0218\xAB\u0179\xAD\u017A\u017B\xB0\xB1\u010C\u0142\u017D\u201D\xB6\xB7\u017E\u010D\u0219\xBB\u0152\u0153\u0178\u017C\xC0\xC1\xC2\u0102\xC4\u0106\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0110\u0143\xD2\xD3\xD4\u0150\xD6\u015A\u0170\xD9\xDA\xDB\xDC\u0118\u021A\xDF\xE0\xE1\xE2\u0103\xE4\u0107\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0111\u0144\xF2\xF3\xF4\u0151\xF6\u015B\u0171\xF9\xFA\xFB\xFC\u0119\u021B\xFF"
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": "\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u03C5\u03C6\u03C7\u03C8\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03C9\u03AC\u03AD\u03AE\u03CA\u03AF\u03CC\u03CD\u03CB\u03CE\u0386\u0388\u0389\u038A\u038C\u038E\u038F\xB1\u2265\u2264\u03AA\u03AB\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": "\u0106\xFC\xE9\u0101\xE4\u0123\xE5\u0107\u0142\u0113\u0156\u0157\u012B\u0179\xC4\xC5\xC9\xE6\xC6\u014D\xF6\u0122\xA2\u015A\u015B\xD6\xDC\xF8\xA3\xD8\xD7\xA4\u0100\u012A\xF3\u017B\u017C\u017A\u201D\xA6\xA9\xAE\xAC\xBD\xBC\u0141\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0104\u010C\u0118\u0116\u2563\u2551\u2557\u255D\u012E\u0160\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0172\u016A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u017D\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u2518\u250C\u2588\u2584\u258C\u2590\u2580\xD3\xDF\u014C\u0143\xF5\xD5\xB5\u0144\u0136\u0137\u013B\u013C\u0146\u0112\u0145\u2019\xAD\xB1\u201C\xBE\xB6\xA7\xF7\u201E\xB0\u2219\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u0131\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\u016F\u0107\xE7\u0142\xEB\u0150\u0151\xEE\u0179\xC4\u0106\xC9\u0139\u013A\xF4\xF6\u013D\u013E\u015A\u015B\xD6\xDC\u0164\u0165\u0141\xD7\u010D\xE1\xED\xF3\xFA\u0104\u0105\u017D\u017E\u0118\u0119\xAC\u017A\u010C\u015F\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\u011A\u015E\u2563\u2551\u2557\u255D\u017B\u017C\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0102\u0103\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u0111\u0110\u010E\xCB\u010F\u0147\xCD\xCE\u011B\u2518\u250C\u2588\u2584\u0162\u016E\u2580\xD3\xDF\xD4\u0143\u0144\u0148\u0160\u0161\u0154\xDA\u0155\u0170\xFD\xDD\u0163\xB4\xAD\u02DD\u02DB\u02C7\u02D8\xA7\xF7\xB8\xB0\xA8\u02D9\u0171\u0158\u0159\u25A0\xA0"
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": "\u0452\u0402\u0453\u0403\u0451\u0401\u0454\u0404\u0455\u0405\u0456\u0406\u0457\u0407\u0458\u0408\u0459\u0409\u045A\u040A\u045B\u040B\u045C\u040C\u045E\u040E\u045F\u040F\u044E\u042E\u044A\u042A\u0430\u0410\u0431\u0411\u0446\u0426\u0434\u0414\u0435\u0415\u0444\u0424\u0433\u0413\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0445\u0425\u0438\u0418\u2563\u2551\u2557\u255D\u0439\u0419\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u043A\u041A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u043B\u041B\u043C\u041C\u043D\u041D\u043E\u041E\u043F\u2518\u250C\u2588\u2584\u041F\u044F\u2580\u042F\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0436\u0416\u0432\u0412\u044C\u042C\u2116\xAD\u044B\u042B\u0437\u0417\u0448\u0428\u044D\u042D\u0449\u0429\u0447\u0427\xA7\u25A0\xA0"
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\xA3\uFFFD\xD7\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAE\xAC\xBD\xBC\uFFFD\xAB\xBB\u2591\u2592\u2593\u2502\u2524\uFFFD\uFFFD\uFFFD\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\uFFFD\uFFFD\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2518\u250C\u2588\u2584\xA6\uFFFD\u2580\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xB5\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\u0131\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\u0130\xD6\xDC\xF8\xA3\xD8\u015E\u015F\xE1\xED\xF3\xFA\xF1\xD1\u011E\u011F\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xBA\xAA\xCA\xCB\xC8\uFFFD\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\uFFFD\xD7\xDA\xDB\xD9\xEC\xFF\xAF\xB4\xAD\xB1\uFFFD\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u20AC\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE3\xE0\xC1\xE7\xEA\xCA\xE8\xCD\xD4\xEC\xC3\xC2\xC9\xC0\xC8\xF4\xF5\xF2\xDA\xF9\xCC\xD5\xDC\xA2\xA3\xD9\u20A7\xD3\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xD2\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xD0\xF0\xDE\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xFE\xFB\xDD\xFD\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xC1\xCD\xD3\xDA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xC2\xE0\xB6\xE7\xEA\xEB\xE8\xEF\xEE\u2017\xC0\xA7\xC9\xC8\xCA\xF4\xCB\xCF\xFB\xF9\xA4\xD4\xDC\xA2\xA3\xD9\xDB\u0192\xA6\xB4\xF3\xFA\xA8\xB8\xB3\xAF\xCE\u2310\xAC\xBD\xBC\xBE\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xA4\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0386\uFFFD\xB7\xAC\xA6\u2018\u2019\u0388\u2015\u0389\u038A\u03AA\u038C\uFFFD\uFFFD\u038E\u03AB\xA9\u038F\xB2\xB3\u03AC\xA3\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03CD\u0391\u0392\u0393\u0394\u0395\u0396\u0397\xBD\u0398\u0399\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u039A\u039B\u039C\u039D\u2563\u2551\u2557\u255D\u039E\u039F\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u03A0\u03A1\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u2518\u250C\u2588\u2584\u03B4\u03B5\u2580\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u0384\xAD\xB1\u03C5\u03C6\u03C7\xA7\u03C8\u0385\xB0\xA8\u03C9\u03CB\u03B0\u03CE\u25A0\xA0"
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\u203E\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0160\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\u017D\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0161\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\u017E\xFF"
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": "\uFE88\xD7\xF7\uF8F6\uF8F5\uF8F4\uF8F7\uFE71\x88\u25A0\u2502\u2500\u2510\u250C\u2514\u2518\uFE79\uFE7B\uFE7D\uFE7F\uFE77\uFE8A\uFEF0\uFEF3\uFEF2\uFECE\uFECF\uFED0\uFEF6\uFEF8\uFEFA\uFEFC\xA0\uF8FA\uF8F9\uF8F8\xA4\uF8FB\uFE8B\uFE91\uFE97\uFE9B\uFE9F\uFEA3\u060C\xAD\uFEA7\uFEB3\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFEB7\u061B\uFEBB\uFEBF\uFECA\u061F\uFECB\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\uFEC7\u0639\u063A\uFECC\uFE82\uFE84\uFE8E\uFED3\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFED7\uFEDB\uFEDF\uF8FC\uFEF5\uFEF7\uFEF9\uFEFB\uFEE3\uFEE7\uFEEC\uFEE9\uFFFD"
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0490\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0491\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0490\u0491\u0404\u0454\u0406\u0456\u0407\u0457\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E81\u0E82\u0E84\u0E87\u0E88\u0EAA\u0E8A\u0E8D\u0E94\u0E95\u0E96\u0E97\u0E99\u0E9A\u0E9B\u0E9C\u0E9D\u0E9E\u0E9F\u0EA1\u0EA2\u0EA3\u0EA5\u0EA7\u0EAB\u0EAD\u0EAE\uFFFD\uFFFD\uFFFD\u0EAF\u0EB0\u0EB2\u0EB3\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBC\u0EB1\u0EBB\u0EBD\uFFFD\uFFFD\uFFFD\u0EC0\u0EC1\u0EC2\u0EC3\u0EC4\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0EC6\uFFFD\u0EDC\u0EDD\u20AD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\uFFFD\uFFFD\xA2\xAC\xA6\uFFFD"
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E48\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E49\u0E4A\u0E4B\u20AC\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\xA2\xAC\xA6\xA0"
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": "\u20AC\x81\x82\x83\x84\u2026\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u2126\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uFFFD\xA9\u2044\xA4\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\xA2\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u2202\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\xAD\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\u0387\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\uFFFD"
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macroman": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macromania": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u015E\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\u0103\u015F\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\u0162\u0163\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "\xAB\xBB\u2026\uF88C\uF88F\uF892\uF895\uF898\uF88B\uF88E\uF891\uF894\uF897\u201C\u201D\uF899\uFFFD\u2022\uF884\uF889\uF885\uF886\uF887\uF888\uF88A\uF88D\uF890\uF893\uF896\u2018\u2019\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFEFF\u200B\u2013\u2014\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u2122\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\xAE\xA9\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\uFFFD\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u0401\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u255D\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u045E\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u040E\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": "\u049B\u0493\u201A\u0492\u201E\u2026\u2020\u2021\uFFFD\u2030\u04B3\u2039\u04B2\u04B7\u04B6\uFFFD\u049A\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u04EF\u04EE\u0451\xA4\u04E3\xA6\xA7\uFFFD\uFFFD\uFFFD\xAB\xAC\xAD\xAE\uFFFD\xB0\xB1\xB2\u0401\uFFFD\u04E2\xB6\xB7\uFFFD\u2116\uFFFD\xBB\uFFFD\uFFFD\uFFFD\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\u0587\u0589)(\xBB\xAB\u2014.\u055D,-\u058A\u2026\u055C\u055B\u055E\u0531\u0561\u0532\u0562\u0533\u0563\u0534\u0564\u0535\u0565\u0536\u0566\u0537\u0567\u0538\u0568\u0539\u0569\u053A\u056A\u053B\u056B\u053C\u056C\u053D\u056D\u053E\u056E\u053F\u056F\u0540\u0570\u0541\u0571\u0542\u0572\u0543\u0573\u0544\u0574\u0545\u0575\u0546\u0576\u0547\u0577\u0548\u0578\u0549\u0579\u054A\u057A\u054B\u057B\u054C\u057C\u054D\u057D\u054E\u057E\u054F\u057F\u0550\u0580\u0551\u0581\u0552\u0582\u0553\u0583\u0554\u0584\u0555\u0585\u0556\u0586\u055A\uFFFD"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u049A\u04BA\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u049B\u04BB\u045F\xA0\u04B0\u04B1\u04D8\xA4\u04E8\xA6\xA7\u0401\xA9\u0492\xAB\xAC\xAD\xAE\u04AE\xB0\xB1\u0406\u0456\u04E9\xB5\xB6\xB7\u0451\u2116\u0493\xBB\u04D9\u04A2\u04A3\u04AF\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0\xDA\u1EE4\u1EEA\u1EEC\u1EEE\x07\b	\n\v\f\r\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10EF\u10F0\u10F1\u10F2\u10F3\u10F4\u10F5\u10F6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10F1\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10F2\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10F3\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10F4\u10EF\u10F0\u10F5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "pt154": {
        "type": "_sbcs",
        "chars": "\u0496\u0492\u04EE\u0493\u201E\u2026\u04B6\u04AE\u04B2\u04AF\u04A0\u04E2\u04A2\u049A\u04BA\u04B8\u0497\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u04B3\u04B7\u04A1\u04E3\u04A3\u049B\u04BB\u04B9\xA0\u040E\u045E\u0408\u04E8\u0498\u04B0\xA7\u0401\xA9\u04D8\xAB\xAC\u04EF\xAE\u049C\xB0\u04B1\u0406\u0456\u0499\u04E9\xB6\xB7\u0451\u2116\u04D9\xBB\u0458\u04AA\u04AB\u049D\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0\u1EB2\u1EB4\u1EAA\x07\b	\n\v\f\r\u1EF6\u1EF8\x1B\u1EF4 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xC0\xC2\xC8\xCA\xCB\xCE\xCF\xB4\u02CB\u02C6\xA8\u02DC\xD9\xDB\u20A4\xAF\xDD\xFD\xB0\xC7\xE7\xD1\xF1\xA1\xBF\xA4\xA3\xA5\xA7\u0192\xA2\xE2\xEA\xF4\xFB\xE1\xE9\xF3\xFA\xE0\xE8\xF2\xF9\xE4\xEB\xF6\xFC\xC5\xEE\xD8\xC6\xE5\xED\xF8\xE6\xC4\xEC\xD6\xDC\xC9\xEF\xDF\xD4\xC1\xC3\xE3\xD0\xF0\xCD\xCC\xD3\xD2\xD5\xF5\u0160\u0161\xDA\u0178\xFF\xDE\xFE\xB7\xB5\xB6\xBE\u2014\xBC\xBD\xAA\xBA\xAB\u25A0\xBB\xB1\uFFFD"
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "ascii": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "tis620": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      }
    };
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/dbcs-codec.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (i = 0; i < 256; i++)
      UNASSIGNED_NODE[i] = UNASSIGNED;
    var i;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions)
        throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++)
        this._addDecodeChunk(mappingTable[i2]);
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var firstByteNode = this.decodeTables[0];
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
          for (var j = 48; j <= 57; j++) {
            if (secondByteNode[j] === UNASSIGNED) {
              secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
            } else if (secondByteNode[j] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 2");
            }
            var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
            for (var k = 129; k <= 254; k++) {
              if (thirdByteNode[k] === UNASSIGNED) {
                thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
              } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                continue;
              } else if (thirdByteNode[k] > NODE_START) {
                throw new Error("gb18030 decode tables conflict at byte 3");
              }
              var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
              for (var l = 48; l <= 57; l++) {
                if (fourthByteNode[l] === UNASSIGNED)
                  fourthByteNode[l] = GB18030_CODE;
              }
            }
          }
        }
      }
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals)
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number")
            skipEncodeChars[val] = true;
          else
            for (var j = val.from; j <= val.to; j++)
              skipEncodeChars[j] = true;
        }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = "?".charCodeAt(0);
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes = [];
      for (; addr > 0; addr >>>= 8)
        bytes.push(addr & 255);
      if (bytes.length == 0)
        bytes.push(0);
      var node = this.decodeTables[0];
      for (var i2 = bytes.length - 1; i2 > 0; i2--) {
        var val = node[bytes[i2]];
        if (val == UNASSIGNED) {
          node[bytes[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (55296 <= code && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (56320 <= codeTrail && codeTrail < 57344)
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              else
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (4080 < code && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++)
                seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else
              writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++)
            writeTable[curAddr++] = charCode++;
        } else
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 255)
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED)
          node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object")
          node = oldVal;
        else {
          node = node[uCode] = {};
          if (oldVal !== void 0)
            node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      var hasValues = false;
      var subNodeEmpty = {};
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode])
          continue;
        if (uCode >= 0) {
          this._setEncodeChar(uCode, mbCode);
          hasValues = true;
        } else if (uCode <= NODE_START) {
          var subNodeIdx = NODE_START - uCode;
          if (!subNodeEmpty[subNodeIdx]) {
            var newPrefix = mbCode << 8 >>> 0;
            if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
              hasValues = true;
            else
              subNodeEmpty[subNodeIdx] = true;
          }
        } else if (uCode <= SEQ_START) {
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
          hasValues = true;
        }
      }
      return hasValues;
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer3.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length)
            break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (55296 <= uCode && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0)
            dbcsCode = subtable[uCode & 255];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED)
          dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else if (dbcsCode < 16777216) {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >>> 24;
          newBuf[j++] = dbcsCode >>> 16 & 255;
          newBuf[j++] = dbcsCode >>> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0)
        return;
      var newBuf = Buffer3.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBytes = [];
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer3.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          uCode = this.defaultCharUnicode.charCodeAt(0);
          i2 = seqStart;
        } else if (uCode === GB18030_CODE) {
          if (i2 >= 3) {
            var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
          } else {
            var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
          }
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode >= 65536) {
          uCode -= 65536;
          var uCodeLead = 55296 | uCode >> 10;
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 | uCode & 1023;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret = "";
      while (this.prevBytes.length > 0) {
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0)
          ret += this.write(bytesArr);
      }
      this.prevBytes = [];
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val)
        return -1;
      var l = 0, r = table.length;
      while (l < r - 1) {
        var mid = l + (r - l + 1 >> 1);
        if (table[mid] <= val)
          l = mid;
        else
          r = mid;
      }
      return l;
    }
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 128],
      ["a1", "\uFF61", 62],
      ["8140", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7"],
      ["8180", "\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["81b8", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["81c8", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["81da", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["81f0", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["81fc", "\u25EF"],
      ["824f", "\uFF10", 9],
      ["8260", "\uFF21", 25],
      ["8281", "\uFF41", 25],
      ["829f", "\u3041", 82],
      ["8340", "\u30A1", 62],
      ["8380", "\u30E0", 22],
      ["839f", "\u0391", 16, "\u03A3", 6],
      ["83bf", "\u03B1", 16, "\u03C3", 6],
      ["8440", "\u0410", 5, "\u0401\u0416", 25],
      ["8470", "\u0430", 5, "\u0451\u0436", 7],
      ["8480", "\u043E", 17],
      ["849f", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["8740", "\u2460", 19, "\u2160", 9],
      ["875f", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["877e", "\u337B"],
      ["8780", "\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["889f", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["8940", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186"],
      ["8980", "\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["8a40", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B"],
      ["8a80", "\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["8b40", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551"],
      ["8b80", "\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["8c40", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8"],
      ["8c80", "\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["8d40", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D"],
      ["8d80", "\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["8e40", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62"],
      ["8e80", "\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["8f40", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3"],
      ["8f80", "\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["9040", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8"],
      ["9080", "\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["9140", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB"],
      ["9180", "\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["9240", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4"],
      ["9280", "\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["9340", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC"],
      ["9380", "\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["9440", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885"],
      ["9480", "\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["9540", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577"],
      ["9580", "\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["9640", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6"],
      ["9680", "\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["9740", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32"],
      ["9780", "\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["9840", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["989f", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["9940", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED"],
      ["9980", "\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["9a40", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638"],
      ["9a80", "\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["9b40", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80"],
      ["9b80", "\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["9c40", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060"],
      ["9c80", "\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["9d40", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B"],
      ["9d80", "\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["9e40", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E"],
      ["9e80", "\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["9f40", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF"],
      ["9f80", "\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["e040", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD"],
      ["e080", "\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e140", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF"],
      ["e180", "\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e240", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0"],
      ["e280", "\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e340", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37"],
      ["e380", "\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e440", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264"],
      ["e480", "\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e540", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC"],
      ["e580", "\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["e640", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7"],
      ["e680", "\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["e740", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C"],
      ["e780", "\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["e840", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599"],
      ["e880", "\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["e940", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43"],
      ["e980", "\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["ea40", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF"],
      ["ea80", "\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["ed40", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F"],
      ["ed80", "\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["ee40", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559"],
      ["ee80", "\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["eeef", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["f040", "\uE000", 62],
      ["f080", "\uE03F", 124],
      ["f140", "\uE0BC", 62],
      ["f180", "\uE0FB", 124],
      ["f240", "\uE178", 62],
      ["f280", "\uE1B7", 124],
      ["f340", "\uE234", 62],
      ["f380", "\uE273", 124],
      ["f440", "\uE2F0", 62],
      ["f480", "\uE32F", 124],
      ["f540", "\uE3AC", 62],
      ["f580", "\uE3EB", 124],
      ["f640", "\uE468", 62],
      ["f680", "\uE4A7", 124],
      ["f740", "\uE524", 62],
      ["f780", "\uE563", 124],
      ["f840", "\uE5E0", 62],
      ["f880", "\uE61F", 124],
      ["f940", "\uE69C"],
      ["fa40", "\u2170", 9, "\u2160", 9, "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u2235\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A"],
      ["fa80", "\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F"],
      ["fb40", "\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19"],
      ["fb80", "\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9"],
      ["fc40", "\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"]
    ];
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/tables/eucjp.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8ea1", "\uFF61", 62],
      ["a1a1", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7"],
      ["a2a1", "\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["a2ba", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["a2ca", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["a2dc", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["a2f2", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["a2fe", "\u25EF"],
      ["a3b0", "\uFF10", 9],
      ["a3c1", "\uFF21", 25],
      ["a3e1", "\uFF41", 25],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a8a1", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["ada1", "\u2460", 19, "\u2160", 9],
      ["adc0", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["addf", "\u337B\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["b0a1", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["b1a1", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC"],
      ["b2a1", "\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["b3a1", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431"],
      ["b4a1", "\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["b5a1", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC"],
      ["b6a1", "\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["b7a1", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372"],
      ["b8a1", "\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["b9a1", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC"],
      ["baa1", "\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["bba1", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642"],
      ["bca1", "\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["bda1", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F"],
      ["bea1", "\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["bfa1", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE"],
      ["c0a1", "\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["c1a1", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E"],
      ["c2a1", "\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["c3a1", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5"],
      ["c4a1", "\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["c5a1", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230"],
      ["c6a1", "\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["c7a1", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6"],
      ["c8a1", "\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["c9a1", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D"],
      ["caa1", "\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["cba1", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80"],
      ["cca1", "\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["cda1", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483"],
      ["cea1", "\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["cfa1", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["d0a1", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["d1a1", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8"],
      ["d2a1", "\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["d3a1", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709"],
      ["d4a1", "\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["d5a1", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53"],
      ["d6a1", "\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["d7a1", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A"],
      ["d8a1", "\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["d9a1", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC"],
      ["daa1", "\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["dba1", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD"],
      ["dca1", "\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["dda1", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE"],
      ["dea1", "\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["dfa1", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC"],
      ["e0a1", "\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e1a1", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670"],
      ["e2a1", "\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e3a1", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50"],
      ["e4a1", "\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e5a1", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A"],
      ["e6a1", "\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e7a1", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9"],
      ["e8a1", "\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e9a1", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759"],
      ["eaa1", "\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["eba1", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B"],
      ["eca1", "\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["eda1", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8"],
      ["eea1", "\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["efa1", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E"],
      ["f0a1", "\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["f1a1", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7"],
      ["f2a1", "\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["f3a1", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0"],
      ["f4a1", "\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["f9a1", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7"],
      ["faa1", "\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["fba1", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA"],
      ["fca1", "\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["fcf1", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["8fa2af", "\u02D8\u02C7\xB8\u02D9\u02DD\xAF\u02DB\u02DA\uFF5E\u0384\u0385"],
      ["8fa2c2", "\xA1\xA6\xBF"],
      ["8fa2eb", "\xBA\xAA\xA9\xAE\u2122\xA4\u2116"],
      ["8fa6e1", "\u0386\u0388\u0389\u038A\u03AA"],
      ["8fa6e7", "\u038C"],
      ["8fa6e9", "\u038E\u03AB"],
      ["8fa6ec", "\u038F"],
      ["8fa6f1", "\u03AC\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03C2\u03CD\u03CB\u03B0\u03CE"],
      ["8fa7c2", "\u0402", 10, "\u040E\u040F"],
      ["8fa7f2", "\u0452", 10, "\u045E\u045F"],
      ["8fa9a1", "\xC6\u0110"],
      ["8fa9a4", "\u0126"],
      ["8fa9a6", "\u0132"],
      ["8fa9a8", "\u0141\u013F"],
      ["8fa9ab", "\u014A\xD8\u0152"],
      ["8fa9af", "\u0166\xDE"],
      ["8fa9c1", "\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0142\u0140\u0149\u014B\xF8\u0153\xDF\u0167\xFE"],
      ["8faaa1", "\xC1\xC0\xC4\xC2\u0102\u01CD\u0100\u0104\xC5\xC3\u0106\u0108\u010C\xC7\u010A\u010E\xC9\xC8\xCB\xCA\u011A\u0116\u0112\u0118"],
      ["8faaba", "\u011C\u011E\u0122\u0120\u0124\xCD\xCC\xCF\xCE\u01CF\u0130\u012A\u012E\u0128\u0134\u0136\u0139\u013D\u013B\u0143\u0147\u0145\xD1\xD3\xD2\xD6\xD4\u01D1\u0150\u014C\xD5\u0154\u0158\u0156\u015A\u015C\u0160\u015E\u0164\u0162\xDA\xD9\xDC\xDB\u016C\u01D3\u0170\u016A\u0172\u016E\u0168\u01D7\u01DB\u01D9\u01D5\u0174\xDD\u0178\u0176\u0179\u017D\u017B"],
      ["8faba1", "\xE1\xE0\xE4\xE2\u0103\u01CE\u0101\u0105\xE5\xE3\u0107\u0109\u010D\xE7\u010B\u010F\xE9\xE8\xEB\xEA\u011B\u0117\u0113\u0119\u01F5\u011D\u011F"],
      ["8fabbd", "\u0121\u0125\xED\xEC\xEF\xEE\u01D0"],
      ["8fabc5", "\u012B\u012F\u0129\u0135\u0137\u013A\u013E\u013C\u0144\u0148\u0146\xF1\xF3\xF2\xF6\xF4\u01D2\u0151\u014D\xF5\u0155\u0159\u0157\u015B\u015D\u0161\u015F\u0165\u0163\xFA\xF9\xFC\xFB\u016D\u01D4\u0171\u016B\u0173\u016F\u0169\u01D8\u01DC\u01DA\u01D6\u0175\xFD\xFF\u0177\u017A\u017E\u017C"],
      ["8fb0a1", "\u4E02\u4E04\u4E05\u4E0C\u4E12\u4E1F\u4E23\u4E24\u4E28\u4E2B\u4E2E\u4E2F\u4E30\u4E35\u4E40\u4E41\u4E44\u4E47\u4E51\u4E5A\u4E5C\u4E63\u4E68\u4E69\u4E74\u4E75\u4E79\u4E7F\u4E8D\u4E96\u4E97\u4E9D\u4EAF\u4EB9\u4EC3\u4ED0\u4EDA\u4EDB\u4EE0\u4EE1\u4EE2\u4EE8\u4EEF\u4EF1\u4EF3\u4EF5\u4EFD\u4EFE\u4EFF\u4F00\u4F02\u4F03\u4F08\u4F0B\u4F0C\u4F12\u4F15\u4F16\u4F17\u4F19\u4F2E\u4F31\u4F60\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E\u4F40\u4F42\u4F48\u4F49\u4F4B\u4F4C\u4F52\u4F54\u4F56\u4F58\u4F5F\u4F63\u4F6A\u4F6C\u4F6E\u4F71\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F7E\u4F81\u4F82\u4F84"],
      ["8fb1a1", "\u4F85\u4F89\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F94\u4F97\u4F99\u4F9A\u4F9E\u4F9F\u4FB2\u4FB7\u4FB9\u4FBB\u4FBC\u4FBD\u4FBE\u4FC0\u4FC1\u4FC5\u4FC6\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FCF\u4FD2\u4FDC\u4FE0\u4FE2\u4FF0\u4FF2\u4FFC\u4FFD\u4FFF\u5000\u5001\u5004\u5007\u500A\u500C\u500E\u5010\u5013\u5017\u5018\u501B\u501C\u501D\u501E\u5022\u5027\u502E\u5030\u5032\u5033\u5035\u5040\u5041\u5042\u5045\u5046\u504A\u504C\u504E\u5051\u5052\u5053\u5057\u5059\u505F\u5060\u5062\u5063\u5066\u5067\u506A\u506D\u5070\u5071\u503B\u5081\u5083\u5084\u5086\u508A\u508E\u508F\u5090"],
      ["8fb2a1", "\u5092\u5093\u5094\u5096\u509B\u509C\u509E", 4, "\u50AA\u50AF\u50B0\u50B9\u50BA\u50BD\u50C0\u50C3\u50C4\u50C7\u50CC\u50CE\u50D0\u50D3\u50D4\u50D8\u50DC\u50DD\u50DF\u50E2\u50E4\u50E6\u50E8\u50E9\u50EF\u50F1\u50F6\u50FA\u50FE\u5103\u5106\u5107\u5108\u510B\u510C\u510D\u510E\u50F2\u5110\u5117\u5119\u511B\u511C\u511D\u511E\u5123\u5127\u5128\u512C\u512D\u512F\u5131\u5133\u5134\u5135\u5138\u5139\u5142\u514A\u514F\u5153\u5155\u5157\u5158\u515F\u5164\u5166\u517E\u5183\u5184\u518B\u518E\u5198\u519D\u51A1\u51A3\u51AD\u51B8\u51BA\u51BC\u51BE\u51BF\u51C2"],
      ["8fb3a1", "\u51C8\u51CF\u51D1\u51D2\u51D3\u51D5\u51D8\u51DE\u51E2\u51E5\u51EE\u51F2\u51F3\u51F4\u51F7\u5201\u5202\u5205\u5212\u5213\u5215\u5216\u5218\u5222\u5228\u5231\u5232\u5235\u523C\u5245\u5249\u5255\u5257\u5258\u525A\u525C\u525F\u5260\u5261\u5266\u526E\u5277\u5278\u5279\u5280\u5282\u5285\u528A\u528C\u5293\u5295\u5296\u5297\u5298\u529A\u529C\u52A4\u52A5\u52A6\u52A7\u52AF\u52B0\u52B6\u52B7\u52B8\u52BA\u52BB\u52BD\u52C0\u52C4\u52C6\u52C8\u52CC\u52CF\u52D1\u52D4\u52D6\u52DB\u52DC\u52E1\u52E5\u52E8\u52E9\u52EA\u52EC\u52F0\u52F1\u52F4\u52F6\u52F7\u5300\u5303\u530A\u530B"],
      ["8fb4a1", "\u530C\u5311\u5313\u5318\u531B\u531C\u531E\u531F\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u5330\u5332\u5335\u533C\u533D\u533E\u5342\u534C\u534B\u5359\u535B\u5361\u5363\u5365\u536C\u536D\u5372\u5379\u537E\u5383\u5387\u5388\u538E\u5393\u5394\u5399\u539D\u53A1\u53A4\u53AA\u53AB\u53AF\u53B2\u53B4\u53B5\u53B7\u53B8\u53BA\u53BD\u53C0\u53C5\u53CF\u53D2\u53D3\u53D5\u53DA\u53DD\u53DE\u53E0\u53E6\u53E7\u53F5\u5402\u5413\u541A\u5421\u5427\u5428\u542A\u542F\u5431\u5434\u5435\u5443\u5444\u5447\u544D\u544F\u545E\u5462\u5464\u5466\u5467\u5469\u546B\u546D\u546E\u5474\u547F"],
      ["8fb5a1", "\u5481\u5483\u5485\u5488\u5489\u548D\u5491\u5495\u5496\u549C\u549F\u54A1\u54A6\u54A7\u54A9\u54AA\u54AD\u54AE\u54B1\u54B7\u54B9\u54BA\u54BB\u54BF\u54C6\u54CA\u54CD\u54CE\u54E0\u54EA\u54EC\u54EF\u54F6\u54FC\u54FE\u54FF\u5500\u5501\u5505\u5508\u5509\u550C\u550D\u550E\u5515\u552A\u552B\u5532\u5535\u5536\u553B\u553C\u553D\u5541\u5547\u5549\u554A\u554D\u5550\u5551\u5558\u555A\u555B\u555E\u5560\u5561\u5564\u5566\u557F\u5581\u5582\u5586\u5588\u558E\u558F\u5591\u5592\u5593\u5594\u5597\u55A3\u55A4\u55AD\u55B2\u55BF\u55C1\u55C3\u55C6\u55C9\u55CB\u55CC\u55CE\u55D1\u55D2"],
      ["8fb6a1", "\u55D3\u55D7\u55D8\u55DB\u55DE\u55E2\u55E9\u55F6\u55FF\u5605\u5608\u560A\u560D", 5, "\u5619\u562C\u5630\u5633\u5635\u5637\u5639\u563B\u563C\u563D\u563F\u5640\u5641\u5643\u5644\u5646\u5649\u564B\u564D\u564F\u5654\u565E\u5660\u5661\u5662\u5663\u5666\u5669\u566D\u566F\u5671\u5672\u5675\u5684\u5685\u5688\u568B\u568C\u5695\u5699\u569A\u569D\u569E\u569F\u56A6\u56A7\u56A8\u56A9\u56AB\u56AC\u56AD\u56B1\u56B3\u56B7\u56BE\u56C5\u56C9\u56CA\u56CB\u56CF\u56D0\u56CC\u56CD\u56D9\u56DC\u56DD\u56DF\u56E1\u56E4", 4, "\u56F1\u56EB\u56ED"],
      ["8fb7a1", "\u56F6\u56F7\u5701\u5702\u5707\u570A\u570C\u5711\u5715\u571A\u571B\u571D\u5720\u5722\u5723\u5724\u5725\u5729\u572A\u572C\u572E\u572F\u5733\u5734\u573D\u573E\u573F\u5745\u5746\u574C\u574D\u5752\u5762\u5765\u5767\u5768\u576B\u576D", 4, "\u5773\u5774\u5775\u5777\u5779\u577A\u577B\u577C\u577E\u5781\u5783\u578C\u5794\u5797\u5799\u579A\u579C\u579D\u579E\u579F\u57A1\u5795\u57A7\u57A8\u57A9\u57AC\u57B8\u57BD\u57C7\u57C8\u57CC\u57CF\u57D5\u57DD\u57DE\u57E4\u57E6\u57E7\u57E9\u57ED\u57F0\u57F5\u57F6\u57F8\u57FD\u57FE\u57FF\u5803\u5804\u5808\u5809\u57E1"],
      ["8fb8a1", "\u580C\u580D\u581B\u581E\u581F\u5820\u5826\u5827\u582D\u5832\u5839\u583F\u5849\u584C\u584D\u584F\u5850\u5855\u585F\u5861\u5864\u5867\u5868\u5878\u587C\u587F\u5880\u5881\u5887\u5888\u5889\u588A\u588C\u588D\u588F\u5890\u5894\u5896\u589D\u58A0\u58A1\u58A2\u58A6\u58A9\u58B1\u58B2\u58C4\u58BC\u58C2\u58C8\u58CD\u58CE\u58D0\u58D2\u58D4\u58D6\u58DA\u58DD\u58E1\u58E2\u58E9\u58F3\u5905\u5906\u590B\u590C\u5912\u5913\u5914\u8641\u591D\u5921\u5923\u5924\u5928\u592F\u5930\u5933\u5935\u5936\u593F\u5943\u5946\u5952\u5953\u5959\u595B\u595D\u595E\u595F\u5961\u5963\u596B\u596D"],
      ["8fb9a1", "\u596F\u5972\u5975\u5976\u5979\u597B\u597C\u598B\u598C\u598E\u5992\u5995\u5997\u599F\u59A4\u59A7\u59AD\u59AE\u59AF\u59B0\u59B3\u59B7\u59BA\u59BC\u59C1\u59C3\u59C4\u59C8\u59CA\u59CD\u59D2\u59DD\u59DE\u59DF\u59E3\u59E4\u59E7\u59EE\u59EF\u59F1\u59F2\u59F4\u59F7\u5A00\u5A04\u5A0C\u5A0D\u5A0E\u5A12\u5A13\u5A1E\u5A23\u5A24\u5A27\u5A28\u5A2A\u5A2D\u5A30\u5A44\u5A45\u5A47\u5A48\u5A4C\u5A50\u5A55\u5A5E\u5A63\u5A65\u5A67\u5A6D\u5A77\u5A7A\u5A7B\u5A7E\u5A8B\u5A90\u5A93\u5A96\u5A99\u5A9C\u5A9E\u5A9F\u5AA0\u5AA2\u5AA7\u5AAC\u5AB1\u5AB2\u5AB3\u5AB5\u5AB8\u5ABA\u5ABB\u5ABF"],
      ["8fbaa1", "\u5AC4\u5AC6\u5AC8\u5ACF\u5ADA\u5ADC\u5AE0\u5AE5\u5AEA\u5AEE\u5AF5\u5AF6\u5AFD\u5B00\u5B01\u5B08\u5B17\u5B34\u5B19\u5B1B\u5B1D\u5B21\u5B25\u5B2D\u5B38\u5B41\u5B4B\u5B4C\u5B52\u5B56\u5B5E\u5B68\u5B6E\u5B6F\u5B7C\u5B7D\u5B7E\u5B7F\u5B81\u5B84\u5B86\u5B8A\u5B8E\u5B90\u5B91\u5B93\u5B94\u5B96\u5BA8\u5BA9\u5BAC\u5BAD\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBC\u5BC0\u5BC1\u5BCD\u5BCF\u5BD6", 4, "\u5BE0\u5BEF\u5BF1\u5BF4\u5BFD\u5C0C\u5C17\u5C1E\u5C1F\u5C23\u5C26\u5C29\u5C2B\u5C2C\u5C2E\u5C30\u5C32\u5C35\u5C36\u5C59\u5C5A\u5C5C\u5C62\u5C63\u5C67\u5C68\u5C69"],
      ["8fbba1", "\u5C6D\u5C70\u5C74\u5C75\u5C7A\u5C7B\u5C7C\u5C7D\u5C87\u5C88\u5C8A\u5C8F\u5C92\u5C9D\u5C9F\u5CA0\u5CA2\u5CA3\u5CA6\u5CAA\u5CB2\u5CB4\u5CB5\u5CBA\u5CC9\u5CCB\u5CD2\u5CDD\u5CD7\u5CEE\u5CF1\u5CF2\u5CF4\u5D01\u5D06\u5D0D\u5D12\u5D2B\u5D23\u5D24\u5D26\u5D27\u5D31\u5D34\u5D39\u5D3D\u5D3F\u5D42\u5D43\u5D46\u5D48\u5D55\u5D51\u5D59\u5D4A\u5D5F\u5D60\u5D61\u5D62\u5D64\u5D6A\u5D6D\u5D70\u5D79\u5D7A\u5D7E\u5D7F\u5D81\u5D83\u5D88\u5D8A\u5D92\u5D93\u5D94\u5D95\u5D99\u5D9B\u5D9F\u5DA0\u5DA7\u5DAB\u5DB0\u5DB4\u5DB8\u5DB9\u5DC3\u5DC7\u5DCB\u5DD0\u5DCE\u5DD8\u5DD9\u5DE0\u5DE4"],
      ["8fbca1", "\u5DE9\u5DF8\u5DF9\u5E00\u5E07\u5E0D\u5E12\u5E14\u5E15\u5E18\u5E1F\u5E20\u5E2E\u5E28\u5E32\u5E35\u5E3E\u5E4B\u5E50\u5E49\u5E51\u5E56\u5E58\u5E5B\u5E5C\u5E5E\u5E68\u5E6A", 4, "\u5E70\u5E80\u5E8B\u5E8E\u5EA2\u5EA4\u5EA5\u5EA8\u5EAA\u5EAC\u5EB1\u5EB3\u5EBD\u5EBE\u5EBF\u5EC6\u5ECC\u5ECB\u5ECE\u5ED1\u5ED2\u5ED4\u5ED5\u5EDC\u5EDE\u5EE5\u5EEB\u5F02\u5F06\u5F07\u5F08\u5F0E\u5F19\u5F1C\u5F1D\u5F21\u5F22\u5F23\u5F24\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F34\u5F36\u5F3B\u5F3D\u5F3F\u5F40\u5F44\u5F45\u5F47\u5F4D\u5F50\u5F54\u5F58\u5F5B\u5F60\u5F63\u5F64\u5F67"],
      ["8fbda1", "\u5F6F\u5F72\u5F74\u5F75\u5F78\u5F7A\u5F7D\u5F7E\u5F89\u5F8D\u5F8F\u5F96\u5F9C\u5F9D\u5FA2\u5FA7\u5FAB\u5FA4\u5FAC\u5FAF\u5FB0\u5FB1\u5FB8\u5FC4\u5FC7\u5FC8\u5FC9\u5FCB\u5FD0", 4, "\u5FDE\u5FE1\u5FE2\u5FE8\u5FE9\u5FEA\u5FEC\u5FED\u5FEE\u5FEF\u5FF2\u5FF3\u5FF6\u5FFA\u5FFC\u6007\u600A\u600D\u6013\u6014\u6017\u6018\u601A\u601F\u6024\u602D\u6033\u6035\u6040\u6047\u6048\u6049\u604C\u6051\u6054\u6056\u6057\u605D\u6061\u6067\u6071\u607E\u607F\u6082\u6086\u6088\u608A\u608E\u6091\u6093\u6095\u6098\u609D\u609E\u60A2\u60A4\u60A5\u60A8\u60B0\u60B1\u60B7"],
      ["8fbea1", "\u60BB\u60BE\u60C2\u60C4\u60C8\u60C9\u60CA\u60CB\u60CE\u60CF\u60D4\u60D5\u60D9\u60DB\u60DD\u60DE\u60E2\u60E5\u60F2\u60F5\u60F8\u60FC\u60FD\u6102\u6107\u610A\u610C\u6110", 4, "\u6116\u6117\u6119\u611C\u611E\u6122\u612A\u612B\u6130\u6131\u6135\u6136\u6137\u6139\u6141\u6145\u6146\u6149\u615E\u6160\u616C\u6172\u6178\u617B\u617C\u617F\u6180\u6181\u6183\u6184\u618B\u618D\u6192\u6193\u6197\u6198\u619C\u619D\u619F\u61A0\u61A5\u61A8\u61AA\u61AD\u61B8\u61B9\u61BC\u61C0\u61C1\u61C2\u61CE\u61CF\u61D5\u61DC\u61DD\u61DE\u61DF\u61E1\u61E2\u61E7\u61E9\u61E5"],
      ["8fbfa1", "\u61EC\u61ED\u61EF\u6201\u6203\u6204\u6207\u6213\u6215\u621C\u6220\u6222\u6223\u6227\u6229\u622B\u6239\u623D\u6242\u6243\u6244\u6246\u624C\u6250\u6251\u6252\u6254\u6256\u625A\u625C\u6264\u626D\u626F\u6273\u627A\u627D\u628D\u628E\u628F\u6290\u62A6\u62A8\u62B3\u62B6\u62B7\u62BA\u62BE\u62BF\u62C4\u62CE\u62D5\u62D6\u62DA\u62EA\u62F2\u62F4\u62FC\u62FD\u6303\u6304\u630A\u630B\u630D\u6310\u6313\u6316\u6318\u6329\u632A\u632D\u6335\u6336\u6339\u633C\u6341\u6342\u6343\u6344\u6346\u634A\u634B\u634E\u6352\u6353\u6354\u6358\u635B\u6365\u6366\u636C\u636D\u6371\u6374\u6375"],
      ["8fc0a1", "\u6378\u637C\u637D\u637F\u6382\u6384\u6387\u638A\u6390\u6394\u6395\u6399\u639A\u639E\u63A4\u63A6\u63AD\u63AE\u63AF\u63BD\u63C1\u63C5\u63C8\u63CE\u63D1\u63D3\u63D4\u63D5\u63DC\u63E0\u63E5\u63EA\u63EC\u63F2\u63F3\u63F5\u63F8\u63F9\u6409\u640A\u6410\u6412\u6414\u6418\u641E\u6420\u6422\u6424\u6425\u6429\u642A\u642F\u6430\u6435\u643D\u643F\u644B\u644F\u6451\u6452\u6453\u6454\u645A\u645B\u645C\u645D\u645F\u6460\u6461\u6463\u646D\u6473\u6474\u647B\u647D\u6485\u6487\u648F\u6490\u6491\u6498\u6499\u649B\u649D\u649F\u64A1\u64A3\u64A6\u64A8\u64AC\u64B3\u64BD\u64BE\u64BF"],
      ["8fc1a1", "\u64C4\u64C9\u64CA\u64CB\u64CC\u64CE\u64D0\u64D1\u64D5\u64D7\u64E4\u64E5\u64E9\u64EA\u64ED\u64F0\u64F5\u64F7\u64FB\u64FF\u6501\u6504\u6508\u6509\u650A\u650F\u6513\u6514\u6516\u6519\u651B\u651E\u651F\u6522\u6526\u6529\u652E\u6531\u653A\u653C\u653D\u6543\u6547\u6549\u6550\u6552\u6554\u655F\u6560\u6567\u656B\u657A\u657D\u6581\u6585\u658A\u6592\u6595\u6598\u659D\u65A0\u65A3\u65A6\u65AE\u65B2\u65B3\u65B4\u65BF\u65C2\u65C8\u65C9\u65CE\u65D0\u65D4\u65D6\u65D8\u65DF\u65F0\u65F2\u65F4\u65F5\u65F9\u65FE\u65FF\u6600\u6604\u6608\u6609\u660D\u6611\u6612\u6615\u6616\u661D"],
      ["8fc2a1", "\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6631\u6633\u6639\u6637\u6640\u6645\u6646\u664A\u664C\u6651\u664E\u6657\u6658\u6659\u665B\u665C\u6660\u6661\u66FB\u666A\u666B\u666C\u667E\u6673\u6675\u667F\u6677\u6678\u6679\u667B\u6680\u667C\u668B\u668C\u668D\u6690\u6692\u6699\u669A\u669B\u669C\u669F\u66A0\u66A4\u66AD\u66B1\u66B2\u66B5\u66BB\u66BF\u66C0\u66C2\u66C3\u66C8\u66CC\u66CE\u66CF\u66D4\u66DB\u66DF\u66E8\u66EB\u66EC\u66EE\u66FA\u6705\u6707\u670E\u6713\u6719\u671C\u6720\u6722\u6733\u673E\u6745\u6747\u6748\u674C\u6754\u6755\u675D"],
      ["8fc3a1", "\u6766\u676C\u676E\u6774\u6776\u677B\u6781\u6784\u678E\u678F\u6791\u6793\u6796\u6798\u6799\u679B\u67B0\u67B1\u67B2\u67B5\u67BB\u67BC\u67BD\u67F9\u67C0\u67C2\u67C3\u67C5\u67C8\u67C9\u67D2\u67D7\u67D9\u67DC\u67E1\u67E6\u67F0\u67F2\u67F6\u67F7\u6852\u6814\u6819\u681D\u681F\u6828\u6827\u682C\u682D\u682F\u6830\u6831\u6833\u683B\u683F\u6844\u6845\u684A\u684C\u6855\u6857\u6858\u685B\u686B\u686E", 4, "\u6875\u6879\u687A\u687B\u687C\u6882\u6884\u6886\u6888\u6896\u6898\u689A\u689C\u68A1\u68A3\u68A5\u68A9\u68AA\u68AE\u68B2\u68BB\u68C5\u68C8\u68CC\u68CF"],
      ["8fc4a1", "\u68D0\u68D1\u68D3\u68D6\u68D9\u68DC\u68DD\u68E5\u68E8\u68EA\u68EB\u68EC\u68ED\u68F0\u68F1\u68F5\u68F6\u68FB\u68FC\u68FD\u6906\u6909\u690A\u6910\u6911\u6913\u6916\u6917\u6931\u6933\u6935\u6938\u693B\u6942\u6945\u6949\u694E\u6957\u695B\u6963\u6964\u6965\u6966\u6968\u6969\u696C\u6970\u6971\u6972\u697A\u697B\u697F\u6980\u698D\u6992\u6996\u6998\u69A1\u69A5\u69A6\u69A8\u69AB\u69AD\u69AF\u69B7\u69B8\u69BA\u69BC\u69C5\u69C8\u69D1\u69D6\u69D7\u69E2\u69E5\u69EE\u69EF\u69F1\u69F3\u69F5\u69FE\u6A00\u6A01\u6A03\u6A0F\u6A11\u6A15\u6A1A\u6A1D\u6A20\u6A24\u6A28\u6A30\u6A32"],
      ["8fc5a1", "\u6A34\u6A37\u6A3B\u6A3E\u6A3F\u6A45\u6A46\u6A49\u6A4A\u6A4E\u6A50\u6A51\u6A52\u6A55\u6A56\u6A5B\u6A64\u6A67\u6A6A\u6A71\u6A73\u6A7E\u6A81\u6A83\u6A86\u6A87\u6A89\u6A8B\u6A91\u6A9B\u6A9D\u6A9E\u6A9F\u6AA5\u6AAB\u6AAF\u6AB0\u6AB1\u6AB4\u6ABD\u6ABE\u6ABF\u6AC6\u6AC9\u6AC8\u6ACC\u6AD0\u6AD4\u6AD5\u6AD6\u6ADC\u6ADD\u6AE4\u6AE7\u6AEC\u6AF0\u6AF1\u6AF2\u6AFC\u6AFD\u6B02\u6B03\u6B06\u6B07\u6B09\u6B0F\u6B10\u6B11\u6B17\u6B1B\u6B1E\u6B24\u6B28\u6B2B\u6B2C\u6B2F\u6B35\u6B36\u6B3B\u6B3F\u6B46\u6B4A\u6B4D\u6B52\u6B56\u6B58\u6B5D\u6B60\u6B67\u6B6B\u6B6E\u6B70\u6B75\u6B7D"],
      ["8fc6a1", "\u6B7E\u6B82\u6B85\u6B97\u6B9B\u6B9F\u6BA0\u6BA2\u6BA3\u6BA8\u6BA9\u6BAC\u6BAD\u6BAE\u6BB0\u6BB8\u6BB9\u6BBD\u6BBE\u6BC3\u6BC4\u6BC9\u6BCC\u6BD6\u6BDA\u6BE1\u6BE3\u6BE6\u6BE7\u6BEE\u6BF1\u6BF7\u6BF9\u6BFF\u6C02\u6C04\u6C05\u6C09\u6C0D\u6C0E\u6C10\u6C12\u6C19\u6C1F\u6C26\u6C27\u6C28\u6C2C\u6C2E\u6C33\u6C35\u6C36\u6C3A\u6C3B\u6C3F\u6C4A\u6C4B\u6C4D\u6C4F\u6C52\u6C54\u6C59\u6C5B\u6C5C\u6C6B\u6C6D\u6C6F\u6C74\u6C76\u6C78\u6C79\u6C7B\u6C85\u6C86\u6C87\u6C89\u6C94\u6C95\u6C97\u6C98\u6C9C\u6C9F\u6CB0\u6CB2\u6CB4\u6CC2\u6CC6\u6CCD\u6CCF\u6CD0\u6CD1\u6CD2\u6CD4\u6CD6"],
      ["8fc7a1", "\u6CDA\u6CDC\u6CE0\u6CE7\u6CE9\u6CEB\u6CEC\u6CEE\u6CF2\u6CF4\u6D04\u6D07\u6D0A\u6D0E\u6D0F\u6D11\u6D13\u6D1A\u6D26\u6D27\u6D28\u6C67\u6D2E\u6D2F\u6D31\u6D39\u6D3C\u6D3F\u6D57\u6D5E\u6D5F\u6D61\u6D65\u6D67\u6D6F\u6D70\u6D7C\u6D82\u6D87\u6D91\u6D92\u6D94\u6D96\u6D97\u6D98\u6DAA\u6DAC\u6DB4\u6DB7\u6DB9\u6DBD\u6DBF\u6DC4\u6DC8\u6DCA\u6DCE\u6DCF\u6DD6\u6DDB\u6DDD\u6DDF\u6DE0\u6DE2\u6DE5\u6DE9\u6DEF\u6DF0\u6DF4\u6DF6\u6DFC\u6E00\u6E04\u6E1E\u6E22\u6E27\u6E32\u6E36\u6E39\u6E3B\u6E3C\u6E44\u6E45\u6E48\u6E49\u6E4B\u6E4F\u6E51\u6E52\u6E53\u6E54\u6E57\u6E5C\u6E5D\u6E5E"],
      ["8fc8a1", "\u6E62\u6E63\u6E68\u6E73\u6E7B\u6E7D\u6E8D\u6E93\u6E99\u6EA0\u6EA7\u6EAD\u6EAE\u6EB1\u6EB3\u6EBB\u6EBF\u6EC0\u6EC1\u6EC3\u6EC7\u6EC8\u6ECA\u6ECD\u6ECE\u6ECF\u6EEB\u6EED\u6EEE\u6EF9\u6EFB\u6EFD\u6F04\u6F08\u6F0A\u6F0C\u6F0D\u6F16\u6F18\u6F1A\u6F1B\u6F26\u6F29\u6F2A\u6F2F\u6F30\u6F33\u6F36\u6F3B\u6F3C\u6F2D\u6F4F\u6F51\u6F52\u6F53\u6F57\u6F59\u6F5A\u6F5D\u6F5E\u6F61\u6F62\u6F68\u6F6C\u6F7D\u6F7E\u6F83\u6F87\u6F88\u6F8B\u6F8C\u6F8D\u6F90\u6F92\u6F93\u6F94\u6F96\u6F9A\u6F9F\u6FA0\u6FA5\u6FA6\u6FA7\u6FA8\u6FAE\u6FAF\u6FB0\u6FB5\u6FB6\u6FBC\u6FC5\u6FC7\u6FC8\u6FCA"],
      ["8fc9a1", "\u6FDA\u6FDE\u6FE8\u6FE9\u6FF0\u6FF5\u6FF9\u6FFC\u6FFD\u7000\u7005\u7006\u7007\u700D\u7017\u7020\u7023\u702F\u7034\u7037\u7039\u703C\u7043\u7044\u7048\u7049\u704A\u704B\u7054\u7055\u705D\u705E\u704E\u7064\u7065\u706C\u706E\u7075\u7076\u707E\u7081\u7085\u7086\u7094", 4, "\u709B\u70A4\u70AB\u70B0\u70B1\u70B4\u70B7\u70CA\u70D1\u70D3\u70D4\u70D5\u70D6\u70D8\u70DC\u70E4\u70FA\u7103", 4, "\u710B\u710C\u710F\u711E\u7120\u712B\u712D\u712F\u7130\u7131\u7138\u7141\u7145\u7146\u7147\u714A\u714B\u7150\u7152\u7157\u715A\u715C\u715E\u7160"],
      ["8fcaa1", "\u7168\u7179\u7180\u7185\u7187\u718C\u7192\u719A\u719B\u71A0\u71A2\u71AF\u71B0\u71B2\u71B3\u71BA\u71BF\u71C0\u71C1\u71C4\u71CB\u71CC\u71D3\u71D6\u71D9\u71DA\u71DC\u71F8\u71FE\u7200\u7207\u7208\u7209\u7213\u7217\u721A\u721D\u721F\u7224\u722B\u722F\u7234\u7238\u7239\u7241\u7242\u7243\u7245\u724E\u724F\u7250\u7253\u7255\u7256\u725A\u725C\u725E\u7260\u7263\u7268\u726B\u726E\u726F\u7271\u7277\u7278\u727B\u727C\u727F\u7284\u7289\u728D\u728E\u7293\u729B\u72A8\u72AD\u72AE\u72B1\u72B4\u72BE\u72C1\u72C7\u72C9\u72CC\u72D5\u72D6\u72D8\u72DF\u72E5\u72F3\u72F4\u72FA\u72FB"],
      ["8fcba1", "\u72FE\u7302\u7304\u7305\u7307\u730B\u730D\u7312\u7313\u7318\u7319\u731E\u7322\u7324\u7327\u7328\u732C\u7331\u7332\u7335\u733A\u733B\u733D\u7343\u734D\u7350\u7352\u7356\u7358\u735D\u735E\u735F\u7360\u7366\u7367\u7369\u736B\u736C\u736E\u736F\u7371\u7377\u7379\u737C\u7380\u7381\u7383\u7385\u7386\u738E\u7390\u7393\u7395\u7397\u7398\u739C\u739E\u739F\u73A0\u73A2\u73A5\u73A6\u73AA\u73AB\u73AD\u73B5\u73B7\u73B9\u73BC\u73BD\u73BF\u73C5\u73C6\u73C9\u73CB\u73CC\u73CF\u73D2\u73D3\u73D6\u73D9\u73DD\u73E1\u73E3\u73E6\u73E7\u73E9\u73F4\u73F5\u73F7\u73F9\u73FA\u73FB\u73FD"],
      ["8fcca1", "\u73FF\u7400\u7401\u7404\u7407\u740A\u7411\u741A\u741B\u7424\u7426\u7428", 9, "\u7439\u7440\u7443\u7444\u7446\u7447\u744B\u744D\u7451\u7452\u7457\u745D\u7462\u7466\u7467\u7468\u746B\u746D\u746E\u7471\u7472\u7480\u7481\u7485\u7486\u7487\u7489\u748F\u7490\u7491\u7492\u7498\u7499\u749A\u749C\u749F\u74A0\u74A1\u74A3\u74A6\u74A8\u74A9\u74AA\u74AB\u74AE\u74AF\u74B1\u74B2\u74B5\u74B9\u74BB\u74BF\u74C8\u74C9\u74CC\u74D0\u74D3\u74D8\u74DA\u74DB\u74DE\u74DF\u74E4\u74E8\u74EA\u74EB\u74EF\u74F4\u74FA\u74FB\u74FC\u74FF\u7506"],
      ["8fcda1", "\u7512\u7516\u7517\u7520\u7521\u7524\u7527\u7529\u752A\u752F\u7536\u7539\u753D\u753E\u753F\u7540\u7543\u7547\u7548\u754E\u7550\u7552\u7557\u755E\u755F\u7561\u756F\u7571\u7579", 5, "\u7581\u7585\u7590\u7592\u7593\u7595\u7599\u759C\u75A2\u75A4\u75B4\u75BA\u75BF\u75C0\u75C1\u75C4\u75C6\u75CC\u75CE\u75CF\u75D7\u75DC\u75DF\u75E0\u75E1\u75E4\u75E7\u75EC\u75EE\u75EF\u75F1\u75F9\u7600\u7602\u7603\u7604\u7607\u7608\u760A\u760C\u760F\u7612\u7613\u7615\u7616\u7619\u761B\u761C\u761D\u761E\u7623\u7625\u7626\u7629\u762D\u7632\u7633\u7635\u7638\u7639"],
      ["8fcea1", "\u763A\u763C\u764A\u7640\u7641\u7643\u7644\u7645\u7649\u764B\u7655\u7659\u765F\u7664\u7665\u766D\u766E\u766F\u7671\u7674\u7681\u7685\u768C\u768D\u7695\u769B\u769C\u769D\u769F\u76A0\u76A2", 6, "\u76AA\u76AD\u76BD\u76C1\u76C5\u76C9\u76CB\u76CC\u76CE\u76D4\u76D9\u76E0\u76E6\u76E8\u76EC\u76F0\u76F1\u76F6\u76F9\u76FC\u7700\u7706\u770A\u770E\u7712\u7714\u7715\u7717\u7719\u771A\u771C\u7722\u7728\u772D\u772E\u772F\u7734\u7735\u7736\u7739\u773D\u773E\u7742\u7745\u7746\u774A\u774D\u774E\u774F\u7752\u7756\u7757\u775C\u775E\u775F\u7760\u7762"],
      ["8fcfa1", "\u7764\u7767\u776A\u776C\u7770\u7772\u7773\u7774\u777A\u777D\u7780\u7784\u778C\u778D\u7794\u7795\u7796\u779A\u779F\u77A2\u77A7\u77AA\u77AE\u77AF\u77B1\u77B5\u77BE\u77C3\u77C9\u77D1\u77D2\u77D5\u77D9\u77DE\u77DF\u77E0\u77E4\u77E6\u77EA\u77EC\u77F0\u77F1\u77F4\u77F8\u77FB\u7805\u7806\u7809\u780D\u780E\u7811\u781D\u7821\u7822\u7823\u782D\u782E\u7830\u7835\u7837\u7843\u7844\u7847\u7848\u784C\u784E\u7852\u785C\u785E\u7860\u7861\u7863\u7864\u7868\u786A\u786E\u787A\u787E\u788A\u788F\u7894\u7898\u78A1\u789D\u789E\u789F\u78A4\u78A8\u78AC\u78AD\u78B0\u78B1\u78B2\u78B3"],
      ["8fd0a1", "\u78BB\u78BD\u78BF\u78C7\u78C8\u78C9\u78CC\u78CE\u78D2\u78D3\u78D5\u78D6\u78E4\u78DB\u78DF\u78E0\u78E1\u78E6\u78EA\u78F2\u78F3\u7900\u78F6\u78F7\u78FA\u78FB\u78FF\u7906\u790C\u7910\u791A\u791C\u791E\u791F\u7920\u7925\u7927\u7929\u792D\u7931\u7934\u7935\u793B\u793D\u793F\u7944\u7945\u7946\u794A\u794B\u794F\u7951\u7954\u7958\u795B\u795C\u7967\u7969\u796B\u7972\u7979\u797B\u797C\u797E\u798B\u798C\u7991\u7993\u7994\u7995\u7996\u7998\u799B\u799C\u79A1\u79A8\u79A9\u79AB\u79AF\u79B1\u79B4\u79B8\u79BB\u79C2\u79C4\u79C7\u79C8\u79CA\u79CF\u79D4\u79D6\u79DA\u79DD\u79DE"],
      ["8fd1a1", "\u79E0\u79E2\u79E5\u79EA\u79EB\u79ED\u79F1\u79F8\u79FC\u7A02\u7A03\u7A07\u7A09\u7A0A\u7A0C\u7A11\u7A15\u7A1B\u7A1E\u7A21\u7A27\u7A2B\u7A2D\u7A2F\u7A30\u7A34\u7A35\u7A38\u7A39\u7A3A\u7A44\u7A45\u7A47\u7A48\u7A4C\u7A55\u7A56\u7A59\u7A5C\u7A5D\u7A5F\u7A60\u7A65\u7A67\u7A6A\u7A6D\u7A75\u7A78\u7A7E\u7A80\u7A82\u7A85\u7A86\u7A8A\u7A8B\u7A90\u7A91\u7A94\u7A9E\u7AA0\u7AA3\u7AAC\u7AB3\u7AB5\u7AB9\u7ABB\u7ABC\u7AC6\u7AC9\u7ACC\u7ACE\u7AD1\u7ADB\u7AE8\u7AE9\u7AEB\u7AEC\u7AF1\u7AF4\u7AFB\u7AFD\u7AFE\u7B07\u7B14\u7B1F\u7B23\u7B27\u7B29\u7B2A\u7B2B\u7B2D\u7B2E\u7B2F\u7B30"],
      ["8fd2a1", "\u7B31\u7B34\u7B3D\u7B3F\u7B40\u7B41\u7B47\u7B4E\u7B55\u7B60\u7B64\u7B66\u7B69\u7B6A\u7B6D\u7B6F\u7B72\u7B73\u7B77\u7B84\u7B89\u7B8E\u7B90\u7B91\u7B96\u7B9B\u7B9E\u7BA0\u7BA5\u7BAC\u7BAF\u7BB0\u7BB2\u7BB5\u7BB6\u7BBA\u7BBB\u7BBC\u7BBD\u7BC2\u7BC5\u7BC8\u7BCA\u7BD4\u7BD6\u7BD7\u7BD9\u7BDA\u7BDB\u7BE8\u7BEA\u7BF2\u7BF4\u7BF5\u7BF8\u7BF9\u7BFA\u7BFC\u7BFE\u7C01\u7C02\u7C03\u7C04\u7C06\u7C09\u7C0B\u7C0C\u7C0E\u7C0F\u7C19\u7C1B\u7C20\u7C25\u7C26\u7C28\u7C2C\u7C31\u7C33\u7C34\u7C36\u7C39\u7C3A\u7C46\u7C4A\u7C55\u7C51\u7C52\u7C53\u7C59", 5],
      ["8fd3a1", "\u7C61\u7C63\u7C67\u7C69\u7C6D\u7C6E\u7C70\u7C72\u7C79\u7C7C\u7C7D\u7C86\u7C87\u7C8F\u7C94\u7C9E\u7CA0\u7CA6\u7CB0\u7CB6\u7CB7\u7CBA\u7CBB\u7CBC\u7CBF\u7CC4\u7CC7\u7CC8\u7CC9\u7CCD\u7CCF\u7CD3\u7CD4\u7CD5\u7CD7\u7CD9\u7CDA\u7CDD\u7CE6\u7CE9\u7CEB\u7CF5\u7D03\u7D07\u7D08\u7D09\u7D0F\u7D11\u7D12\u7D13\u7D16\u7D1D\u7D1E\u7D23\u7D26\u7D2A\u7D2D\u7D31\u7D3C\u7D3D\u7D3E\u7D40\u7D41\u7D47\u7D48\u7D4D\u7D51\u7D53\u7D57\u7D59\u7D5A\u7D5C\u7D5D\u7D65\u7D67\u7D6A\u7D70\u7D78\u7D7A\u7D7B\u7D7F\u7D81\u7D82\u7D83\u7D85\u7D86\u7D88\u7D8B\u7D8C\u7D8D\u7D91\u7D96\u7D97\u7D9D"],
      ["8fd4a1", "\u7D9E\u7DA6\u7DA7\u7DAA\u7DB3\u7DB6\u7DB7\u7DB9\u7DC2", 4, "\u7DCC\u7DCD\u7DCE\u7DD7\u7DD9\u7E00\u7DE2\u7DE5\u7DE6\u7DEA\u7DEB\u7DED\u7DF1\u7DF5\u7DF6\u7DF9\u7DFA\u7E08\u7E10\u7E11\u7E15\u7E17\u7E1C\u7E1D\u7E20\u7E27\u7E28\u7E2C\u7E2D\u7E2F\u7E33\u7E36\u7E3F\u7E44\u7E45\u7E47\u7E4E\u7E50\u7E52\u7E58\u7E5F\u7E61\u7E62\u7E65\u7E6B\u7E6E\u7E6F\u7E73\u7E78\u7E7E\u7E81\u7E86\u7E87\u7E8A\u7E8D\u7E91\u7E95\u7E98\u7E9A\u7E9D\u7E9E\u7F3C\u7F3B\u7F3D\u7F3E\u7F3F\u7F43\u7F44\u7F47\u7F4F\u7F52\u7F53\u7F5B\u7F5C\u7F5D\u7F61\u7F63\u7F64\u7F65\u7F66\u7F6D"],
      ["8fd5a1", "\u7F71\u7F7D\u7F7E\u7F7F\u7F80\u7F8B\u7F8D\u7F8F\u7F90\u7F91\u7F96\u7F97\u7F9C\u7FA1\u7FA2\u7FA6\u7FAA\u7FAD\u7FB4\u7FBC\u7FBF\u7FC0\u7FC3\u7FC8\u7FCE\u7FCF\u7FDB\u7FDF\u7FE3\u7FE5\u7FE8\u7FEC\u7FEE\u7FEF\u7FF2\u7FFA\u7FFD\u7FFE\u7FFF\u8007\u8008\u800A\u800D\u800E\u800F\u8011\u8013\u8014\u8016\u801D\u801E\u801F\u8020\u8024\u8026\u802C\u802E\u8030\u8034\u8035\u8037\u8039\u803A\u803C\u803E\u8040\u8044\u8060\u8064\u8066\u806D\u8071\u8075\u8081\u8088\u808E\u809C\u809E\u80A6\u80A7\u80AB\u80B8\u80B9\u80C8\u80CD\u80CF\u80D2\u80D4\u80D5\u80D7\u80D8\u80E0\u80ED\u80EE"],
      ["8fd6a1", "\u80F0\u80F2\u80F3\u80F6\u80F9\u80FA\u80FE\u8103\u810B\u8116\u8117\u8118\u811C\u811E\u8120\u8124\u8127\u812C\u8130\u8135\u813A\u813C\u8145\u8147\u814A\u814C\u8152\u8157\u8160\u8161\u8167\u8168\u8169\u816D\u816F\u8177\u8181\u8190\u8184\u8185\u8186\u818B\u818E\u8196\u8198\u819B\u819E\u81A2\u81AE\u81B2\u81B4\u81BB\u81CB\u81C3\u81C5\u81CA\u81CE\u81CF\u81D5\u81D7\u81DB\u81DD\u81DE\u81E1\u81E4\u81EB\u81EC\u81F0\u81F1\u81F2\u81F5\u81F6\u81F8\u81F9\u81FD\u81FF\u8200\u8203\u820F\u8213\u8214\u8219\u821A\u821D\u8221\u8222\u8228\u8232\u8234\u823A\u8243\u8244\u8245\u8246"],
      ["8fd7a1", "\u824B\u824E\u824F\u8251\u8256\u825C\u8260\u8263\u8267\u826D\u8274\u827B\u827D\u827F\u8280\u8281\u8283\u8284\u8287\u8289\u828A\u828E\u8291\u8294\u8296\u8298\u829A\u829B\u82A0\u82A1\u82A3\u82A4\u82A7\u82A8\u82A9\u82AA\u82AE\u82B0\u82B2\u82B4\u82B7\u82BA\u82BC\u82BE\u82BF\u82C6\u82D0\u82D5\u82DA\u82E0\u82E2\u82E4\u82E8\u82EA\u82ED\u82EF\u82F6\u82F7\u82FD\u82FE\u8300\u8301\u8307\u8308\u830A\u830B\u8354\u831B\u831D\u831E\u831F\u8321\u8322\u832C\u832D\u832E\u8330\u8333\u8337\u833A\u833C\u833D\u8342\u8343\u8344\u8347\u834D\u834E\u8351\u8355\u8356\u8357\u8370\u8378"],
      ["8fd8a1", "\u837D\u837F\u8380\u8382\u8384\u8386\u838D\u8392\u8394\u8395\u8398\u8399\u839B\u839C\u839D\u83A6\u83A7\u83A9\u83AC\u83BE\u83BF\u83C0\u83C7\u83C9\u83CF\u83D0\u83D1\u83D4\u83DD\u8353\u83E8\u83EA\u83F6\u83F8\u83F9\u83FC\u8401\u8406\u840A\u840F\u8411\u8415\u8419\u83AD\u842F\u8439\u8445\u8447\u8448\u844A\u844D\u844F\u8451\u8452\u8456\u8458\u8459\u845A\u845C\u8460\u8464\u8465\u8467\u846A\u8470\u8473\u8474\u8476\u8478\u847C\u847D\u8481\u8485\u8492\u8493\u8495\u849E\u84A6\u84A8\u84A9\u84AA\u84AF\u84B1\u84B4\u84BA\u84BD\u84BE\u84C0\u84C2\u84C7\u84C8\u84CC\u84CF\u84D3"],
      ["8fd9a1", "\u84DC\u84E7\u84EA\u84EF\u84F0\u84F1\u84F2\u84F7\u8532\u84FA\u84FB\u84FD\u8502\u8503\u8507\u850C\u850E\u8510\u851C\u851E\u8522\u8523\u8524\u8525\u8527\u852A\u852B\u852F\u8533\u8534\u8536\u853F\u8546\u854F", 4, "\u8556\u8559\u855C", 6, "\u8564\u856B\u856F\u8579\u857A\u857B\u857D\u857F\u8581\u8585\u8586\u8589\u858B\u858C\u858F\u8593\u8598\u859D\u859F\u85A0\u85A2\u85A5\u85A7\u85B4\u85B6\u85B7\u85B8\u85BC\u85BD\u85BE\u85BF\u85C2\u85C7\u85CA\u85CB\u85CE\u85AD\u85D8\u85DA\u85DF\u85E0\u85E6\u85E8\u85ED\u85F3\u85F6\u85FC"],
      ["8fdaa1", "\u85FF\u8600\u8604\u8605\u860D\u860E\u8610\u8611\u8612\u8618\u8619\u861B\u861E\u8621\u8627\u8629\u8636\u8638\u863A\u863C\u863D\u8640\u8642\u8646\u8652\u8653\u8656\u8657\u8658\u8659\u865D\u8660", 4, "\u8669\u866C\u866F\u8675\u8676\u8677\u867A\u868D\u8691\u8696\u8698\u869A\u869C\u86A1\u86A6\u86A7\u86A8\u86AD\u86B1\u86B3\u86B4\u86B5\u86B7\u86B8\u86B9\u86BF\u86C0\u86C1\u86C3\u86C5\u86D1\u86D2\u86D5\u86D7\u86DA\u86DC\u86E0\u86E3\u86E5\u86E7\u8688\u86FA\u86FC\u86FD\u8704\u8705\u8707\u870B\u870E\u870F\u8710\u8713\u8714\u8719\u871E\u871F\u8721\u8723"],
      ["8fdba1", "\u8728\u872E\u872F\u8731\u8732\u8739\u873A\u873C\u873D\u873E\u8740\u8743\u8745\u874D\u8758\u875D\u8761\u8764\u8765\u876F\u8771\u8772\u877B\u8783", 6, "\u878B\u878C\u8790\u8793\u8795\u8797\u8798\u8799\u879E\u87A0\u87A3\u87A7\u87AC\u87AD\u87AE\u87B1\u87B5\u87BE\u87BF\u87C1\u87C8\u87C9\u87CA\u87CE\u87D5\u87D6\u87D9\u87DA\u87DC\u87DF\u87E2\u87E3\u87E4\u87EA\u87EB\u87ED\u87F1\u87F3\u87F8\u87FA\u87FF\u8801\u8803\u8806\u8809\u880A\u880B\u8810\u8819\u8812\u8813\u8814\u8818\u881A\u881B\u881C\u881E\u881F\u8828\u882D\u882E\u8830\u8832\u8835"],
      ["8fdca1", "\u883A\u883C\u8841\u8843\u8845\u8848\u8849\u884A\u884B\u884E\u8851\u8855\u8856\u8858\u885A\u885C\u885F\u8860\u8864\u8869\u8871\u8879\u887B\u8880\u8898\u889A\u889B\u889C\u889F\u88A0\u88A8\u88AA\u88BA\u88BD\u88BE\u88C0\u88CA", 4, "\u88D1\u88D2\u88D3\u88DB\u88DE\u88E7\u88EF\u88F0\u88F1\u88F5\u88F7\u8901\u8906\u890D\u890E\u890F\u8915\u8916\u8918\u8919\u891A\u891C\u8920\u8926\u8927\u8928\u8930\u8931\u8932\u8935\u8939\u893A\u893E\u8940\u8942\u8945\u8946\u8949\u894F\u8952\u8957\u895A\u895B\u895C\u8961\u8962\u8963\u896B\u896E\u8970\u8973\u8975\u897A"],
      ["8fdda1", "\u897B\u897C\u897D\u8989\u898D\u8990\u8994\u8995\u899B\u899C\u899F\u89A0\u89A5\u89B0\u89B4\u89B5\u89B6\u89B7\u89BC\u89D4", 4, "\u89E5\u89E9\u89EB\u89ED\u89F1\u89F3\u89F6\u89F9\u89FD\u89FF\u8A04\u8A05\u8A07\u8A0F\u8A11\u8A12\u8A14\u8A15\u8A1E\u8A20\u8A22\u8A24\u8A26\u8A2B\u8A2C\u8A2F\u8A35\u8A37\u8A3D\u8A3E\u8A40\u8A43\u8A45\u8A47\u8A49\u8A4D\u8A4E\u8A53\u8A56\u8A57\u8A58\u8A5C\u8A5D\u8A61\u8A65\u8A67\u8A75\u8A76\u8A77\u8A79\u8A7A\u8A7B\u8A7E\u8A7F\u8A80\u8A83\u8A86\u8A8B\u8A8F\u8A90\u8A92\u8A96\u8A97\u8A99\u8A9F\u8AA7\u8AA9\u8AAE\u8AAF\u8AB3"],
      ["8fdea1", "\u8AB6\u8AB7\u8ABB\u8ABE\u8AC3\u8AC6\u8AC8\u8AC9\u8ACA\u8AD1\u8AD3\u8AD4\u8AD5\u8AD7\u8ADD\u8ADF\u8AEC\u8AF0\u8AF4\u8AF5\u8AF6\u8AFC\u8AFF\u8B05\u8B06\u8B0B\u8B11\u8B1C\u8B1E\u8B1F\u8B0A\u8B2D\u8B30\u8B37\u8B3C\u8B42", 4, "\u8B48\u8B52\u8B53\u8B54\u8B59\u8B4D\u8B5E\u8B63\u8B6D\u8B76\u8B78\u8B79\u8B7C\u8B7E\u8B81\u8B84\u8B85\u8B8B\u8B8D\u8B8F\u8B94\u8B95\u8B9C\u8B9E\u8B9F\u8C38\u8C39\u8C3D\u8C3E\u8C45\u8C47\u8C49\u8C4B\u8C4F\u8C51\u8C53\u8C54\u8C57\u8C58\u8C5B\u8C5D\u8C59\u8C63\u8C64\u8C66\u8C68\u8C69\u8C6D\u8C73\u8C75\u8C76\u8C7B\u8C7E\u8C86"],
      ["8fdfa1", "\u8C87\u8C8B\u8C90\u8C92\u8C93\u8C99\u8C9B\u8C9C\u8CA4\u8CB9\u8CBA\u8CC5\u8CC6\u8CC9\u8CCB\u8CCF\u8CD6\u8CD5\u8CD9\u8CDD\u8CE1\u8CE8\u8CEC\u8CEF\u8CF0\u8CF2\u8CF5\u8CF7\u8CF8\u8CFE\u8CFF\u8D01\u8D03\u8D09\u8D12\u8D17\u8D1B\u8D65\u8D69\u8D6C\u8D6E\u8D7F\u8D82\u8D84\u8D88\u8D8D\u8D90\u8D91\u8D95\u8D9E\u8D9F\u8DA0\u8DA6\u8DAB\u8DAC\u8DAF\u8DB2\u8DB5\u8DB7\u8DB9\u8DBB\u8DC0\u8DC5\u8DC6\u8DC7\u8DC8\u8DCA\u8DCE\u8DD1\u8DD4\u8DD5\u8DD7\u8DD9\u8DE4\u8DE5\u8DE7\u8DEC\u8DF0\u8DBC\u8DF1\u8DF2\u8DF4\u8DFD\u8E01\u8E04\u8E05\u8E06\u8E0B\u8E11\u8E14\u8E16\u8E20\u8E21\u8E22"],
      ["8fe0a1", "\u8E23\u8E26\u8E27\u8E31\u8E33\u8E36\u8E37\u8E38\u8E39\u8E3D\u8E40\u8E41\u8E4B\u8E4D\u8E4E\u8E4F\u8E54\u8E5B\u8E5C\u8E5D\u8E5E\u8E61\u8E62\u8E69\u8E6C\u8E6D\u8E6F\u8E70\u8E71\u8E79\u8E7A\u8E7B\u8E82\u8E83\u8E89\u8E90\u8E92\u8E95\u8E9A\u8E9B\u8E9D\u8E9E\u8EA2\u8EA7\u8EA9\u8EAD\u8EAE\u8EB3\u8EB5\u8EBA\u8EBB\u8EC0\u8EC1\u8EC3\u8EC4\u8EC7\u8ECF\u8ED1\u8ED4\u8EDC\u8EE8\u8EEE\u8EF0\u8EF1\u8EF7\u8EF9\u8EFA\u8EED\u8F00\u8F02\u8F07\u8F08\u8F0F\u8F10\u8F16\u8F17\u8F18\u8F1E\u8F20\u8F21\u8F23\u8F25\u8F27\u8F28\u8F2C\u8F2D\u8F2E\u8F34\u8F35\u8F36\u8F37\u8F3A\u8F40\u8F41"],
      ["8fe1a1", "\u8F43\u8F47\u8F4F\u8F51", 4, "\u8F58\u8F5D\u8F5E\u8F65\u8F9D\u8FA0\u8FA1\u8FA4\u8FA5\u8FA6\u8FB5\u8FB6\u8FB8\u8FBE\u8FC0\u8FC1\u8FC6\u8FCA\u8FCB\u8FCD\u8FD0\u8FD2\u8FD3\u8FD5\u8FE0\u8FE3\u8FE4\u8FE8\u8FEE\u8FF1\u8FF5\u8FF6\u8FFB\u8FFE\u9002\u9004\u9008\u900C\u9018\u901B\u9028\u9029\u902F\u902A\u902C\u902D\u9033\u9034\u9037\u903F\u9043\u9044\u904C\u905B\u905D\u9062\u9066\u9067\u906C\u9070\u9074\u9079\u9085\u9088\u908B\u908C\u908E\u9090\u9095\u9097\u9098\u9099\u909B\u90A0\u90A1\u90A2\u90A5\u90B0\u90B2\u90B3\u90B4\u90B6\u90BD\u90CC\u90BE\u90C3"],
      ["8fe2a1", "\u90C4\u90C5\u90C7\u90C8\u90D5\u90D7\u90D8\u90D9\u90DC\u90DD\u90DF\u90E5\u90D2\u90F6\u90EB\u90EF\u90F0\u90F4\u90FE\u90FF\u9100\u9104\u9105\u9106\u9108\u910D\u9110\u9114\u9116\u9117\u9118\u911A\u911C\u911E\u9120\u9125\u9122\u9123\u9127\u9129\u912E\u912F\u9131\u9134\u9136\u9137\u9139\u913A\u913C\u913D\u9143\u9147\u9148\u914F\u9153\u9157\u9159\u915A\u915B\u9161\u9164\u9167\u916D\u9174\u9179\u917A\u917B\u9181\u9183\u9185\u9186\u918A\u918E\u9191\u9193\u9194\u9195\u9198\u919E\u91A1\u91A6\u91A8\u91AC\u91AD\u91AE\u91B0\u91B1\u91B2\u91B3\u91B6\u91BB\u91BC\u91BD\u91BF"],
      ["8fe3a1", "\u91C2\u91C3\u91C5\u91D3\u91D4\u91D7\u91D9\u91DA\u91DE\u91E4\u91E5\u91E9\u91EA\u91EC", 5, "\u91F7\u91F9\u91FB\u91FD\u9200\u9201\u9204\u9205\u9206\u9207\u9209\u920A\u920C\u9210\u9212\u9213\u9216\u9218\u921C\u921D\u9223\u9224\u9225\u9226\u9228\u922E\u922F\u9230\u9233\u9235\u9236\u9238\u9239\u923A\u923C\u923E\u9240\u9242\u9243\u9246\u9247\u924A\u924D\u924E\u924F\u9251\u9258\u9259\u925C\u925D\u9260\u9261\u9265\u9267\u9268\u9269\u926E\u926F\u9270\u9275", 4, "\u927B\u927C\u927D\u927F\u9288\u9289\u928A\u928D\u928E\u9292\u9297"],
      ["8fe4a1", "\u9299\u929F\u92A0\u92A4\u92A5\u92A7\u92A8\u92AB\u92AF\u92B2\u92B6\u92B8\u92BA\u92BB\u92BC\u92BD\u92BF", 4, "\u92C5\u92C6\u92C7\u92C8\u92CB\u92CC\u92CD\u92CE\u92D0\u92D3\u92D5\u92D7\u92D8\u92D9\u92DC\u92DD\u92DF\u92E0\u92E1\u92E3\u92E5\u92E7\u92E8\u92EC\u92EE\u92F0\u92F9\u92FB\u92FF\u9300\u9302\u9308\u930D\u9311\u9314\u9315\u931C\u931D\u931E\u931F\u9321\u9324\u9325\u9327\u9329\u932A\u9333\u9334\u9336\u9337\u9347\u9348\u9349\u9350\u9351\u9352\u9355\u9357\u9358\u935A\u935E\u9364\u9365\u9367\u9369\u936A\u936D\u936F\u9370\u9371\u9373\u9374\u9376"],
      ["8fe5a1", "\u937A\u937D\u937F\u9380\u9381\u9382\u9388\u938A\u938B\u938D\u938F\u9392\u9395\u9398\u939B\u939E\u93A1\u93A3\u93A4\u93A6\u93A8\u93AB\u93B4\u93B5\u93B6\u93BA\u93A9\u93C1\u93C4\u93C5\u93C6\u93C7\u93C9", 4, "\u93D3\u93D9\u93DC\u93DE\u93DF\u93E2\u93E6\u93E7\u93F9\u93F7\u93F8\u93FA\u93FB\u93FD\u9401\u9402\u9404\u9408\u9409\u940D\u940E\u940F\u9415\u9416\u9417\u941F\u942E\u942F\u9431\u9432\u9433\u9434\u943B\u943F\u943D\u9443\u9445\u9448\u944A\u944C\u9455\u9459\u945C\u945F\u9461\u9463\u9468\u946B\u946D\u946E\u946F\u9471\u9472\u9484\u9483\u9578\u9579"],
      ["8fe6a1", "\u957E\u9584\u9588\u958C\u958D\u958E\u959D\u959E\u959F\u95A1\u95A6\u95A9\u95AB\u95AC\u95B4\u95B6\u95BA\u95BD\u95BF\u95C6\u95C8\u95C9\u95CB\u95D0\u95D1\u95D2\u95D3\u95D9\u95DA\u95DD\u95DE\u95DF\u95E0\u95E4\u95E6\u961D\u961E\u9622\u9624\u9625\u9626\u962C\u9631\u9633\u9637\u9638\u9639\u963A\u963C\u963D\u9641\u9652\u9654\u9656\u9657\u9658\u9661\u966E\u9674\u967B\u967C\u967E\u967F\u9681\u9682\u9683\u9684\u9689\u9691\u9696\u969A\u969D\u969F\u96A4\u96A5\u96A6\u96A9\u96AE\u96AF\u96B3\u96BA\u96CA\u96D2\u5DB2\u96D8\u96DA\u96DD\u96DE\u96DF\u96E9\u96EF\u96F1\u96FA\u9702"],
      ["8fe7a1", "\u9703\u9705\u9709\u971A\u971B\u971D\u9721\u9722\u9723\u9728\u9731\u9733\u9741\u9743\u974A\u974E\u974F\u9755\u9757\u9758\u975A\u975B\u9763\u9767\u976A\u976E\u9773\u9776\u9777\u9778\u977B\u977D\u977F\u9780\u9789\u9795\u9796\u9797\u9799\u979A\u979E\u979F\u97A2\u97AC\u97AE\u97B1\u97B2\u97B5\u97B6\u97B8\u97B9\u97BA\u97BC\u97BE\u97BF\u97C1\u97C4\u97C5\u97C7\u97C9\u97CA\u97CC\u97CD\u97CE\u97D0\u97D1\u97D4\u97D7\u97D8\u97D9\u97DD\u97DE\u97E0\u97DB\u97E1\u97E4\u97EF\u97F1\u97F4\u97F7\u97F8\u97FA\u9807\u980A\u9819\u980D\u980E\u9814\u9816\u981C\u981E\u9820\u9823\u9826"],
      ["8fe8a1", "\u982B\u982E\u982F\u9830\u9832\u9833\u9835\u9825\u983E\u9844\u9847\u984A\u9851\u9852\u9853\u9856\u9857\u9859\u985A\u9862\u9863\u9865\u9866\u986A\u986C\u98AB\u98AD\u98AE\u98B0\u98B4\u98B7\u98B8\u98BA\u98BB\u98BF\u98C2\u98C5\u98C8\u98CC\u98E1\u98E3\u98E5\u98E6\u98E7\u98EA\u98F3\u98F6\u9902\u9907\u9908\u9911\u9915\u9916\u9917\u991A\u991B\u991C\u991F\u9922\u9926\u9927\u992B\u9931", 4, "\u9939\u993A\u993B\u993C\u9940\u9941\u9946\u9947\u9948\u994D\u994E\u9954\u9958\u9959\u995B\u995C\u995E\u995F\u9960\u999B\u999D\u999F\u99A6\u99B0\u99B1\u99B2\u99B5"],
      ["8fe9a1", "\u99B9\u99BA\u99BD\u99BF\u99C3\u99C9\u99D3\u99D4\u99D9\u99DA\u99DC\u99DE\u99E7\u99EA\u99EB\u99EC\u99F0\u99F4\u99F5\u99F9\u99FD\u99FE\u9A02\u9A03\u9A04\u9A0B\u9A0C\u9A10\u9A11\u9A16\u9A1E\u9A20\u9A22\u9A23\u9A24\u9A27\u9A2D\u9A2E\u9A33\u9A35\u9A36\u9A38\u9A47\u9A41\u9A44\u9A4A\u9A4B\u9A4C\u9A4E\u9A51\u9A54\u9A56\u9A5D\u9AAA\u9AAC\u9AAE\u9AAF\u9AB2\u9AB4\u9AB5\u9AB6\u9AB9\u9ABB\u9ABE\u9ABF\u9AC1\u9AC3\u9AC6\u9AC8\u9ACE\u9AD0\u9AD2\u9AD5\u9AD6\u9AD7\u9ADB\u9ADC\u9AE0\u9AE4\u9AE5\u9AE7\u9AE9\u9AEC\u9AF2\u9AF3\u9AF5\u9AF9\u9AFA\u9AFD\u9AFF", 4],
      ["8feaa1", "\u9B04\u9B05\u9B08\u9B09\u9B0B\u9B0C\u9B0D\u9B0E\u9B10\u9B12\u9B16\u9B19\u9B1B\u9B1C\u9B20\u9B26\u9B2B\u9B2D\u9B33\u9B34\u9B35\u9B37\u9B39\u9B3A\u9B3D\u9B48\u9B4B\u9B4C\u9B55\u9B56\u9B57\u9B5B\u9B5E\u9B61\u9B63\u9B65\u9B66\u9B68\u9B6A", 4, "\u9B73\u9B75\u9B77\u9B78\u9B79\u9B7F\u9B80\u9B84\u9B85\u9B86\u9B87\u9B89\u9B8A\u9B8B\u9B8D\u9B8F\u9B90\u9B94\u9B9A\u9B9D\u9B9E\u9BA6\u9BA7\u9BA9\u9BAC\u9BB0\u9BB1\u9BB2\u9BB7\u9BB8\u9BBB\u9BBC\u9BBE\u9BBF\u9BC1\u9BC7\u9BC8\u9BCE\u9BD0\u9BD7\u9BD8\u9BDD\u9BDF\u9BE5\u9BE7\u9BEA\u9BEB\u9BEF\u9BF3\u9BF7\u9BF8"],
      ["8feba1", "\u9BF9\u9BFA\u9BFD\u9BFF\u9C00\u9C02\u9C0B\u9C0F\u9C11\u9C16\u9C18\u9C19\u9C1A\u9C1C\u9C1E\u9C22\u9C23\u9C26", 4, "\u9C31\u9C35\u9C36\u9C37\u9C3D\u9C41\u9C43\u9C44\u9C45\u9C49\u9C4A\u9C4E\u9C4F\u9C50\u9C53\u9C54\u9C56\u9C58\u9C5B\u9C5D\u9C5E\u9C5F\u9C63\u9C69\u9C6A\u9C5C\u9C6B\u9C68\u9C6E\u9C70\u9C72\u9C75\u9C77\u9C7B\u9CE6\u9CF2\u9CF7\u9CF9\u9D0B\u9D02\u9D11\u9D17\u9D18\u9D1C\u9D1D\u9D1E\u9D2F\u9D30\u9D32\u9D33\u9D34\u9D3A\u9D3C\u9D45\u9D3D\u9D42\u9D43\u9D47\u9D4A\u9D53\u9D54\u9D5F\u9D63\u9D62\u9D65\u9D69\u9D6A\u9D6B\u9D70\u9D76\u9D77\u9D7B"],
      ["8feca1", "\u9D7C\u9D7E\u9D83\u9D84\u9D86\u9D8A\u9D8D\u9D8E\u9D92\u9D93\u9D95\u9D96\u9D97\u9D98\u9DA1\u9DAA\u9DAC\u9DAE\u9DB1\u9DB5\u9DB9\u9DBC\u9DBF\u9DC3\u9DC7\u9DC9\u9DCA\u9DD4\u9DD5\u9DD6\u9DD7\u9DDA\u9DDE\u9DDF\u9DE0\u9DE5\u9DE7\u9DE9\u9DEB\u9DEE\u9DF0\u9DF3\u9DF4\u9DFE\u9E0A\u9E02\u9E07\u9E0E\u9E10\u9E11\u9E12\u9E15\u9E16\u9E19\u9E1C\u9E1D\u9E7A\u9E7B\u9E7C\u9E80\u9E82\u9E83\u9E84\u9E85\u9E87\u9E8E\u9E8F\u9E96\u9E98\u9E9B\u9E9E\u9EA4\u9EA8\u9EAC\u9EAE\u9EAF\u9EB0\u9EB3\u9EB4\u9EB5\u9EC6\u9EC8\u9ECB\u9ED5\u9EDF\u9EE4\u9EE7\u9EEC\u9EED\u9EEE\u9EF0\u9EF1\u9EF2\u9EF5"],
      ["8feda1", "\u9EF8\u9EFF\u9F02\u9F03\u9F09\u9F0F\u9F10\u9F11\u9F12\u9F14\u9F16\u9F17\u9F19\u9F1A\u9F1B\u9F1F\u9F22\u9F26\u9F2A\u9F2B\u9F2F\u9F31\u9F32\u9F34\u9F37\u9F39\u9F3A\u9F3C\u9F3D\u9F3F\u9F41\u9F43", 4, "\u9F53\u9F55\u9F56\u9F57\u9F58\u9F5A\u9F5D\u9F5E\u9F68\u9F69\u9F6D", 4, "\u9F73\u9F75\u9F7A\u9F7D\u9F8F\u9F90\u9F91\u9F92\u9F94\u9F96\u9F97\u9F9E\u9FA1\u9FA2\u9FA3\u9FA5"]
    ];
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/tables/cp936.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127, "\u20AC"],
      ["8140", "\u4E02\u4E04\u4E05\u4E06\u4E0F\u4E12\u4E17\u4E1F\u4E20\u4E21\u4E23\u4E26\u4E29\u4E2E\u4E2F\u4E31\u4E33\u4E35\u4E37\u4E3C\u4E40\u4E41\u4E42\u4E44\u4E46\u4E4A\u4E51\u4E55\u4E57\u4E5A\u4E5B\u4E62\u4E63\u4E64\u4E65\u4E67\u4E68\u4E6A", 5, "\u4E72\u4E74", 9, "\u4E7F", 6, "\u4E87\u4E8A"],
      ["8180", "\u4E90\u4E96\u4E97\u4E99\u4E9C\u4E9D\u4E9E\u4EA3\u4EAA\u4EAF\u4EB0\u4EB1\u4EB4\u4EB6\u4EB7\u4EB8\u4EB9\u4EBC\u4EBD\u4EBE\u4EC8\u4ECC\u4ECF\u4ED0\u4ED2\u4EDA\u4EDB\u4EDC\u4EE0\u4EE2\u4EE6\u4EE7\u4EE9\u4EED\u4EEE\u4EEF\u4EF1\u4EF4\u4EF8\u4EF9\u4EFA\u4EFC\u4EFE\u4F00\u4F02", 6, "\u4F0B\u4F0C\u4F12", 4, "\u4F1C\u4F1D\u4F21\u4F23\u4F28\u4F29\u4F2C\u4F2D\u4F2E\u4F31\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E", 4, "\u4F44\u4F45\u4F47", 5, "\u4F52\u4F54\u4F56\u4F61\u4F62\u4F66\u4F68\u4F6A\u4F6B\u4F6D\u4F6E\u4F71\u4F72\u4F75\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F80\u4F81\u4F82\u4F85\u4F86\u4F87\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F95\u4F96\u4F98\u4F99\u4F9A\u4F9C\u4F9E\u4F9F\u4FA1\u4FA2"],
      ["8240", "\u4FA4\u4FAB\u4FAD\u4FB0", 4, "\u4FB6", 8, "\u4FC0\u4FC1\u4FC2\u4FC6\u4FC7\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FD2", 4, "\u4FD9\u4FDB\u4FE0\u4FE2\u4FE4\u4FE5\u4FE7\u4FEB\u4FEC\u4FF0\u4FF2\u4FF4\u4FF5\u4FF6\u4FF7\u4FF9\u4FFB\u4FFC\u4FFD\u4FFF", 11],
      ["8280", "\u500B\u500E\u5010\u5011\u5013\u5015\u5016\u5017\u501B\u501D\u501E\u5020\u5022\u5023\u5024\u5027\u502B\u502F", 10, "\u503B\u503D\u503F\u5040\u5041\u5042\u5044\u5045\u5046\u5049\u504A\u504B\u504D\u5050", 4, "\u5056\u5057\u5058\u5059\u505B\u505D", 7, "\u5066", 5, "\u506D", 8, "\u5078\u5079\u507A\u507C\u507D\u5081\u5082\u5083\u5084\u5086\u5087\u5089\u508A\u508B\u508C\u508E", 20, "\u50A4\u50A6\u50AA\u50AB\u50AD", 4, "\u50B3", 6, "\u50BC"],
      ["8340", "\u50BD", 17, "\u50D0", 5, "\u50D7\u50D8\u50D9\u50DB", 10, "\u50E8\u50E9\u50EA\u50EB\u50EF\u50F0\u50F1\u50F2\u50F4\u50F6", 4, "\u50FC", 9, "\u5108"],
      ["8380", "\u5109\u510A\u510C", 5, "\u5113", 13, "\u5122", 28, "\u5142\u5147\u514A\u514C\u514E\u514F\u5150\u5152\u5153\u5157\u5158\u5159\u515B\u515D", 4, "\u5163\u5164\u5166\u5167\u5169\u516A\u516F\u5172\u517A\u517E\u517F\u5183\u5184\u5186\u5187\u518A\u518B\u518E\u518F\u5190\u5191\u5193\u5194\u5198\u519A\u519D\u519E\u519F\u51A1\u51A3\u51A6", 4, "\u51AD\u51AE\u51B4\u51B8\u51B9\u51BA\u51BE\u51BF\u51C1\u51C2\u51C3\u51C5\u51C8\u51CA\u51CD\u51CE\u51D0\u51D2", 5],
      ["8440", "\u51D8\u51D9\u51DA\u51DC\u51DE\u51DF\u51E2\u51E3\u51E5", 5, "\u51EC\u51EE\u51F1\u51F2\u51F4\u51F7\u51FE\u5204\u5205\u5209\u520B\u520C\u520F\u5210\u5213\u5214\u5215\u521C\u521E\u521F\u5221\u5222\u5223\u5225\u5226\u5227\u522A\u522C\u522F\u5231\u5232\u5234\u5235\u523C\u523E\u5244", 5, "\u524B\u524E\u524F\u5252\u5253\u5255\u5257\u5258"],
      ["8480", "\u5259\u525A\u525B\u525D\u525F\u5260\u5262\u5263\u5264\u5266\u5268\u526B\u526C\u526D\u526E\u5270\u5271\u5273", 9, "\u527E\u5280\u5283", 4, "\u5289", 6, "\u5291\u5292\u5294", 6, "\u529C\u52A4\u52A5\u52A6\u52A7\u52AE\u52AF\u52B0\u52B4", 9, "\u52C0\u52C1\u52C2\u52C4\u52C5\u52C6\u52C8\u52CA\u52CC\u52CD\u52CE\u52CF\u52D1\u52D3\u52D4\u52D5\u52D7\u52D9", 5, "\u52E0\u52E1\u52E2\u52E3\u52E5", 10, "\u52F1", 7, "\u52FB\u52FC\u52FD\u5301\u5302\u5303\u5304\u5307\u5309\u530A\u530B\u530C\u530E"],
      ["8540", "\u5311\u5312\u5313\u5314\u5318\u531B\u531C\u531E\u531F\u5322\u5324\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u532F", 9, "\u533C\u533D\u5340\u5342\u5344\u5346\u534B\u534C\u534D\u5350\u5354\u5358\u5359\u535B\u535D\u5365\u5368\u536A\u536C\u536D\u5372\u5376\u5379\u537B\u537C\u537D\u537E\u5380\u5381\u5383\u5387\u5388\u538A\u538E\u538F"],
      ["8580", "\u5390", 4, "\u5396\u5397\u5399\u539B\u539C\u539E\u53A0\u53A1\u53A4\u53A7\u53AA\u53AB\u53AC\u53AD\u53AF", 6, "\u53B7\u53B8\u53B9\u53BA\u53BC\u53BD\u53BE\u53C0\u53C3", 4, "\u53CE\u53CF\u53D0\u53D2\u53D3\u53D5\u53DA\u53DC\u53DD\u53DE\u53E1\u53E2\u53E7\u53F4\u53FA\u53FE\u53FF\u5400\u5402\u5405\u5407\u540B\u5414\u5418\u5419\u541A\u541C\u5422\u5424\u5425\u542A\u5430\u5433\u5436\u5437\u543A\u543D\u543F\u5441\u5442\u5444\u5445\u5447\u5449\u544C\u544D\u544E\u544F\u5451\u545A\u545D", 4, "\u5463\u5465\u5467\u5469", 7, "\u5474\u5479\u547A\u547E\u547F\u5481\u5483\u5485\u5487\u5488\u5489\u548A\u548D\u5491\u5493\u5497\u5498\u549C\u549E\u549F\u54A0\u54A1"],
      ["8640", "\u54A2\u54A5\u54AE\u54B0\u54B2\u54B5\u54B6\u54B7\u54B9\u54BA\u54BC\u54BE\u54C3\u54C5\u54CA\u54CB\u54D6\u54D8\u54DB\u54E0", 4, "\u54EB\u54EC\u54EF\u54F0\u54F1\u54F4", 5, "\u54FB\u54FE\u5500\u5502\u5503\u5504\u5505\u5508\u550A", 4, "\u5512\u5513\u5515", 5, "\u551C\u551D\u551E\u551F\u5521\u5525\u5526"],
      ["8680", "\u5528\u5529\u552B\u552D\u5532\u5534\u5535\u5536\u5538\u5539\u553A\u553B\u553D\u5540\u5542\u5545\u5547\u5548\u554B", 4, "\u5551\u5552\u5553\u5554\u5557", 4, "\u555D\u555E\u555F\u5560\u5562\u5563\u5568\u5569\u556B\u556F", 5, "\u5579\u557A\u557D\u557F\u5585\u5586\u558C\u558D\u558E\u5590\u5592\u5593\u5595\u5596\u5597\u559A\u559B\u559E\u55A0", 6, "\u55A8", 8, "\u55B2\u55B4\u55B6\u55B8\u55BA\u55BC\u55BF", 4, "\u55C6\u55C7\u55C8\u55CA\u55CB\u55CE\u55CF\u55D0\u55D5\u55D7", 4, "\u55DE\u55E0\u55E2\u55E7\u55E9\u55ED\u55EE\u55F0\u55F1\u55F4\u55F6\u55F8", 4, "\u55FF\u5602\u5603\u5604\u5605"],
      ["8740", "\u5606\u5607\u560A\u560B\u560D\u5610", 7, "\u5619\u561A\u561C\u561D\u5620\u5621\u5622\u5625\u5626\u5628\u5629\u562A\u562B\u562E\u562F\u5630\u5633\u5635\u5637\u5638\u563A\u563C\u563D\u563E\u5640", 11, "\u564F", 4, "\u5655\u5656\u565A\u565B\u565D", 4],
      ["8780", "\u5663\u5665\u5666\u5667\u566D\u566E\u566F\u5670\u5672\u5673\u5674\u5675\u5677\u5678\u5679\u567A\u567D", 7, "\u5687", 6, "\u5690\u5691\u5692\u5694", 14, "\u56A4", 10, "\u56B0", 6, "\u56B8\u56B9\u56BA\u56BB\u56BD", 12, "\u56CB", 8, "\u56D5\u56D6\u56D8\u56D9\u56DC\u56E3\u56E5", 5, "\u56EC\u56EE\u56EF\u56F2\u56F3\u56F6\u56F7\u56F8\u56FB\u56FC\u5700\u5701\u5702\u5705\u5707\u570B", 6],
      ["8840", "\u5712", 9, "\u571D\u571E\u5720\u5721\u5722\u5724\u5725\u5726\u5727\u572B\u5731\u5732\u5734", 4, "\u573C\u573D\u573F\u5741\u5743\u5744\u5745\u5746\u5748\u5749\u574B\u5752", 4, "\u5758\u5759\u5762\u5763\u5765\u5767\u576C\u576E\u5770\u5771\u5772\u5774\u5775\u5778\u5779\u577A\u577D\u577E\u577F\u5780"],
      ["8880", "\u5781\u5787\u5788\u5789\u578A\u578D", 4, "\u5794", 6, "\u579C\u579D\u579E\u579F\u57A5\u57A8\u57AA\u57AC\u57AF\u57B0\u57B1\u57B3\u57B5\u57B6\u57B7\u57B9", 8, "\u57C4", 6, "\u57CC\u57CD\u57D0\u57D1\u57D3\u57D6\u57D7\u57DB\u57DC\u57DE\u57E1\u57E2\u57E3\u57E5", 7, "\u57EE\u57F0\u57F1\u57F2\u57F3\u57F5\u57F6\u57F7\u57FB\u57FC\u57FE\u57FF\u5801\u5803\u5804\u5805\u5808\u5809\u580A\u580C\u580E\u580F\u5810\u5812\u5813\u5814\u5816\u5817\u5818\u581A\u581B\u581C\u581D\u581F\u5822\u5823\u5825", 4, "\u582B", 4, "\u5831\u5832\u5833\u5834\u5836", 7],
      ["8940", "\u583E", 5, "\u5845", 6, "\u584E\u584F\u5850\u5852\u5853\u5855\u5856\u5857\u5859", 4, "\u585F", 5, "\u5866", 4, "\u586D", 16, "\u587F\u5882\u5884\u5886\u5887\u5888\u588A\u588B\u588C"],
      ["8980", "\u588D", 4, "\u5894", 4, "\u589B\u589C\u589D\u58A0", 7, "\u58AA", 17, "\u58BD\u58BE\u58BF\u58C0\u58C2\u58C3\u58C4\u58C6", 10, "\u58D2\u58D3\u58D4\u58D6", 13, "\u58E5", 5, "\u58ED\u58EF\u58F1\u58F2\u58F4\u58F5\u58F7\u58F8\u58FA", 7, "\u5903\u5905\u5906\u5908", 4, "\u590E\u5910\u5911\u5912\u5913\u5917\u5918\u591B\u591D\u591E\u5920\u5921\u5922\u5923\u5926\u5928\u592C\u5930\u5932\u5933\u5935\u5936\u593B"],
      ["8a40", "\u593D\u593E\u593F\u5940\u5943\u5945\u5946\u594A\u594C\u594D\u5950\u5952\u5953\u5959\u595B", 4, "\u5961\u5963\u5964\u5966", 12, "\u5975\u5977\u597A\u597B\u597C\u597E\u597F\u5980\u5985\u5989\u598B\u598C\u598E\u598F\u5990\u5991\u5994\u5995\u5998\u599A\u599B\u599C\u599D\u599F\u59A0\u59A1\u59A2\u59A6"],
      ["8a80", "\u59A7\u59AC\u59AD\u59B0\u59B1\u59B3", 5, "\u59BA\u59BC\u59BD\u59BF", 6, "\u59C7\u59C8\u59C9\u59CC\u59CD\u59CE\u59CF\u59D5\u59D6\u59D9\u59DB\u59DE", 4, "\u59E4\u59E6\u59E7\u59E9\u59EA\u59EB\u59ED", 11, "\u59FA\u59FC\u59FD\u59FE\u5A00\u5A02\u5A0A\u5A0B\u5A0D\u5A0E\u5A0F\u5A10\u5A12\u5A14\u5A15\u5A16\u5A17\u5A19\u5A1A\u5A1B\u5A1D\u5A1E\u5A21\u5A22\u5A24\u5A26\u5A27\u5A28\u5A2A", 6, "\u5A33\u5A35\u5A37", 4, "\u5A3D\u5A3E\u5A3F\u5A41", 4, "\u5A47\u5A48\u5A4B", 9, "\u5A56\u5A57\u5A58\u5A59\u5A5B", 5],
      ["8b40", "\u5A61\u5A63\u5A64\u5A65\u5A66\u5A68\u5A69\u5A6B", 8, "\u5A78\u5A79\u5A7B\u5A7C\u5A7D\u5A7E\u5A80", 17, "\u5A93", 6, "\u5A9C", 13, "\u5AAB\u5AAC"],
      ["8b80", "\u5AAD", 4, "\u5AB4\u5AB6\u5AB7\u5AB9", 4, "\u5ABF\u5AC0\u5AC3", 5, "\u5ACA\u5ACB\u5ACD", 4, "\u5AD3\u5AD5\u5AD7\u5AD9\u5ADA\u5ADB\u5ADD\u5ADE\u5ADF\u5AE2\u5AE4\u5AE5\u5AE7\u5AE8\u5AEA\u5AEC", 4, "\u5AF2", 22, "\u5B0A", 11, "\u5B18", 25, "\u5B33\u5B35\u5B36\u5B38", 7, "\u5B41", 6],
      ["8c40", "\u5B48", 7, "\u5B52\u5B56\u5B5E\u5B60\u5B61\u5B67\u5B68\u5B6B\u5B6D\u5B6E\u5B6F\u5B72\u5B74\u5B76\u5B77\u5B78\u5B79\u5B7B\u5B7C\u5B7E\u5B7F\u5B82\u5B86\u5B8A\u5B8D\u5B8E\u5B90\u5B91\u5B92\u5B94\u5B96\u5B9F\u5BA7\u5BA8\u5BA9\u5BAC\u5BAD\u5BAE\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBB\u5BBC\u5BC0\u5BC1\u5BC3\u5BC8\u5BC9\u5BCA\u5BCB\u5BCD\u5BCE\u5BCF"],
      ["8c80", "\u5BD1\u5BD4", 8, "\u5BE0\u5BE2\u5BE3\u5BE6\u5BE7\u5BE9", 4, "\u5BEF\u5BF1", 6, "\u5BFD\u5BFE\u5C00\u5C02\u5C03\u5C05\u5C07\u5C08\u5C0B\u5C0C\u5C0D\u5C0E\u5C10\u5C12\u5C13\u5C17\u5C19\u5C1B\u5C1E\u5C1F\u5C20\u5C21\u5C23\u5C26\u5C28\u5C29\u5C2A\u5C2B\u5C2D\u5C2E\u5C2F\u5C30\u5C32\u5C33\u5C35\u5C36\u5C37\u5C43\u5C44\u5C46\u5C47\u5C4C\u5C4D\u5C52\u5C53\u5C54\u5C56\u5C57\u5C58\u5C5A\u5C5B\u5C5C\u5C5D\u5C5F\u5C62\u5C64\u5C67", 6, "\u5C70\u5C72", 6, "\u5C7B\u5C7C\u5C7D\u5C7E\u5C80\u5C83", 4, "\u5C89\u5C8A\u5C8B\u5C8E\u5C8F\u5C92\u5C93\u5C95\u5C9D", 4, "\u5CA4", 4],
      ["8d40", "\u5CAA\u5CAE\u5CAF\u5CB0\u5CB2\u5CB4\u5CB6\u5CB9\u5CBA\u5CBB\u5CBC\u5CBE\u5CC0\u5CC2\u5CC3\u5CC5", 5, "\u5CCC", 5, "\u5CD3", 5, "\u5CDA", 6, "\u5CE2\u5CE3\u5CE7\u5CE9\u5CEB\u5CEC\u5CEE\u5CEF\u5CF1", 9, "\u5CFC", 4],
      ["8d80", "\u5D01\u5D04\u5D05\u5D08", 5, "\u5D0F", 4, "\u5D15\u5D17\u5D18\u5D19\u5D1A\u5D1C\u5D1D\u5D1F", 4, "\u5D25\u5D28\u5D2A\u5D2B\u5D2C\u5D2F", 4, "\u5D35", 7, "\u5D3F", 7, "\u5D48\u5D49\u5D4D", 10, "\u5D59\u5D5A\u5D5C\u5D5E", 10, "\u5D6A\u5D6D\u5D6E\u5D70\u5D71\u5D72\u5D73\u5D75", 12, "\u5D83", 21, "\u5D9A\u5D9B\u5D9C\u5D9E\u5D9F\u5DA0"],
      ["8e40", "\u5DA1", 21, "\u5DB8", 12, "\u5DC6", 6, "\u5DCE", 12, "\u5DDC\u5DDF\u5DE0\u5DE3\u5DE4\u5DEA\u5DEC\u5DED"],
      ["8e80", "\u5DF0\u5DF5\u5DF6\u5DF8", 4, "\u5DFF\u5E00\u5E04\u5E07\u5E09\u5E0A\u5E0B\u5E0D\u5E0E\u5E12\u5E13\u5E17\u5E1E", 7, "\u5E28", 4, "\u5E2F\u5E30\u5E32", 4, "\u5E39\u5E3A\u5E3E\u5E3F\u5E40\u5E41\u5E43\u5E46", 5, "\u5E4D", 6, "\u5E56", 4, "\u5E5C\u5E5D\u5E5F\u5E60\u5E63", 14, "\u5E75\u5E77\u5E79\u5E7E\u5E81\u5E82\u5E83\u5E85\u5E88\u5E89\u5E8C\u5E8D\u5E8E\u5E92\u5E98\u5E9B\u5E9D\u5EA1\u5EA2\u5EA3\u5EA4\u5EA8", 4, "\u5EAE", 4, "\u5EB4\u5EBA\u5EBB\u5EBC\u5EBD\u5EBF", 6],
      ["8f40", "\u5EC6\u5EC7\u5EC8\u5ECB", 5, "\u5ED4\u5ED5\u5ED7\u5ED8\u5ED9\u5EDA\u5EDC", 11, "\u5EE9\u5EEB", 8, "\u5EF5\u5EF8\u5EF9\u5EFB\u5EFC\u5EFD\u5F05\u5F06\u5F07\u5F09\u5F0C\u5F0D\u5F0E\u5F10\u5F12\u5F14\u5F16\u5F19\u5F1A\u5F1C\u5F1D\u5F1E\u5F21\u5F22\u5F23\u5F24"],
      ["8f80", "\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F32", 6, "\u5F3B\u5F3D\u5F3E\u5F3F\u5F41", 14, "\u5F51\u5F54\u5F59\u5F5A\u5F5B\u5F5C\u5F5E\u5F5F\u5F60\u5F63\u5F65\u5F67\u5F68\u5F6B\u5F6E\u5F6F\u5F72\u5F74\u5F75\u5F76\u5F78\u5F7A\u5F7D\u5F7E\u5F7F\u5F83\u5F86\u5F8D\u5F8E\u5F8F\u5F91\u5F93\u5F94\u5F96\u5F9A\u5F9B\u5F9D\u5F9E\u5F9F\u5FA0\u5FA2", 5, "\u5FA9\u5FAB\u5FAC\u5FAF", 5, "\u5FB6\u5FB8\u5FB9\u5FBA\u5FBB\u5FBE", 4, "\u5FC7\u5FC8\u5FCA\u5FCB\u5FCE\u5FD3\u5FD4\u5FD5\u5FDA\u5FDB\u5FDC\u5FDE\u5FDF\u5FE2\u5FE3\u5FE5\u5FE6\u5FE8\u5FE9\u5FEC\u5FEF\u5FF0\u5FF2\u5FF3\u5FF4\u5FF6\u5FF7\u5FF9\u5FFA\u5FFC\u6007"],
      ["9040", "\u6008\u6009\u600B\u600C\u6010\u6011\u6013\u6017\u6018\u601A\u601E\u601F\u6022\u6023\u6024\u602C\u602D\u602E\u6030", 4, "\u6036", 4, "\u603D\u603E\u6040\u6044", 6, "\u604C\u604E\u604F\u6051\u6053\u6054\u6056\u6057\u6058\u605B\u605C\u605E\u605F\u6060\u6061\u6065\u6066\u606E\u6071\u6072\u6074\u6075\u6077\u607E\u6080"],
      ["9080", "\u6081\u6082\u6085\u6086\u6087\u6088\u608A\u608B\u608E\u608F\u6090\u6091\u6093\u6095\u6097\u6098\u6099\u609C\u609E\u60A1\u60A2\u60A4\u60A5\u60A7\u60A9\u60AA\u60AE\u60B0\u60B3\u60B5\u60B6\u60B7\u60B9\u60BA\u60BD", 7, "\u60C7\u60C8\u60C9\u60CC", 4, "\u60D2\u60D3\u60D4\u60D6\u60D7\u60D9\u60DB\u60DE\u60E1", 4, "\u60EA\u60F1\u60F2\u60F5\u60F7\u60F8\u60FB", 4, "\u6102\u6103\u6104\u6105\u6107\u610A\u610B\u610C\u6110", 4, "\u6116\u6117\u6118\u6119\u611B\u611C\u611D\u611E\u6121\u6122\u6125\u6128\u6129\u612A\u612C", 18, "\u6140", 6],
      ["9140", "\u6147\u6149\u614B\u614D\u614F\u6150\u6152\u6153\u6154\u6156", 6, "\u615E\u615F\u6160\u6161\u6163\u6164\u6165\u6166\u6169", 6, "\u6171\u6172\u6173\u6174\u6176\u6178", 18, "\u618C\u618D\u618F", 4, "\u6195"],
      ["9180", "\u6196", 6, "\u619E", 8, "\u61AA\u61AB\u61AD", 9, "\u61B8", 5, "\u61BF\u61C0\u61C1\u61C3", 4, "\u61C9\u61CC", 4, "\u61D3\u61D5", 16, "\u61E7", 13, "\u61F6", 8, "\u6200", 5, "\u6207\u6209\u6213\u6214\u6219\u621C\u621D\u621E\u6220\u6223\u6226\u6227\u6228\u6229\u622B\u622D\u622F\u6230\u6231\u6232\u6235\u6236\u6238", 4, "\u6242\u6244\u6245\u6246\u624A"],
      ["9240", "\u624F\u6250\u6255\u6256\u6257\u6259\u625A\u625C", 6, "\u6264\u6265\u6268\u6271\u6272\u6274\u6275\u6277\u6278\u627A\u627B\u627D\u6281\u6282\u6283\u6285\u6286\u6287\u6288\u628B", 5, "\u6294\u6299\u629C\u629D\u629E\u62A3\u62A6\u62A7\u62A9\u62AA\u62AD\u62AE\u62AF\u62B0\u62B2\u62B3\u62B4\u62B6\u62B7\u62B8\u62BA\u62BE\u62C0\u62C1"],
      ["9280", "\u62C3\u62CB\u62CF\u62D1\u62D5\u62DD\u62DE\u62E0\u62E1\u62E4\u62EA\u62EB\u62F0\u62F2\u62F5\u62F8\u62F9\u62FA\u62FB\u6300\u6303\u6304\u6305\u6306\u630A\u630B\u630C\u630D\u630F\u6310\u6312\u6313\u6314\u6315\u6317\u6318\u6319\u631C\u6326\u6327\u6329\u632C\u632D\u632E\u6330\u6331\u6333", 5, "\u633B\u633C\u633E\u633F\u6340\u6341\u6344\u6347\u6348\u634A\u6351\u6352\u6353\u6354\u6356", 7, "\u6360\u6364\u6365\u6366\u6368\u636A\u636B\u636C\u636F\u6370\u6372\u6373\u6374\u6375\u6378\u6379\u637C\u637D\u637E\u637F\u6381\u6383\u6384\u6385\u6386\u638B\u638D\u6391\u6393\u6394\u6395\u6397\u6399", 6, "\u63A1\u63A4\u63A6\u63AB\u63AF\u63B1\u63B2\u63B5\u63B6\u63B9\u63BB\u63BD\u63BF\u63C0"],
      ["9340", "\u63C1\u63C2\u63C3\u63C5\u63C7\u63C8\u63CA\u63CB\u63CC\u63D1\u63D3\u63D4\u63D5\u63D7", 6, "\u63DF\u63E2\u63E4", 4, "\u63EB\u63EC\u63EE\u63EF\u63F0\u63F1\u63F3\u63F5\u63F7\u63F9\u63FA\u63FB\u63FC\u63FE\u6403\u6404\u6406", 4, "\u640D\u640E\u6411\u6412\u6415", 5, "\u641D\u641F\u6422\u6423\u6424"],
      ["9380", "\u6425\u6427\u6428\u6429\u642B\u642E", 5, "\u6435", 4, "\u643B\u643C\u643E\u6440\u6442\u6443\u6449\u644B", 6, "\u6453\u6455\u6456\u6457\u6459", 4, "\u645F", 7, "\u6468\u646A\u646B\u646C\u646E", 9, "\u647B", 6, "\u6483\u6486\u6488", 8, "\u6493\u6494\u6497\u6498\u649A\u649B\u649C\u649D\u649F", 4, "\u64A5\u64A6\u64A7\u64A8\u64AA\u64AB\u64AF\u64B1\u64B2\u64B3\u64B4\u64B6\u64B9\u64BB\u64BD\u64BE\u64BF\u64C1\u64C3\u64C4\u64C6", 6, "\u64CF\u64D1\u64D3\u64D4\u64D5\u64D6\u64D9\u64DA"],
      ["9440", "\u64DB\u64DC\u64DD\u64DF\u64E0\u64E1\u64E3\u64E5\u64E7", 24, "\u6501", 7, "\u650A", 7, "\u6513", 4, "\u6519", 8],
      ["9480", "\u6522\u6523\u6524\u6526", 4, "\u652C\u652D\u6530\u6531\u6532\u6533\u6537\u653A\u653C\u653D\u6540", 4, "\u6546\u6547\u654A\u654B\u654D\u654E\u6550\u6552\u6553\u6554\u6557\u6558\u655A\u655C\u655F\u6560\u6561\u6564\u6565\u6567\u6568\u6569\u656A\u656D\u656E\u656F\u6571\u6573\u6575\u6576\u6578", 14, "\u6588\u6589\u658A\u658D\u658E\u658F\u6592\u6594\u6595\u6596\u6598\u659A\u659D\u659E\u65A0\u65A2\u65A3\u65A6\u65A8\u65AA\u65AC\u65AE\u65B1", 7, "\u65BA\u65BB\u65BE\u65BF\u65C0\u65C2\u65C7\u65C8\u65C9\u65CA\u65CD\u65D0\u65D1\u65D3\u65D4\u65D5\u65D8", 7, "\u65E1\u65E3\u65E4\u65EA\u65EB"],
      ["9540", "\u65F2\u65F3\u65F4\u65F5\u65F8\u65F9\u65FB", 4, "\u6601\u6604\u6605\u6607\u6608\u6609\u660B\u660D\u6610\u6611\u6612\u6616\u6617\u6618\u661A\u661B\u661C\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6632\u6633\u6637", 4, "\u663D\u663F\u6640\u6642\u6644", 6, "\u664D\u664E\u6650\u6651\u6658"],
      ["9580", "\u6659\u665B\u665C\u665D\u665E\u6660\u6662\u6663\u6665\u6667\u6669", 4, "\u6671\u6672\u6673\u6675\u6678\u6679\u667B\u667C\u667D\u667F\u6680\u6681\u6683\u6685\u6686\u6688\u6689\u668A\u668B\u668D\u668E\u668F\u6690\u6692\u6693\u6694\u6695\u6698", 4, "\u669E", 8, "\u66A9", 4, "\u66AF", 4, "\u66B5\u66B6\u66B7\u66B8\u66BA\u66BB\u66BC\u66BD\u66BF", 25, "\u66DA\u66DE", 7, "\u66E7\u66E8\u66EA", 5, "\u66F1\u66F5\u66F6\u66F8\u66FA\u66FB\u66FD\u6701\u6702\u6703"],
      ["9640", "\u6704\u6705\u6706\u6707\u670C\u670E\u670F\u6711\u6712\u6713\u6716\u6718\u6719\u671A\u671C\u671E\u6720", 5, "\u6727\u6729\u672E\u6730\u6732\u6733\u6736\u6737\u6738\u6739\u673B\u673C\u673E\u673F\u6741\u6744\u6745\u6747\u674A\u674B\u674D\u6752\u6754\u6755\u6757", 4, "\u675D\u6762\u6763\u6764\u6766\u6767\u676B\u676C\u676E\u6771\u6774\u6776"],
      ["9680", "\u6778\u6779\u677A\u677B\u677D\u6780\u6782\u6783\u6785\u6786\u6788\u678A\u678C\u678D\u678E\u678F\u6791\u6792\u6793\u6794\u6796\u6799\u679B\u679F\u67A0\u67A1\u67A4\u67A6\u67A9\u67AC\u67AE\u67B1\u67B2\u67B4\u67B9", 7, "\u67C2\u67C5", 9, "\u67D5\u67D6\u67D7\u67DB\u67DF\u67E1\u67E3\u67E4\u67E6\u67E7\u67E8\u67EA\u67EB\u67ED\u67EE\u67F2\u67F5", 7, "\u67FE\u6801\u6802\u6803\u6804\u6806\u680D\u6810\u6812\u6814\u6815\u6818", 4, "\u681E\u681F\u6820\u6822", 6, "\u682B", 6, "\u6834\u6835\u6836\u683A\u683B\u683F\u6847\u684B\u684D\u684F\u6852\u6856", 5],
      ["9740", "\u685C\u685D\u685E\u685F\u686A\u686C", 7, "\u6875\u6878", 8, "\u6882\u6884\u6887", 7, "\u6890\u6891\u6892\u6894\u6895\u6896\u6898", 9, "\u68A3\u68A4\u68A5\u68A9\u68AA\u68AB\u68AC\u68AE\u68B1\u68B2\u68B4\u68B6\u68B7\u68B8"],
      ["9780", "\u68B9", 6, "\u68C1\u68C3", 5, "\u68CA\u68CC\u68CE\u68CF\u68D0\u68D1\u68D3\u68D4\u68D6\u68D7\u68D9\u68DB", 4, "\u68E1\u68E2\u68E4", 9, "\u68EF\u68F2\u68F3\u68F4\u68F6\u68F7\u68F8\u68FB\u68FD\u68FE\u68FF\u6900\u6902\u6903\u6904\u6906", 4, "\u690C\u690F\u6911\u6913", 11, "\u6921\u6922\u6923\u6925", 7, "\u692E\u692F\u6931\u6932\u6933\u6935\u6936\u6937\u6938\u693A\u693B\u693C\u693E\u6940\u6941\u6943", 16, "\u6955\u6956\u6958\u6959\u695B\u695C\u695F"],
      ["9840", "\u6961\u6962\u6964\u6965\u6967\u6968\u6969\u696A\u696C\u696D\u696F\u6970\u6972", 4, "\u697A\u697B\u697D\u697E\u697F\u6981\u6983\u6985\u698A\u698B\u698C\u698E", 5, "\u6996\u6997\u6999\u699A\u699D", 9, "\u69A9\u69AA\u69AC\u69AE\u69AF\u69B0\u69B2\u69B3\u69B5\u69B6\u69B8\u69B9\u69BA\u69BC\u69BD"],
      ["9880", "\u69BE\u69BF\u69C0\u69C2", 7, "\u69CB\u69CD\u69CF\u69D1\u69D2\u69D3\u69D5", 5, "\u69DC\u69DD\u69DE\u69E1", 11, "\u69EE\u69EF\u69F0\u69F1\u69F3", 9, "\u69FE\u6A00", 9, "\u6A0B", 11, "\u6A19", 5, "\u6A20\u6A22", 5, "\u6A29\u6A2B\u6A2C\u6A2D\u6A2E\u6A30\u6A32\u6A33\u6A34\u6A36", 6, "\u6A3F", 4, "\u6A45\u6A46\u6A48", 7, "\u6A51", 6, "\u6A5A"],
      ["9940", "\u6A5C", 4, "\u6A62\u6A63\u6A64\u6A66", 10, "\u6A72", 6, "\u6A7A\u6A7B\u6A7D\u6A7E\u6A7F\u6A81\u6A82\u6A83\u6A85", 8, "\u6A8F\u6A92", 4, "\u6A98", 7, "\u6AA1", 5],
      ["9980", "\u6AA7\u6AA8\u6AAA\u6AAD", 114, "\u6B25\u6B26\u6B28", 6],
      ["9a40", "\u6B2F\u6B30\u6B31\u6B33\u6B34\u6B35\u6B36\u6B38\u6B3B\u6B3C\u6B3D\u6B3F\u6B40\u6B41\u6B42\u6B44\u6B45\u6B48\u6B4A\u6B4B\u6B4D", 11, "\u6B5A", 7, "\u6B68\u6B69\u6B6B", 13, "\u6B7A\u6B7D\u6B7E\u6B7F\u6B80\u6B85\u6B88"],
      ["9a80", "\u6B8C\u6B8E\u6B8F\u6B90\u6B91\u6B94\u6B95\u6B97\u6B98\u6B99\u6B9C", 4, "\u6BA2", 7, "\u6BAB", 7, "\u6BB6\u6BB8", 6, "\u6BC0\u6BC3\u6BC4\u6BC6", 4, "\u6BCC\u6BCE\u6BD0\u6BD1\u6BD8\u6BDA\u6BDC", 4, "\u6BE2", 7, "\u6BEC\u6BED\u6BEE\u6BF0\u6BF1\u6BF2\u6BF4\u6BF6\u6BF7\u6BF8\u6BFA\u6BFB\u6BFC\u6BFE", 6, "\u6C08", 4, "\u6C0E\u6C12\u6C17\u6C1C\u6C1D\u6C1E\u6C20\u6C23\u6C25\u6C2B\u6C2C\u6C2D\u6C31\u6C33\u6C36\u6C37\u6C39\u6C3A\u6C3B\u6C3C\u6C3E\u6C3F\u6C43\u6C44\u6C45\u6C48\u6C4B", 4, "\u6C51\u6C52\u6C53\u6C56\u6C58"],
      ["9b40", "\u6C59\u6C5A\u6C62\u6C63\u6C65\u6C66\u6C67\u6C6B", 4, "\u6C71\u6C73\u6C75\u6C77\u6C78\u6C7A\u6C7B\u6C7C\u6C7F\u6C80\u6C84\u6C87\u6C8A\u6C8B\u6C8D\u6C8E\u6C91\u6C92\u6C95\u6C96\u6C97\u6C98\u6C9A\u6C9C\u6C9D\u6C9E\u6CA0\u6CA2\u6CA8\u6CAC\u6CAF\u6CB0\u6CB4\u6CB5\u6CB6\u6CB7\u6CBA\u6CC0\u6CC1\u6CC2\u6CC3\u6CC6\u6CC7\u6CC8\u6CCB\u6CCD\u6CCE\u6CCF\u6CD1\u6CD2\u6CD8"],
      ["9b80", "\u6CD9\u6CDA\u6CDC\u6CDD\u6CDF\u6CE4\u6CE6\u6CE7\u6CE9\u6CEC\u6CED\u6CF2\u6CF4\u6CF9\u6CFF\u6D00\u6D02\u6D03\u6D05\u6D06\u6D08\u6D09\u6D0A\u6D0D\u6D0F\u6D10\u6D11\u6D13\u6D14\u6D15\u6D16\u6D18\u6D1C\u6D1D\u6D1F", 5, "\u6D26\u6D28\u6D29\u6D2C\u6D2D\u6D2F\u6D30\u6D34\u6D36\u6D37\u6D38\u6D3A\u6D3F\u6D40\u6D42\u6D44\u6D49\u6D4C\u6D50\u6D55\u6D56\u6D57\u6D58\u6D5B\u6D5D\u6D5F\u6D61\u6D62\u6D64\u6D65\u6D67\u6D68\u6D6B\u6D6C\u6D6D\u6D70\u6D71\u6D72\u6D73\u6D75\u6D76\u6D79\u6D7A\u6D7B\u6D7D", 4, "\u6D83\u6D84\u6D86\u6D87\u6D8A\u6D8B\u6D8D\u6D8F\u6D90\u6D92\u6D96", 4, "\u6D9C\u6DA2\u6DA5\u6DAC\u6DAD\u6DB0\u6DB1\u6DB3\u6DB4\u6DB6\u6DB7\u6DB9", 5, "\u6DC1\u6DC2\u6DC3\u6DC8\u6DC9\u6DCA"],
      ["9c40", "\u6DCD\u6DCE\u6DCF\u6DD0\u6DD2\u6DD3\u6DD4\u6DD5\u6DD7\u6DDA\u6DDB\u6DDC\u6DDF\u6DE2\u6DE3\u6DE5\u6DE7\u6DE8\u6DE9\u6DEA\u6DED\u6DEF\u6DF0\u6DF2\u6DF4\u6DF5\u6DF6\u6DF8\u6DFA\u6DFD", 7, "\u6E06\u6E07\u6E08\u6E09\u6E0B\u6E0F\u6E12\u6E13\u6E15\u6E18\u6E19\u6E1B\u6E1C\u6E1E\u6E1F\u6E22\u6E26\u6E27\u6E28\u6E2A\u6E2C\u6E2E\u6E30\u6E31\u6E33\u6E35"],
      ["9c80", "\u6E36\u6E37\u6E39\u6E3B", 7, "\u6E45", 7, "\u6E4F\u6E50\u6E51\u6E52\u6E55\u6E57\u6E59\u6E5A\u6E5C\u6E5D\u6E5E\u6E60", 10, "\u6E6C\u6E6D\u6E6F", 14, "\u6E80\u6E81\u6E82\u6E84\u6E87\u6E88\u6E8A", 4, "\u6E91", 6, "\u6E99\u6E9A\u6E9B\u6E9D\u6E9E\u6EA0\u6EA1\u6EA3\u6EA4\u6EA6\u6EA8\u6EA9\u6EAB\u6EAC\u6EAD\u6EAE\u6EB0\u6EB3\u6EB5\u6EB8\u6EB9\u6EBC\u6EBE\u6EBF\u6EC0\u6EC3\u6EC4\u6EC5\u6EC6\u6EC8\u6EC9\u6ECA\u6ECC\u6ECD\u6ECE\u6ED0\u6ED2\u6ED6\u6ED8\u6ED9\u6EDB\u6EDC\u6EDD\u6EE3\u6EE7\u6EEA", 5],
      ["9d40", "\u6EF0\u6EF1\u6EF2\u6EF3\u6EF5\u6EF6\u6EF7\u6EF8\u6EFA", 7, "\u6F03\u6F04\u6F05\u6F07\u6F08\u6F0A", 4, "\u6F10\u6F11\u6F12\u6F16", 9, "\u6F21\u6F22\u6F23\u6F25\u6F26\u6F27\u6F28\u6F2C\u6F2E\u6F30\u6F32\u6F34\u6F35\u6F37", 6, "\u6F3F\u6F40\u6F41\u6F42"],
      ["9d80", "\u6F43\u6F44\u6F45\u6F48\u6F49\u6F4A\u6F4C\u6F4E", 9, "\u6F59\u6F5A\u6F5B\u6F5D\u6F5F\u6F60\u6F61\u6F63\u6F64\u6F65\u6F67", 5, "\u6F6F\u6F70\u6F71\u6F73\u6F75\u6F76\u6F77\u6F79\u6F7B\u6F7D", 6, "\u6F85\u6F86\u6F87\u6F8A\u6F8B\u6F8F", 12, "\u6F9D\u6F9E\u6F9F\u6FA0\u6FA2", 4, "\u6FA8", 10, "\u6FB4\u6FB5\u6FB7\u6FB8\u6FBA", 5, "\u6FC1\u6FC3", 5, "\u6FCA", 6, "\u6FD3", 10, "\u6FDF\u6FE2\u6FE3\u6FE4\u6FE5"],
      ["9e40", "\u6FE6", 7, "\u6FF0", 32, "\u7012", 7, "\u701C", 6, "\u7024", 6],
      ["9e80", "\u702B", 9, "\u7036\u7037\u7038\u703A", 17, "\u704D\u704E\u7050", 13, "\u705F", 11, "\u706E\u7071\u7072\u7073\u7074\u7077\u7079\u707A\u707B\u707D\u7081\u7082\u7083\u7084\u7086\u7087\u7088\u708B\u708C\u708D\u708F\u7090\u7091\u7093\u7097\u7098\u709A\u709B\u709E", 12, "\u70B0\u70B2\u70B4\u70B5\u70B6\u70BA\u70BE\u70BF\u70C4\u70C5\u70C6\u70C7\u70C9\u70CB", 12, "\u70DA"],
      ["9f40", "\u70DC\u70DD\u70DE\u70E0\u70E1\u70E2\u70E3\u70E5\u70EA\u70EE\u70F0", 6, "\u70F8\u70FA\u70FB\u70FC\u70FE", 10, "\u710B", 4, "\u7111\u7112\u7114\u7117\u711B", 10, "\u7127", 7, "\u7132\u7133\u7134"],
      ["9f80", "\u7135\u7137", 13, "\u7146\u7147\u7148\u7149\u714B\u714D\u714F", 12, "\u715D\u715F", 4, "\u7165\u7169", 4, "\u716F\u7170\u7171\u7174\u7175\u7176\u7177\u7179\u717B\u717C\u717E", 5, "\u7185", 4, "\u718B\u718C\u718D\u718E\u7190\u7191\u7192\u7193\u7195\u7196\u7197\u719A", 4, "\u71A1", 6, "\u71A9\u71AA\u71AB\u71AD", 5, "\u71B4\u71B6\u71B7\u71B8\u71BA", 8, "\u71C4", 9, "\u71CF", 4],
      ["a040", "\u71D6", 9, "\u71E1\u71E2\u71E3\u71E4\u71E6\u71E8", 5, "\u71EF", 9, "\u71FA", 11, "\u7207", 19],
      ["a080", "\u721B\u721C\u721E", 9, "\u7229\u722B\u722D\u722E\u722F\u7232\u7233\u7234\u723A\u723C\u723E\u7240", 6, "\u7249\u724A\u724B\u724E\u724F\u7250\u7251\u7253\u7254\u7255\u7257\u7258\u725A\u725C\u725E\u7260\u7263\u7264\u7265\u7268\u726A\u726B\u726C\u726D\u7270\u7271\u7273\u7274\u7276\u7277\u7278\u727B\u727C\u727D\u7282\u7283\u7285", 4, "\u728C\u728E\u7290\u7291\u7293", 11, "\u72A0", 11, "\u72AE\u72B1\u72B2\u72B3\u72B5\u72BA", 6, "\u72C5\u72C6\u72C7\u72C9\u72CA\u72CB\u72CC\u72CF\u72D1\u72D3\u72D4\u72D5\u72D6\u72D8\u72DA\u72DB"],
      ["a1a1", "\u3000\u3001\u3002\xB7\u02C9\u02C7\xA8\u3003\u3005\u2014\uFF5E\u2016\u2026\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 7, "\u3016\u3017\u3010\u3011\xB1\xD7\xF7\u2236\u2227\u2228\u2211\u220F\u222A\u2229\u2208\u2237\u221A\u22A5\u2225\u2220\u2312\u2299\u222B\u222E\u2261\u224C\u2248\u223D\u221D\u2260\u226E\u226F\u2264\u2265\u221E\u2235\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFF04\xA4\uFFE0\uFFE1\u2030\xA7\u2116\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u203B\u2192\u2190\u2191\u2193\u3013"],
      ["a2a1", "\u2170", 9],
      ["a2b1", "\u2488", 19, "\u2474", 19, "\u2460", 9],
      ["a2e5", "\u3220", 9],
      ["a2f1", "\u2160", 11],
      ["a3a1", "\uFF01\uFF02\uFF03\uFFE5\uFF05", 88, "\uFFE3"],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a6e0", "\uFE35\uFE36\uFE39\uFE3A\uFE3F\uFE40\uFE3D\uFE3E\uFE41\uFE42\uFE43\uFE44"],
      ["a6ee", "\uFE3B\uFE3C\uFE37\uFE38\uFE31"],
      ["a6f4", "\uFE33\uFE34"],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a840", "\u02CA\u02CB\u02D9\u2013\u2015\u2025\u2035\u2105\u2109\u2196\u2197\u2198\u2199\u2215\u221F\u2223\u2252\u2266\u2267\u22BF\u2550", 35, "\u2581", 6],
      ["a880", "\u2588", 7, "\u2593\u2594\u2595\u25BC\u25BD\u25E2\u25E3\u25E4\u25E5\u2609\u2295\u3012\u301D\u301E"],
      ["a8a1", "\u0101\xE1\u01CE\xE0\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA\u01DC\xFC\xEA\u0251"],
      ["a8bd", "\u0144\u0148"],
      ["a8c0", "\u0261"],
      ["a8c5", "\u3105", 36],
      ["a940", "\u3021", 8, "\u32A3\u338E\u338F\u339C\u339D\u339E\u33A1\u33C4\u33CE\u33D1\u33D2\u33D5\uFE30\uFFE2\uFFE4"],
      ["a959", "\u2121\u3231"],
      ["a95c", "\u2010"],
      ["a960", "\u30FC\u309B\u309C\u30FD\u30FE\u3006\u309D\u309E\uFE49", 9, "\uFE54\uFE55\uFE56\uFE57\uFE59", 8],
      ["a980", "\uFE62", 4, "\uFE68\uFE69\uFE6A\uFE6B"],
      ["a996", "\u3007"],
      ["a9a4", "\u2500", 75],
      ["aa40", "\u72DC\u72DD\u72DF\u72E2", 5, "\u72EA\u72EB\u72F5\u72F6\u72F9\u72FD\u72FE\u72FF\u7300\u7302\u7304", 5, "\u730B\u730C\u730D\u730F\u7310\u7311\u7312\u7314\u7318\u7319\u731A\u731F\u7320\u7323\u7324\u7326\u7327\u7328\u732D\u732F\u7330\u7332\u7333\u7335\u7336\u733A\u733B\u733C\u733D\u7340", 8],
      ["aa80", "\u7349\u734A\u734B\u734C\u734E\u734F\u7351\u7353\u7354\u7355\u7356\u7358", 7, "\u7361", 10, "\u736E\u7370\u7371"],
      ["ab40", "\u7372", 11, "\u737F", 4, "\u7385\u7386\u7388\u738A\u738C\u738D\u738F\u7390\u7392\u7393\u7394\u7395\u7397\u7398\u7399\u739A\u739C\u739D\u739E\u73A0\u73A1\u73A3", 5, "\u73AA\u73AC\u73AD\u73B1\u73B4\u73B5\u73B6\u73B8\u73B9\u73BC\u73BD\u73BE\u73BF\u73C1\u73C3", 4],
      ["ab80", "\u73CB\u73CC\u73CE\u73D2", 6, "\u73DA\u73DB\u73DC\u73DD\u73DF\u73E1\u73E2\u73E3\u73E4\u73E6\u73E8\u73EA\u73EB\u73EC\u73EE\u73EF\u73F0\u73F1\u73F3", 4],
      ["ac40", "\u73F8", 10, "\u7404\u7407\u7408\u740B\u740C\u740D\u740E\u7411", 8, "\u741C", 5, "\u7423\u7424\u7427\u7429\u742B\u742D\u742F\u7431\u7432\u7437", 4, "\u743D\u743E\u743F\u7440\u7442", 11],
      ["ac80", "\u744E", 6, "\u7456\u7458\u745D\u7460", 12, "\u746E\u746F\u7471", 4, "\u7478\u7479\u747A"],
      ["ad40", "\u747B\u747C\u747D\u747F\u7482\u7484\u7485\u7486\u7488\u7489\u748A\u748C\u748D\u748F\u7491", 10, "\u749D\u749F", 7, "\u74AA", 15, "\u74BB", 12],
      ["ad80", "\u74C8", 9, "\u74D3", 8, "\u74DD\u74DF\u74E1\u74E5\u74E7", 6, "\u74F0\u74F1\u74F2"],
      ["ae40", "\u74F3\u74F5\u74F8", 6, "\u7500\u7501\u7502\u7503\u7505", 7, "\u750E\u7510\u7512\u7514\u7515\u7516\u7517\u751B\u751D\u751E\u7520", 4, "\u7526\u7527\u752A\u752E\u7534\u7536\u7539\u753C\u753D\u753F\u7541\u7542\u7543\u7544\u7546\u7547\u7549\u754A\u754D\u7550\u7551\u7552\u7553\u7555\u7556\u7557\u7558"],
      ["ae80", "\u755D", 7, "\u7567\u7568\u7569\u756B", 6, "\u7573\u7575\u7576\u7577\u757A", 4, "\u7580\u7581\u7582\u7584\u7585\u7587"],
      ["af40", "\u7588\u7589\u758A\u758C\u758D\u758E\u7590\u7593\u7595\u7598\u759B\u759C\u759E\u75A2\u75A6", 4, "\u75AD\u75B6\u75B7\u75BA\u75BB\u75BF\u75C0\u75C1\u75C6\u75CB\u75CC\u75CE\u75CF\u75D0\u75D1\u75D3\u75D7\u75D9\u75DA\u75DC\u75DD\u75DF\u75E0\u75E1\u75E5\u75E9\u75EC\u75ED\u75EE\u75EF\u75F2\u75F3\u75F5\u75F6\u75F7\u75F8\u75FA\u75FB\u75FD\u75FE\u7602\u7604\u7606\u7607"],
      ["af80", "\u7608\u7609\u760B\u760D\u760E\u760F\u7611\u7612\u7613\u7614\u7616\u761A\u761C\u761D\u761E\u7621\u7623\u7627\u7628\u762C\u762E\u762F\u7631\u7632\u7636\u7637\u7639\u763A\u763B\u763D\u7641\u7642\u7644"],
      ["b040", "\u7645", 6, "\u764E", 5, "\u7655\u7657", 4, "\u765D\u765F\u7660\u7661\u7662\u7664", 6, "\u766C\u766D\u766E\u7670", 7, "\u7679\u767A\u767C\u767F\u7680\u7681\u7683\u7685\u7689\u768A\u768C\u768D\u768F\u7690\u7692\u7694\u7695\u7697\u7698\u769A\u769B"],
      ["b080", "\u769C", 7, "\u76A5", 8, "\u76AF\u76B0\u76B3\u76B5", 9, "\u76C0\u76C1\u76C3\u554A\u963F\u57C3\u6328\u54CE\u5509\u54C0\u7691\u764C\u853C\u77EE\u827E\u788D\u7231\u9698\u978D\u6C28\u5B89\u4FFA\u6309\u6697\u5CB8\u80FA\u6848\u80AE\u6602\u76CE\u51F9\u6556\u71AC\u7FF1\u8884\u50B2\u5965\u61CA\u6FB3\u82AD\u634C\u6252\u53ED\u5427\u7B06\u516B\u75A4\u5DF4\u62D4\u8DCB\u9776\u628A\u8019\u575D\u9738\u7F62\u7238\u767D\u67CF\u767E\u6446\u4F70\u8D25\u62DC\u7A17\u6591\u73ED\u642C\u6273\u822C\u9881\u677F\u7248\u626E\u62CC\u4F34\u74E3\u534A\u529E\u7ECA\u90A6\u5E2E\u6886\u699C\u8180\u7ED1\u68D2\u78C5\u868C\u9551\u508D\u8C24\u82DE\u80DE\u5305\u8912\u5265"],
      ["b140", "\u76C4\u76C7\u76C9\u76CB\u76CC\u76D3\u76D5\u76D9\u76DA\u76DC\u76DD\u76DE\u76E0", 4, "\u76E6", 7, "\u76F0\u76F3\u76F5\u76F6\u76F7\u76FA\u76FB\u76FD\u76FF\u7700\u7702\u7703\u7705\u7706\u770A\u770C\u770E", 10, "\u771B\u771C\u771D\u771E\u7721\u7723\u7724\u7725\u7727\u772A\u772B"],
      ["b180", "\u772C\u772E\u7730", 4, "\u7739\u773B\u773D\u773E\u773F\u7742\u7744\u7745\u7746\u7748", 7, "\u7752", 7, "\u775C\u8584\u96F9\u4FDD\u5821\u9971\u5B9D\u62B1\u62A5\u66B4\u8C79\u9C8D\u7206\u676F\u7891\u60B2\u5351\u5317\u8F88\u80CC\u8D1D\u94A1\u500D\u72C8\u5907\u60EB\u7119\u88AB\u5954\u82EF\u672C\u7B28\u5D29\u7EF7\u752D\u6CF5\u8E66\u8FF8\u903C\u9F3B\u6BD4\u9119\u7B14\u5F7C\u78A7\u84D6\u853D\u6BD5\u6BD9\u6BD6\u5E01\u5E87\u75F9\u95ED\u655D\u5F0A\u5FC5\u8F9F\u58C1\u81C2\u907F\u965B\u97AD\u8FB9\u7F16\u8D2C\u6241\u4FBF\u53D8\u535E\u8FA8\u8FA9\u8FAB\u904D\u6807\u5F6A\u8198\u8868\u9CD6\u618B\u522B\u762A\u5F6C\u658C\u6FD2\u6EE8\u5BBE\u6448\u5175\u51B0\u67C4\u4E19\u79C9\u997C\u70B3"],
      ["b240", "\u775D\u775E\u775F\u7760\u7764\u7767\u7769\u776A\u776D", 11, "\u777A\u777B\u777C\u7781\u7782\u7783\u7786", 5, "\u778F\u7790\u7793", 11, "\u77A1\u77A3\u77A4\u77A6\u77A8\u77AB\u77AD\u77AE\u77AF\u77B1\u77B2\u77B4\u77B6", 4],
      ["b280", "\u77BC\u77BE\u77C0", 12, "\u77CE", 8, "\u77D8\u77D9\u77DA\u77DD", 4, "\u77E4\u75C5\u5E76\u73BB\u83E0\u64AD\u62E8\u94B5\u6CE2\u535A\u52C3\u640F\u94C2\u7B94\u4F2F\u5E1B\u8236\u8116\u818A\u6E24\u6CCA\u9A73\u6355\u535C\u54FA\u8865\u57E0\u4E0D\u5E03\u6B65\u7C3F\u90E8\u6016\u64E6\u731C\u88C1\u6750\u624D\u8D22\u776C\u8E29\u91C7\u5F69\u83DC\u8521\u9910\u53C2\u8695\u6B8B\u60ED\u60E8\u707F\u82CD\u8231\u4ED3\u6CA7\u85CF\u64CD\u7CD9\u69FD\u66F9\u8349\u5395\u7B56\u4FA7\u518C\u6D4B\u5C42\u8E6D\u63D2\u53C9\u832C\u8336\u67E5\u78B4\u643D\u5BDF\u5C94\u5DEE\u8BE7\u62C6\u67F4\u8C7A\u6400\u63BA\u8749\u998B\u8C17\u7F20\u94F2\u4EA7\u9610\u98A4\u660C\u7316"],
      ["b340", "\u77E6\u77E8\u77EA\u77EF\u77F0\u77F1\u77F2\u77F4\u77F5\u77F7\u77F9\u77FA\u77FB\u77FC\u7803", 5, "\u780A\u780B\u780E\u780F\u7810\u7813\u7815\u7819\u781B\u781E\u7820\u7821\u7822\u7824\u7828\u782A\u782B\u782E\u782F\u7831\u7832\u7833\u7835\u7836\u783D\u783F\u7841\u7842\u7843\u7844\u7846\u7848\u7849\u784A\u784B\u784D\u784F\u7851\u7853\u7854\u7858\u7859\u785A"],
      ["b380", "\u785B\u785C\u785E", 11, "\u786F", 7, "\u7878\u7879\u787A\u787B\u787D", 6, "\u573A\u5C1D\u5E38\u957F\u507F\u80A0\u5382\u655E\u7545\u5531\u5021\u8D85\u6284\u949E\u671D\u5632\u6F6E\u5DE2\u5435\u7092\u8F66\u626F\u64A4\u63A3\u5F7B\u6F88\u90F4\u81E3\u8FB0\u5C18\u6668\u5FF1\u6C89\u9648\u8D81\u886C\u6491\u79F0\u57CE\u6A59\u6210\u5448\u4E58\u7A0B\u60E9\u6F84\u8BDA\u627F\u901E\u9A8B\u79E4\u5403\u75F4\u6301\u5319\u6C60\u8FDF\u5F1B\u9A70\u803B\u9F7F\u4F88\u5C3A\u8D64\u7FC5\u65A5\u70BD\u5145\u51B2\u866B\u5D07\u5BA0\u62BD\u916C\u7574\u8E0C\u7A20\u6101\u7B79\u4EC7\u7EF8\u7785\u4E11\u81ED\u521D\u51FA\u6A71\u53A8\u8E87\u9504\u96CF\u6EC1\u9664\u695A"],
      ["b440", "\u7884\u7885\u7886\u7888\u788A\u788B\u788F\u7890\u7892\u7894\u7895\u7896\u7899\u789D\u789E\u78A0\u78A2\u78A4\u78A6\u78A8", 7, "\u78B5\u78B6\u78B7\u78B8\u78BA\u78BB\u78BC\u78BD\u78BF\u78C0\u78C2\u78C3\u78C4\u78C6\u78C7\u78C8\u78CC\u78CD\u78CE\u78CF\u78D1\u78D2\u78D3\u78D6\u78D7\u78D8\u78DA", 9],
      ["b480", "\u78E4\u78E5\u78E6\u78E7\u78E9\u78EA\u78EB\u78ED", 4, "\u78F3\u78F5\u78F6\u78F8\u78F9\u78FB", 5, "\u7902\u7903\u7904\u7906", 6, "\u7840\u50A8\u77D7\u6410\u89E6\u5904\u63E3\u5DDD\u7A7F\u693D\u4F20\u8239\u5598\u4E32\u75AE\u7A97\u5E62\u5E8A\u95EF\u521B\u5439\u708A\u6376\u9524\u5782\u6625\u693F\u9187\u5507\u6DF3\u7EAF\u8822\u6233\u7EF0\u75B5\u8328\u78C1\u96CC\u8F9E\u6148\u74F7\u8BCD\u6B64\u523A\u8D50\u6B21\u806A\u8471\u56F1\u5306\u4ECE\u4E1B\u51D1\u7C97\u918B\u7C07\u4FC3\u8E7F\u7BE1\u7A9C\u6467\u5D14\u50AC\u8106\u7601\u7CB9\u6DEC\u7FE0\u6751\u5B58\u5BF8\u78CB\u64AE\u6413\u63AA\u632B\u9519\u642D\u8FBE\u7B54\u7629\u6253\u5927\u5446\u6B79\u50A3\u6234\u5E26\u6B86\u4EE3\u8D37\u888B\u5F85\u902E"],
      ["b540", "\u790D", 5, "\u7914", 9, "\u791F", 4, "\u7925", 14, "\u7935", 4, "\u793D\u793F\u7942\u7943\u7944\u7945\u7947\u794A", 8, "\u7954\u7955\u7958\u7959\u7961\u7963"],
      ["b580", "\u7964\u7966\u7969\u796A\u796B\u796C\u796E\u7970", 6, "\u7979\u797B", 4, "\u7982\u7983\u7986\u7987\u7988\u7989\u798B\u798C\u798D\u798E\u7990\u7991\u7992\u6020\u803D\u62C5\u4E39\u5355\u90F8\u63B8\u80C6\u65E6\u6C2E\u4F46\u60EE\u6DE1\u8BDE\u5F39\u86CB\u5F53\u6321\u515A\u8361\u6863\u5200\u6363\u8E48\u5012\u5C9B\u7977\u5BFC\u5230\u7A3B\u60BC\u9053\u76D7\u5FB7\u5F97\u7684\u8E6C\u706F\u767B\u7B49\u77AA\u51F3\u9093\u5824\u4F4E\u6EF4\u8FEA\u654C\u7B1B\u72C4\u6DA4\u7FDF\u5AE1\u62B5\u5E95\u5730\u8482\u7B2C\u5E1D\u5F1F\u9012\u7F14\u98A0\u6382\u6EC7\u7898\u70B9\u5178\u975B\u57AB\u7535\u4F43\u7538\u5E97\u60E6\u5960\u6DC0\u6BBF\u7889\u53FC\u96D5\u51CB\u5201\u6389\u540A\u9493\u8C03\u8DCC\u7239\u789F\u8776\u8FED\u8C0D\u53E0"],
      ["b640", "\u7993", 6, "\u799B", 11, "\u79A8", 10, "\u79B4", 4, "\u79BC\u79BF\u79C2\u79C4\u79C5\u79C7\u79C8\u79CA\u79CC\u79CE\u79CF\u79D0\u79D3\u79D4\u79D6\u79D7\u79D9", 5, "\u79E0\u79E1\u79E2\u79E5\u79E8\u79EA"],
      ["b680", "\u79EC\u79EE\u79F1", 6, "\u79F9\u79FA\u79FC\u79FE\u79FF\u7A01\u7A04\u7A05\u7A07\u7A08\u7A09\u7A0A\u7A0C\u7A0F", 4, "\u7A15\u7A16\u7A18\u7A19\u7A1B\u7A1C\u4E01\u76EF\u53EE\u9489\u9876\u9F0E\u952D\u5B9A\u8BA2\u4E22\u4E1C\u51AC\u8463\u61C2\u52A8\u680B\u4F97\u606B\u51BB\u6D1E\u515C\u6296\u6597\u9661\u8C46\u9017\u75D8\u90FD\u7763\u6BD2\u728A\u72EC\u8BFB\u5835\u7779\u8D4C\u675C\u9540\u809A\u5EA6\u6E21\u5992\u7AEF\u77ED\u953B\u6BB5\u65AD\u7F0E\u5806\u5151\u961F\u5BF9\u58A9\u5428\u8E72\u6566\u987F\u56E4\u949D\u76FE\u9041\u6387\u54C6\u591A\u593A\u579B\u8EB2\u6735\u8DFA\u8235\u5241\u60F0\u5815\u86FE\u5CE8\u9E45\u4FC4\u989D\u8BB9\u5A25\u6076\u5384\u627C\u904F\u9102\u997F\u6069\u800C\u513F\u8033\u5C14\u9975\u6D31\u4E8C"],
      ["b740", "\u7A1D\u7A1F\u7A21\u7A22\u7A24", 14, "\u7A34\u7A35\u7A36\u7A38\u7A3A\u7A3E\u7A40", 5, "\u7A47", 9, "\u7A52", 4, "\u7A58", 16],
      ["b780", "\u7A69", 6, "\u7A71\u7A72\u7A73\u7A75\u7A7B\u7A7C\u7A7D\u7A7E\u7A82\u7A85\u7A87\u7A89\u7A8A\u7A8B\u7A8C\u7A8E\u7A8F\u7A90\u7A93\u7A94\u7A99\u7A9A\u7A9B\u7A9E\u7AA1\u7AA2\u8D30\u53D1\u7F5A\u7B4F\u4F10\u4E4F\u9600\u6CD5\u73D0\u85E9\u5E06\u756A\u7FFB\u6A0A\u77FE\u9492\u7E41\u51E1\u70E6\u53CD\u8FD4\u8303\u8D29\u72AF\u996D\u6CDB\u574A\u82B3\u65B9\u80AA\u623F\u9632\u59A8\u4EFF\u8BBF\u7EBA\u653E\u83F2\u975E\u5561\u98DE\u80A5\u532A\u8BFD\u5420\u80BA\u5E9F\u6CB8\u8D39\u82AC\u915A\u5429\u6C1B\u5206\u7EB7\u575F\u711A\u6C7E\u7C89\u594B\u4EFD\u5FFF\u6124\u7CAA\u4E30\u5C01\u67AB\u8702\u5CF0\u950B\u98CE\u75AF\u70FD\u9022\u51AF\u7F1D\u8BBD\u5949\u51E4\u4F5B\u5426\u592B\u6577\u80A4\u5B75\u6276\u62C2\u8F90\u5E45\u6C1F\u7B26\u4F0F\u4FD8\u670D"],
      ["b840", "\u7AA3\u7AA4\u7AA7\u7AA9\u7AAA\u7AAB\u7AAE", 4, "\u7AB4", 10, "\u7AC0", 10, "\u7ACC", 9, "\u7AD7\u7AD8\u7ADA\u7ADB\u7ADC\u7ADD\u7AE1\u7AE2\u7AE4\u7AE7", 5, "\u7AEE\u7AF0\u7AF1\u7AF2\u7AF3"],
      ["b880", "\u7AF4", 4, "\u7AFB\u7AFC\u7AFE\u7B00\u7B01\u7B02\u7B05\u7B07\u7B09\u7B0C\u7B0D\u7B0E\u7B10\u7B12\u7B13\u7B16\u7B17\u7B18\u7B1A\u7B1C\u7B1D\u7B1F\u7B21\u7B22\u7B23\u7B27\u7B29\u7B2D\u6D6E\u6DAA\u798F\u88B1\u5F17\u752B\u629A\u8F85\u4FEF\u91DC\u65A7\u812F\u8151\u5E9C\u8150\u8D74\u526F\u8986\u8D4B\u590D\u5085\u4ED8\u961C\u7236\u8179\u8D1F\u5BCC\u8BA3\u9644\u5987\u7F1A\u5490\u5676\u560E\u8BE5\u6539\u6982\u9499\u76D6\u6E89\u5E72\u7518\u6746\u67D1\u7AFF\u809D\u8D76\u611F\u79C6\u6562\u8D63\u5188\u521A\u94A2\u7F38\u809B\u7EB2\u5C97\u6E2F\u6760\u7BD9\u768B\u9AD8\u818F\u7F94\u7CD5\u641E\u9550\u7A3F\u544A\u54E5\u6B4C\u6401\u6208\u9E3D\u80F3\u7599\u5272\u9769\u845B\u683C\u86E4\u9601\u9694\u94EC\u4E2A\u5404\u7ED9\u6839\u8DDF\u8015\u66F4\u5E9A\u7FB9"],
      ["b940", "\u7B2F\u7B30\u7B32\u7B34\u7B35\u7B36\u7B37\u7B39\u7B3B\u7B3D\u7B3F", 5, "\u7B46\u7B48\u7B4A\u7B4D\u7B4E\u7B53\u7B55\u7B57\u7B59\u7B5C\u7B5E\u7B5F\u7B61\u7B63", 10, "\u7B6F\u7B70\u7B73\u7B74\u7B76\u7B78\u7B7A\u7B7C\u7B7D\u7B7F\u7B81\u7B82\u7B83\u7B84\u7B86", 6, "\u7B8E\u7B8F"],
      ["b980", "\u7B91\u7B92\u7B93\u7B96\u7B98\u7B99\u7B9A\u7B9B\u7B9E\u7B9F\u7BA0\u7BA3\u7BA4\u7BA5\u7BAE\u7BAF\u7BB0\u7BB2\u7BB3\u7BB5\u7BB6\u7BB7\u7BB9", 7, "\u7BC2\u7BC3\u7BC4\u57C2\u803F\u6897\u5DE5\u653B\u529F\u606D\u9F9A\u4F9B\u8EAC\u516C\u5BAB\u5F13\u5DE9\u6C5E\u62F1\u8D21\u5171\u94A9\u52FE\u6C9F\u82DF\u72D7\u57A2\u6784\u8D2D\u591F\u8F9C\u83C7\u5495\u7B8D\u4F30\u6CBD\u5B64\u59D1\u9F13\u53E4\u86CA\u9AA8\u8C37\u80A1\u6545\u987E\u56FA\u96C7\u522E\u74DC\u5250\u5BE1\u6302\u8902\u4E56\u62D0\u602A\u68FA\u5173\u5B98\u51A0\u89C2\u7BA1\u9986\u7F50\u60EF\u704C\u8D2F\u5149\u5E7F\u901B\u7470\u89C4\u572D\u7845\u5F52\u9F9F\u95FA\u8F68\u9B3C\u8BE1\u7678\u6842\u67DC\u8DEA\u8D35\u523D\u8F8A\u6EDA\u68CD\u9505\u90ED\u56FD\u679C\u88F9\u8FC7\u54C8"],
      ["ba40", "\u7BC5\u7BC8\u7BC9\u7BCA\u7BCB\u7BCD\u7BCE\u7BCF\u7BD0\u7BD2\u7BD4", 4, "\u7BDB\u7BDC\u7BDE\u7BDF\u7BE0\u7BE2\u7BE3\u7BE4\u7BE7\u7BE8\u7BE9\u7BEB\u7BEC\u7BED\u7BEF\u7BF0\u7BF2", 4, "\u7BF8\u7BF9\u7BFA\u7BFB\u7BFD\u7BFF", 7, "\u7C08\u7C09\u7C0A\u7C0D\u7C0E\u7C10", 5, "\u7C17\u7C18\u7C19"],
      ["ba80", "\u7C1A", 4, "\u7C20", 5, "\u7C28\u7C29\u7C2B", 12, "\u7C39", 5, "\u7C42\u9AB8\u5B69\u6D77\u6C26\u4EA5\u5BB3\u9A87\u9163\u61A8\u90AF\u97E9\u542B\u6DB5\u5BD2\u51FD\u558A\u7F55\u7FF0\u64BC\u634D\u65F1\u61BE\u608D\u710A\u6C57\u6C49\u592F\u676D\u822A\u58D5\u568E\u8C6A\u6BEB\u90DD\u597D\u8017\u53F7\u6D69\u5475\u559D\u8377\u83CF\u6838\u79BE\u548C\u4F55\u5408\u76D2\u8C89\u9602\u6CB3\u6DB8\u8D6B\u8910\u9E64\u8D3A\u563F\u9ED1\u75D5\u5F88\u72E0\u6068\u54FC\u4EA8\u6A2A\u8861\u6052\u8F70\u54C4\u70D8\u8679\u9E3F\u6D2A\u5B8F\u5F18\u7EA2\u5589\u4FAF\u7334\u543C\u539A\u5019\u540E\u547C\u4E4E\u5FFD\u745A\u58F6\u846B\u80E1\u8774\u72D0\u7CCA\u6E56"],
      ["bb40", "\u7C43", 9, "\u7C4E", 36, "\u7C75", 5, "\u7C7E", 9],
      ["bb80", "\u7C88\u7C8A", 6, "\u7C93\u7C94\u7C96\u7C99\u7C9A\u7C9B\u7CA0\u7CA1\u7CA3\u7CA6\u7CA7\u7CA8\u7CA9\u7CAB\u7CAC\u7CAD\u7CAF\u7CB0\u7CB4", 4, "\u7CBA\u7CBB\u5F27\u864E\u552C\u62A4\u4E92\u6CAA\u6237\u82B1\u54D7\u534E\u733E\u6ED1\u753B\u5212\u5316\u8BDD\u69D0\u5F8A\u6000\u6DEE\u574F\u6B22\u73AF\u6853\u8FD8\u7F13\u6362\u60A3\u5524\u75EA\u8C62\u7115\u6DA3\u5BA6\u5E7B\u8352\u614C\u9EC4\u78FA\u8757\u7C27\u7687\u51F0\u60F6\u714C\u6643\u5E4C\u604D\u8C0E\u7070\u6325\u8F89\u5FBD\u6062\u86D4\u56DE\u6BC1\u6094\u6167\u5349\u60E0\u6666\u8D3F\u79FD\u4F1A\u70E9\u6C47\u8BB3\u8BF2\u7ED8\u8364\u660F\u5A5A\u9B42\u6D51\u6DF7\u8C41\u6D3B\u4F19\u706B\u83B7\u6216\u60D1\u970D\u8D27\u7978\u51FB\u573E\u57FA\u673A\u7578\u7A3D\u79EF\u7B95"],
      ["bc40", "\u7CBF\u7CC0\u7CC2\u7CC3\u7CC4\u7CC6\u7CC9\u7CCB\u7CCE", 6, "\u7CD8\u7CDA\u7CDB\u7CDD\u7CDE\u7CE1", 6, "\u7CE9", 5, "\u7CF0", 7, "\u7CF9\u7CFA\u7CFC", 13, "\u7D0B", 5],
      ["bc80", "\u7D11", 14, "\u7D21\u7D23\u7D24\u7D25\u7D26\u7D28\u7D29\u7D2A\u7D2C\u7D2D\u7D2E\u7D30", 6, "\u808C\u9965\u8FF9\u6FC0\u8BA5\u9E21\u59EC\u7EE9\u7F09\u5409\u6781\u68D8\u8F91\u7C4D\u96C6\u53CA\u6025\u75BE\u6C72\u5373\u5AC9\u7EA7\u6324\u51E0\u810A\u5DF1\u84DF\u6280\u5180\u5B63\u4F0E\u796D\u5242\u60B8\u6D4E\u5BC4\u5BC2\u8BA1\u8BB0\u65E2\u5FCC\u9645\u5993\u7EE7\u7EAA\u5609\u67B7\u5939\u4F73\u5BB6\u52A0\u835A\u988A\u8D3E\u7532\u94BE\u5047\u7A3C\u4EF7\u67B6\u9A7E\u5AC1\u6B7C\u76D1\u575A\u5C16\u7B3A\u95F4\u714E\u517C\u80A9\u8270\u5978\u7F04\u8327\u68C0\u67EC\u78B1\u7877\u62E3\u6361\u7B80\u4FED\u526A\u51CF\u8350\u69DB\u9274\u8DF5\u8D31\u89C1\u952E\u7BAD\u4EF6"],
      ["bd40", "\u7D37", 54, "\u7D6F", 7],
      ["bd80", "\u7D78", 32, "\u5065\u8230\u5251\u996F\u6E10\u6E85\u6DA7\u5EFA\u50F5\u59DC\u5C06\u6D46\u6C5F\u7586\u848B\u6868\u5956\u8BB2\u5320\u9171\u964D\u8549\u6912\u7901\u7126\u80F6\u4EA4\u90CA\u6D47\u9A84\u5A07\u56BC\u6405\u94F0\u77EB\u4FA5\u811A\u72E1\u89D2\u997A\u7F34\u7EDE\u527F\u6559\u9175\u8F7F\u8F83\u53EB\u7A96\u63ED\u63A5\u7686\u79F8\u8857\u9636\u622A\u52AB\u8282\u6854\u6770\u6377\u776B\u7AED\u6D01\u7ED3\u89E3\u59D0\u6212\u85C9\u82A5\u754C\u501F\u4ECB\u75A5\u8BEB\u5C4A\u5DFE\u7B4B\u65A4\u91D1\u4ECA\u6D25\u895F\u7D27\u9526\u4EC5\u8C28\u8FDB\u9773\u664B\u7981\u8FD1\u70EC\u6D78"],
      ["be40", "\u7D99", 12, "\u7DA7", 6, "\u7DAF", 42],
      ["be80", "\u7DDA", 32, "\u5C3D\u52B2\u8346\u5162\u830E\u775B\u6676\u9CB8\u4EAC\u60CA\u7CBE\u7CB3\u7ECF\u4E95\u8B66\u666F\u9888\u9759\u5883\u656C\u955C\u5F84\u75C9\u9756\u7ADF\u7ADE\u51C0\u70AF\u7A98\u63EA\u7A76\u7EA0\u7396\u97ED\u4E45\u7078\u4E5D\u9152\u53A9\u6551\u65E7\u81FC\u8205\u548E\u5C31\u759A\u97A0\u62D8\u72D9\u75BD\u5C45\u9A79\u83CA\u5C40\u5480\u77E9\u4E3E\u6CAE\u805A\u62D2\u636E\u5DE8\u5177\u8DDD\u8E1E\u952F\u4FF1\u53E5\u60E7\u70AC\u5267\u6350\u9E43\u5A1F\u5026\u7737\u5377\u7EE2\u6485\u652B\u6289\u6398\u5014\u7235\u89C9\u51B3\u8BC0\u7EDD\u5747\u83CC\u94A7\u519B\u541B\u5CFB"],
      ["bf40", "\u7DFB", 62],
      ["bf80", "\u7E3A\u7E3C", 4, "\u7E42", 4, "\u7E48", 21, "\u4FCA\u7AE3\u6D5A\u90E1\u9A8F\u5580\u5496\u5361\u54AF\u5F00\u63E9\u6977\u51EF\u6168\u520A\u582A\u52D8\u574E\u780D\u770B\u5EB7\u6177\u7CE0\u625B\u6297\u4EA2\u7095\u8003\u62F7\u70E4\u9760\u5777\u82DB\u67EF\u68F5\u78D5\u9897\u79D1\u58F3\u54B3\u53EF\u6E34\u514B\u523B\u5BA2\u8BFE\u80AF\u5543\u57A6\u6073\u5751\u542D\u7A7A\u6050\u5B54\u63A7\u62A0\u53E3\u6263\u5BC7\u67AF\u54ED\u7A9F\u82E6\u9177\u5E93\u88E4\u5938\u57AE\u630E\u8DE8\u80EF\u5757\u7B77\u4FA9\u5FEB\u5BBD\u6B3E\u5321\u7B50\u72C2\u6846\u77FF\u7736\u65F7\u51B5\u4E8F\u76D4\u5CBF\u7AA5\u8475\u594E\u9B41\u5080"],
      ["c040", "\u7E5E", 35, "\u7E83", 23, "\u7E9C\u7E9D\u7E9E"],
      ["c080", "\u7EAE\u7EB4\u7EBB\u7EBC\u7ED6\u7EE4\u7EEC\u7EF9\u7F0A\u7F10\u7F1E\u7F37\u7F39\u7F3B", 6, "\u7F43\u7F46", 9, "\u7F52\u7F53\u9988\u6127\u6E83\u5764\u6606\u6346\u56F0\u62EC\u6269\u5ED3\u9614\u5783\u62C9\u5587\u8721\u814A\u8FA3\u5566\u83B1\u6765\u8D56\u84DD\u5A6A\u680F\u62E6\u7BEE\u9611\u5170\u6F9C\u8C30\u63FD\u89C8\u61D2\u7F06\u70C2\u6EE5\u7405\u6994\u72FC\u5ECA\u90CE\u6717\u6D6A\u635E\u52B3\u7262\u8001\u4F6C\u59E5\u916A\u70D9\u6D9D\u52D2\u4E50\u96F7\u956D\u857E\u78CA\u7D2F\u5121\u5792\u64C2\u808B\u7C7B\u6CEA\u68F1\u695E\u51B7\u5398\u68A8\u7281\u9ECE\u7BF1\u72F8\u79BB\u6F13\u7406\u674E\u91CC\u9CA4\u793C\u8389\u8354\u540F\u6817\u4E3D\u5389\u52B1\u783E\u5386\u5229\u5088\u4F8B\u4FD0"],
      ["c140", "\u7F56\u7F59\u7F5B\u7F5C\u7F5D\u7F5E\u7F60\u7F63", 4, "\u7F6B\u7F6C\u7F6D\u7F6F\u7F70\u7F73\u7F75\u7F76\u7F77\u7F78\u7F7A\u7F7B\u7F7C\u7F7D\u7F7F\u7F80\u7F82", 7, "\u7F8B\u7F8D\u7F8F", 4, "\u7F95", 4, "\u7F9B\u7F9C\u7FA0\u7FA2\u7FA3\u7FA5\u7FA6\u7FA8", 6, "\u7FB1"],
      ["c180", "\u7FB3", 4, "\u7FBA\u7FBB\u7FBE\u7FC0\u7FC2\u7FC3\u7FC4\u7FC6\u7FC7\u7FC8\u7FC9\u7FCB\u7FCD\u7FCF", 4, "\u7FD6\u7FD7\u7FD9", 5, "\u7FE2\u7FE3\u75E2\u7ACB\u7C92\u6CA5\u96B6\u529B\u7483\u54E9\u4FE9\u8054\u83B2\u8FDE\u9570\u5EC9\u601C\u6D9F\u5E18\u655B\u8138\u94FE\u604B\u70BC\u7EC3\u7CAE\u51C9\u6881\u7CB1\u826F\u4E24\u8F86\u91CF\u667E\u4EAE\u8C05\u64A9\u804A\u50DA\u7597\u71CE\u5BE5\u8FBD\u6F66\u4E86\u6482\u9563\u5ED6\u6599\u5217\u88C2\u70C8\u52A3\u730E\u7433\u6797\u78F7\u9716\u4E34\u90BB\u9CDE\u6DCB\u51DB\u8D41\u541D\u62CE\u73B2\u83F1\u96F6\u9F84\u94C3\u4F36\u7F9A\u51CC\u7075\u9675\u5CAD\u9886\u53E6\u4EE4\u6E9C\u7409\u69B4\u786B\u998F\u7559\u5218\u7624\u6D41\u67F3\u516D\u9F99\u804B\u5499\u7B3C\u7ABF"],
      ["c240", "\u7FE4\u7FE7\u7FE8\u7FEA\u7FEB\u7FEC\u7FED\u7FEF\u7FF2\u7FF4", 6, "\u7FFD\u7FFE\u7FFF\u8002\u8007\u8008\u8009\u800A\u800E\u800F\u8011\u8013\u801A\u801B\u801D\u801E\u801F\u8021\u8023\u8024\u802B", 5, "\u8032\u8034\u8039\u803A\u803C\u803E\u8040\u8041\u8044\u8045\u8047\u8048\u8049\u804E\u804F\u8050\u8051\u8053\u8055\u8056\u8057"],
      ["c280", "\u8059\u805B", 13, "\u806B", 5, "\u8072", 11, "\u9686\u5784\u62E2\u9647\u697C\u5A04\u6402\u7BD3\u6F0F\u964B\u82A6\u5362\u9885\u5E90\u7089\u63B3\u5364\u864F\u9C81\u9E93\u788C\u9732\u8DEF\u8D42\u9E7F\u6F5E\u7984\u5F55\u9646\u622E\u9A74\u5415\u94DD\u4FA3\u65C5\u5C65\u5C61\u7F15\u8651\u6C2F\u5F8B\u7387\u6EE4\u7EFF\u5CE6\u631B\u5B6A\u6EE6\u5375\u4E71\u63A0\u7565\u62A1\u8F6E\u4F26\u4ED1\u6CA6\u7EB6\u8BBA\u841D\u87BA\u7F57\u903B\u9523\u7BA9\u9AA1\u88F8\u843D\u6D1B\u9A86\u7EDC\u5988\u9EBB\u739B\u7801\u8682\u9A6C\u9A82\u561B\u5417\u57CB\u4E70\u9EA6\u5356\u8FC8\u8109\u7792\u9992\u86EE\u6EE1\u8513\u66FC\u6162\u6F2B"],
      ["c340", "\u807E\u8081\u8082\u8085\u8088\u808A\u808D", 5, "\u8094\u8095\u8097\u8099\u809E\u80A3\u80A6\u80A7\u80A8\u80AC\u80B0\u80B3\u80B5\u80B6\u80B8\u80B9\u80BB\u80C5\u80C7", 4, "\u80CF", 6, "\u80D8\u80DF\u80E0\u80E2\u80E3\u80E6\u80EE\u80F5\u80F7\u80F9\u80FB\u80FE\u80FF\u8100\u8101\u8103\u8104\u8105\u8107\u8108\u810B"],
      ["c380", "\u810C\u8115\u8117\u8119\u811B\u811C\u811D\u811F", 12, "\u812D\u812E\u8130\u8133\u8134\u8135\u8137\u8139", 4, "\u813F\u8C29\u8292\u832B\u76F2\u6C13\u5FD9\u83BD\u732B\u8305\u951A\u6BDB\u77DB\u94C6\u536F\u8302\u5192\u5E3D\u8C8C\u8D38\u4E48\u73AB\u679A\u6885\u9176\u9709\u7164\u6CA1\u7709\u5A92\u9541\u6BCF\u7F8E\u6627\u5BD0\u59B9\u5A9A\u95E8\u95F7\u4EEC\u840C\u8499\u6AAC\u76DF\u9530\u731B\u68A6\u5B5F\u772F\u919A\u9761\u7CDC\u8FF7\u8C1C\u5F25\u7C73\u79D8\u89C5\u6CCC\u871C\u5BC6\u5E42\u68C9\u7720\u7EF5\u5195\u514D\u52C9\u5A29\u7F05\u9762\u82D7\u63CF\u7784\u85D0\u79D2\u6E3A\u5E99\u5999\u8511\u706D\u6C11\u62BF\u76BF\u654F\u60AF\u95FD\u660E\u879F\u9E23\u94ED\u540D\u547D\u8C2C\u6478"],
      ["c440", "\u8140", 5, "\u8147\u8149\u814D\u814E\u814F\u8152\u8156\u8157\u8158\u815B", 4, "\u8161\u8162\u8163\u8164\u8166\u8168\u816A\u816B\u816C\u816F\u8172\u8173\u8175\u8176\u8177\u8178\u8181\u8183", 4, "\u8189\u818B\u818C\u818D\u818E\u8190\u8192", 5, "\u8199\u819A\u819E", 4, "\u81A4\u81A5"],
      ["c480", "\u81A7\u81A9\u81AB", 7, "\u81B4", 5, "\u81BC\u81BD\u81BE\u81BF\u81C4\u81C5\u81C7\u81C8\u81C9\u81CB\u81CD", 6, "\u6479\u8611\u6A21\u819C\u78E8\u6469\u9B54\u62B9\u672B\u83AB\u58A8\u9ED8\u6CAB\u6F20\u5BDE\u964C\u8C0B\u725F\u67D0\u62C7\u7261\u4EA9\u59C6\u6BCD\u5893\u66AE\u5E55\u52DF\u6155\u6728\u76EE\u7766\u7267\u7A46\u62FF\u54EA\u5450\u94A0\u90A3\u5A1C\u7EB3\u6C16\u4E43\u5976\u8010\u5948\u5357\u7537\u96BE\u56CA\u6320\u8111\u607C\u95F9\u6DD6\u5462\u9981\u5185\u5AE9\u80FD\u59AE\u9713\u502A\u6CE5\u5C3C\u62DF\u4F60\u533F\u817B\u9006\u6EBA\u852B\u62C8\u5E74\u78BE\u64B5\u637B\u5FF5\u5A18\u917F\u9E1F\u5C3F\u634F\u8042\u5B7D\u556E\u954A\u954D\u6D85\u60A8\u67E0\u72DE\u51DD\u5B81"],
      ["c540", "\u81D4", 14, "\u81E4\u81E5\u81E6\u81E8\u81E9\u81EB\u81EE", 4, "\u81F5", 5, "\u81FD\u81FF\u8203\u8207", 4, "\u820E\u820F\u8211\u8213\u8215", 5, "\u821D\u8220\u8224\u8225\u8226\u8227\u8229\u822E\u8232\u823A\u823C\u823D\u823F"],
      ["c580", "\u8240\u8241\u8242\u8243\u8245\u8246\u8248\u824A\u824C\u824D\u824E\u8250", 7, "\u8259\u825B\u825C\u825D\u825E\u8260", 7, "\u8269\u62E7\u6CDE\u725B\u626D\u94AE\u7EBD\u8113\u6D53\u519C\u5F04\u5974\u52AA\u6012\u5973\u6696\u8650\u759F\u632A\u61E6\u7CEF\u8BFA\u54E6\u6B27\u9E25\u6BB4\u85D5\u5455\u5076\u6CA4\u556A\u8DB4\u722C\u5E15\u6015\u7436\u62CD\u6392\u724C\u5F98\u6E43\u6D3E\u6500\u6F58\u76D8\u78D0\u76FC\u7554\u5224\u53DB\u4E53\u5E9E\u65C1\u802A\u80D6\u629B\u5486\u5228\u70AE\u888D\u8DD1\u6CE1\u5478\u80DA\u57F9\u88F4\u8D54\u966A\u914D\u4F69\u6C9B\u55B7\u76C6\u7830\u62A8\u70F9\u6F8E\u5F6D\u84EC\u68DA\u787C\u7BF7\u81A8\u670B\u9E4F\u6367\u78B0\u576F\u7812\u9739\u6279\u62AB\u5288\u7435\u6BD7"],
      ["c640", "\u826A\u826B\u826C\u826D\u8271\u8275\u8276\u8277\u8278\u827B\u827C\u8280\u8281\u8283\u8285\u8286\u8287\u8289\u828C\u8290\u8293\u8294\u8295\u8296\u829A\u829B\u829E\u82A0\u82A2\u82A3\u82A7\u82B2\u82B5\u82B6\u82BA\u82BB\u82BC\u82BF\u82C0\u82C2\u82C3\u82C5\u82C6\u82C9\u82D0\u82D6\u82D9\u82DA\u82DD\u82E2\u82E7\u82E8\u82E9\u82EA\u82EC\u82ED\u82EE\u82F0\u82F2\u82F3\u82F5\u82F6\u82F8"],
      ["c680", "\u82FA\u82FC", 4, "\u830A\u830B\u830D\u8310\u8312\u8313\u8316\u8318\u8319\u831D", 9, "\u8329\u832A\u832E\u8330\u8332\u8337\u833B\u833D\u5564\u813E\u75B2\u76AE\u5339\u75DE\u50FB\u5C41\u8B6C\u7BC7\u504F\u7247\u9A97\u98D8\u6F02\u74E2\u7968\u6487\u77A5\u62FC\u9891\u8D2B\u54C1\u8058\u4E52\u576A\u82F9\u840D\u5E73\u51ED\u74F6\u8BC4\u5C4F\u5761\u6CFC\u9887\u5A46\u7834\u9B44\u8FEB\u7C95\u5256\u6251\u94FA\u4EC6\u8386\u8461\u83E9\u84B2\u57D4\u6734\u5703\u666E\u6D66\u8C31\u66DD\u7011\u671F\u6B3A\u6816\u621A\u59BB\u4E03\u51C4\u6F06\u67D2\u6C8F\u5176\u68CB\u5947\u6B67\u7566\u5D0E\u8110\u9F50\u65D7\u7948\u7941\u9A91\u8D77\u5C82\u4E5E\u4F01\u542F\u5951\u780C\u5668\u6C14\u8FC4\u5F03\u6C7D\u6CE3\u8BAB\u6390"],
      ["c740", "\u833E\u833F\u8341\u8342\u8344\u8345\u8348\u834A", 4, "\u8353\u8355", 4, "\u835D\u8362\u8370", 6, "\u8379\u837A\u837E", 6, "\u8387\u8388\u838A\u838B\u838C\u838D\u838F\u8390\u8391\u8394\u8395\u8396\u8397\u8399\u839A\u839D\u839F\u83A1", 6, "\u83AC\u83AD\u83AE"],
      ["c780", "\u83AF\u83B5\u83BB\u83BE\u83BF\u83C2\u83C3\u83C4\u83C6\u83C8\u83C9\u83CB\u83CD\u83CE\u83D0\u83D1\u83D2\u83D3\u83D5\u83D7\u83D9\u83DA\u83DB\u83DE\u83E2\u83E3\u83E4\u83E6\u83E7\u83E8\u83EB\u83EC\u83ED\u6070\u6D3D\u7275\u6266\u948E\u94C5\u5343\u8FC1\u7B7E\u4EDF\u8C26\u4E7E\u9ED4\u94B1\u94B3\u524D\u6F5C\u9063\u6D45\u8C34\u5811\u5D4C\u6B20\u6B49\u67AA\u545B\u8154\u7F8C\u5899\u8537\u5F3A\u62A2\u6A47\u9539\u6572\u6084\u6865\u77A7\u4E54\u4FA8\u5DE7\u9798\u64AC\u7FD8\u5CED\u4FCF\u7A8D\u5207\u8304\u4E14\u602F\u7A83\u94A6\u4FB5\u4EB2\u79E6\u7434\u52E4\u82B9\u64D2\u79BD\u5BDD\u6C81\u9752\u8F7B\u6C22\u503E\u537F\u6E05\u64CE\u6674\u6C30\u60C5\u9877\u8BF7\u5E86\u743C\u7A77\u79CB\u4E18\u90B1\u7403\u6C42\u56DA\u914B\u6CC5\u8D8B\u533A\u86C6\u66F2\u8EAF\u5C48\u9A71\u6E20"],
      ["c840", "\u83EE\u83EF\u83F3", 4, "\u83FA\u83FB\u83FC\u83FE\u83FF\u8400\u8402\u8405\u8407\u8408\u8409\u840A\u8410\u8412", 5, "\u8419\u841A\u841B\u841E", 5, "\u8429", 7, "\u8432", 5, "\u8439\u843A\u843B\u843E", 7, "\u8447\u8448\u8449"],
      ["c880", "\u844A", 6, "\u8452", 4, "\u8458\u845D\u845E\u845F\u8460\u8462\u8464", 4, "\u846A\u846E\u846F\u8470\u8472\u8474\u8477\u8479\u847B\u847C\u53D6\u5A36\u9F8B\u8DA3\u53BB\u5708\u98A7\u6743\u919B\u6CC9\u5168\u75CA\u62F3\u72AC\u5238\u529D\u7F3A\u7094\u7638\u5374\u9E4A\u69B7\u786E\u96C0\u88D9\u7FA4\u7136\u71C3\u5189\u67D3\u74E4\u58E4\u6518\u56B7\u8BA9\u9976\u6270\u7ED5\u60F9\u70ED\u58EC\u4EC1\u4EBA\u5FCD\u97E7\u4EFB\u8BA4\u5203\u598A\u7EAB\u6254\u4ECD\u65E5\u620E\u8338\u84C9\u8363\u878D\u7194\u6EB6\u5BB9\u7ED2\u5197\u63C9\u67D4\u8089\u8339\u8815\u5112\u5B7A\u5982\u8FB1\u4E73\u6C5D\u5165\u8925\u8F6F\u962E\u854A\u745E\u9510\u95F0\u6DA6\u82E5\u5F31\u6492\u6D12\u8428\u816E\u9CC3\u585E\u8D5B\u4E09\u53C1"],
      ["c940", "\u847D", 4, "\u8483\u8484\u8485\u8486\u848A\u848D\u848F", 7, "\u8498\u849A\u849B\u849D\u849E\u849F\u84A0\u84A2", 12, "\u84B0\u84B1\u84B3\u84B5\u84B6\u84B7\u84BB\u84BC\u84BE\u84C0\u84C2\u84C3\u84C5\u84C6\u84C7\u84C8\u84CB\u84CC\u84CE\u84CF\u84D2\u84D4\u84D5\u84D7"],
      ["c980", "\u84D8", 4, "\u84DE\u84E1\u84E2\u84E4\u84E7", 4, "\u84ED\u84EE\u84EF\u84F1", 10, "\u84FD\u84FE\u8500\u8501\u8502\u4F1E\u6563\u6851\u55D3\u4E27\u6414\u9A9A\u626B\u5AC2\u745F\u8272\u6DA9\u68EE\u50E7\u838E\u7802\u6740\u5239\u6C99\u7EB1\u50BB\u5565\u715E\u7B5B\u6652\u73CA\u82EB\u6749\u5C71\u5220\u717D\u886B\u95EA\u9655\u64C5\u8D61\u81B3\u5584\u6C55\u6247\u7F2E\u5892\u4F24\u5546\u8D4F\u664C\u4E0A\u5C1A\u88F3\u68A2\u634E\u7A0D\u70E7\u828D\u52FA\u97F6\u5C11\u54E8\u90B5\u7ECD\u5962\u8D4A\u86C7\u820C\u820D\u8D66\u6444\u5C04\u6151\u6D89\u793E\u8BBE\u7837\u7533\u547B\u4F38\u8EAB\u6DF1\u5A20\u7EC5\u795E\u6C88\u5BA1\u5A76\u751A\u80BE\u614E\u6E17\u58F0\u751F\u7525\u7272\u5347\u7EF3"],
      ["ca40", "\u8503", 8, "\u850D\u850E\u850F\u8510\u8512\u8514\u8515\u8516\u8518\u8519\u851B\u851C\u851D\u851E\u8520\u8522", 8, "\u852D", 9, "\u853E", 4, "\u8544\u8545\u8546\u8547\u854B", 10],
      ["ca80", "\u8557\u8558\u855A\u855B\u855C\u855D\u855F", 4, "\u8565\u8566\u8567\u8569", 8, "\u8573\u8575\u8576\u8577\u8578\u857C\u857D\u857F\u8580\u8581\u7701\u76DB\u5269\u80DC\u5723\u5E08\u5931\u72EE\u65BD\u6E7F\u8BD7\u5C38\u8671\u5341\u77F3\u62FE\u65F6\u4EC0\u98DF\u8680\u5B9E\u8BC6\u53F2\u77E2\u4F7F\u5C4E\u9A76\u59CB\u5F0F\u793A\u58EB\u4E16\u67FF\u4E8B\u62ED\u8A93\u901D\u52BF\u662F\u55DC\u566C\u9002\u4ED5\u4F8D\u91CA\u9970\u6C0F\u5E02\u6043\u5BA4\u89C6\u8BD5\u6536\u624B\u9996\u5B88\u5BFF\u6388\u552E\u53D7\u7626\u517D\u852C\u67A2\u68B3\u6B8A\u6292\u8F93\u53D4\u8212\u6DD1\u758F\u4E66\u8D4E\u5B70\u719F\u85AF\u6691\u66D9\u7F72\u8700\u9ECD\u9F20\u5C5E\u672F\u8FF0\u6811\u675F\u620D\u7AD6\u5885\u5EB6\u6570\u6F31"],
      ["cb40", "\u8582\u8583\u8586\u8588", 6, "\u8590", 10, "\u859D", 6, "\u85A5\u85A6\u85A7\u85A9\u85AB\u85AC\u85AD\u85B1", 5, "\u85B8\u85BA", 6, "\u85C2", 6, "\u85CA", 4, "\u85D1\u85D2"],
      ["cb80", "\u85D4\u85D6", 5, "\u85DD", 6, "\u85E5\u85E6\u85E7\u85E8\u85EA", 14, "\u6055\u5237\u800D\u6454\u8870\u7529\u5E05\u6813\u62F4\u971C\u53CC\u723D\u8C01\u6C34\u7761\u7A0E\u542E\u77AC\u987A\u821C\u8BF4\u7855\u6714\u70C1\u65AF\u6495\u5636\u601D\u79C1\u53F8\u4E1D\u6B7B\u8086\u5BFA\u55E3\u56DB\u4F3A\u4F3C\u9972\u5DF3\u677E\u8038\u6002\u9882\u9001\u5B8B\u8BBC\u8BF5\u641C\u8258\u64DE\u55FD\u82CF\u9165\u4FD7\u7D20\u901F\u7C9F\u50F3\u5851\u6EAF\u5BBF\u8BC9\u8083\u9178\u849C\u7B97\u867D\u968B\u968F\u7EE5\u9AD3\u788E\u5C81\u7A57\u9042\u96A7\u795F\u5B59\u635F\u7B0B\u84D1\u68AD\u5506\u7F29\u7410\u7D22\u9501\u6240\u584C\u4ED6\u5B83\u5979\u5854"],
      ["cc40", "\u85F9\u85FA\u85FC\u85FD\u85FE\u8600", 4, "\u8606", 10, "\u8612\u8613\u8614\u8615\u8617", 15, "\u8628\u862A", 13, "\u8639\u863A\u863B\u863D\u863E\u863F\u8640"],
      ["cc80", "\u8641", 11, "\u8652\u8653\u8655", 4, "\u865B\u865C\u865D\u865F\u8660\u8661\u8663", 7, "\u736D\u631E\u8E4B\u8E0F\u80CE\u82D4\u62AC\u53F0\u6CF0\u915E\u592A\u6001\u6C70\u574D\u644A\u8D2A\u762B\u6EE9\u575B\u6A80\u75F0\u6F6D\u8C2D\u8C08\u5766\u6BEF\u8892\u78B3\u63A2\u53F9\u70AD\u6C64\u5858\u642A\u5802\u68E0\u819B\u5510\u7CD6\u5018\u8EBA\u6DCC\u8D9F\u70EB\u638F\u6D9B\u6ED4\u7EE6\u8404\u6843\u9003\u6DD8\u9676\u8BA8\u5957\u7279\u85E4\u817E\u75BC\u8A8A\u68AF\u5254\u8E22\u9511\u63D0\u9898\u8E44\u557C\u4F53\u66FF\u568F\u60D5\u6D95\u5243\u5C49\u5929\u6DFB\u586B\u7530\u751C\u606C\u8214\u8146\u6311\u6761\u8FE2\u773A\u8DF3\u8D34\u94C1\u5E16\u5385\u542C\u70C3"],
      ["cd40", "\u866D\u866F\u8670\u8672", 6, "\u8683", 6, "\u868E", 4, "\u8694\u8696", 5, "\u869E", 4, "\u86A5\u86A6\u86AB\u86AD\u86AE\u86B2\u86B3\u86B7\u86B8\u86B9\u86BB", 4, "\u86C1\u86C2\u86C3\u86C5\u86C8\u86CC\u86CD\u86D2\u86D3\u86D5\u86D6\u86D7\u86DA\u86DC"],
      ["cd80", "\u86DD\u86E0\u86E1\u86E2\u86E3\u86E5\u86E6\u86E7\u86E8\u86EA\u86EB\u86EC\u86EF\u86F5\u86F6\u86F7\u86FA\u86FB\u86FC\u86FD\u86FF\u8701\u8704\u8705\u8706\u870B\u870C\u870E\u870F\u8710\u8711\u8714\u8716\u6C40\u5EF7\u505C\u4EAD\u5EAD\u633A\u8247\u901A\u6850\u916E\u77B3\u540C\u94DC\u5F64\u7AE5\u6876\u6345\u7B52\u7EDF\u75DB\u5077\u6295\u5934\u900F\u51F8\u79C3\u7A81\u56FE\u5F92\u9014\u6D82\u5C60\u571F\u5410\u5154\u6E4D\u56E2\u63A8\u9893\u817F\u8715\u892A\u9000\u541E\u5C6F\u81C0\u62D6\u6258\u8131\u9E35\u9640\u9A6E\u9A7C\u692D\u59A5\u62D3\u553E\u6316\u54C7\u86D9\u6D3C\u5A03\u74E6\u889C\u6B6A\u5916\u8C4C\u5F2F\u6E7E\u73A9\u987D\u4E38\u70F7\u5B8C\u7897\u633D\u665A\u7696\u60CB\u5B9B\u5A49\u4E07\u8155\u6C6A\u738B\u4EA1\u6789\u7F51\u5F80\u65FA\u671B\u5FD8\u5984\u5A01"],
      ["ce40", "\u8719\u871B\u871D\u871F\u8720\u8724\u8726\u8727\u8728\u872A\u872B\u872C\u872D\u872F\u8730\u8732\u8733\u8735\u8736\u8738\u8739\u873A\u873C\u873D\u8740", 6, "\u874A\u874B\u874D\u874F\u8750\u8751\u8752\u8754\u8755\u8756\u8758\u875A", 5, "\u8761\u8762\u8766", 7, "\u876F\u8771\u8772\u8773\u8775"],
      ["ce80", "\u8777\u8778\u8779\u877A\u877F\u8780\u8781\u8784\u8786\u8787\u8789\u878A\u878C\u878E", 4, "\u8794\u8795\u8796\u8798", 6, "\u87A0", 4, "\u5DCD\u5FAE\u5371\u97E6\u8FDD\u6845\u56F4\u552F\u60DF\u4E3A\u6F4D\u7EF4\u82C7\u840E\u59D4\u4F1F\u4F2A\u5C3E\u7EAC\u672A\u851A\u5473\u754F\u80C3\u5582\u9B4F\u4F4D\u6E2D\u8C13\u5C09\u6170\u536B\u761F\u6E29\u868A\u6587\u95FB\u7EB9\u543B\u7A33\u7D0A\u95EE\u55E1\u7FC1\u74EE\u631D\u8717\u6DA1\u7A9D\u6211\u65A1\u5367\u63E1\u6C83\u5DEB\u545C\u94A8\u4E4C\u6C61\u8BEC\u5C4B\u65E0\u829C\u68A7\u543E\u5434\u6BCB\u6B66\u4E94\u6342\u5348\u821E\u4F0D\u4FAE\u575E\u620A\u96FE\u6664\u7269\u52FF\u52A1\u609F\u8BEF\u6614\u7199\u6790\u897F\u7852\u77FD\u6670\u563B\u5438\u9521\u727A"],
      ["cf40", "\u87A5\u87A6\u87A7\u87A9\u87AA\u87AE\u87B0\u87B1\u87B2\u87B4\u87B6\u87B7\u87B8\u87B9\u87BB\u87BC\u87BE\u87BF\u87C1", 4, "\u87C7\u87C8\u87C9\u87CC", 4, "\u87D4", 6, "\u87DC\u87DD\u87DE\u87DF\u87E1\u87E2\u87E3\u87E4\u87E6\u87E7\u87E8\u87E9\u87EB\u87EC\u87ED\u87EF", 9],
      ["cf80", "\u87FA\u87FB\u87FC\u87FD\u87FF\u8800\u8801\u8802\u8804", 5, "\u880B", 7, "\u8814\u8817\u8818\u8819\u881A\u881C", 4, "\u8823\u7A00\u606F\u5E0C\u6089\u819D\u5915\u60DC\u7184\u70EF\u6EAA\u6C50\u7280\u6A84\u88AD\u5E2D\u4E60\u5AB3\u559C\u94E3\u6D17\u7CFB\u9699\u620F\u7EC6\u778E\u867E\u5323\u971E\u8F96\u6687\u5CE1\u4FA0\u72ED\u4E0B\u53A6\u590F\u5413\u6380\u9528\u5148\u4ED9\u9C9C\u7EA4\u54B8\u8D24\u8854\u8237\u95F2\u6D8E\u5F26\u5ACC\u663E\u9669\u73B0\u732E\u53BF\u817A\u9985\u7FA1\u5BAA\u9677\u9650\u7EBF\u76F8\u53A2\u9576\u9999\u7BB1\u8944\u6E58\u4E61\u7FD4\u7965\u8BE6\u60F3\u54CD\u4EAB\u9879\u5DF7\u6A61\u50CF\u5411\u8C61\u8427\u785D\u9704\u524A\u54EE\u56A3\u9500\u6D88\u5BB5\u6DC6\u6653"],
      ["d040", "\u8824", 13, "\u8833", 5, "\u883A\u883B\u883D\u883E\u883F\u8841\u8842\u8843\u8846", 5, "\u884E", 5, "\u8855\u8856\u8858\u885A", 6, "\u8866\u8867\u886A\u886D\u886F\u8871\u8873\u8874\u8875\u8876\u8878\u8879\u887A"],
      ["d080", "\u887B\u887C\u8880\u8883\u8886\u8887\u8889\u888A\u888C\u888E\u888F\u8890\u8891\u8893\u8894\u8895\u8897", 4, "\u889D", 4, "\u88A3\u88A5", 5, "\u5C0F\u5B5D\u6821\u8096\u5578\u7B11\u6548\u6954\u4E9B\u6B47\u874E\u978B\u534F\u631F\u643A\u90AA\u659C\u80C1\u8C10\u5199\u68B0\u5378\u87F9\u61C8\u6CC4\u6CFB\u8C22\u5C51\u85AA\u82AF\u950C\u6B23\u8F9B\u65B0\u5FFB\u5FC3\u4FE1\u8845\u661F\u8165\u7329\u60FA\u5174\u5211\u578B\u5F62\u90A2\u884C\u9192\u5E78\u674F\u6027\u59D3\u5144\u51F6\u80F8\u5308\u6C79\u96C4\u718A\u4F11\u4FEE\u7F9E\u673D\u55C5\u9508\u79C0\u8896\u7EE3\u589F\u620C\u9700\u865A\u5618\u987B\u5F90\u8BB8\u84C4\u9157\u53D9\u65ED\u5E8F\u755C\u6064\u7D6E\u5A7F\u7EEA\u7EED\u8F69\u55A7\u5BA3\u60AC\u65CB\u7384"],
      ["d140", "\u88AC\u88AE\u88AF\u88B0\u88B2", 4, "\u88B8\u88B9\u88BA\u88BB\u88BD\u88BE\u88BF\u88C0\u88C3\u88C4\u88C7\u88C8\u88CA\u88CB\u88CC\u88CD\u88CF\u88D0\u88D1\u88D3\u88D6\u88D7\u88DA", 4, "\u88E0\u88E1\u88E6\u88E7\u88E9", 6, "\u88F2\u88F5\u88F6\u88F7\u88FA\u88FB\u88FD\u88FF\u8900\u8901\u8903", 5],
      ["d180", "\u8909\u890B", 4, "\u8911\u8914", 4, "\u891C", 4, "\u8922\u8923\u8924\u8926\u8927\u8928\u8929\u892C\u892D\u892E\u892F\u8931\u8932\u8933\u8935\u8937\u9009\u7663\u7729\u7EDA\u9774\u859B\u5B66\u7A74\u96EA\u8840\u52CB\u718F\u5FAA\u65EC\u8BE2\u5BFB\u9A6F\u5DE1\u6B89\u6C5B\u8BAD\u8BAF\u900A\u8FC5\u538B\u62BC\u9E26\u9E2D\u5440\u4E2B\u82BD\u7259\u869C\u5D16\u8859\u6DAF\u96C5\u54D1\u4E9A\u8BB6\u7109\u54BD\u9609\u70DF\u6DF9\u76D0\u4E25\u7814\u8712\u5CA9\u5EF6\u8A00\u989C\u960E\u708E\u6CBF\u5944\u63A9\u773C\u884D\u6F14\u8273\u5830\u71D5\u538C\u781A\u96C1\u5501\u5F66\u7130\u5BB4\u8C1A\u9A8C\u6B83\u592E\u9E2F\u79E7\u6768\u626C\u4F6F\u75A1\u7F8A\u6D0B\u9633\u6C27\u4EF0\u75D2\u517B\u6837\u6F3E\u9080\u8170\u5996\u7476"],
      ["d240", "\u8938", 8, "\u8942\u8943\u8945", 24, "\u8960", 5, "\u8967", 19, "\u897C"],
      ["d280", "\u897D\u897E\u8980\u8982\u8984\u8985\u8987", 26, "\u6447\u5C27\u9065\u7A91\u8C23\u59DA\u54AC\u8200\u836F\u8981\u8000\u6930\u564E\u8036\u7237\u91CE\u51B6\u4E5F\u9875\u6396\u4E1A\u53F6\u66F3\u814B\u591C\u6DB2\u4E00\u58F9\u533B\u63D6\u94F1\u4F9D\u4F0A\u8863\u9890\u5937\u9057\u79FB\u4EEA\u80F0\u7591\u6C82\u5B9C\u59E8\u5F5D\u6905\u8681\u501A\u5DF2\u4E59\u77E3\u4EE5\u827A\u6291\u6613\u9091\u5C79\u4EBF\u5F79\u81C6\u9038\u8084\u75AB\u4EA6\u88D4\u610F\u6BC5\u5FC6\u4E49\u76CA\u6EA2\u8BE3\u8BAE\u8C0A\u8BD1\u5F02\u7FFC\u7FCC\u7ECE\u8335\u836B\u56E0\u6BB7\u97F3\u9634\u59FB\u541F\u94F6\u6DEB\u5BC5\u996E\u5C39\u5F15\u9690"],
      ["d340", "\u89A2", 30, "\u89C3\u89CD\u89D3\u89D4\u89D5\u89D7\u89D8\u89D9\u89DB\u89DD\u89DF\u89E0\u89E1\u89E2\u89E4\u89E7\u89E8\u89E9\u89EA\u89EC\u89ED\u89EE\u89F0\u89F1\u89F2\u89F4", 6],
      ["d380", "\u89FB", 4, "\u8A01", 5, "\u8A08", 21, "\u5370\u82F1\u6A31\u5A74\u9E70\u5E94\u7F28\u83B9\u8424\u8425\u8367\u8747\u8FCE\u8D62\u76C8\u5F71\u9896\u786C\u6620\u54DF\u62E5\u4F63\u81C3\u75C8\u5EB8\u96CD\u8E0A\u86F9\u548F\u6CF3\u6D8C\u6C38\u607F\u52C7\u7528\u5E7D\u4F18\u60A0\u5FE7\u5C24\u7531\u90AE\u94C0\u72B9\u6CB9\u6E38\u9149\u6709\u53CB\u53F3\u4F51\u91C9\u8BF1\u53C8\u5E7C\u8FC2\u6DE4\u4E8E\u76C2\u6986\u865E\u611A\u8206\u4F59\u4FDE\u903E\u9C7C\u6109\u6E1D\u6E14\u9685\u4E88\u5A31\u96E8\u4E0E\u5C7F\u79B9\u5B87\u8BED\u7FBD\u7389\u57DF\u828B\u90C1\u5401\u9047\u55BB\u5CEA\u5FA1\u6108\u6B32\u72F1\u80B2\u8A89"],
      ["d440", "\u8A1E", 31, "\u8A3F", 8, "\u8A49", 21],
      ["d480", "\u8A5F", 25, "\u8A7A", 6, "\u6D74\u5BD3\u88D5\u9884\u8C6B\u9A6D\u9E33\u6E0A\u51A4\u5143\u57A3\u8881\u539F\u63F4\u8F95\u56ED\u5458\u5706\u733F\u6E90\u7F18\u8FDC\u82D1\u613F\u6028\u9662\u66F0\u7EA6\u8D8A\u8DC3\u94A5\u5CB3\u7CA4\u6708\u60A6\u9605\u8018\u4E91\u90E7\u5300\u9668\u5141\u8FD0\u8574\u915D\u6655\u97F5\u5B55\u531D\u7838\u6742\u683D\u54C9\u707E\u5BB0\u8F7D\u518D\u5728\u54B1\u6512\u6682\u8D5E\u8D43\u810F\u846C\u906D\u7CDF\u51FF\u85FB\u67A3\u65E9\u6FA1\u86A4\u8E81\u566A\u9020\u7682\u7076\u71E5\u8D23\u62E9\u5219\u6CFD\u8D3C\u600E\u589E\u618E\u66FE\u8D60\u624E\u55B3\u6E23\u672D\u8F67"],
      ["d540", "\u8A81", 7, "\u8A8B", 7, "\u8A94", 46],
      ["d580", "\u8AC3", 32, "\u94E1\u95F8\u7728\u6805\u69A8\u548B\u4E4D\u70B8\u8BC8\u6458\u658B\u5B85\u7A84\u503A\u5BE8\u77BB\u6BE1\u8A79\u7C98\u6CBE\u76CF\u65A9\u8F97\u5D2D\u5C55\u8638\u6808\u5360\u6218\u7AD9\u6E5B\u7EFD\u6A1F\u7AE0\u5F70\u6F33\u5F20\u638C\u6DA8\u6756\u4E08\u5E10\u8D26\u4ED7\u80C0\u7634\u969C\u62DB\u662D\u627E\u6CBC\u8D75\u7167\u7F69\u5146\u8087\u53EC\u906E\u6298\u54F2\u86F0\u8F99\u8005\u9517\u8517\u8FD9\u6D59\u73CD\u659F\u771F\u7504\u7827\u81FB\u8D1E\u9488\u4FA6\u6795\u75B9\u8BCA\u9707\u632F\u9547\u9635\u84B8\u6323\u7741\u5F81\u72F0\u4E89\u6014\u6574\u62EF\u6B63\u653F"],
      ["d640", "\u8AE4", 34, "\u8B08", 27],
      ["d680", "\u8B24\u8B25\u8B27", 30, "\u5E27\u75C7\u90D1\u8BC1\u829D\u679D\u652F\u5431\u8718\u77E5\u80A2\u8102\u6C41\u4E4B\u7EC7\u804C\u76F4\u690D\u6B96\u6267\u503C\u4F84\u5740\u6307\u6B62\u8DBE\u53EA\u65E8\u7EB8\u5FD7\u631A\u63B7\u81F3\u81F4\u7F6E\u5E1C\u5CD9\u5236\u667A\u79E9\u7A1A\u8D28\u7099\u75D4\u6EDE\u6CBB\u7A92\u4E2D\u76C5\u5FE0\u949F\u8877\u7EC8\u79CD\u80BF\u91CD\u4EF2\u4F17\u821F\u5468\u5DDE\u6D32\u8BCC\u7CA5\u8F74\u8098\u5E1A\u5492\u76B1\u5B99\u663C\u9AA4\u73E0\u682A\u86DB\u6731\u732A\u8BF8\u8BDB\u9010\u7AF9\u70DB\u716E\u62C4\u77A9\u5631\u4E3B\u8457\u67F1\u52A9\u86C0\u8D2E\u94F8\u7B51"],
      ["d740", "\u8B46", 31, "\u8B67", 4, "\u8B6D", 25],
      ["d780", "\u8B87", 24, "\u8BAC\u8BB1\u8BBB\u8BC7\u8BD0\u8BEA\u8C09\u8C1E\u4F4F\u6CE8\u795D\u9A7B\u6293\u722A\u62FD\u4E13\u7816\u8F6C\u64B0\u8D5A\u7BC6\u6869\u5E84\u88C5\u5986\u649E\u58EE\u72B6\u690E\u9525\u8FFD\u8D58\u5760\u7F00\u8C06\u51C6\u6349\u62D9\u5353\u684C\u7422\u8301\u914C\u5544\u7740\u707C\u6D4A\u5179\u54A8\u8D44\u59FF\u6ECB\u6DC4\u5B5C\u7D2B\u4ED4\u7C7D\u6ED3\u5B50\u81EA\u6E0D\u5B57\u9B03\u68D5\u8E2A\u5B97\u7EFC\u603B\u7EB5\u90B9\u8D70\u594F\u63CD\u79DF\u8DB3\u5352\u65CF\u7956\u8BC5\u963B\u7EC4\u94BB\u7E82\u5634\u9189\u6700\u7F6A\u5C0A\u9075\u6628\u5DE6\u4F50\u67DE\u505A\u4F5C\u5750\u5EA7"],
      ["d840", "\u8C38", 8, "\u8C42\u8C43\u8C44\u8C45\u8C48\u8C4A\u8C4B\u8C4D", 7, "\u8C56\u8C57\u8C58\u8C59\u8C5B", 5, "\u8C63", 6, "\u8C6C", 6, "\u8C74\u8C75\u8C76\u8C77\u8C7B", 6, "\u8C83\u8C84\u8C86\u8C87"],
      ["d880", "\u8C88\u8C8B\u8C8D", 6, "\u8C95\u8C96\u8C97\u8C99", 20, "\u4E8D\u4E0C\u5140\u4E10\u5EFF\u5345\u4E15\u4E98\u4E1E\u9B32\u5B6C\u5669\u4E28\u79BA\u4E3F\u5315\u4E47\u592D\u723B\u536E\u6C10\u56DF\u80E4\u9997\u6BD3\u777E\u9F17\u4E36\u4E9F\u9F10\u4E5C\u4E69\u4E93\u8288\u5B5B\u556C\u560F\u4EC4\u538D\u539D\u53A3\u53A5\u53AE\u9765\u8D5D\u531A\u53F5\u5326\u532E\u533E\u8D5C\u5366\u5363\u5202\u5208\u520E\u522D\u5233\u523F\u5240\u524C\u525E\u5261\u525C\u84AF\u527D\u5282\u5281\u5290\u5293\u5182\u7F54\u4EBB\u4EC3\u4EC9\u4EC2\u4EE8\u4EE1\u4EEB\u4EDE\u4F1B\u4EF3\u4F22\u4F64\u4EF5\u4F25\u4F27\u4F09\u4F2B\u4F5E\u4F67\u6538\u4F5A\u4F5D"],
      ["d940", "\u8CAE", 62],
      ["d980", "\u8CED", 32, "\u4F5F\u4F57\u4F32\u4F3D\u4F76\u4F74\u4F91\u4F89\u4F83\u4F8F\u4F7E\u4F7B\u4FAA\u4F7C\u4FAC\u4F94\u4FE6\u4FE8\u4FEA\u4FC5\u4FDA\u4FE3\u4FDC\u4FD1\u4FDF\u4FF8\u5029\u504C\u4FF3\u502C\u500F\u502E\u502D\u4FFE\u501C\u500C\u5025\u5028\u507E\u5043\u5055\u5048\u504E\u506C\u507B\u50A5\u50A7\u50A9\u50BA\u50D6\u5106\u50ED\u50EC\u50E6\u50EE\u5107\u510B\u4EDD\u6C3D\u4F58\u4F65\u4FCE\u9FA0\u6C46\u7C74\u516E\u5DFD\u9EC9\u9998\u5181\u5914\u52F9\u530D\u8A07\u5310\u51EB\u5919\u5155\u4EA0\u5156\u4EB3\u886E\u88A4\u4EB5\u8114\u88D2\u7980\u5B34\u8803\u7FB8\u51AB\u51B1\u51BD\u51BC"],
      ["da40", "\u8D0E", 14, "\u8D20\u8D51\u8D52\u8D57\u8D5F\u8D65\u8D68\u8D69\u8D6A\u8D6C\u8D6E\u8D6F\u8D71\u8D72\u8D78", 8, "\u8D82\u8D83\u8D86\u8D87\u8D88\u8D89\u8D8C", 4, "\u8D92\u8D93\u8D95", 9, "\u8DA0\u8DA1"],
      ["da80", "\u8DA2\u8DA4", 12, "\u8DB2\u8DB6\u8DB7\u8DB9\u8DBB\u8DBD\u8DC0\u8DC1\u8DC2\u8DC5\u8DC7\u8DC8\u8DC9\u8DCA\u8DCD\u8DD0\u8DD2\u8DD3\u8DD4\u51C7\u5196\u51A2\u51A5\u8BA0\u8BA6\u8BA7\u8BAA\u8BB4\u8BB5\u8BB7\u8BC2\u8BC3\u8BCB\u8BCF\u8BCE\u8BD2\u8BD3\u8BD4\u8BD6\u8BD8\u8BD9\u8BDC\u8BDF\u8BE0\u8BE4\u8BE8\u8BE9\u8BEE\u8BF0\u8BF3\u8BF6\u8BF9\u8BFC\u8BFF\u8C00\u8C02\u8C04\u8C07\u8C0C\u8C0F\u8C11\u8C12\u8C14\u8C15\u8C16\u8C19\u8C1B\u8C18\u8C1D\u8C1F\u8C20\u8C21\u8C25\u8C27\u8C2A\u8C2B\u8C2E\u8C2F\u8C32\u8C33\u8C35\u8C36\u5369\u537A\u961D\u9622\u9621\u9631\u962A\u963D\u963C\u9642\u9649\u9654\u965F\u9667\u966C\u9672\u9674\u9688\u968D\u9697\u96B0\u9097\u909B\u909D\u9099\u90AC\u90A1\u90B4\u90B3\u90B6\u90BA"],
      ["db40", "\u8DD5\u8DD8\u8DD9\u8DDC\u8DE0\u8DE1\u8DE2\u8DE5\u8DE6\u8DE7\u8DE9\u8DED\u8DEE\u8DF0\u8DF1\u8DF2\u8DF4\u8DF6\u8DFC\u8DFE", 6, "\u8E06\u8E07\u8E08\u8E0B\u8E0D\u8E0E\u8E10\u8E11\u8E12\u8E13\u8E15", 7, "\u8E20\u8E21\u8E24", 4, "\u8E2B\u8E2D\u8E30\u8E32\u8E33\u8E34\u8E36\u8E37\u8E38\u8E3B\u8E3C\u8E3E"],
      ["db80", "\u8E3F\u8E43\u8E45\u8E46\u8E4C", 4, "\u8E53", 5, "\u8E5A", 11, "\u8E67\u8E68\u8E6A\u8E6B\u8E6E\u8E71\u90B8\u90B0\u90CF\u90C5\u90BE\u90D0\u90C4\u90C7\u90D3\u90E6\u90E2\u90DC\u90D7\u90DB\u90EB\u90EF\u90FE\u9104\u9122\u911E\u9123\u9131\u912F\u9139\u9143\u9146\u520D\u5942\u52A2\u52AC\u52AD\u52BE\u54FF\u52D0\u52D6\u52F0\u53DF\u71EE\u77CD\u5EF4\u51F5\u51FC\u9B2F\u53B6\u5F01\u755A\u5DEF\u574C\u57A9\u57A1\u587E\u58BC\u58C5\u58D1\u5729\u572C\u572A\u5733\u5739\u572E\u572F\u575C\u573B\u5742\u5769\u5785\u576B\u5786\u577C\u577B\u5768\u576D\u5776\u5773\u57AD\u57A4\u578C\u57B2\u57CF\u57A7\u57B4\u5793\u57A0\u57D5\u57D8\u57DA\u57D9\u57D2\u57B8\u57F4\u57EF\u57F8\u57E4\u57DD"],
      ["dc40", "\u8E73\u8E75\u8E77", 4, "\u8E7D\u8E7E\u8E80\u8E82\u8E83\u8E84\u8E86\u8E88", 6, "\u8E91\u8E92\u8E93\u8E95", 6, "\u8E9D\u8E9F", 11, "\u8EAD\u8EAE\u8EB0\u8EB1\u8EB3", 6, "\u8EBB", 7],
      ["dc80", "\u8EC3", 10, "\u8ECF", 21, "\u580B\u580D\u57FD\u57ED\u5800\u581E\u5819\u5844\u5820\u5865\u586C\u5881\u5889\u589A\u5880\u99A8\u9F19\u61FF\u8279\u827D\u827F\u828F\u828A\u82A8\u8284\u828E\u8291\u8297\u8299\u82AB\u82B8\u82BE\u82B0\u82C8\u82CA\u82E3\u8298\u82B7\u82AE\u82CB\u82CC\u82C1\u82A9\u82B4\u82A1\u82AA\u829F\u82C4\u82CE\u82A4\u82E1\u8309\u82F7\u82E4\u830F\u8307\u82DC\u82F4\u82D2\u82D8\u830C\u82FB\u82D3\u8311\u831A\u8306\u8314\u8315\u82E0\u82D5\u831C\u8351\u835B\u835C\u8308\u8392\u833C\u8334\u8331\u839B\u835E\u832F\u834F\u8347\u8343\u835F\u8340\u8317\u8360\u832D\u833A\u8333\u8366\u8365"],
      ["dd40", "\u8EE5", 62],
      ["dd80", "\u8F24", 32, "\u8368\u831B\u8369\u836C\u836A\u836D\u836E\u83B0\u8378\u83B3\u83B4\u83A0\u83AA\u8393\u839C\u8385\u837C\u83B6\u83A9\u837D\u83B8\u837B\u8398\u839E\u83A8\u83BA\u83BC\u83C1\u8401\u83E5\u83D8\u5807\u8418\u840B\u83DD\u83FD\u83D6\u841C\u8438\u8411\u8406\u83D4\u83DF\u840F\u8403\u83F8\u83F9\u83EA\u83C5\u83C0\u8426\u83F0\u83E1\u845C\u8451\u845A\u8459\u8473\u8487\u8488\u847A\u8489\u8478\u843C\u8446\u8469\u8476\u848C\u848E\u8431\u846D\u84C1\u84CD\u84D0\u84E6\u84BD\u84D3\u84CA\u84BF\u84BA\u84E0\u84A1\u84B9\u84B4\u8497\u84E5\u84E3\u850C\u750D\u8538\u84F0\u8539\u851F\u853A"],
      ["de40", "\u8F45", 32, "\u8F6A\u8F80\u8F8C\u8F92\u8F9D\u8FA0\u8FA1\u8FA2\u8FA4\u8FA5\u8FA6\u8FA7\u8FAA\u8FAC\u8FAD\u8FAE\u8FAF\u8FB2\u8FB3\u8FB4\u8FB5\u8FB7\u8FB8\u8FBA\u8FBB\u8FBC\u8FBF\u8FC0\u8FC3\u8FC6"],
      ["de80", "\u8FC9", 4, "\u8FCF\u8FD2\u8FD6\u8FD7\u8FDA\u8FE0\u8FE1\u8FE3\u8FE7\u8FEC\u8FEF\u8FF1\u8FF2\u8FF4\u8FF5\u8FF6\u8FFA\u8FFB\u8FFC\u8FFE\u8FFF\u9007\u9008\u900C\u900E\u9013\u9015\u9018\u8556\u853B\u84FF\u84FC\u8559\u8548\u8568\u8564\u855E\u857A\u77A2\u8543\u8572\u857B\u85A4\u85A8\u8587\u858F\u8579\u85AE\u859C\u8585\u85B9\u85B7\u85B0\u85D3\u85C1\u85DC\u85FF\u8627\u8605\u8629\u8616\u863C\u5EFE\u5F08\u593C\u5941\u8037\u5955\u595A\u5958\u530F\u5C22\u5C25\u5C2C\u5C34\u624C\u626A\u629F\u62BB\u62CA\u62DA\u62D7\u62EE\u6322\u62F6\u6339\u634B\u6343\u63AD\u63F6\u6371\u637A\u638E\u63B4\u636D\u63AC\u638A\u6369\u63AE\u63BC\u63F2\u63F8\u63E0\u63FF\u63C4\u63DE\u63CE\u6452\u63C6\u63BE\u6445\u6441\u640B\u641B\u6420\u640C\u6426\u6421\u645E\u6484\u646D\u6496"],
      ["df40", "\u9019\u901C\u9023\u9024\u9025\u9027", 5, "\u9030", 4, "\u9037\u9039\u903A\u903D\u903F\u9040\u9043\u9045\u9046\u9048", 4, "\u904E\u9054\u9055\u9056\u9059\u905A\u905C", 5, "\u9064\u9066\u9067\u9069\u906A\u906B\u906C\u906F", 4, "\u9076", 6, "\u907E\u9081"],
      ["df80", "\u9084\u9085\u9086\u9087\u9089\u908A\u908C", 4, "\u9092\u9094\u9096\u9098\u909A\u909C\u909E\u909F\u90A0\u90A4\u90A5\u90A7\u90A8\u90A9\u90AB\u90AD\u90B2\u90B7\u90BC\u90BD\u90BF\u90C0\u647A\u64B7\u64B8\u6499\u64BA\u64C0\u64D0\u64D7\u64E4\u64E2\u6509\u6525\u652E\u5F0B\u5FD2\u7519\u5F11\u535F\u53F1\u53FD\u53E9\u53E8\u53FB\u5412\u5416\u5406\u544B\u5452\u5453\u5454\u5456\u5443\u5421\u5457\u5459\u5423\u5432\u5482\u5494\u5477\u5471\u5464\u549A\u549B\u5484\u5476\u5466\u549D\u54D0\u54AD\u54C2\u54B4\u54D2\u54A7\u54A6\u54D3\u54D4\u5472\u54A3\u54D5\u54BB\u54BF\u54CC\u54D9\u54DA\u54DC\u54A9\u54AA\u54A4\u54DD\u54CF\u54DE\u551B\u54E7\u5520\u54FD\u5514\u54F3\u5522\u5523\u550F\u5511\u5527\u552A\u5567\u558F\u55B5\u5549\u556D\u5541\u5555\u553F\u5550\u553C"],
      ["e040", "\u90C2\u90C3\u90C6\u90C8\u90C9\u90CB\u90CC\u90CD\u90D2\u90D4\u90D5\u90D6\u90D8\u90D9\u90DA\u90DE\u90DF\u90E0\u90E3\u90E4\u90E5\u90E9\u90EA\u90EC\u90EE\u90F0\u90F1\u90F2\u90F3\u90F5\u90F6\u90F7\u90F9\u90FA\u90FB\u90FC\u90FF\u9100\u9101\u9103\u9105", 19, "\u911A\u911B\u911C"],
      ["e080", "\u911D\u911F\u9120\u9121\u9124", 10, "\u9130\u9132", 6, "\u913A", 8, "\u9144\u5537\u5556\u5575\u5576\u5577\u5533\u5530\u555C\u558B\u55D2\u5583\u55B1\u55B9\u5588\u5581\u559F\u557E\u55D6\u5591\u557B\u55DF\u55BD\u55BE\u5594\u5599\u55EA\u55F7\u55C9\u561F\u55D1\u55EB\u55EC\u55D4\u55E6\u55DD\u55C4\u55EF\u55E5\u55F2\u55F3\u55CC\u55CD\u55E8\u55F5\u55E4\u8F94\u561E\u5608\u560C\u5601\u5624\u5623\u55FE\u5600\u5627\u562D\u5658\u5639\u5657\u562C\u564D\u5662\u5659\u565C\u564C\u5654\u5686\u5664\u5671\u566B\u567B\u567C\u5685\u5693\u56AF\u56D4\u56D7\u56DD\u56E1\u56F5\u56EB\u56F9\u56FF\u5704\u570A\u5709\u571C\u5E0F\u5E19\u5E14\u5E11\u5E31\u5E3B\u5E3C"],
      ["e140", "\u9145\u9147\u9148\u9151\u9153\u9154\u9155\u9156\u9158\u9159\u915B\u915C\u915F\u9160\u9166\u9167\u9168\u916B\u916D\u9173\u917A\u917B\u917C\u9180", 4, "\u9186\u9188\u918A\u918E\u918F\u9193", 6, "\u919C", 5, "\u91A4", 5, "\u91AB\u91AC\u91B0\u91B1\u91B2\u91B3\u91B6\u91B7\u91B8\u91B9\u91BB"],
      ["e180", "\u91BC", 10, "\u91C8\u91CB\u91D0\u91D2", 9, "\u91DD", 8, "\u5E37\u5E44\u5E54\u5E5B\u5E5E\u5E61\u5C8C\u5C7A\u5C8D\u5C90\u5C96\u5C88\u5C98\u5C99\u5C91\u5C9A\u5C9C\u5CB5\u5CA2\u5CBD\u5CAC\u5CAB\u5CB1\u5CA3\u5CC1\u5CB7\u5CC4\u5CD2\u5CE4\u5CCB\u5CE5\u5D02\u5D03\u5D27\u5D26\u5D2E\u5D24\u5D1E\u5D06\u5D1B\u5D58\u5D3E\u5D34\u5D3D\u5D6C\u5D5B\u5D6F\u5D5D\u5D6B\u5D4B\u5D4A\u5D69\u5D74\u5D82\u5D99\u5D9D\u8C73\u5DB7\u5DC5\u5F73\u5F77\u5F82\u5F87\u5F89\u5F8C\u5F95\u5F99\u5F9C\u5FA8\u5FAD\u5FB5\u5FBC\u8862\u5F61\u72AD\u72B0\u72B4\u72B7\u72B8\u72C3\u72C1\u72CE\u72CD\u72D2\u72E8\u72EF\u72E9\u72F2\u72F4\u72F7\u7301\u72F3\u7303\u72FA"],
      ["e240", "\u91E6", 62],
      ["e280", "\u9225", 32, "\u72FB\u7317\u7313\u7321\u730A\u731E\u731D\u7315\u7322\u7339\u7325\u732C\u7338\u7331\u7350\u734D\u7357\u7360\u736C\u736F\u737E\u821B\u5925\u98E7\u5924\u5902\u9963\u9967", 5, "\u9974\u9977\u997D\u9980\u9984\u9987\u998A\u998D\u9990\u9991\u9993\u9994\u9995\u5E80\u5E91\u5E8B\u5E96\u5EA5\u5EA0\u5EB9\u5EB5\u5EBE\u5EB3\u8D53\u5ED2\u5ED1\u5EDB\u5EE8\u5EEA\u81BA\u5FC4\u5FC9\u5FD6\u5FCF\u6003\u5FEE\u6004\u5FE1\u5FE4\u5FFE\u6005\u6006\u5FEA\u5FED\u5FF8\u6019\u6035\u6026\u601B\u600F\u600D\u6029\u602B\u600A\u603F\u6021\u6078\u6079\u607B\u607A\u6042"],
      ["e340", "\u9246", 45, "\u9275", 16],
      ["e380", "\u9286", 7, "\u928F", 24, "\u606A\u607D\u6096\u609A\u60AD\u609D\u6083\u6092\u608C\u609B\u60EC\u60BB\u60B1\u60DD\u60D8\u60C6\u60DA\u60B4\u6120\u6126\u6115\u6123\u60F4\u6100\u610E\u612B\u614A\u6175\u61AC\u6194\u61A7\u61B7\u61D4\u61F5\u5FDD\u96B3\u95E9\u95EB\u95F1\u95F3\u95F5\u95F6\u95FC\u95FE\u9603\u9604\u9606\u9608\u960A\u960B\u960C\u960D\u960F\u9612\u9615\u9616\u9617\u9619\u961A\u4E2C\u723F\u6215\u6C35\u6C54\u6C5C\u6C4A\u6CA3\u6C85\u6C90\u6C94\u6C8C\u6C68\u6C69\u6C74\u6C76\u6C86\u6CA9\u6CD0\u6CD4\u6CAD\u6CF7\u6CF8\u6CF1\u6CD7\u6CB2\u6CE0\u6CD6\u6CFA\u6CEB\u6CEE\u6CB1\u6CD3\u6CEF\u6CFE"],
      ["e440", "\u92A8", 5, "\u92AF", 24, "\u92C9", 31],
      ["e480", "\u92E9", 32, "\u6D39\u6D27\u6D0C\u6D43\u6D48\u6D07\u6D04\u6D19\u6D0E\u6D2B\u6D4D\u6D2E\u6D35\u6D1A\u6D4F\u6D52\u6D54\u6D33\u6D91\u6D6F\u6D9E\u6DA0\u6D5E\u6D93\u6D94\u6D5C\u6D60\u6D7C\u6D63\u6E1A\u6DC7\u6DC5\u6DDE\u6E0E\u6DBF\u6DE0\u6E11\u6DE6\u6DDD\u6DD9\u6E16\u6DAB\u6E0C\u6DAE\u6E2B\u6E6E\u6E4E\u6E6B\u6EB2\u6E5F\u6E86\u6E53\u6E54\u6E32\u6E25\u6E44\u6EDF\u6EB1\u6E98\u6EE0\u6F2D\u6EE2\u6EA5\u6EA7\u6EBD\u6EBB\u6EB7\u6ED7\u6EB4\u6ECF\u6E8F\u6EC2\u6E9F\u6F62\u6F46\u6F47\u6F24\u6F15\u6EF9\u6F2F\u6F36\u6F4B\u6F74\u6F2A\u6F09\u6F29\u6F89\u6F8D\u6F8C\u6F78\u6F72\u6F7C\u6F7A\u6FD1"],
      ["e540", "\u930A", 51, "\u933F", 10],
      ["e580", "\u934A", 31, "\u936B\u6FC9\u6FA7\u6FB9\u6FB6\u6FC2\u6FE1\u6FEE\u6FDE\u6FE0\u6FEF\u701A\u7023\u701B\u7039\u7035\u704F\u705E\u5B80\u5B84\u5B95\u5B93\u5BA5\u5BB8\u752F\u9A9E\u6434\u5BE4\u5BEE\u8930\u5BF0\u8E47\u8B07\u8FB6\u8FD3\u8FD5\u8FE5\u8FEE\u8FE4\u8FE9\u8FE6\u8FF3\u8FE8\u9005\u9004\u900B\u9026\u9011\u900D\u9016\u9021\u9035\u9036\u902D\u902F\u9044\u9051\u9052\u9050\u9068\u9058\u9062\u905B\u66B9\u9074\u907D\u9082\u9088\u9083\u908B\u5F50\u5F57\u5F56\u5F58\u5C3B\u54AB\u5C50\u5C59\u5B71\u5C63\u5C66\u7FBC\u5F2A\u5F29\u5F2D\u8274\u5F3C\u9B3B\u5C6E\u5981\u5983\u598D\u59A9\u59AA\u59A3"],
      ["e640", "\u936C", 34, "\u9390", 27],
      ["e680", "\u93AC", 29, "\u93CB\u93CC\u93CD\u5997\u59CA\u59AB\u599E\u59A4\u59D2\u59B2\u59AF\u59D7\u59BE\u5A05\u5A06\u59DD\u5A08\u59E3\u59D8\u59F9\u5A0C\u5A09\u5A32\u5A34\u5A11\u5A23\u5A13\u5A40\u5A67\u5A4A\u5A55\u5A3C\u5A62\u5A75\u80EC\u5AAA\u5A9B\u5A77\u5A7A\u5ABE\u5AEB\u5AB2\u5AD2\u5AD4\u5AB8\u5AE0\u5AE3\u5AF1\u5AD6\u5AE6\u5AD8\u5ADC\u5B09\u5B17\u5B16\u5B32\u5B37\u5B40\u5C15\u5C1C\u5B5A\u5B65\u5B73\u5B51\u5B53\u5B62\u9A75\u9A77\u9A78\u9A7A\u9A7F\u9A7D\u9A80\u9A81\u9A85\u9A88\u9A8A\u9A90\u9A92\u9A93\u9A96\u9A98\u9A9B\u9A9C\u9A9D\u9A9F\u9AA0\u9AA2\u9AA3\u9AA5\u9AA7\u7E9F\u7EA1\u7EA3\u7EA5\u7EA8\u7EA9"],
      ["e740", "\u93CE", 7, "\u93D7", 54],
      ["e780", "\u940E", 32, "\u7EAD\u7EB0\u7EBE\u7EC0\u7EC1\u7EC2\u7EC9\u7ECB\u7ECC\u7ED0\u7ED4\u7ED7\u7EDB\u7EE0\u7EE1\u7EE8\u7EEB\u7EEE\u7EEF\u7EF1\u7EF2\u7F0D\u7EF6\u7EFA\u7EFB\u7EFE\u7F01\u7F02\u7F03\u7F07\u7F08\u7F0B\u7F0C\u7F0F\u7F11\u7F12\u7F17\u7F19\u7F1C\u7F1B\u7F1F\u7F21", 6, "\u7F2A\u7F2B\u7F2C\u7F2D\u7F2F", 4, "\u7F35\u5E7A\u757F\u5DDB\u753E\u9095\u738E\u7391\u73AE\u73A2\u739F\u73CF\u73C2\u73D1\u73B7\u73B3\u73C0\u73C9\u73C8\u73E5\u73D9\u987C\u740A\u73E9\u73E7\u73DE\u73BA\u73F2\u740F\u742A\u745B\u7426\u7425\u7428\u7430\u742E\u742C"],
      ["e840", "\u942F", 14, "\u943F", 43, "\u946C\u946D\u946E\u946F"],
      ["e880", "\u9470", 20, "\u9491\u9496\u9498\u94C7\u94CF\u94D3\u94D4\u94DA\u94E6\u94FB\u951C\u9520\u741B\u741A\u7441\u745C\u7457\u7455\u7459\u7477\u746D\u747E\u749C\u748E\u7480\u7481\u7487\u748B\u749E\u74A8\u74A9\u7490\u74A7\u74D2\u74BA\u97EA\u97EB\u97EC\u674C\u6753\u675E\u6748\u6769\u67A5\u6787\u676A\u6773\u6798\u67A7\u6775\u67A8\u679E\u67AD\u678B\u6777\u677C\u67F0\u6809\u67D8\u680A\u67E9\u67B0\u680C\u67D9\u67B5\u67DA\u67B3\u67DD\u6800\u67C3\u67B8\u67E2\u680E\u67C1\u67FD\u6832\u6833\u6860\u6861\u684E\u6862\u6844\u6864\u6883\u681D\u6855\u6866\u6841\u6867\u6840\u683E\u684A\u6849\u6829\u68B5\u688F\u6874\u6877\u6893\u686B\u68C2\u696E\u68FC\u691F\u6920\u68F9"],
      ["e940", "\u9527\u9533\u953D\u9543\u9548\u954B\u9555\u955A\u9560\u956E\u9574\u9575\u9577", 7, "\u9580", 42],
      ["e980", "\u95AB", 32, "\u6924\u68F0\u690B\u6901\u6957\u68E3\u6910\u6971\u6939\u6960\u6942\u695D\u6984\u696B\u6980\u6998\u6978\u6934\u69CC\u6987\u6988\u69CE\u6989\u6966\u6963\u6979\u699B\u69A7\u69BB\u69AB\u69AD\u69D4\u69B1\u69C1\u69CA\u69DF\u6995\u69E0\u698D\u69FF\u6A2F\u69ED\u6A17\u6A18\u6A65\u69F2\u6A44\u6A3E\u6AA0\u6A50\u6A5B\u6A35\u6A8E\u6A79\u6A3D\u6A28\u6A58\u6A7C\u6A91\u6A90\u6AA9\u6A97\u6AAB\u7337\u7352\u6B81\u6B82\u6B87\u6B84\u6B92\u6B93\u6B8D\u6B9A\u6B9B\u6BA1\u6BAA\u8F6B\u8F6D\u8F71\u8F72\u8F73\u8F75\u8F76\u8F78\u8F77\u8F79\u8F7A\u8F7C\u8F7E\u8F81\u8F82\u8F84\u8F87\u8F8B"],
      ["ea40", "\u95CC", 27, "\u95EC\u95FF\u9607\u9613\u9618\u961B\u961E\u9620\u9623", 6, "\u962B\u962C\u962D\u962F\u9630\u9637\u9638\u9639\u963A\u963E\u9641\u9643\u964A\u964E\u964F\u9651\u9652\u9653\u9656\u9657"],
      ["ea80", "\u9658\u9659\u965A\u965C\u965D\u965E\u9660\u9663\u9665\u9666\u966B\u966D", 4, "\u9673\u9678", 12, "\u9687\u9689\u968A\u8F8D\u8F8E\u8F8F\u8F98\u8F9A\u8ECE\u620B\u6217\u621B\u621F\u6222\u6221\u6225\u6224\u622C\u81E7\u74EF\u74F4\u74FF\u750F\u7511\u7513\u6534\u65EE\u65EF\u65F0\u660A\u6619\u6772\u6603\u6615\u6600\u7085\u66F7\u661D\u6634\u6631\u6636\u6635\u8006\u665F\u6654\u6641\u664F\u6656\u6661\u6657\u6677\u6684\u668C\u66A7\u669D\u66BE\u66DB\u66DC\u66E6\u66E9\u8D32\u8D33\u8D36\u8D3B\u8D3D\u8D40\u8D45\u8D46\u8D48\u8D49\u8D47\u8D4D\u8D55\u8D59\u89C7\u89CA\u89CB\u89CC\u89CE\u89CF\u89D0\u89D1\u726E\u729F\u725D\u7266\u726F\u727E\u727F\u7284\u728B\u728D\u728F\u7292\u6308\u6332\u63B0"],
      ["eb40", "\u968C\u968E\u9691\u9692\u9693\u9695\u9696\u969A\u969B\u969D", 9, "\u96A8", 7, "\u96B1\u96B2\u96B4\u96B5\u96B7\u96B8\u96BA\u96BB\u96BF\u96C2\u96C3\u96C8\u96CA\u96CB\u96D0\u96D1\u96D3\u96D4\u96D6", 9, "\u96E1", 6, "\u96EB"],
      ["eb80", "\u96EC\u96ED\u96EE\u96F0\u96F1\u96F2\u96F4\u96F5\u96F8\u96FA\u96FB\u96FC\u96FD\u96FF\u9702\u9703\u9705\u970A\u970B\u970C\u9710\u9711\u9712\u9714\u9715\u9717", 4, "\u971D\u971F\u9720\u643F\u64D8\u8004\u6BEA\u6BF3\u6BFD\u6BF5\u6BF9\u6C05\u6C07\u6C06\u6C0D\u6C15\u6C18\u6C19\u6C1A\u6C21\u6C29\u6C24\u6C2A\u6C32\u6535\u6555\u656B\u724D\u7252\u7256\u7230\u8662\u5216\u809F\u809C\u8093\u80BC\u670A\u80BD\u80B1\u80AB\u80AD\u80B4\u80B7\u80E7\u80E8\u80E9\u80EA\u80DB\u80C2\u80C4\u80D9\u80CD\u80D7\u6710\u80DD\u80EB\u80F1\u80F4\u80ED\u810D\u810E\u80F2\u80FC\u6715\u8112\u8C5A\u8136\u811E\u812C\u8118\u8132\u8148\u814C\u8153\u8174\u8159\u815A\u8171\u8160\u8169\u817C\u817D\u816D\u8167\u584D\u5AB5\u8188\u8182\u8191\u6ED5\u81A3\u81AA\u81CC\u6726\u81CA\u81BB"],
      ["ec40", "\u9721", 8, "\u972B\u972C\u972E\u972F\u9731\u9733", 4, "\u973A\u973B\u973C\u973D\u973F", 18, "\u9754\u9755\u9757\u9758\u975A\u975C\u975D\u975F\u9763\u9764\u9766\u9767\u9768\u976A", 7],
      ["ec80", "\u9772\u9775\u9777", 4, "\u977D", 7, "\u9786", 4, "\u978C\u978E\u978F\u9790\u9793\u9795\u9796\u9797\u9799", 4, "\u81C1\u81A6\u6B24\u6B37\u6B39\u6B43\u6B46\u6B59\u98D1\u98D2\u98D3\u98D5\u98D9\u98DA\u6BB3\u5F40\u6BC2\u89F3\u6590\u9F51\u6593\u65BC\u65C6\u65C4\u65C3\u65CC\u65CE\u65D2\u65D6\u7080\u709C\u7096\u709D\u70BB\u70C0\u70B7\u70AB\u70B1\u70E8\u70CA\u7110\u7113\u7116\u712F\u7131\u7173\u715C\u7168\u7145\u7172\u714A\u7178\u717A\u7198\u71B3\u71B5\u71A8\u71A0\u71E0\u71D4\u71E7\u71F9\u721D\u7228\u706C\u7118\u7166\u71B9\u623E\u623D\u6243\u6248\u6249\u793B\u7940\u7946\u7949\u795B\u795C\u7953\u795A\u7962\u7957\u7960\u796F\u7967\u797A\u7985\u798A\u799A\u79A7\u79B3\u5FD1\u5FD0"],
      ["ed40", "\u979E\u979F\u97A1\u97A2\u97A4", 6, "\u97AC\u97AE\u97B0\u97B1\u97B3\u97B5", 46],
      ["ed80", "\u97E4\u97E5\u97E8\u97EE", 4, "\u97F4\u97F7", 23, "\u603C\u605D\u605A\u6067\u6041\u6059\u6063\u60AB\u6106\u610D\u615D\u61A9\u619D\u61CB\u61D1\u6206\u8080\u807F\u6C93\u6CF6\u6DFC\u77F6\u77F8\u7800\u7809\u7817\u7818\u7811\u65AB\u782D\u781C\u781D\u7839\u783A\u783B\u781F\u783C\u7825\u782C\u7823\u7829\u784E\u786D\u7856\u7857\u7826\u7850\u7847\u784C\u786A\u789B\u7893\u789A\u7887\u789C\u78A1\u78A3\u78B2\u78B9\u78A5\u78D4\u78D9\u78C9\u78EC\u78F2\u7905\u78F4\u7913\u7924\u791E\u7934\u9F9B\u9EF9\u9EFB\u9EFC\u76F1\u7704\u770D\u76F9\u7707\u7708\u771A\u7722\u7719\u772D\u7726\u7735\u7738\u7750\u7751\u7747\u7743\u775A\u7768"],
      ["ee40", "\u980F", 62],
      ["ee80", "\u984E", 32, "\u7762\u7765\u777F\u778D\u777D\u7780\u778C\u7791\u779F\u77A0\u77B0\u77B5\u77BD\u753A\u7540\u754E\u754B\u7548\u755B\u7572\u7579\u7583\u7F58\u7F61\u7F5F\u8A48\u7F68\u7F74\u7F71\u7F79\u7F81\u7F7E\u76CD\u76E5\u8832\u9485\u9486\u9487\u948B\u948A\u948C\u948D\u948F\u9490\u9494\u9497\u9495\u949A\u949B\u949C\u94A3\u94A4\u94AB\u94AA\u94AD\u94AC\u94AF\u94B0\u94B2\u94B4\u94B6", 4, "\u94BC\u94BD\u94BF\u94C4\u94C8", 6, "\u94D0\u94D1\u94D2\u94D5\u94D6\u94D7\u94D9\u94D8\u94DB\u94DE\u94DF\u94E0\u94E2\u94E4\u94E5\u94E7\u94E8\u94EA"],
      ["ef40", "\u986F", 5, "\u988B\u988E\u9892\u9895\u9899\u98A3\u98A8", 37, "\u98CF\u98D0\u98D4\u98D6\u98D7\u98DB\u98DC\u98DD\u98E0", 4],
      ["ef80", "\u98E5\u98E6\u98E9", 30, "\u94E9\u94EB\u94EE\u94EF\u94F3\u94F4\u94F5\u94F7\u94F9\u94FC\u94FD\u94FF\u9503\u9502\u9506\u9507\u9509\u950A\u950D\u950E\u950F\u9512", 4, "\u9518\u951B\u951D\u951E\u951F\u9522\u952A\u952B\u9529\u952C\u9531\u9532\u9534\u9536\u9537\u9538\u953C\u953E\u953F\u9542\u9535\u9544\u9545\u9546\u9549\u954C\u954E\u954F\u9552\u9553\u9554\u9556\u9557\u9558\u9559\u955B\u955E\u955F\u955D\u9561\u9562\u9564", 8, "\u956F\u9571\u9572\u9573\u953A\u77E7\u77EC\u96C9\u79D5\u79ED\u79E3\u79EB\u7A06\u5D47\u7A03\u7A02\u7A1E\u7A14"],
      ["f040", "\u9908", 4, "\u990E\u990F\u9911", 28, "\u992F", 26],
      ["f080", "\u994A", 9, "\u9956", 12, "\u9964\u9966\u9973\u9978\u9979\u997B\u997E\u9982\u9983\u9989\u7A39\u7A37\u7A51\u9ECF\u99A5\u7A70\u7688\u768E\u7693\u7699\u76A4\u74DE\u74E0\u752C\u9E20\u9E22\u9E28", 4, "\u9E32\u9E31\u9E36\u9E38\u9E37\u9E39\u9E3A\u9E3E\u9E41\u9E42\u9E44\u9E46\u9E47\u9E48\u9E49\u9E4B\u9E4C\u9E4E\u9E51\u9E55\u9E57\u9E5A\u9E5B\u9E5C\u9E5E\u9E63\u9E66", 6, "\u9E71\u9E6D\u9E73\u7592\u7594\u7596\u75A0\u759D\u75AC\u75A3\u75B3\u75B4\u75B8\u75C4\u75B1\u75B0\u75C3\u75C2\u75D6\u75CD\u75E3\u75E8\u75E6\u75E4\u75EB\u75E7\u7603\u75F1\u75FC\u75FF\u7610\u7600\u7605\u760C\u7617\u760A\u7625\u7618\u7615\u7619"],
      ["f140", "\u998C\u998E\u999A", 10, "\u99A6\u99A7\u99A9", 47],
      ["f180", "\u99D9", 32, "\u761B\u763C\u7622\u7620\u7640\u762D\u7630\u763F\u7635\u7643\u763E\u7633\u764D\u765E\u7654\u765C\u7656\u766B\u766F\u7FCA\u7AE6\u7A78\u7A79\u7A80\u7A86\u7A88\u7A95\u7AA6\u7AA0\u7AAC\u7AA8\u7AAD\u7AB3\u8864\u8869\u8872\u887D\u887F\u8882\u88A2\u88C6\u88B7\u88BC\u88C9\u88E2\u88CE\u88E3\u88E5\u88F1\u891A\u88FC\u88E8\u88FE\u88F0\u8921\u8919\u8913\u891B\u890A\u8934\u892B\u8936\u8941\u8966\u897B\u758B\u80E5\u76B2\u76B4\u77DC\u8012\u8014\u8016\u801C\u8020\u8022\u8025\u8026\u8027\u8029\u8028\u8031\u800B\u8035\u8043\u8046\u804D\u8052\u8069\u8071\u8983\u9878\u9880\u9883"],
      ["f240", "\u99FA", 62],
      ["f280", "\u9A39", 32, "\u9889\u988C\u988D\u988F\u9894\u989A\u989B\u989E\u989F\u98A1\u98A2\u98A5\u98A6\u864D\u8654\u866C\u866E\u867F\u867A\u867C\u867B\u86A8\u868D\u868B\u86AC\u869D\u86A7\u86A3\u86AA\u8693\u86A9\u86B6\u86C4\u86B5\u86CE\u86B0\u86BA\u86B1\u86AF\u86C9\u86CF\u86B4\u86E9\u86F1\u86F2\u86ED\u86F3\u86D0\u8713\u86DE\u86F4\u86DF\u86D8\u86D1\u8703\u8707\u86F8\u8708\u870A\u870D\u8709\u8723\u873B\u871E\u8725\u872E\u871A\u873E\u8748\u8734\u8731\u8729\u8737\u873F\u8782\u8722\u877D\u877E\u877B\u8760\u8770\u874C\u876E\u878B\u8753\u8763\u877C\u8764\u8759\u8765\u8793\u87AF\u87A8\u87D2"],
      ["f340", "\u9A5A", 17, "\u9A72\u9A83\u9A89\u9A8D\u9A8E\u9A94\u9A95\u9A99\u9AA6\u9AA9", 6, "\u9AB2\u9AB3\u9AB4\u9AB5\u9AB9\u9ABB\u9ABD\u9ABE\u9ABF\u9AC3\u9AC4\u9AC6", 4, "\u9ACD\u9ACE\u9ACF\u9AD0\u9AD2\u9AD4\u9AD5\u9AD6\u9AD7\u9AD9\u9ADA\u9ADB\u9ADC"],
      ["f380", "\u9ADD\u9ADE\u9AE0\u9AE2\u9AE3\u9AE4\u9AE5\u9AE7\u9AE8\u9AE9\u9AEA\u9AEC\u9AEE\u9AF0", 8, "\u9AFA\u9AFC", 6, "\u9B04\u9B05\u9B06\u87C6\u8788\u8785\u87AD\u8797\u8783\u87AB\u87E5\u87AC\u87B5\u87B3\u87CB\u87D3\u87BD\u87D1\u87C0\u87CA\u87DB\u87EA\u87E0\u87EE\u8816\u8813\u87FE\u880A\u881B\u8821\u8839\u883C\u7F36\u7F42\u7F44\u7F45\u8210\u7AFA\u7AFD\u7B08\u7B03\u7B04\u7B15\u7B0A\u7B2B\u7B0F\u7B47\u7B38\u7B2A\u7B19\u7B2E\u7B31\u7B20\u7B25\u7B24\u7B33\u7B3E\u7B1E\u7B58\u7B5A\u7B45\u7B75\u7B4C\u7B5D\u7B60\u7B6E\u7B7B\u7B62\u7B72\u7B71\u7B90\u7BA6\u7BA7\u7BB8\u7BAC\u7B9D\u7BA8\u7B85\u7BAA\u7B9C\u7BA2\u7BAB\u7BB4\u7BD1\u7BC1\u7BCC\u7BDD\u7BDA\u7BE5\u7BE6\u7BEA\u7C0C\u7BFE\u7BFC\u7C0F\u7C16\u7C0B"],
      ["f440", "\u9B07\u9B09", 5, "\u9B10\u9B11\u9B12\u9B14", 10, "\u9B20\u9B21\u9B22\u9B24", 10, "\u9B30\u9B31\u9B33", 7, "\u9B3D\u9B3E\u9B3F\u9B40\u9B46\u9B4A\u9B4B\u9B4C\u9B4E\u9B50\u9B52\u9B53\u9B55", 5],
      ["f480", "\u9B5B", 32, "\u7C1F\u7C2A\u7C26\u7C38\u7C41\u7C40\u81FE\u8201\u8202\u8204\u81EC\u8844\u8221\u8222\u8223\u822D\u822F\u8228\u822B\u8238\u823B\u8233\u8234\u823E\u8244\u8249\u824B\u824F\u825A\u825F\u8268\u887E\u8885\u8888\u88D8\u88DF\u895E\u7F9D\u7F9F\u7FA7\u7FAF\u7FB0\u7FB2\u7C7C\u6549\u7C91\u7C9D\u7C9C\u7C9E\u7CA2\u7CB2\u7CBC\u7CBD\u7CC1\u7CC7\u7CCC\u7CCD\u7CC8\u7CC5\u7CD7\u7CE8\u826E\u66A8\u7FBF\u7FCE\u7FD5\u7FE5\u7FE1\u7FE6\u7FE9\u7FEE\u7FF3\u7CF8\u7D77\u7DA6\u7DAE\u7E47\u7E9B\u9EB8\u9EB4\u8D73\u8D84\u8D94\u8D91\u8DB1\u8D67\u8D6D\u8C47\u8C49\u914A\u9150\u914E\u914F\u9164"],
      ["f540", "\u9B7C", 62],
      ["f580", "\u9BBB", 32, "\u9162\u9161\u9170\u9169\u916F\u917D\u917E\u9172\u9174\u9179\u918C\u9185\u9190\u918D\u9191\u91A2\u91A3\u91AA\u91AD\u91AE\u91AF\u91B5\u91B4\u91BA\u8C55\u9E7E\u8DB8\u8DEB\u8E05\u8E59\u8E69\u8DB5\u8DBF\u8DBC\u8DBA\u8DC4\u8DD6\u8DD7\u8DDA\u8DDE\u8DCE\u8DCF\u8DDB\u8DC6\u8DEC\u8DF7\u8DF8\u8DE3\u8DF9\u8DFB\u8DE4\u8E09\u8DFD\u8E14\u8E1D\u8E1F\u8E2C\u8E2E\u8E23\u8E2F\u8E3A\u8E40\u8E39\u8E35\u8E3D\u8E31\u8E49\u8E41\u8E42\u8E51\u8E52\u8E4A\u8E70\u8E76\u8E7C\u8E6F\u8E74\u8E85\u8E8F\u8E94\u8E90\u8E9C\u8E9E\u8C78\u8C82\u8C8A\u8C85\u8C98\u8C94\u659B\u89D6\u89DE\u89DA\u89DC"],
      ["f640", "\u9BDC", 62],
      ["f680", "\u9C1B", 32, "\u89E5\u89EB\u89EF\u8A3E\u8B26\u9753\u96E9\u96F3\u96EF\u9706\u9701\u9708\u970F\u970E\u972A\u972D\u9730\u973E\u9F80\u9F83\u9F85", 5, "\u9F8C\u9EFE\u9F0B\u9F0D\u96B9\u96BC\u96BD\u96CE\u96D2\u77BF\u96E0\u928E\u92AE\u92C8\u933E\u936A\u93CA\u938F\u943E\u946B\u9C7F\u9C82\u9C85\u9C86\u9C87\u9C88\u7A23\u9C8B\u9C8E\u9C90\u9C91\u9C92\u9C94\u9C95\u9C9A\u9C9B\u9C9E", 5, "\u9CA5", 4, "\u9CAB\u9CAD\u9CAE\u9CB0", 7, "\u9CBA\u9CBB\u9CBC\u9CBD\u9CC4\u9CC5\u9CC6\u9CC7\u9CCA\u9CCB"],
      ["f740", "\u9C3C", 62],
      ["f780", "\u9C7B\u9C7D\u9C7E\u9C80\u9C83\u9C84\u9C89\u9C8A\u9C8C\u9C8F\u9C93\u9C96\u9C97\u9C98\u9C99\u9C9D\u9CAA\u9CAC\u9CAF\u9CB9\u9CBE", 4, "\u9CC8\u9CC9\u9CD1\u9CD2\u9CDA\u9CDB\u9CE0\u9CE1\u9CCC", 4, "\u9CD3\u9CD4\u9CD5\u9CD7\u9CD8\u9CD9\u9CDC\u9CDD\u9CDF\u9CE2\u977C\u9785\u9791\u9792\u9794\u97AF\u97AB\u97A3\u97B2\u97B4\u9AB1\u9AB0\u9AB7\u9E58\u9AB6\u9ABA\u9ABC\u9AC1\u9AC0\u9AC5\u9AC2\u9ACB\u9ACC\u9AD1\u9B45\u9B43\u9B47\u9B49\u9B48\u9B4D\u9B51\u98E8\u990D\u992E\u9955\u9954\u9ADF\u9AE1\u9AE6\u9AEF\u9AEB\u9AFB\u9AED\u9AF9\u9B08\u9B0F\u9B13\u9B1F\u9B23\u9EBD\u9EBE\u7E3B\u9E82\u9E87\u9E88\u9E8B\u9E92\u93D6\u9E9D\u9E9F\u9EDB\u9EDC\u9EDD\u9EE0\u9EDF\u9EE2\u9EE9\u9EE7\u9EE5\u9EEA\u9EEF\u9F22\u9F2C\u9F2F\u9F39\u9F37\u9F3D\u9F3E\u9F44"],
      ["f840", "\u9CE3", 62],
      ["f880", "\u9D22", 32],
      ["f940", "\u9D43", 62],
      ["f980", "\u9D82", 32],
      ["fa40", "\u9DA3", 62],
      ["fa80", "\u9DE2", 32],
      ["fb40", "\u9E03", 27, "\u9E24\u9E27\u9E2E\u9E30\u9E34\u9E3B\u9E3C\u9E40\u9E4D\u9E50\u9E52\u9E53\u9E54\u9E56\u9E59\u9E5D\u9E5F\u9E60\u9E61\u9E62\u9E65\u9E6E\u9E6F\u9E72\u9E74", 9, "\u9E80"],
      ["fb80", "\u9E81\u9E83\u9E84\u9E85\u9E86\u9E89\u9E8A\u9E8C", 5, "\u9E94", 8, "\u9E9E\u9EA0", 5, "\u9EA7\u9EA8\u9EA9\u9EAA"],
      ["fc40", "\u9EAB", 8, "\u9EB5\u9EB6\u9EB7\u9EB9\u9EBA\u9EBC\u9EBF", 4, "\u9EC5\u9EC6\u9EC7\u9EC8\u9ECA\u9ECB\u9ECC\u9ED0\u9ED2\u9ED3\u9ED5\u9ED6\u9ED7\u9ED9\u9EDA\u9EDE\u9EE1\u9EE3\u9EE4\u9EE6\u9EE8\u9EEB\u9EEC\u9EED\u9EEE\u9EF0", 8, "\u9EFA\u9EFD\u9EFF", 6],
      ["fc80", "\u9F06", 4, "\u9F0C\u9F0F\u9F11\u9F12\u9F14\u9F15\u9F16\u9F18\u9F1A", 5, "\u9F21\u9F23", 8, "\u9F2D\u9F2E\u9F30\u9F31"],
      ["fd40", "\u9F32", 4, "\u9F38\u9F3A\u9F3C\u9F3F", 4, "\u9F45", 10, "\u9F52", 38],
      ["fd80", "\u9F79", 5, "\u9F81\u9F82\u9F8D", 11, "\u9F9C\u9F9D\u9F9E\u9FA1", 4, "\uF92C\uF979\uF995\uF9E7\uF9F1"],
      ["fe40", "\uFA0C\uFA0D\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA18\uFA1F\uFA20\uFA21\uFA23\uFA24\uFA27\uFA28\uFA29"]
    ];
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports2, module2) {
    module2.exports = [
      ["a140", "\uE4C6", 62],
      ["a180", "\uE505", 32],
      ["a240", "\uE526", 62],
      ["a280", "\uE565", 32],
      ["a2ab", "\uE766", 5],
      ["a2e3", "\u20AC\uE76D"],
      ["a2ef", "\uE76E\uE76F"],
      ["a2fd", "\uE770\uE771"],
      ["a340", "\uE586", 62],
      ["a380", "\uE5C5", 31, "\u3000"],
      ["a440", "\uE5E6", 62],
      ["a480", "\uE625", 32],
      ["a4f4", "\uE772", 10],
      ["a540", "\uE646", 62],
      ["a580", "\uE685", 32],
      ["a5f7", "\uE77D", 7],
      ["a640", "\uE6A6", 62],
      ["a680", "\uE6E5", 32],
      ["a6b9", "\uE785", 7],
      ["a6d9", "\uE78D", 6],
      ["a6ec", "\uE794\uE795"],
      ["a6f3", "\uE796"],
      ["a6f6", "\uE797", 8],
      ["a740", "\uE706", 62],
      ["a780", "\uE745", 32],
      ["a7c2", "\uE7A0", 14],
      ["a7f2", "\uE7AF", 12],
      ["a896", "\uE7BC", 10],
      ["a8bc", "\u1E3F"],
      ["a8bf", "\u01F9"],
      ["a8c1", "\uE7C9\uE7CA\uE7CB\uE7CC"],
      ["a8ea", "\uE7CD", 20],
      ["a958", "\uE7E2"],
      ["a95b", "\uE7E3"],
      ["a95d", "\uE7E4\uE7E5\uE7E6"],
      ["a989", "\u303E\u2FF0", 11],
      ["a997", "\uE7F4", 12],
      ["a9f0", "\uE801", 14],
      ["aaa1", "\uE000", 93],
      ["aba1", "\uE05E", 93],
      ["aca1", "\uE0BC", 93],
      ["ada1", "\uE11A", 93],
      ["aea1", "\uE178", 93],
      ["afa1", "\uE1D6", 93],
      ["d7fa", "\uE810", 4],
      ["f8a1", "\uE234", 93],
      ["f9a1", "\uE292", 93],
      ["faa1", "\uE2F0", 93],
      ["fba1", "\uE34E", 93],
      ["fca1", "\uE3AC", 93],
      ["fda1", "\uE40A", 93],
      ["fe50", "\u2E81\uE816\uE817\uE818\u2E84\u3473\u3447\u2E88\u2E8B\uE81E\u359E\u361A\u360E\u2E8C\u2E97\u396E\u3918\uE826\u39CF\u39DF\u3A73\u39D0\uE82B\uE82C\u3B4E\u3C6E\u3CE0\u2EA7\uE831\uE832\u2EAA\u4056\u415F\u2EAE\u4337\u2EB3\u2EB6\u2EB7\uE83B\u43B1\u43AC\u2EBB\u43DD\u44D6\u4661\u464C\uE843"],
      ["fe80", "\u4723\u4729\u477C\u478D\u2ECA\u4947\u497A\u497D\u4982\u4983\u4985\u4986\u499F\u499B\u49B7\u49B6\uE854\uE855\u4CA3\u4C9F\u4CA0\u4CA1\u4C77\u4CA2\u4D13", 6, "\u4DAE\uE864\uE468", 93],
      ["8135f437", "\uE7C7"]
    ];
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports2, module2) {
    module2.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/tables/cp949.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8141", "\uAC02\uAC03\uAC05\uAC06\uAC0B", 4, "\uAC18\uAC1E\uAC1F\uAC21\uAC22\uAC23\uAC25", 6, "\uAC2E\uAC32\uAC33\uAC34"],
      ["8161", "\uAC35\uAC36\uAC37\uAC3A\uAC3B\uAC3D\uAC3E\uAC3F\uAC41", 9, "\uAC4C\uAC4E", 5, "\uAC55"],
      ["8181", "\uAC56\uAC57\uAC59\uAC5A\uAC5B\uAC5D", 18, "\uAC72\uAC73\uAC75\uAC76\uAC79\uAC7B", 4, "\uAC82\uAC87\uAC88\uAC8D\uAC8E\uAC8F\uAC91\uAC92\uAC93\uAC95", 6, "\uAC9E\uACA2", 5, "\uACAB\uACAD\uACAE\uACB1", 6, "\uACBA\uACBE\uACBF\uACC0\uACC2\uACC3\uACC5\uACC6\uACC7\uACC9\uACCA\uACCB\uACCD", 7, "\uACD6\uACD8", 7, "\uACE2\uACE3\uACE5\uACE6\uACE9\uACEB\uACED\uACEE\uACF2\uACF4\uACF7", 4, "\uACFE\uACFF\uAD01\uAD02\uAD03\uAD05\uAD07", 4, "\uAD0E\uAD10\uAD12\uAD13"],
      ["8241", "\uAD14\uAD15\uAD16\uAD17\uAD19\uAD1A\uAD1B\uAD1D\uAD1E\uAD1F\uAD21", 7, "\uAD2A\uAD2B\uAD2E", 5],
      ["8261", "\uAD36\uAD37\uAD39\uAD3A\uAD3B\uAD3D", 6, "\uAD46\uAD48\uAD4A", 5, "\uAD51\uAD52\uAD53\uAD55\uAD56\uAD57"],
      ["8281", "\uAD59", 7, "\uAD62\uAD64", 7, "\uAD6E\uAD6F\uAD71\uAD72\uAD77\uAD78\uAD79\uAD7A\uAD7E\uAD80\uAD83", 4, "\uAD8A\uAD8B\uAD8D\uAD8E\uAD8F\uAD91", 10, "\uAD9E", 5, "\uADA5", 17, "\uADB8", 7, "\uADC2\uADC3\uADC5\uADC6\uADC7\uADC9", 6, "\uADD2\uADD4", 7, "\uADDD\uADDE\uADDF\uADE1\uADE2\uADE3\uADE5", 18],
      ["8341", "\uADFA\uADFB\uADFD\uADFE\uAE02", 5, "\uAE0A\uAE0C\uAE0E", 5, "\uAE15", 7],
      ["8361", "\uAE1D", 18, "\uAE32\uAE33\uAE35\uAE36\uAE39\uAE3B\uAE3C"],
      ["8381", "\uAE3D\uAE3E\uAE3F\uAE42\uAE44\uAE47\uAE48\uAE49\uAE4B\uAE4F\uAE51\uAE52\uAE53\uAE55\uAE57", 4, "\uAE5E\uAE62\uAE63\uAE64\uAE66\uAE67\uAE6A\uAE6B\uAE6D\uAE6E\uAE6F\uAE71", 6, "\uAE7A\uAE7E", 5, "\uAE86", 5, "\uAE8D", 46, "\uAEBF\uAEC1\uAEC2\uAEC3\uAEC5", 6, "\uAECE\uAED2", 5, "\uAEDA\uAEDB\uAEDD", 8],
      ["8441", "\uAEE6\uAEE7\uAEE9\uAEEA\uAEEC\uAEEE", 5, "\uAEF5\uAEF6\uAEF7\uAEF9\uAEFA\uAEFB\uAEFD", 8],
      ["8461", "\uAF06\uAF09\uAF0A\uAF0B\uAF0C\uAF0E\uAF0F\uAF11", 18],
      ["8481", "\uAF24", 7, "\uAF2E\uAF2F\uAF31\uAF33\uAF35", 6, "\uAF3E\uAF40\uAF44\uAF45\uAF46\uAF47\uAF4A", 5, "\uAF51", 10, "\uAF5E", 5, "\uAF66", 18, "\uAF7A", 5, "\uAF81\uAF82\uAF83\uAF85\uAF86\uAF87\uAF89", 6, "\uAF92\uAF93\uAF94\uAF96", 5, "\uAF9D", 26, "\uAFBA\uAFBB\uAFBD\uAFBE"],
      ["8541", "\uAFBF\uAFC1", 5, "\uAFCA\uAFCC\uAFCF", 4, "\uAFD5", 6, "\uAFDD", 4],
      ["8561", "\uAFE2", 5, "\uAFEA", 5, "\uAFF2\uAFF3\uAFF5\uAFF6\uAFF7\uAFF9", 6, "\uB002\uB003"],
      ["8581", "\uB005", 6, "\uB00D\uB00E\uB00F\uB011\uB012\uB013\uB015", 6, "\uB01E", 9, "\uB029", 26, "\uB046\uB047\uB049\uB04B\uB04D\uB04F\uB050\uB051\uB052\uB056\uB058\uB05A\uB05B\uB05C\uB05E", 29, "\uB07E\uB07F\uB081\uB082\uB083\uB085", 6, "\uB08E\uB090\uB092", 5, "\uB09B\uB09D\uB09E\uB0A3\uB0A4"],
      ["8641", "\uB0A5\uB0A6\uB0A7\uB0AA\uB0B0\uB0B2\uB0B6\uB0B7\uB0B9\uB0BA\uB0BB\uB0BD", 6, "\uB0C6\uB0CA", 5, "\uB0D2"],
      ["8661", "\uB0D3\uB0D5\uB0D6\uB0D7\uB0D9", 6, "\uB0E1\uB0E2\uB0E3\uB0E4\uB0E6", 10],
      ["8681", "\uB0F1", 22, "\uB10A\uB10D\uB10E\uB10F\uB111\uB114\uB115\uB116\uB117\uB11A\uB11E", 4, "\uB126\uB127\uB129\uB12A\uB12B\uB12D", 6, "\uB136\uB13A", 5, "\uB142\uB143\uB145\uB146\uB147\uB149", 6, "\uB152\uB153\uB156\uB157\uB159\uB15A\uB15B\uB15D\uB15E\uB15F\uB161", 22, "\uB17A\uB17B\uB17D\uB17E\uB17F\uB181\uB183", 4, "\uB18A\uB18C\uB18E\uB18F\uB190\uB191\uB195\uB196\uB197\uB199\uB19A\uB19B\uB19D"],
      ["8741", "\uB19E", 9, "\uB1A9", 15],
      ["8761", "\uB1B9", 18, "\uB1CD\uB1CE\uB1CF\uB1D1\uB1D2\uB1D3\uB1D5"],
      ["8781", "\uB1D6", 5, "\uB1DE\uB1E0", 7, "\uB1EA\uB1EB\uB1ED\uB1EE\uB1EF\uB1F1", 7, "\uB1FA\uB1FC\uB1FE", 5, "\uB206\uB207\uB209\uB20A\uB20D", 6, "\uB216\uB218\uB21A", 5, "\uB221", 18, "\uB235", 6, "\uB23D", 26, "\uB259\uB25A\uB25B\uB25D\uB25E\uB25F\uB261", 6, "\uB26A", 4],
      ["8841", "\uB26F", 4, "\uB276", 5, "\uB27D", 6, "\uB286\uB287\uB288\uB28A", 4],
      ["8861", "\uB28F\uB292\uB293\uB295\uB296\uB297\uB29B", 4, "\uB2A2\uB2A4\uB2A7\uB2A8\uB2A9\uB2AB\uB2AD\uB2AE\uB2AF\uB2B1\uB2B2\uB2B3\uB2B5\uB2B6\uB2B7"],
      ["8881", "\uB2B8", 15, "\uB2CA\uB2CB\uB2CD\uB2CE\uB2CF\uB2D1\uB2D3", 4, "\uB2DA\uB2DC\uB2DE\uB2DF\uB2E0\uB2E1\uB2E3\uB2E7\uB2E9\uB2EA\uB2F0\uB2F1\uB2F2\uB2F6\uB2FC\uB2FD\uB2FE\uB302\uB303\uB305\uB306\uB307\uB309", 6, "\uB312\uB316", 5, "\uB31D", 54, "\uB357\uB359\uB35A\uB35D\uB360\uB361\uB362\uB363"],
      ["8941", "\uB366\uB368\uB36A\uB36C\uB36D\uB36F\uB372\uB373\uB375\uB376\uB377\uB379", 6, "\uB382\uB386", 5, "\uB38D"],
      ["8961", "\uB38E\uB38F\uB391\uB392\uB393\uB395", 10, "\uB3A2", 5, "\uB3A9\uB3AA\uB3AB\uB3AD"],
      ["8981", "\uB3AE", 21, "\uB3C6\uB3C7\uB3C9\uB3CA\uB3CD\uB3CF\uB3D1\uB3D2\uB3D3\uB3D6\uB3D8\uB3DA\uB3DC\uB3DE\uB3DF\uB3E1\uB3E2\uB3E3\uB3E5\uB3E6\uB3E7\uB3E9", 18, "\uB3FD", 18, "\uB411", 6, "\uB419\uB41A\uB41B\uB41D\uB41E\uB41F\uB421", 6, "\uB42A\uB42C", 7, "\uB435", 15],
      ["8a41", "\uB445", 10, "\uB452\uB453\uB455\uB456\uB457\uB459", 6, "\uB462\uB464\uB466"],
      ["8a61", "\uB467", 4, "\uB46D", 18, "\uB481\uB482"],
      ["8a81", "\uB483", 4, "\uB489", 19, "\uB49E", 5, "\uB4A5\uB4A6\uB4A7\uB4A9\uB4AA\uB4AB\uB4AD", 7, "\uB4B6\uB4B8\uB4BA", 5, "\uB4C1\uB4C2\uB4C3\uB4C5\uB4C6\uB4C7\uB4C9", 6, "\uB4D1\uB4D2\uB4D3\uB4D4\uB4D6", 5, "\uB4DE\uB4DF\uB4E1\uB4E2\uB4E5\uB4E7", 4, "\uB4EE\uB4F0\uB4F2", 5, "\uB4F9", 26, "\uB516\uB517\uB519\uB51A\uB51D"],
      ["8b41", "\uB51E", 5, "\uB526\uB52B", 4, "\uB532\uB533\uB535\uB536\uB537\uB539", 6, "\uB542\uB546"],
      ["8b61", "\uB547\uB548\uB549\uB54A\uB54E\uB54F\uB551\uB552\uB553\uB555", 6, "\uB55E\uB562", 8],
      ["8b81", "\uB56B", 52, "\uB5A2\uB5A3\uB5A5\uB5A6\uB5A7\uB5A9\uB5AC\uB5AD\uB5AE\uB5AF\uB5B2\uB5B6", 4, "\uB5BE\uB5BF\uB5C1\uB5C2\uB5C3\uB5C5", 6, "\uB5CE\uB5D2", 5, "\uB5D9", 18, "\uB5ED", 18],
      ["8c41", "\uB600", 15, "\uB612\uB613\uB615\uB616\uB617\uB619", 4],
      ["8c61", "\uB61E", 6, "\uB626", 5, "\uB62D", 6, "\uB635", 5],
      ["8c81", "\uB63B", 12, "\uB649", 26, "\uB665\uB666\uB667\uB669", 50, "\uB69E\uB69F\uB6A1\uB6A2\uB6A3\uB6A5", 5, "\uB6AD\uB6AE\uB6AF\uB6B0\uB6B2", 16],
      ["8d41", "\uB6C3", 16, "\uB6D5", 8],
      ["8d61", "\uB6DE", 17, "\uB6F1\uB6F2\uB6F3\uB6F5\uB6F6\uB6F7\uB6F9\uB6FA"],
      ["8d81", "\uB6FB", 4, "\uB702\uB703\uB704\uB706", 33, "\uB72A\uB72B\uB72D\uB72E\uB731", 6, "\uB73A\uB73C", 7, "\uB745\uB746\uB747\uB749\uB74A\uB74B\uB74D", 6, "\uB756", 9, "\uB761\uB762\uB763\uB765\uB766\uB767\uB769", 6, "\uB772\uB774\uB776", 5, "\uB77E\uB77F\uB781\uB782\uB783\uB785", 6, "\uB78E\uB793\uB794\uB795\uB79A\uB79B\uB79D\uB79E"],
      ["8e41", "\uB79F\uB7A1", 6, "\uB7AA\uB7AE", 5, "\uB7B6\uB7B7\uB7B9", 8],
      ["8e61", "\uB7C2", 4, "\uB7C8\uB7CA", 19],
      ["8e81", "\uB7DE", 13, "\uB7EE\uB7EF\uB7F1\uB7F2\uB7F3\uB7F5", 6, "\uB7FE\uB802", 4, "\uB80A\uB80B\uB80D\uB80E\uB80F\uB811", 6, "\uB81A\uB81C\uB81E", 5, "\uB826\uB827\uB829\uB82A\uB82B\uB82D", 6, "\uB836\uB83A", 5, "\uB841\uB842\uB843\uB845", 11, "\uB852\uB854", 7, "\uB85E\uB85F\uB861\uB862\uB863\uB865", 6, "\uB86E\uB870\uB872", 5, "\uB879\uB87A\uB87B\uB87D", 7],
      ["8f41", "\uB885", 7, "\uB88E", 17],
      ["8f61", "\uB8A0", 7, "\uB8A9", 6, "\uB8B1\uB8B2\uB8B3\uB8B5\uB8B6\uB8B7\uB8B9", 4],
      ["8f81", "\uB8BE\uB8BF\uB8C2\uB8C4\uB8C6", 5, "\uB8CD\uB8CE\uB8CF\uB8D1\uB8D2\uB8D3\uB8D5", 7, "\uB8DE\uB8E0\uB8E2", 5, "\uB8EA\uB8EB\uB8ED\uB8EE\uB8EF\uB8F1", 6, "\uB8FA\uB8FC\uB8FE", 5, "\uB905", 18, "\uB919", 6, "\uB921", 26, "\uB93E\uB93F\uB941\uB942\uB943\uB945", 6, "\uB94D\uB94E\uB950\uB952", 5],
      ["9041", "\uB95A\uB95B\uB95D\uB95E\uB95F\uB961", 6, "\uB96A\uB96C\uB96E", 5, "\uB976\uB977\uB979\uB97A\uB97B\uB97D"],
      ["9061", "\uB97E", 5, "\uB986\uB988\uB98B\uB98C\uB98F", 15],
      ["9081", "\uB99F", 12, "\uB9AE\uB9AF\uB9B1\uB9B2\uB9B3\uB9B5", 6, "\uB9BE\uB9C0\uB9C2", 5, "\uB9CA\uB9CB\uB9CD\uB9D3", 4, "\uB9DA\uB9DC\uB9DF\uB9E0\uB9E2\uB9E6\uB9E7\uB9E9\uB9EA\uB9EB\uB9ED", 6, "\uB9F6\uB9FB", 4, "\uBA02", 5, "\uBA09", 11, "\uBA16", 33, "\uBA3A\uBA3B\uBA3D\uBA3E\uBA3F\uBA41\uBA43\uBA44\uBA45\uBA46"],
      ["9141", "\uBA47\uBA4A\uBA4C\uBA4F\uBA50\uBA51\uBA52\uBA56\uBA57\uBA59\uBA5A\uBA5B\uBA5D", 6, "\uBA66\uBA6A", 5],
      ["9161", "\uBA72\uBA73\uBA75\uBA76\uBA77\uBA79", 9, "\uBA86\uBA88\uBA89\uBA8A\uBA8B\uBA8D", 5],
      ["9181", "\uBA93", 20, "\uBAAA\uBAAD\uBAAE\uBAAF\uBAB1\uBAB3", 4, "\uBABA\uBABC\uBABE", 5, "\uBAC5\uBAC6\uBAC7\uBAC9", 14, "\uBADA", 33, "\uBAFD\uBAFE\uBAFF\uBB01\uBB02\uBB03\uBB05", 7, "\uBB0E\uBB10\uBB12", 5, "\uBB19\uBB1A\uBB1B\uBB1D\uBB1E\uBB1F\uBB21", 6],
      ["9241", "\uBB28\uBB2A\uBB2C", 7, "\uBB37\uBB39\uBB3A\uBB3F", 4, "\uBB46\uBB48\uBB4A\uBB4B\uBB4C\uBB4E\uBB51\uBB52"],
      ["9261", "\uBB53\uBB55\uBB56\uBB57\uBB59", 7, "\uBB62\uBB64", 7, "\uBB6D", 4],
      ["9281", "\uBB72", 21, "\uBB89\uBB8A\uBB8B\uBB8D\uBB8E\uBB8F\uBB91", 18, "\uBBA5\uBBA6\uBBA7\uBBA9\uBBAA\uBBAB\uBBAD", 6, "\uBBB5\uBBB6\uBBB8", 7, "\uBBC1\uBBC2\uBBC3\uBBC5\uBBC6\uBBC7\uBBC9", 6, "\uBBD1\uBBD2\uBBD4", 35, "\uBBFA\uBBFB\uBBFD\uBBFE\uBC01"],
      ["9341", "\uBC03", 4, "\uBC0A\uBC0E\uBC10\uBC12\uBC13\uBC19\uBC1A\uBC20\uBC21\uBC22\uBC23\uBC26\uBC28\uBC2A\uBC2B\uBC2C\uBC2E\uBC2F\uBC32\uBC33\uBC35"],
      ["9361", "\uBC36\uBC37\uBC39", 6, "\uBC42\uBC46\uBC47\uBC48\uBC4A\uBC4B\uBC4E\uBC4F\uBC51", 8],
      ["9381", "\uBC5A\uBC5B\uBC5C\uBC5E", 37, "\uBC86\uBC87\uBC89\uBC8A\uBC8D\uBC8F", 4, "\uBC96\uBC98\uBC9B", 4, "\uBCA2\uBCA3\uBCA5\uBCA6\uBCA9", 6, "\uBCB2\uBCB6", 5, "\uBCBE\uBCBF\uBCC1\uBCC2\uBCC3\uBCC5", 7, "\uBCCE\uBCD2\uBCD3\uBCD4\uBCD6\uBCD7\uBCD9\uBCDA\uBCDB\uBCDD", 22, "\uBCF7\uBCF9\uBCFA\uBCFB\uBCFD"],
      ["9441", "\uBCFE", 5, "\uBD06\uBD08\uBD0A", 5, "\uBD11\uBD12\uBD13\uBD15", 8],
      ["9461", "\uBD1E", 5, "\uBD25", 6, "\uBD2D", 12],
      ["9481", "\uBD3A", 5, "\uBD41", 6, "\uBD4A\uBD4B\uBD4D\uBD4E\uBD4F\uBD51", 6, "\uBD5A", 9, "\uBD65\uBD66\uBD67\uBD69", 22, "\uBD82\uBD83\uBD85\uBD86\uBD8B", 4, "\uBD92\uBD94\uBD96\uBD97\uBD98\uBD9B\uBD9D", 6, "\uBDA5", 10, "\uBDB1", 6, "\uBDB9", 24],
      ["9541", "\uBDD2\uBDD3\uBDD6\uBDD7\uBDD9\uBDDA\uBDDB\uBDDD", 11, "\uBDEA", 5, "\uBDF1"],
      ["9561", "\uBDF2\uBDF3\uBDF5\uBDF6\uBDF7\uBDF9", 6, "\uBE01\uBE02\uBE04\uBE06", 5, "\uBE0E\uBE0F\uBE11\uBE12\uBE13"],
      ["9581", "\uBE15", 6, "\uBE1E\uBE20", 35, "\uBE46\uBE47\uBE49\uBE4A\uBE4B\uBE4D\uBE4F", 4, "\uBE56\uBE58\uBE5C\uBE5D\uBE5E\uBE5F\uBE62\uBE63\uBE65\uBE66\uBE67\uBE69\uBE6B", 4, "\uBE72\uBE76", 4, "\uBE7E\uBE7F\uBE81\uBE82\uBE83\uBE85", 6, "\uBE8E\uBE92", 5, "\uBE9A", 13, "\uBEA9", 14],
      ["9641", "\uBEB8", 23, "\uBED2\uBED3"],
      ["9661", "\uBED5\uBED6\uBED9", 6, "\uBEE1\uBEE2\uBEE6", 5, "\uBEED", 8],
      ["9681", "\uBEF6", 10, "\uBF02", 5, "\uBF0A", 13, "\uBF1A\uBF1E", 33, "\uBF42\uBF43\uBF45\uBF46\uBF47\uBF49", 6, "\uBF52\uBF53\uBF54\uBF56", 44],
      ["9741", "\uBF83", 16, "\uBF95", 8],
      ["9761", "\uBF9E", 17, "\uBFB1", 7],
      ["9781", "\uBFB9", 11, "\uBFC6", 5, "\uBFCE\uBFCF\uBFD1\uBFD2\uBFD3\uBFD5", 6, "\uBFDD\uBFDE\uBFE0\uBFE2", 89, "\uC03D\uC03E\uC03F"],
      ["9841", "\uC040", 16, "\uC052", 5, "\uC059\uC05A\uC05B"],
      ["9861", "\uC05D\uC05E\uC05F\uC061", 6, "\uC06A", 15],
      ["9881", "\uC07A", 21, "\uC092\uC093\uC095\uC096\uC097\uC099", 6, "\uC0A2\uC0A4\uC0A6", 5, "\uC0AE\uC0B1\uC0B2\uC0B7", 4, "\uC0BE\uC0C2\uC0C3\uC0C4\uC0C6\uC0C7\uC0CA\uC0CB\uC0CD\uC0CE\uC0CF\uC0D1", 6, "\uC0DA\uC0DE", 5, "\uC0E6\uC0E7\uC0E9\uC0EA\uC0EB\uC0ED", 6, "\uC0F6\uC0F8\uC0FA", 5, "\uC101\uC102\uC103\uC105\uC106\uC107\uC109", 6, "\uC111\uC112\uC113\uC114\uC116", 5, "\uC121\uC122\uC125\uC128\uC129\uC12A\uC12B\uC12E"],
      ["9941", "\uC132\uC133\uC134\uC135\uC137\uC13A\uC13B\uC13D\uC13E\uC13F\uC141", 6, "\uC14A\uC14E", 5, "\uC156\uC157"],
      ["9961", "\uC159\uC15A\uC15B\uC15D", 6, "\uC166\uC16A", 5, "\uC171\uC172\uC173\uC175\uC176\uC177\uC179\uC17A\uC17B"],
      ["9981", "\uC17C", 8, "\uC186", 5, "\uC18F\uC191\uC192\uC193\uC195\uC197", 4, "\uC19E\uC1A0\uC1A2\uC1A3\uC1A4\uC1A6\uC1A7\uC1AA\uC1AB\uC1AD\uC1AE\uC1AF\uC1B1", 11, "\uC1BE", 5, "\uC1C5\uC1C6\uC1C7\uC1C9\uC1CA\uC1CB\uC1CD", 6, "\uC1D5\uC1D6\uC1D9", 6, "\uC1E1\uC1E2\uC1E3\uC1E5\uC1E6\uC1E7\uC1E9", 6, "\uC1F2\uC1F4", 7, "\uC1FE\uC1FF\uC201\uC202\uC203\uC205", 6, "\uC20E\uC210\uC212", 5, "\uC21A\uC21B\uC21D\uC21E\uC221\uC222\uC223"],
      ["9a41", "\uC224\uC225\uC226\uC227\uC22A\uC22C\uC22E\uC230\uC233\uC235", 16],
      ["9a61", "\uC246\uC247\uC249", 6, "\uC252\uC253\uC255\uC256\uC257\uC259", 6, "\uC261\uC262\uC263\uC264\uC266"],
      ["9a81", "\uC267", 4, "\uC26E\uC26F\uC271\uC272\uC273\uC275", 6, "\uC27E\uC280\uC282", 5, "\uC28A", 5, "\uC291", 6, "\uC299\uC29A\uC29C\uC29E", 5, "\uC2A6\uC2A7\uC2A9\uC2AA\uC2AB\uC2AE", 5, "\uC2B6\uC2B8\uC2BA", 33, "\uC2DE\uC2DF\uC2E1\uC2E2\uC2E5", 5, "\uC2EE\uC2F0\uC2F2\uC2F3\uC2F4\uC2F5\uC2F7\uC2FA\uC2FD\uC2FE\uC2FF\uC301", 6, "\uC30A\uC30B\uC30E\uC30F"],
      ["9b41", "\uC310\uC311\uC312\uC316\uC317\uC319\uC31A\uC31B\uC31D", 6, "\uC326\uC327\uC32A", 8],
      ["9b61", "\uC333", 17, "\uC346", 7],
      ["9b81", "\uC34E", 25, "\uC36A\uC36B\uC36D\uC36E\uC36F\uC371\uC373", 4, "\uC37A\uC37B\uC37E", 5, "\uC385\uC386\uC387\uC389\uC38A\uC38B\uC38D", 50, "\uC3C1", 22, "\uC3DA"],
      ["9c41", "\uC3DB\uC3DD\uC3DE\uC3E1\uC3E3", 4, "\uC3EA\uC3EB\uC3EC\uC3EE", 5, "\uC3F6\uC3F7\uC3F9", 5],
      ["9c61", "\uC3FF", 8, "\uC409", 6, "\uC411", 9],
      ["9c81", "\uC41B", 8, "\uC425", 6, "\uC42D\uC42E\uC42F\uC431\uC432\uC433\uC435", 6, "\uC43E", 9, "\uC449", 26, "\uC466\uC467\uC469\uC46A\uC46B\uC46D", 6, "\uC476\uC477\uC478\uC47A", 5, "\uC481", 18, "\uC495", 6, "\uC49D", 12],
      ["9d41", "\uC4AA", 13, "\uC4B9\uC4BA\uC4BB\uC4BD", 8],
      ["9d61", "\uC4C6", 25],
      ["9d81", "\uC4E0", 8, "\uC4EA", 5, "\uC4F2\uC4F3\uC4F5\uC4F6\uC4F7\uC4F9\uC4FB\uC4FC\uC4FD\uC4FE\uC502", 9, "\uC50D\uC50E\uC50F\uC511\uC512\uC513\uC515", 6, "\uC51D", 10, "\uC52A\uC52B\uC52D\uC52E\uC52F\uC531", 6, "\uC53A\uC53C\uC53E", 5, "\uC546\uC547\uC54B\uC54F\uC550\uC551\uC552\uC556\uC55A\uC55B\uC55C\uC55F\uC562\uC563\uC565\uC566\uC567\uC569", 6, "\uC572\uC576", 5, "\uC57E\uC57F\uC581\uC582\uC583\uC585\uC586\uC588\uC589\uC58A\uC58B\uC58E\uC590\uC592\uC593\uC594"],
      ["9e41", "\uC596\uC599\uC59A\uC59B\uC59D\uC59E\uC59F\uC5A1", 7, "\uC5AA", 9, "\uC5B6"],
      ["9e61", "\uC5B7\uC5BA\uC5BF", 4, "\uC5CB\uC5CD\uC5CF\uC5D2\uC5D3\uC5D5\uC5D6\uC5D7\uC5D9", 6, "\uC5E2\uC5E4\uC5E6\uC5E7"],
      ["9e81", "\uC5E8\uC5E9\uC5EA\uC5EB\uC5EF\uC5F1\uC5F2\uC5F3\uC5F5\uC5F8\uC5F9\uC5FA\uC5FB\uC602\uC603\uC604\uC609\uC60A\uC60B\uC60D\uC60E\uC60F\uC611", 6, "\uC61A\uC61D", 6, "\uC626\uC627\uC629\uC62A\uC62B\uC62F\uC631\uC632\uC636\uC638\uC63A\uC63C\uC63D\uC63E\uC63F\uC642\uC643\uC645\uC646\uC647\uC649", 6, "\uC652\uC656", 5, "\uC65E\uC65F\uC661", 10, "\uC66D\uC66E\uC670\uC672", 5, "\uC67A\uC67B\uC67D\uC67E\uC67F\uC681", 6, "\uC68A\uC68C\uC68E", 5, "\uC696\uC697\uC699\uC69A\uC69B\uC69D", 6, "\uC6A6"],
      ["9f41", "\uC6A8\uC6AA", 5, "\uC6B2\uC6B3\uC6B5\uC6B6\uC6B7\uC6BB", 4, "\uC6C2\uC6C4\uC6C6", 5, "\uC6CE"],
      ["9f61", "\uC6CF\uC6D1\uC6D2\uC6D3\uC6D5", 6, "\uC6DE\uC6DF\uC6E2", 5, "\uC6EA\uC6EB\uC6ED\uC6EE\uC6EF\uC6F1\uC6F2"],
      ["9f81", "\uC6F3", 4, "\uC6FA\uC6FB\uC6FC\uC6FE", 5, "\uC706\uC707\uC709\uC70A\uC70B\uC70D", 6, "\uC716\uC718\uC71A", 5, "\uC722\uC723\uC725\uC726\uC727\uC729", 6, "\uC732\uC734\uC736\uC738\uC739\uC73A\uC73B\uC73E\uC73F\uC741\uC742\uC743\uC745", 4, "\uC74B\uC74E\uC750\uC759\uC75A\uC75B\uC75D\uC75E\uC75F\uC761", 6, "\uC769\uC76A\uC76C", 7, "\uC776\uC777\uC779\uC77A\uC77B\uC77F\uC780\uC781\uC782\uC786\uC78B\uC78C\uC78D\uC78F\uC792\uC793\uC795\uC799\uC79B", 4, "\uC7A2\uC7A7", 4, "\uC7AE\uC7AF\uC7B1\uC7B2\uC7B3\uC7B5\uC7B6\uC7B7"],
      ["a041", "\uC7B8\uC7B9\uC7BA\uC7BB\uC7BE\uC7C2", 5, "\uC7CA\uC7CB\uC7CD\uC7CF\uC7D1", 6, "\uC7D9\uC7DA\uC7DB\uC7DC"],
      ["a061", "\uC7DE", 5, "\uC7E5\uC7E6\uC7E7\uC7E9\uC7EA\uC7EB\uC7ED", 13],
      ["a081", "\uC7FB", 4, "\uC802\uC803\uC805\uC806\uC807\uC809\uC80B", 4, "\uC812\uC814\uC817", 4, "\uC81E\uC81F\uC821\uC822\uC823\uC825", 6, "\uC82E\uC830\uC832", 5, "\uC839\uC83A\uC83B\uC83D\uC83E\uC83F\uC841", 6, "\uC84A\uC84B\uC84E", 5, "\uC855", 26, "\uC872\uC873\uC875\uC876\uC877\uC879\uC87B", 4, "\uC882\uC884\uC888\uC889\uC88A\uC88E", 5, "\uC895", 7, "\uC89E\uC8A0\uC8A2\uC8A3\uC8A4"],
      ["a141", "\uC8A5\uC8A6\uC8A7\uC8A9", 18, "\uC8BE\uC8BF\uC8C0\uC8C1"],
      ["a161", "\uC8C2\uC8C3\uC8C5\uC8C6\uC8C7\uC8C9\uC8CA\uC8CB\uC8CD", 6, "\uC8D6\uC8D8\uC8DA", 5, "\uC8E2\uC8E3\uC8E5"],
      ["a181", "\uC8E6", 14, "\uC8F6", 5, "\uC8FE\uC8FF\uC901\uC902\uC903\uC907", 4, "\uC90E\u3000\u3001\u3002\xB7\u2025\u2026\xA8\u3003\xAD\u2015\u2225\uFF3C\u223C\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 9, "\xB1\xD7\xF7\u2260\u2264\u2265\u221E\u2234\xB0\u2032\u2033\u2103\u212B\uFFE0\uFFE1\uFFE5\u2642\u2640\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\xA7\u203B\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u2192\u2190\u2191\u2193\u2194\u3013\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229\u2227\u2228\uFFE2"],
      ["a241", "\uC910\uC912", 5, "\uC919", 18],
      ["a261", "\uC92D", 6, "\uC935", 18],
      ["a281", "\uC948", 7, "\uC952\uC953\uC955\uC956\uC957\uC959", 6, "\uC962\uC964", 7, "\uC96D\uC96E\uC96F\u21D2\u21D4\u2200\u2203\xB4\uFF5E\u02C7\u02D8\u02DD\u02DA\u02D9\xB8\u02DB\xA1\xBF\u02D0\u222E\u2211\u220F\xA4\u2109\u2030\u25C1\u25C0\u25B7\u25B6\u2664\u2660\u2661\u2665\u2667\u2663\u2299\u25C8\u25A3\u25D0\u25D1\u2592\u25A4\u25A5\u25A8\u25A7\u25A6\u25A9\u2668\u260F\u260E\u261C\u261E\xB6\u2020\u2021\u2195\u2197\u2199\u2196\u2198\u266D\u2669\u266A\u266C\u327F\u321C\u2116\u33C7\u2122\u33C2\u33D8\u2121\u20AC\xAE"],
      ["a341", "\uC971\uC972\uC973\uC975", 6, "\uC97D", 10, "\uC98A\uC98B\uC98D\uC98E\uC98F"],
      ["a361", "\uC991", 6, "\uC99A\uC99C\uC99E", 16],
      ["a381", "\uC9AF", 16, "\uC9C2\uC9C3\uC9C5\uC9C6\uC9C9\uC9CB", 4, "\uC9D2\uC9D4\uC9D7\uC9D8\uC9DB\uFF01", 58, "\uFFE6\uFF3D", 32, "\uFFE3"],
      ["a441", "\uC9DE\uC9DF\uC9E1\uC9E3\uC9E5\uC9E6\uC9E8\uC9E9\uC9EA\uC9EB\uC9EE\uC9F2", 5, "\uC9FA\uC9FB\uC9FD\uC9FE\uC9FF\uCA01\uCA02\uCA03\uCA04"],
      ["a461", "\uCA05\uCA06\uCA07\uCA0A\uCA0E", 5, "\uCA15\uCA16\uCA17\uCA19", 12],
      ["a481", "\uCA26\uCA27\uCA28\uCA2A", 28, "\u3131", 93],
      ["a541", "\uCA47", 4, "\uCA4E\uCA4F\uCA51\uCA52\uCA53\uCA55", 6, "\uCA5E\uCA62", 5, "\uCA69\uCA6A"],
      ["a561", "\uCA6B", 17, "\uCA7E", 5, "\uCA85\uCA86"],
      ["a581", "\uCA87", 16, "\uCA99", 14, "\u2170", 9],
      ["a5b0", "\u2160", 9],
      ["a5c1", "\u0391", 16, "\u03A3", 6],
      ["a5e1", "\u03B1", 16, "\u03C3", 6],
      ["a641", "\uCAA8", 19, "\uCABE\uCABF\uCAC1\uCAC2\uCAC3\uCAC5"],
      ["a661", "\uCAC6", 5, "\uCACE\uCAD0\uCAD2\uCAD4\uCAD5\uCAD6\uCAD7\uCADA", 5, "\uCAE1", 6],
      ["a681", "\uCAE8\uCAE9\uCAEA\uCAEB\uCAED", 6, "\uCAF5", 18, "\uCB09\uCB0A\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542\u2512\u2511\u251A\u2519\u2516\u2515\u250E\u250D\u251E\u251F\u2521\u2522\u2526\u2527\u2529\u252A\u252D\u252E\u2531\u2532\u2535\u2536\u2539\u253A\u253D\u253E\u2540\u2541\u2543", 7],
      ["a741", "\uCB0B", 4, "\uCB11\uCB12\uCB13\uCB15\uCB16\uCB17\uCB19", 6, "\uCB22", 7],
      ["a761", "\uCB2A", 22, "\uCB42\uCB43\uCB44"],
      ["a781", "\uCB45\uCB46\uCB47\uCB4A\uCB4B\uCB4D\uCB4E\uCB4F\uCB51", 6, "\uCB5A\uCB5B\uCB5C\uCB5E", 5, "\uCB65", 7, "\u3395\u3396\u3397\u2113\u3398\u33C4\u33A3\u33A4\u33A5\u33A6\u3399", 9, "\u33CA\u338D\u338E\u338F\u33CF\u3388\u3389\u33C8\u33A7\u33A8\u33B0", 9, "\u3380", 4, "\u33BA", 5, "\u3390", 4, "\u2126\u33C0\u33C1\u338A\u338B\u338C\u33D6\u33C5\u33AD\u33AE\u33AF\u33DB\u33A9\u33AA\u33AB\u33AC\u33DD\u33D0\u33D3\u33C3\u33C9\u33DC\u33C6"],
      ["a841", "\uCB6D", 10, "\uCB7A", 14],
      ["a861", "\uCB89", 18, "\uCB9D", 6],
      ["a881", "\uCBA4", 19, "\uCBB9", 11, "\xC6\xD0\xAA\u0126"],
      ["a8a6", "\u0132"],
      ["a8a8", "\u013F\u0141\xD8\u0152\xBA\xDE\u0166\u014A"],
      ["a8b1", "\u3260", 27, "\u24D0", 25, "\u2460", 14, "\xBD\u2153\u2154\xBC\xBE\u215B\u215C\u215D\u215E"],
      ["a941", "\uCBC5", 14, "\uCBD5", 10],
      ["a961", "\uCBE0\uCBE1\uCBE2\uCBE3\uCBE5\uCBE6\uCBE8\uCBEA", 18],
      ["a981", "\uCBFD", 14, "\uCC0E\uCC0F\uCC11\uCC12\uCC13\uCC15", 6, "\uCC1E\uCC1F\uCC20\uCC23\uCC24\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0140\u0142\xF8\u0153\xDF\xFE\u0167\u014B\u0149\u3200", 27, "\u249C", 25, "\u2474", 14, "\xB9\xB2\xB3\u2074\u207F\u2081\u2082\u2083\u2084"],
      ["aa41", "\uCC25\uCC26\uCC2A\uCC2B\uCC2D\uCC2F\uCC31", 6, "\uCC3A\uCC3F", 4, "\uCC46\uCC47\uCC49\uCC4A\uCC4B\uCC4D\uCC4E"],
      ["aa61", "\uCC4F", 4, "\uCC56\uCC5A", 5, "\uCC61\uCC62\uCC63\uCC65\uCC67\uCC69", 6, "\uCC71\uCC72"],
      ["aa81", "\uCC73\uCC74\uCC76", 29, "\u3041", 82],
      ["ab41", "\uCC94\uCC95\uCC96\uCC97\uCC9A\uCC9B\uCC9D\uCC9E\uCC9F\uCCA1", 6, "\uCCAA\uCCAE", 5, "\uCCB6\uCCB7\uCCB9"],
      ["ab61", "\uCCBA\uCCBB\uCCBD", 6, "\uCCC6\uCCC8\uCCCA", 5, "\uCCD1\uCCD2\uCCD3\uCCD5", 5],
      ["ab81", "\uCCDB", 8, "\uCCE5", 6, "\uCCED\uCCEE\uCCEF\uCCF1", 12, "\u30A1", 85],
      ["ac41", "\uCCFE\uCCFF\uCD00\uCD02", 5, "\uCD0A\uCD0B\uCD0D\uCD0E\uCD0F\uCD11", 6, "\uCD1A\uCD1C\uCD1E\uCD1F\uCD20"],
      ["ac61", "\uCD21\uCD22\uCD23\uCD25\uCD26\uCD27\uCD29\uCD2A\uCD2B\uCD2D", 11, "\uCD3A", 4],
      ["ac81", "\uCD3F", 28, "\uCD5D\uCD5E\uCD5F\u0410", 5, "\u0401\u0416", 25],
      ["acd1", "\u0430", 5, "\u0451\u0436", 25],
      ["ad41", "\uCD61\uCD62\uCD63\uCD65", 6, "\uCD6E\uCD70\uCD72", 5, "\uCD79", 7],
      ["ad61", "\uCD81", 6, "\uCD89", 10, "\uCD96\uCD97\uCD99\uCD9A\uCD9B\uCD9D\uCD9E\uCD9F"],
      ["ad81", "\uCDA0\uCDA1\uCDA2\uCDA3\uCDA6\uCDA8\uCDAA", 5, "\uCDB1", 18, "\uCDC5"],
      ["ae41", "\uCDC6", 5, "\uCDCD\uCDCE\uCDCF\uCDD1", 16],
      ["ae61", "\uCDE2", 5, "\uCDE9\uCDEA\uCDEB\uCDED\uCDEE\uCDEF\uCDF1", 6, "\uCDFA\uCDFC\uCDFE", 4],
      ["ae81", "\uCE03\uCE05\uCE06\uCE07\uCE09\uCE0A\uCE0B\uCE0D", 6, "\uCE15\uCE16\uCE17\uCE18\uCE1A", 5, "\uCE22\uCE23\uCE25\uCE26\uCE27\uCE29\uCE2A\uCE2B"],
      ["af41", "\uCE2C\uCE2D\uCE2E\uCE2F\uCE32\uCE34\uCE36", 19],
      ["af61", "\uCE4A", 13, "\uCE5A\uCE5B\uCE5D\uCE5E\uCE62", 5, "\uCE6A\uCE6C"],
      ["af81", "\uCE6E", 5, "\uCE76\uCE77\uCE79\uCE7A\uCE7B\uCE7D", 6, "\uCE86\uCE88\uCE8A", 5, "\uCE92\uCE93\uCE95\uCE96\uCE97\uCE99"],
      ["b041", "\uCE9A", 5, "\uCEA2\uCEA6", 5, "\uCEAE", 12],
      ["b061", "\uCEBB", 5, "\uCEC2", 19],
      ["b081", "\uCED6", 13, "\uCEE6\uCEE7\uCEE9\uCEEA\uCEED", 6, "\uCEF6\uCEFA", 5, "\uAC00\uAC01\uAC04\uAC07\uAC08\uAC09\uAC0A\uAC10", 7, "\uAC19", 4, "\uAC20\uAC24\uAC2C\uAC2D\uAC2F\uAC30\uAC31\uAC38\uAC39\uAC3C\uAC40\uAC4B\uAC4D\uAC54\uAC58\uAC5C\uAC70\uAC71\uAC74\uAC77\uAC78\uAC7A\uAC80\uAC81\uAC83\uAC84\uAC85\uAC86\uAC89\uAC8A\uAC8B\uAC8C\uAC90\uAC94\uAC9C\uAC9D\uAC9F\uACA0\uACA1\uACA8\uACA9\uACAA\uACAC\uACAF\uACB0\uACB8\uACB9\uACBB\uACBC\uACBD\uACC1\uACC4\uACC8\uACCC\uACD5\uACD7\uACE0\uACE1\uACE4\uACE7\uACE8\uACEA\uACEC\uACEF\uACF0\uACF1\uACF3\uACF5\uACF6\uACFC\uACFD\uAD00\uAD04\uAD06"],
      ["b141", "\uCF02\uCF03\uCF05\uCF06\uCF07\uCF09", 6, "\uCF12\uCF14\uCF16", 5, "\uCF1D\uCF1E\uCF1F\uCF21\uCF22\uCF23"],
      ["b161", "\uCF25", 6, "\uCF2E\uCF32", 5, "\uCF39", 11],
      ["b181", "\uCF45", 14, "\uCF56\uCF57\uCF59\uCF5A\uCF5B\uCF5D", 6, "\uCF66\uCF68\uCF6A\uCF6B\uCF6C\uAD0C\uAD0D\uAD0F\uAD11\uAD18\uAD1C\uAD20\uAD29\uAD2C\uAD2D\uAD34\uAD35\uAD38\uAD3C\uAD44\uAD45\uAD47\uAD49\uAD50\uAD54\uAD58\uAD61\uAD63\uAD6C\uAD6D\uAD70\uAD73\uAD74\uAD75\uAD76\uAD7B\uAD7C\uAD7D\uAD7F\uAD81\uAD82\uAD88\uAD89\uAD8C\uAD90\uAD9C\uAD9D\uADA4\uADB7\uADC0\uADC1\uADC4\uADC8\uADD0\uADD1\uADD3\uADDC\uADE0\uADE4\uADF8\uADF9\uADFC\uADFF\uAE00\uAE01\uAE08\uAE09\uAE0B\uAE0D\uAE14\uAE30\uAE31\uAE34\uAE37\uAE38\uAE3A\uAE40\uAE41\uAE43\uAE45\uAE46\uAE4A\uAE4C\uAE4D\uAE4E\uAE50\uAE54\uAE56\uAE5C\uAE5D\uAE5F\uAE60\uAE61\uAE65\uAE68\uAE69\uAE6C\uAE70\uAE78"],
      ["b241", "\uCF6D\uCF6E\uCF6F\uCF72\uCF73\uCF75\uCF76\uCF77\uCF79", 6, "\uCF81\uCF82\uCF83\uCF84\uCF86", 5, "\uCF8D"],
      ["b261", "\uCF8E", 18, "\uCFA2", 5, "\uCFA9"],
      ["b281", "\uCFAA", 5, "\uCFB1", 18, "\uCFC5", 6, "\uAE79\uAE7B\uAE7C\uAE7D\uAE84\uAE85\uAE8C\uAEBC\uAEBD\uAEBE\uAEC0\uAEC4\uAECC\uAECD\uAECF\uAED0\uAED1\uAED8\uAED9\uAEDC\uAEE8\uAEEB\uAEED\uAEF4\uAEF8\uAEFC\uAF07\uAF08\uAF0D\uAF10\uAF2C\uAF2D\uAF30\uAF32\uAF34\uAF3C\uAF3D\uAF3F\uAF41\uAF42\uAF43\uAF48\uAF49\uAF50\uAF5C\uAF5D\uAF64\uAF65\uAF79\uAF80\uAF84\uAF88\uAF90\uAF91\uAF95\uAF9C\uAFB8\uAFB9\uAFBC\uAFC0\uAFC7\uAFC8\uAFC9\uAFCB\uAFCD\uAFCE\uAFD4\uAFDC\uAFE8\uAFE9\uAFF0\uAFF1\uAFF4\uAFF8\uB000\uB001\uB004\uB00C\uB010\uB014\uB01C\uB01D\uB028\uB044\uB045\uB048\uB04A\uB04C\uB04E\uB053\uB054\uB055\uB057\uB059"],
      ["b341", "\uCFCC", 19, "\uCFE2\uCFE3\uCFE5\uCFE6\uCFE7\uCFE9"],
      ["b361", "\uCFEA", 5, "\uCFF2\uCFF4\uCFF6", 5, "\uCFFD\uCFFE\uCFFF\uD001\uD002\uD003\uD005", 5],
      ["b381", "\uD00B", 5, "\uD012", 5, "\uD019", 19, "\uB05D\uB07C\uB07D\uB080\uB084\uB08C\uB08D\uB08F\uB091\uB098\uB099\uB09A\uB09C\uB09F\uB0A0\uB0A1\uB0A2\uB0A8\uB0A9\uB0AB", 4, "\uB0B1\uB0B3\uB0B4\uB0B5\uB0B8\uB0BC\uB0C4\uB0C5\uB0C7\uB0C8\uB0C9\uB0D0\uB0D1\uB0D4\uB0D8\uB0E0\uB0E5\uB108\uB109\uB10B\uB10C\uB110\uB112\uB113\uB118\uB119\uB11B\uB11C\uB11D\uB123\uB124\uB125\uB128\uB12C\uB134\uB135\uB137\uB138\uB139\uB140\uB141\uB144\uB148\uB150\uB151\uB154\uB155\uB158\uB15C\uB160\uB178\uB179\uB17C\uB180\uB182\uB188\uB189\uB18B\uB18D\uB192\uB193\uB194\uB198\uB19C\uB1A8\uB1CC\uB1D0\uB1D4\uB1DC\uB1DD"],
      ["b441", "\uD02E", 5, "\uD036\uD037\uD039\uD03A\uD03B\uD03D", 6, "\uD046\uD048\uD04A", 5],
      ["b461", "\uD051\uD052\uD053\uD055\uD056\uD057\uD059", 6, "\uD061", 10, "\uD06E\uD06F"],
      ["b481", "\uD071\uD072\uD073\uD075", 6, "\uD07E\uD07F\uD080\uD082", 18, "\uB1DF\uB1E8\uB1E9\uB1EC\uB1F0\uB1F9\uB1FB\uB1FD\uB204\uB205\uB208\uB20B\uB20C\uB214\uB215\uB217\uB219\uB220\uB234\uB23C\uB258\uB25C\uB260\uB268\uB269\uB274\uB275\uB27C\uB284\uB285\uB289\uB290\uB291\uB294\uB298\uB299\uB29A\uB2A0\uB2A1\uB2A3\uB2A5\uB2A6\uB2AA\uB2AC\uB2B0\uB2B4\uB2C8\uB2C9\uB2CC\uB2D0\uB2D2\uB2D8\uB2D9\uB2DB\uB2DD\uB2E2\uB2E4\uB2E5\uB2E6\uB2E8\uB2EB", 4, "\uB2F3\uB2F4\uB2F5\uB2F7", 4, "\uB2FF\uB300\uB301\uB304\uB308\uB310\uB311\uB313\uB314\uB315\uB31C\uB354\uB355\uB356\uB358\uB35B\uB35C\uB35E\uB35F\uB364\uB365"],
      ["b541", "\uD095", 14, "\uD0A6\uD0A7\uD0A9\uD0AA\uD0AB\uD0AD", 5],
      ["b561", "\uD0B3\uD0B6\uD0B8\uD0BA", 5, "\uD0C2\uD0C3\uD0C5\uD0C6\uD0C7\uD0CA", 5, "\uD0D2\uD0D6", 4],
      ["b581", "\uD0DB\uD0DE\uD0DF\uD0E1\uD0E2\uD0E3\uD0E5", 6, "\uD0EE\uD0F2", 5, "\uD0F9", 11, "\uB367\uB369\uB36B\uB36E\uB370\uB371\uB374\uB378\uB380\uB381\uB383\uB384\uB385\uB38C\uB390\uB394\uB3A0\uB3A1\uB3A8\uB3AC\uB3C4\uB3C5\uB3C8\uB3CB\uB3CC\uB3CE\uB3D0\uB3D4\uB3D5\uB3D7\uB3D9\uB3DB\uB3DD\uB3E0\uB3E4\uB3E8\uB3FC\uB410\uB418\uB41C\uB420\uB428\uB429\uB42B\uB434\uB450\uB451\uB454\uB458\uB460\uB461\uB463\uB465\uB46C\uB480\uB488\uB49D\uB4A4\uB4A8\uB4AC\uB4B5\uB4B7\uB4B9\uB4C0\uB4C4\uB4C8\uB4D0\uB4D5\uB4DC\uB4DD\uB4E0\uB4E3\uB4E4\uB4E6\uB4EC\uB4ED\uB4EF\uB4F1\uB4F8\uB514\uB515\uB518\uB51B\uB51C\uB524\uB525\uB527\uB528\uB529\uB52A\uB530\uB531\uB534\uB538"],
      ["b641", "\uD105", 7, "\uD10E", 17],
      ["b661", "\uD120", 15, "\uD132\uD133\uD135\uD136\uD137\uD139\uD13B\uD13C\uD13D\uD13E"],
      ["b681", "\uD13F\uD142\uD146", 5, "\uD14E\uD14F\uD151\uD152\uD153\uD155", 6, "\uD15E\uD160\uD162", 5, "\uD169\uD16A\uD16B\uD16D\uB540\uB541\uB543\uB544\uB545\uB54B\uB54C\uB54D\uB550\uB554\uB55C\uB55D\uB55F\uB560\uB561\uB5A0\uB5A1\uB5A4\uB5A8\uB5AA\uB5AB\uB5B0\uB5B1\uB5B3\uB5B4\uB5B5\uB5BB\uB5BC\uB5BD\uB5C0\uB5C4\uB5CC\uB5CD\uB5CF\uB5D0\uB5D1\uB5D8\uB5EC\uB610\uB611\uB614\uB618\uB625\uB62C\uB634\uB648\uB664\uB668\uB69C\uB69D\uB6A0\uB6A4\uB6AB\uB6AC\uB6B1\uB6D4\uB6F0\uB6F4\uB6F8\uB700\uB701\uB705\uB728\uB729\uB72C\uB72F\uB730\uB738\uB739\uB73B\uB744\uB748\uB74C\uB754\uB755\uB760\uB764\uB768\uB770\uB771\uB773\uB775\uB77C\uB77D\uB780\uB784\uB78C\uB78D\uB78F\uB790\uB791\uB792\uB796\uB797"],
      ["b741", "\uD16E", 13, "\uD17D", 6, "\uD185\uD186\uD187\uD189\uD18A"],
      ["b761", "\uD18B", 20, "\uD1A2\uD1A3\uD1A5\uD1A6\uD1A7"],
      ["b781", "\uD1A9", 6, "\uD1B2\uD1B4\uD1B6\uD1B7\uD1B8\uD1B9\uD1BB\uD1BD\uD1BE\uD1BF\uD1C1", 14, "\uB798\uB799\uB79C\uB7A0\uB7A8\uB7A9\uB7AB\uB7AC\uB7AD\uB7B4\uB7B5\uB7B8\uB7C7\uB7C9\uB7EC\uB7ED\uB7F0\uB7F4\uB7FC\uB7FD\uB7FF\uB800\uB801\uB807\uB808\uB809\uB80C\uB810\uB818\uB819\uB81B\uB81D\uB824\uB825\uB828\uB82C\uB834\uB835\uB837\uB838\uB839\uB840\uB844\uB851\uB853\uB85C\uB85D\uB860\uB864\uB86C\uB86D\uB86F\uB871\uB878\uB87C\uB88D\uB8A8\uB8B0\uB8B4\uB8B8\uB8C0\uB8C1\uB8C3\uB8C5\uB8CC\uB8D0\uB8D4\uB8DD\uB8DF\uB8E1\uB8E8\uB8E9\uB8EC\uB8F0\uB8F8\uB8F9\uB8FB\uB8FD\uB904\uB918\uB920\uB93C\uB93D\uB940\uB944\uB94C\uB94F\uB951\uB958\uB959\uB95C\uB960\uB968\uB969"],
      ["b841", "\uD1D0", 7, "\uD1D9", 17],
      ["b861", "\uD1EB", 8, "\uD1F5\uD1F6\uD1F7\uD1F9", 13],
      ["b881", "\uD208\uD20A", 5, "\uD211", 24, "\uB96B\uB96D\uB974\uB975\uB978\uB97C\uB984\uB985\uB987\uB989\uB98A\uB98D\uB98E\uB9AC\uB9AD\uB9B0\uB9B4\uB9BC\uB9BD\uB9BF\uB9C1\uB9C8\uB9C9\uB9CC\uB9CE", 4, "\uB9D8\uB9D9\uB9DB\uB9DD\uB9DE\uB9E1\uB9E3\uB9E4\uB9E5\uB9E8\uB9EC\uB9F4\uB9F5\uB9F7\uB9F8\uB9F9\uB9FA\uBA00\uBA01\uBA08\uBA15\uBA38\uBA39\uBA3C\uBA40\uBA42\uBA48\uBA49\uBA4B\uBA4D\uBA4E\uBA53\uBA54\uBA55\uBA58\uBA5C\uBA64\uBA65\uBA67\uBA68\uBA69\uBA70\uBA71\uBA74\uBA78\uBA83\uBA84\uBA85\uBA87\uBA8C\uBAA8\uBAA9\uBAAB\uBAAC\uBAB0\uBAB2\uBAB8\uBAB9\uBABB\uBABD\uBAC4\uBAC8\uBAD8\uBAD9\uBAFC"],
      ["b941", "\uD22A\uD22B\uD22E\uD22F\uD231\uD232\uD233\uD235", 6, "\uD23E\uD240\uD242", 5, "\uD249\uD24A\uD24B\uD24C"],
      ["b961", "\uD24D", 14, "\uD25D", 6, "\uD265\uD266\uD267\uD268"],
      ["b981", "\uD269", 22, "\uD282\uD283\uD285\uD286\uD287\uD289\uD28A\uD28B\uD28C\uBB00\uBB04\uBB0D\uBB0F\uBB11\uBB18\uBB1C\uBB20\uBB29\uBB2B\uBB34\uBB35\uBB36\uBB38\uBB3B\uBB3C\uBB3D\uBB3E\uBB44\uBB45\uBB47\uBB49\uBB4D\uBB4F\uBB50\uBB54\uBB58\uBB61\uBB63\uBB6C\uBB88\uBB8C\uBB90\uBBA4\uBBA8\uBBAC\uBBB4\uBBB7\uBBC0\uBBC4\uBBC8\uBBD0\uBBD3\uBBF8\uBBF9\uBBFC\uBBFF\uBC00\uBC02\uBC08\uBC09\uBC0B\uBC0C\uBC0D\uBC0F\uBC11\uBC14", 4, "\uBC1B", 4, "\uBC24\uBC25\uBC27\uBC29\uBC2D\uBC30\uBC31\uBC34\uBC38\uBC40\uBC41\uBC43\uBC44\uBC45\uBC49\uBC4C\uBC4D\uBC50\uBC5D\uBC84\uBC85\uBC88\uBC8B\uBC8C\uBC8E\uBC94\uBC95\uBC97"],
      ["ba41", "\uD28D\uD28E\uD28F\uD292\uD293\uD294\uD296", 5, "\uD29D\uD29E\uD29F\uD2A1\uD2A2\uD2A3\uD2A5", 6, "\uD2AD"],
      ["ba61", "\uD2AE\uD2AF\uD2B0\uD2B2", 5, "\uD2BA\uD2BB\uD2BD\uD2BE\uD2C1\uD2C3", 4, "\uD2CA\uD2CC", 5],
      ["ba81", "\uD2D2\uD2D3\uD2D5\uD2D6\uD2D7\uD2D9\uD2DA\uD2DB\uD2DD", 6, "\uD2E6", 9, "\uD2F2\uD2F3\uD2F5\uD2F6\uD2F7\uD2F9\uD2FA\uBC99\uBC9A\uBCA0\uBCA1\uBCA4\uBCA7\uBCA8\uBCB0\uBCB1\uBCB3\uBCB4\uBCB5\uBCBC\uBCBD\uBCC0\uBCC4\uBCCD\uBCCF\uBCD0\uBCD1\uBCD5\uBCD8\uBCDC\uBCF4\uBCF5\uBCF6\uBCF8\uBCFC\uBD04\uBD05\uBD07\uBD09\uBD10\uBD14\uBD24\uBD2C\uBD40\uBD48\uBD49\uBD4C\uBD50\uBD58\uBD59\uBD64\uBD68\uBD80\uBD81\uBD84\uBD87\uBD88\uBD89\uBD8A\uBD90\uBD91\uBD93\uBD95\uBD99\uBD9A\uBD9C\uBDA4\uBDB0\uBDB8\uBDD4\uBDD5\uBDD8\uBDDC\uBDE9\uBDF0\uBDF4\uBDF8\uBE00\uBE03\uBE05\uBE0C\uBE0D\uBE10\uBE14\uBE1C\uBE1D\uBE1F\uBE44\uBE45\uBE48\uBE4C\uBE4E\uBE54\uBE55\uBE57\uBE59\uBE5A\uBE5B\uBE60\uBE61\uBE64"],
      ["bb41", "\uD2FB", 4, "\uD302\uD304\uD306", 5, "\uD30F\uD311\uD312\uD313\uD315\uD317", 4, "\uD31E\uD322\uD323"],
      ["bb61", "\uD324\uD326\uD327\uD32A\uD32B\uD32D\uD32E\uD32F\uD331", 6, "\uD33A\uD33E", 5, "\uD346\uD347\uD348\uD349"],
      ["bb81", "\uD34A", 31, "\uBE68\uBE6A\uBE70\uBE71\uBE73\uBE74\uBE75\uBE7B\uBE7C\uBE7D\uBE80\uBE84\uBE8C\uBE8D\uBE8F\uBE90\uBE91\uBE98\uBE99\uBEA8\uBED0\uBED1\uBED4\uBED7\uBED8\uBEE0\uBEE3\uBEE4\uBEE5\uBEEC\uBF01\uBF08\uBF09\uBF18\uBF19\uBF1B\uBF1C\uBF1D\uBF40\uBF41\uBF44\uBF48\uBF50\uBF51\uBF55\uBF94\uBFB0\uBFC5\uBFCC\uBFCD\uBFD0\uBFD4\uBFDC\uBFDF\uBFE1\uC03C\uC051\uC058\uC05C\uC060\uC068\uC069\uC090\uC091\uC094\uC098\uC0A0\uC0A1\uC0A3\uC0A5\uC0AC\uC0AD\uC0AF\uC0B0\uC0B3\uC0B4\uC0B5\uC0B6\uC0BC\uC0BD\uC0BF\uC0C0\uC0C1\uC0C5\uC0C8\uC0C9\uC0CC\uC0D0\uC0D8\uC0D9\uC0DB\uC0DC\uC0DD\uC0E4"],
      ["bc41", "\uD36A", 17, "\uD37E\uD37F\uD381\uD382\uD383\uD385\uD386\uD387"],
      ["bc61", "\uD388\uD389\uD38A\uD38B\uD38E\uD392", 5, "\uD39A\uD39B\uD39D\uD39E\uD39F\uD3A1", 6, "\uD3AA\uD3AC\uD3AE"],
      ["bc81", "\uD3AF", 4, "\uD3B5\uD3B6\uD3B7\uD3B9\uD3BA\uD3BB\uD3BD", 6, "\uD3C6\uD3C7\uD3CA", 5, "\uD3D1", 5, "\uC0E5\uC0E8\uC0EC\uC0F4\uC0F5\uC0F7\uC0F9\uC100\uC104\uC108\uC110\uC115\uC11C", 4, "\uC123\uC124\uC126\uC127\uC12C\uC12D\uC12F\uC130\uC131\uC136\uC138\uC139\uC13C\uC140\uC148\uC149\uC14B\uC14C\uC14D\uC154\uC155\uC158\uC15C\uC164\uC165\uC167\uC168\uC169\uC170\uC174\uC178\uC185\uC18C\uC18D\uC18E\uC190\uC194\uC196\uC19C\uC19D\uC19F\uC1A1\uC1A5\uC1A8\uC1A9\uC1AC\uC1B0\uC1BD\uC1C4\uC1C8\uC1CC\uC1D4\uC1D7\uC1D8\uC1E0\uC1E4\uC1E8\uC1F0\uC1F1\uC1F3\uC1FC\uC1FD\uC200\uC204\uC20C\uC20D\uC20F\uC211\uC218\uC219\uC21C\uC21F\uC220\uC228\uC229\uC22B\uC22D"],
      ["bd41", "\uD3D7\uD3D9", 7, "\uD3E2\uD3E4", 7, "\uD3EE\uD3EF\uD3F1\uD3F2\uD3F3\uD3F5\uD3F6\uD3F7"],
      ["bd61", "\uD3F8\uD3F9\uD3FA\uD3FB\uD3FE\uD400\uD402", 5, "\uD409", 13],
      ["bd81", "\uD417", 5, "\uD41E", 25, "\uC22F\uC231\uC232\uC234\uC248\uC250\uC251\uC254\uC258\uC260\uC265\uC26C\uC26D\uC270\uC274\uC27C\uC27D\uC27F\uC281\uC288\uC289\uC290\uC298\uC29B\uC29D\uC2A4\uC2A5\uC2A8\uC2AC\uC2AD\uC2B4\uC2B5\uC2B7\uC2B9\uC2DC\uC2DD\uC2E0\uC2E3\uC2E4\uC2EB\uC2EC\uC2ED\uC2EF\uC2F1\uC2F6\uC2F8\uC2F9\uC2FB\uC2FC\uC300\uC308\uC309\uC30C\uC30D\uC313\uC314\uC315\uC318\uC31C\uC324\uC325\uC328\uC329\uC345\uC368\uC369\uC36C\uC370\uC372\uC378\uC379\uC37C\uC37D\uC384\uC388\uC38C\uC3C0\uC3D8\uC3D9\uC3DC\uC3DF\uC3E0\uC3E2\uC3E8\uC3E9\uC3ED\uC3F4\uC3F5\uC3F8\uC408\uC410\uC424\uC42C\uC430"],
      ["be41", "\uD438", 7, "\uD441\uD442\uD443\uD445", 14],
      ["be61", "\uD454", 7, "\uD45D\uD45E\uD45F\uD461\uD462\uD463\uD465", 7, "\uD46E\uD470\uD471\uD472"],
      ["be81", "\uD473", 4, "\uD47A\uD47B\uD47D\uD47E\uD481\uD483", 4, "\uD48A\uD48C\uD48E", 5, "\uD495", 8, "\uC434\uC43C\uC43D\uC448\uC464\uC465\uC468\uC46C\uC474\uC475\uC479\uC480\uC494\uC49C\uC4B8\uC4BC\uC4E9\uC4F0\uC4F1\uC4F4\uC4F8\uC4FA\uC4FF\uC500\uC501\uC50C\uC510\uC514\uC51C\uC528\uC529\uC52C\uC530\uC538\uC539\uC53B\uC53D\uC544\uC545\uC548\uC549\uC54A\uC54C\uC54D\uC54E\uC553\uC554\uC555\uC557\uC558\uC559\uC55D\uC55E\uC560\uC561\uC564\uC568\uC570\uC571\uC573\uC574\uC575\uC57C\uC57D\uC580\uC584\uC587\uC58C\uC58D\uC58F\uC591\uC595\uC597\uC598\uC59C\uC5A0\uC5A9\uC5B4\uC5B5\uC5B8\uC5B9\uC5BB\uC5BC\uC5BD\uC5BE\uC5C4", 6, "\uC5CC\uC5CE"],
      ["bf41", "\uD49E", 10, "\uD4AA", 14],
      ["bf61", "\uD4B9", 18, "\uD4CD\uD4CE\uD4CF\uD4D1\uD4D2\uD4D3\uD4D5"],
      ["bf81", "\uD4D6", 5, "\uD4DD\uD4DE\uD4E0", 7, "\uD4E9\uD4EA\uD4EB\uD4ED\uD4EE\uD4EF\uD4F1", 6, "\uD4F9\uD4FA\uD4FC\uC5D0\uC5D1\uC5D4\uC5D8\uC5E0\uC5E1\uC5E3\uC5E5\uC5EC\uC5ED\uC5EE\uC5F0\uC5F4\uC5F6\uC5F7\uC5FC", 5, "\uC605\uC606\uC607\uC608\uC60C\uC610\uC618\uC619\uC61B\uC61C\uC624\uC625\uC628\uC62C\uC62D\uC62E\uC630\uC633\uC634\uC635\uC637\uC639\uC63B\uC640\uC641\uC644\uC648\uC650\uC651\uC653\uC654\uC655\uC65C\uC65D\uC660\uC66C\uC66F\uC671\uC678\uC679\uC67C\uC680\uC688\uC689\uC68B\uC68D\uC694\uC695\uC698\uC69C\uC6A4\uC6A5\uC6A7\uC6A9\uC6B0\uC6B1\uC6B4\uC6B8\uC6B9\uC6BA\uC6C0\uC6C1\uC6C3\uC6C5\uC6CC\uC6CD\uC6D0\uC6D4\uC6DC\uC6DD\uC6E0\uC6E1\uC6E8"],
      ["c041", "\uD4FE", 5, "\uD505\uD506\uD507\uD509\uD50A\uD50B\uD50D", 6, "\uD516\uD518", 5],
      ["c061", "\uD51E", 25],
      ["c081", "\uD538\uD539\uD53A\uD53B\uD53E\uD53F\uD541\uD542\uD543\uD545", 6, "\uD54E\uD550\uD552", 5, "\uD55A\uD55B\uD55D\uD55E\uD55F\uD561\uD562\uD563\uC6E9\uC6EC\uC6F0\uC6F8\uC6F9\uC6FD\uC704\uC705\uC708\uC70C\uC714\uC715\uC717\uC719\uC720\uC721\uC724\uC728\uC730\uC731\uC733\uC735\uC737\uC73C\uC73D\uC740\uC744\uC74A\uC74C\uC74D\uC74F\uC751", 7, "\uC75C\uC760\uC768\uC76B\uC774\uC775\uC778\uC77C\uC77D\uC77E\uC783\uC784\uC785\uC787\uC788\uC789\uC78A\uC78E\uC790\uC791\uC794\uC796\uC797\uC798\uC79A\uC7A0\uC7A1\uC7A3\uC7A4\uC7A5\uC7A6\uC7AC\uC7AD\uC7B0\uC7B4\uC7BC\uC7BD\uC7BF\uC7C0\uC7C1\uC7C8\uC7C9\uC7CC\uC7CE\uC7D0\uC7D8\uC7DD\uC7E4\uC7E8\uC7EC\uC800\uC801\uC804\uC808\uC80A"],
      ["c141", "\uD564\uD566\uD567\uD56A\uD56C\uD56E", 5, "\uD576\uD577\uD579\uD57A\uD57B\uD57D", 6, "\uD586\uD58A\uD58B"],
      ["c161", "\uD58C\uD58D\uD58E\uD58F\uD591", 19, "\uD5A6\uD5A7"],
      ["c181", "\uD5A8", 31, "\uC810\uC811\uC813\uC815\uC816\uC81C\uC81D\uC820\uC824\uC82C\uC82D\uC82F\uC831\uC838\uC83C\uC840\uC848\uC849\uC84C\uC84D\uC854\uC870\uC871\uC874\uC878\uC87A\uC880\uC881\uC883\uC885\uC886\uC887\uC88B\uC88C\uC88D\uC894\uC89D\uC89F\uC8A1\uC8A8\uC8BC\uC8BD\uC8C4\uC8C8\uC8CC\uC8D4\uC8D5\uC8D7\uC8D9\uC8E0\uC8E1\uC8E4\uC8F5\uC8FC\uC8FD\uC900\uC904\uC905\uC906\uC90C\uC90D\uC90F\uC911\uC918\uC92C\uC934\uC950\uC951\uC954\uC958\uC960\uC961\uC963\uC96C\uC970\uC974\uC97C\uC988\uC989\uC98C\uC990\uC998\uC999\uC99B\uC99D\uC9C0\uC9C1\uC9C4\uC9C7\uC9C8\uC9CA\uC9D0\uC9D1\uC9D3"],
      ["c241", "\uD5CA\uD5CB\uD5CD\uD5CE\uD5CF\uD5D1\uD5D3", 4, "\uD5DA\uD5DC\uD5DE", 5, "\uD5E6\uD5E7\uD5E9\uD5EA\uD5EB\uD5ED\uD5EE"],
      ["c261", "\uD5EF", 4, "\uD5F6\uD5F8\uD5FA", 5, "\uD602\uD603\uD605\uD606\uD607\uD609", 6, "\uD612"],
      ["c281", "\uD616", 5, "\uD61D\uD61E\uD61F\uD621\uD622\uD623\uD625", 7, "\uD62E", 9, "\uD63A\uD63B\uC9D5\uC9D6\uC9D9\uC9DA\uC9DC\uC9DD\uC9E0\uC9E2\uC9E4\uC9E7\uC9EC\uC9ED\uC9EF\uC9F0\uC9F1\uC9F8\uC9F9\uC9FC\uCA00\uCA08\uCA09\uCA0B\uCA0C\uCA0D\uCA14\uCA18\uCA29\uCA4C\uCA4D\uCA50\uCA54\uCA5C\uCA5D\uCA5F\uCA60\uCA61\uCA68\uCA7D\uCA84\uCA98\uCABC\uCABD\uCAC0\uCAC4\uCACC\uCACD\uCACF\uCAD1\uCAD3\uCAD8\uCAD9\uCAE0\uCAEC\uCAF4\uCB08\uCB10\uCB14\uCB18\uCB20\uCB21\uCB41\uCB48\uCB49\uCB4C\uCB50\uCB58\uCB59\uCB5D\uCB64\uCB78\uCB79\uCB9C\uCBB8\uCBD4\uCBE4\uCBE7\uCBE9\uCC0C\uCC0D\uCC10\uCC14\uCC1C\uCC1D\uCC21\uCC22\uCC27\uCC28\uCC29\uCC2C\uCC2E\uCC30\uCC38\uCC39\uCC3B"],
      ["c341", "\uD63D\uD63E\uD63F\uD641\uD642\uD643\uD644\uD646\uD647\uD64A\uD64C\uD64E\uD64F\uD650\uD652\uD653\uD656\uD657\uD659\uD65A\uD65B\uD65D", 4],
      ["c361", "\uD662", 4, "\uD668\uD66A", 5, "\uD672\uD673\uD675", 11],
      ["c381", "\uD681\uD682\uD684\uD686", 5, "\uD68E\uD68F\uD691\uD692\uD693\uD695", 7, "\uD69E\uD6A0\uD6A2", 5, "\uD6A9\uD6AA\uCC3C\uCC3D\uCC3E\uCC44\uCC45\uCC48\uCC4C\uCC54\uCC55\uCC57\uCC58\uCC59\uCC60\uCC64\uCC66\uCC68\uCC70\uCC75\uCC98\uCC99\uCC9C\uCCA0\uCCA8\uCCA9\uCCAB\uCCAC\uCCAD\uCCB4\uCCB5\uCCB8\uCCBC\uCCC4\uCCC5\uCCC7\uCCC9\uCCD0\uCCD4\uCCE4\uCCEC\uCCF0\uCD01\uCD08\uCD09\uCD0C\uCD10\uCD18\uCD19\uCD1B\uCD1D\uCD24\uCD28\uCD2C\uCD39\uCD5C\uCD60\uCD64\uCD6C\uCD6D\uCD6F\uCD71\uCD78\uCD88\uCD94\uCD95\uCD98\uCD9C\uCDA4\uCDA5\uCDA7\uCDA9\uCDB0\uCDC4\uCDCC\uCDD0\uCDE8\uCDEC\uCDF0\uCDF8\uCDF9\uCDFB\uCDFD\uCE04\uCE08\uCE0C\uCE14\uCE19\uCE20\uCE21\uCE24\uCE28\uCE30\uCE31\uCE33\uCE35"],
      ["c441", "\uD6AB\uD6AD\uD6AE\uD6AF\uD6B1", 7, "\uD6BA\uD6BC", 7, "\uD6C6\uD6C7\uD6C9\uD6CA\uD6CB"],
      ["c461", "\uD6CD\uD6CE\uD6CF\uD6D0\uD6D2\uD6D3\uD6D5\uD6D6\uD6D8\uD6DA", 5, "\uD6E1\uD6E2\uD6E3\uD6E5\uD6E6\uD6E7\uD6E9", 4],
      ["c481", "\uD6EE\uD6EF\uD6F1\uD6F2\uD6F3\uD6F4\uD6F6", 5, "\uD6FE\uD6FF\uD701\uD702\uD703\uD705", 11, "\uD712\uD713\uD714\uCE58\uCE59\uCE5C\uCE5F\uCE60\uCE61\uCE68\uCE69\uCE6B\uCE6D\uCE74\uCE75\uCE78\uCE7C\uCE84\uCE85\uCE87\uCE89\uCE90\uCE91\uCE94\uCE98\uCEA0\uCEA1\uCEA3\uCEA4\uCEA5\uCEAC\uCEAD\uCEC1\uCEE4\uCEE5\uCEE8\uCEEB\uCEEC\uCEF4\uCEF5\uCEF7\uCEF8\uCEF9\uCF00\uCF01\uCF04\uCF08\uCF10\uCF11\uCF13\uCF15\uCF1C\uCF20\uCF24\uCF2C\uCF2D\uCF2F\uCF30\uCF31\uCF38\uCF54\uCF55\uCF58\uCF5C\uCF64\uCF65\uCF67\uCF69\uCF70\uCF71\uCF74\uCF78\uCF80\uCF85\uCF8C\uCFA1\uCFA8\uCFB0\uCFC4\uCFE0\uCFE1\uCFE4\uCFE8\uCFF0\uCFF1\uCFF3\uCFF5\uCFFC\uD000\uD004\uD011\uD018\uD02D\uD034\uD035\uD038\uD03C"],
      ["c541", "\uD715\uD716\uD717\uD71A\uD71B\uD71D\uD71E\uD71F\uD721", 6, "\uD72A\uD72C\uD72E", 5, "\uD736\uD737\uD739"],
      ["c561", "\uD73A\uD73B\uD73D", 6, "\uD745\uD746\uD748\uD74A", 5, "\uD752\uD753\uD755\uD75A", 4],
      ["c581", "\uD75F\uD762\uD764\uD766\uD767\uD768\uD76A\uD76B\uD76D\uD76E\uD76F\uD771\uD772\uD773\uD775", 6, "\uD77E\uD77F\uD780\uD782", 5, "\uD78A\uD78B\uD044\uD045\uD047\uD049\uD050\uD054\uD058\uD060\uD06C\uD06D\uD070\uD074\uD07C\uD07D\uD081\uD0A4\uD0A5\uD0A8\uD0AC\uD0B4\uD0B5\uD0B7\uD0B9\uD0C0\uD0C1\uD0C4\uD0C8\uD0C9\uD0D0\uD0D1\uD0D3\uD0D4\uD0D5\uD0DC\uD0DD\uD0E0\uD0E4\uD0EC\uD0ED\uD0EF\uD0F0\uD0F1\uD0F8\uD10D\uD130\uD131\uD134\uD138\uD13A\uD140\uD141\uD143\uD144\uD145\uD14C\uD14D\uD150\uD154\uD15C\uD15D\uD15F\uD161\uD168\uD16C\uD17C\uD184\uD188\uD1A0\uD1A1\uD1A4\uD1A8\uD1B0\uD1B1\uD1B3\uD1B5\uD1BA\uD1BC\uD1C0\uD1D8\uD1F4\uD1F8\uD207\uD209\uD210\uD22C\uD22D\uD230\uD234\uD23C\uD23D\uD23F\uD241\uD248\uD25C"],
      ["c641", "\uD78D\uD78E\uD78F\uD791", 6, "\uD79A\uD79C\uD79E", 5],
      ["c6a1", "\uD264\uD280\uD281\uD284\uD288\uD290\uD291\uD295\uD29C\uD2A0\uD2A4\uD2AC\uD2B1\uD2B8\uD2B9\uD2BC\uD2BF\uD2C0\uD2C2\uD2C8\uD2C9\uD2CB\uD2D4\uD2D8\uD2DC\uD2E4\uD2E5\uD2F0\uD2F1\uD2F4\uD2F8\uD300\uD301\uD303\uD305\uD30C\uD30D\uD30E\uD310\uD314\uD316\uD31C\uD31D\uD31F\uD320\uD321\uD325\uD328\uD329\uD32C\uD330\uD338\uD339\uD33B\uD33C\uD33D\uD344\uD345\uD37C\uD37D\uD380\uD384\uD38C\uD38D\uD38F\uD390\uD391\uD398\uD399\uD39C\uD3A0\uD3A8\uD3A9\uD3AB\uD3AD\uD3B4\uD3B8\uD3BC\uD3C4\uD3C5\uD3C8\uD3C9\uD3D0\uD3D8\uD3E1\uD3E3\uD3EC\uD3ED\uD3F0\uD3F4\uD3FC\uD3FD\uD3FF\uD401"],
      ["c7a1", "\uD408\uD41D\uD440\uD444\uD45C\uD460\uD464\uD46D\uD46F\uD478\uD479\uD47C\uD47F\uD480\uD482\uD488\uD489\uD48B\uD48D\uD494\uD4A9\uD4CC\uD4D0\uD4D4\uD4DC\uD4DF\uD4E8\uD4EC\uD4F0\uD4F8\uD4FB\uD4FD\uD504\uD508\uD50C\uD514\uD515\uD517\uD53C\uD53D\uD540\uD544\uD54C\uD54D\uD54F\uD551\uD558\uD559\uD55C\uD560\uD565\uD568\uD569\uD56B\uD56D\uD574\uD575\uD578\uD57C\uD584\uD585\uD587\uD588\uD589\uD590\uD5A5\uD5C8\uD5C9\uD5CC\uD5D0\uD5D2\uD5D8\uD5D9\uD5DB\uD5DD\uD5E4\uD5E5\uD5E8\uD5EC\uD5F4\uD5F5\uD5F7\uD5F9\uD600\uD601\uD604\uD608\uD610\uD611\uD613\uD614\uD615\uD61C\uD620"],
      ["c8a1", "\uD624\uD62D\uD638\uD639\uD63C\uD640\uD645\uD648\uD649\uD64B\uD64D\uD651\uD654\uD655\uD658\uD65C\uD667\uD669\uD670\uD671\uD674\uD683\uD685\uD68C\uD68D\uD690\uD694\uD69D\uD69F\uD6A1\uD6A8\uD6AC\uD6B0\uD6B9\uD6BB\uD6C4\uD6C5\uD6C8\uD6CC\uD6D1\uD6D4\uD6D7\uD6D9\uD6E0\uD6E4\uD6E8\uD6F0\uD6F5\uD6FC\uD6FD\uD700\uD704\uD711\uD718\uD719\uD71C\uD720\uD728\uD729\uD72B\uD72D\uD734\uD735\uD738\uD73C\uD744\uD747\uD749\uD750\uD751\uD754\uD756\uD757\uD758\uD759\uD760\uD761\uD763\uD765\uD769\uD76C\uD770\uD774\uD77C\uD77D\uD781\uD788\uD789\uD78C\uD790\uD798\uD799\uD79B\uD79D"],
      ["caa1", "\u4F3D\u4F73\u5047\u50F9\u52A0\u53EF\u5475\u54E5\u5609\u5AC1\u5BB6\u6687\u67B6\u67B7\u67EF\u6B4C\u73C2\u75C2\u7A3C\u82DB\u8304\u8857\u8888\u8A36\u8CC8\u8DCF\u8EFB\u8FE6\u99D5\u523B\u5374\u5404\u606A\u6164\u6BBC\u73CF\u811A\u89BA\u89D2\u95A3\u4F83\u520A\u58BE\u5978\u59E6\u5E72\u5E79\u61C7\u63C0\u6746\u67EC\u687F\u6F97\u764E\u770B\u78F5\u7A08\u7AFF\u7C21\u809D\u826E\u8271\u8AEB\u9593\u4E6B\u559D\u66F7\u6E34\u78A3\u7AED\u845B\u8910\u874E\u97A8\u52D8\u574E\u582A\u5D4C\u611F\u61BE\u6221\u6562\u67D1\u6A44\u6E1B\u7518\u75B3\u76E3\u77B0\u7D3A\u90AF\u9451\u9452\u9F95"],
      ["cba1", "\u5323\u5CAC\u7532\u80DB\u9240\u9598\u525B\u5808\u59DC\u5CA1\u5D17\u5EB7\u5F3A\u5F4A\u6177\u6C5F\u757A\u7586\u7CE0\u7D73\u7DB1\u7F8C\u8154\u8221\u8591\u8941\u8B1B\u92FC\u964D\u9C47\u4ECB\u4EF7\u500B\u51F1\u584F\u6137\u613E\u6168\u6539\u69EA\u6F11\u75A5\u7686\u76D6\u7B87\u82A5\u84CB\uF900\u93A7\u958B\u5580\u5BA2\u5751\uF901\u7CB3\u7FB9\u91B5\u5028\u53BB\u5C45\u5DE8\u62D2\u636E\u64DA\u64E7\u6E20\u70AC\u795B\u8DDD\u8E1E\uF902\u907D\u9245\u92F8\u4E7E\u4EF6\u5065\u5DFE\u5EFA\u6106\u6957\u8171\u8654\u8E47\u9375\u9A2B\u4E5E\u5091\u6770\u6840\u5109\u528D\u5292\u6AA2"],
      ["cca1", "\u77BC\u9210\u9ED4\u52AB\u602F\u8FF2\u5048\u61A9\u63ED\u64CA\u683C\u6A84\u6FC0\u8188\u89A1\u9694\u5805\u727D\u72AC\u7504\u7D79\u7E6D\u80A9\u898B\u8B74\u9063\u9D51\u6289\u6C7A\u6F54\u7D50\u7F3A\u8A23\u517C\u614A\u7B9D\u8B19\u9257\u938C\u4EAC\u4FD3\u501E\u50BE\u5106\u52C1\u52CD\u537F\u5770\u5883\u5E9A\u5F91\u6176\u61AC\u64CE\u656C\u666F\u66BB\u66F4\u6897\u6D87\u7085\u70F1\u749F\u74A5\u74CA\u75D9\u786C\u78EC\u7ADF\u7AF6\u7D45\u7D93\u8015\u803F\u811B\u8396\u8B66\u8F15\u9015\u93E1\u9803\u9838\u9A5A\u9BE8\u4FC2\u5553\u583A\u5951\u5B63\u5C46\u60B8\u6212\u6842\u68B0"],
      ["cda1", "\u68E8\u6EAA\u754C\u7678\u78CE\u7A3D\u7CFB\u7E6B\u7E7C\u8A08\u8AA1\u8C3F\u968E\u9DC4\u53E4\u53E9\u544A\u5471\u56FA\u59D1\u5B64\u5C3B\u5EAB\u62F7\u6537\u6545\u6572\u66A0\u67AF\u69C1\u6CBD\u75FC\u7690\u777E\u7A3F\u7F94\u8003\u80A1\u818F\u82E6\u82FD\u83F0\u85C1\u8831\u88B4\u8AA5\uF903\u8F9C\u932E\u96C7\u9867\u9AD8\u9F13\u54ED\u659B\u66F2\u688F\u7A40\u8C37\u9D60\u56F0\u5764\u5D11\u6606\u68B1\u68CD\u6EFE\u7428\u889E\u9BE4\u6C68\uF904\u9AA8\u4F9B\u516C\u5171\u529F\u5B54\u5DE5\u6050\u606D\u62F1\u63A7\u653B\u73D9\u7A7A\u86A3\u8CA2\u978F\u4E32\u5BE1\u6208\u679C\u74DC"],
      ["cea1", "\u79D1\u83D3\u8A87\u8AB2\u8DE8\u904E\u934B\u9846\u5ED3\u69E8\u85FF\u90ED\uF905\u51A0\u5B98\u5BEC\u6163\u68FA\u6B3E\u704C\u742F\u74D8\u7BA1\u7F50\u83C5\u89C0\u8CAB\u95DC\u9928\u522E\u605D\u62EC\u9002\u4F8A\u5149\u5321\u58D9\u5EE3\u66E0\u6D38\u709A\u72C2\u73D6\u7B50\u80F1\u945B\u5366\u639B\u7F6B\u4E56\u5080\u584A\u58DE\u602A\u6127\u62D0\u69D0\u9B41\u5B8F\u7D18\u80B1\u8F5F\u4EA4\u50D1\u54AC\u55AC\u5B0C\u5DA0\u5DE7\u652A\u654E\u6821\u6A4B\u72E1\u768E\u77EF\u7D5E\u7FF9\u81A0\u854E\u86DF\u8F03\u8F4E\u90CA\u9903\u9A55\u9BAB\u4E18\u4E45\u4E5D\u4EC7\u4FF1\u5177\u52FE"],
      ["cfa1", "\u5340\u53E3\u53E5\u548E\u5614\u5775\u57A2\u5BC7\u5D87\u5ED0\u61FC\u62D8\u6551\u67B8\u67E9\u69CB\u6B50\u6BC6\u6BEC\u6C42\u6E9D\u7078\u72D7\u7396\u7403\u77BF\u77E9\u7A76\u7D7F\u8009\u81FC\u8205\u820A\u82DF\u8862\u8B33\u8CFC\u8EC0\u9011\u90B1\u9264\u92B6\u99D2\u9A45\u9CE9\u9DD7\u9F9C\u570B\u5C40\u83CA\u97A0\u97AB\u9EB4\u541B\u7A98\u7FA4\u88D9\u8ECD\u90E1\u5800\u5C48\u6398\u7A9F\u5BAE\u5F13\u7A79\u7AAE\u828E\u8EAC\u5026\u5238\u52F8\u5377\u5708\u62F3\u6372\u6B0A\u6DC3\u7737\u53A5\u7357\u8568\u8E76\u95D5\u673A\u6AC3\u6F70\u8A6D\u8ECC\u994B\uF906\u6677\u6B78\u8CB4"],
      ["d0a1", "\u9B3C\uF907\u53EB\u572D\u594E\u63C6\u69FB\u73EA\u7845\u7ABA\u7AC5\u7CFE\u8475\u898F\u8D73\u9035\u95A8\u52FB\u5747\u7547\u7B60\u83CC\u921E\uF908\u6A58\u514B\u524B\u5287\u621F\u68D8\u6975\u9699\u50C5\u52A4\u52E4\u61C3\u65A4\u6839\u69FF\u747E\u7B4B\u82B9\u83EB\u89B2\u8B39\u8FD1\u9949\uF909\u4ECA\u5997\u64D2\u6611\u6A8E\u7434\u7981\u79BD\u82A9\u887E\u887F\u895F\uF90A\u9326\u4F0B\u53CA\u6025\u6271\u6C72\u7D1A\u7D66\u4E98\u5162\u77DC\u80AF\u4F01\u4F0E\u5176\u5180\u55DC\u5668\u573B\u57FA\u57FC\u5914\u5947\u5993\u5BC4\u5C90\u5D0E\u5DF1\u5E7E\u5FCC\u6280\u65D7\u65E3"],
      ["d1a1", "\u671E\u671F\u675E\u68CB\u68C4\u6A5F\u6B3A\u6C23\u6C7D\u6C82\u6DC7\u7398\u7426\u742A\u7482\u74A3\u7578\u757F\u7881\u78EF\u7941\u7947\u7948\u797A\u7B95\u7D00\u7DBA\u7F88\u8006\u802D\u808C\u8A18\u8B4F\u8C48\u8D77\u9321\u9324\u98E2\u9951\u9A0E\u9A0F\u9A65\u9E92\u7DCA\u4F76\u5409\u62EE\u6854\u91D1\u55AB\u513A\uF90B\uF90C\u5A1C\u61E6\uF90D\u62CF\u62FF\uF90E", 5, "\u90A3\uF914", 4, "\u8AFE\uF919\uF91A\uF91B\uF91C\u6696\uF91D\u7156\uF91E\uF91F\u96E3\uF920\u634F\u637A\u5357\uF921\u678F\u6960\u6E73\uF922\u7537\uF923\uF924\uF925"],
      ["d2a1", "\u7D0D\uF926\uF927\u8872\u56CA\u5A18\uF928", 4, "\u4E43\uF92D\u5167\u5948\u67F0\u8010\uF92E\u5973\u5E74\u649A\u79CA\u5FF5\u606C\u62C8\u637B\u5BE7\u5BD7\u52AA\uF92F\u5974\u5F29\u6012\uF930\uF931\uF932\u7459\uF933", 5, "\u99D1\uF939", 10, "\u6FC3\uF944\uF945\u81BF\u8FB2\u60F1\uF946\uF947\u8166\uF948\uF949\u5C3F\uF94A", 7, "\u5AE9\u8A25\u677B\u7D10\uF952", 5, "\u80FD\uF958\uF959\u5C3C\u6CE5\u533F\u6EBA\u591A\u8336"],
      ["d3a1", "\u4E39\u4EB6\u4F46\u55AE\u5718\u58C7\u5F56\u65B7\u65E6\u6A80\u6BB5\u6E4D\u77ED\u7AEF\u7C1E\u7DDE\u86CB\u8892\u9132\u935B\u64BB\u6FBE\u737A\u75B8\u9054\u5556\u574D\u61BA\u64D4\u66C7\u6DE1\u6E5B\u6F6D\u6FB9\u75F0\u8043\u81BD\u8541\u8983\u8AC7\u8B5A\u931F\u6C93\u7553\u7B54\u8E0F\u905D\u5510\u5802\u5858\u5E62\u6207\u649E\u68E0\u7576\u7CD6\u87B3\u9EE8\u4EE3\u5788\u576E\u5927\u5C0D\u5CB1\u5E36\u5F85\u6234\u64E1\u73B3\u81FA\u888B\u8CB8\u968A\u9EDB\u5B85\u5FB7\u60B3\u5012\u5200\u5230\u5716\u5835\u5857\u5C0E\u5C60\u5CF6\u5D8B\u5EA6\u5F92\u60BC\u6311\u6389\u6417\u6843"],
      ["d4a1", "\u68F9\u6AC2\u6DD8\u6E21\u6ED4\u6FE4\u71FE\u76DC\u7779\u79B1\u7A3B\u8404\u89A9\u8CED\u8DF3\u8E48\u9003\u9014\u9053\u90FD\u934D\u9676\u97DC\u6BD2\u7006\u7258\u72A2\u7368\u7763\u79BF\u7BE4\u7E9B\u8B80\u58A9\u60C7\u6566\u65FD\u66BE\u6C8C\u711E\u71C9\u8C5A\u9813\u4E6D\u7A81\u4EDD\u51AC\u51CD\u52D5\u540C\u61A7\u6771\u6850\u68DF\u6D1E\u6F7C\u75BC\u77B3\u7AE5\u80F4\u8463\u9285\u515C\u6597\u675C\u6793\u75D8\u7AC7\u8373\uF95A\u8C46\u9017\u982D\u5C6F\u81C0\u829A\u9041\u906F\u920D\u5F97\u5D9D\u6A59\u71C8\u767B\u7B49\u85E4\u8B04\u9127\u9A30\u5587\u61F6\uF95B\u7669\u7F85"],
      ["d5a1", "\u863F\u87BA\u88F8\u908F\uF95C\u6D1B\u70D9\u73DE\u7D61\u843D\uF95D\u916A\u99F1\uF95E\u4E82\u5375\u6B04\u6B12\u703E\u721B\u862D\u9E1E\u524C\u8FA3\u5D50\u64E5\u652C\u6B16\u6FEB\u7C43\u7E9C\u85CD\u8964\u89BD\u62C9\u81D8\u881F\u5ECA\u6717\u6D6A\u72FC\u7405\u746F\u8782\u90DE\u4F86\u5D0D\u5FA0\u840A\u51B7\u63A0\u7565\u4EAE\u5006\u5169\u51C9\u6881\u6A11\u7CAE\u7CB1\u7CE7\u826F\u8AD2\u8F1B\u91CF\u4FB6\u5137\u52F5\u5442\u5EEC\u616E\u623E\u65C5\u6ADA\u6FFE\u792A\u85DC\u8823\u95AD\u9A62\u9A6A\u9E97\u9ECE\u529B\u66C6\u6B77\u701D\u792B\u8F62\u9742\u6190\u6200\u6523\u6F23"],
      ["d6a1", "\u7149\u7489\u7DF4\u806F\u84EE\u8F26\u9023\u934A\u51BD\u5217\u52A3\u6D0C\u70C8\u88C2\u5EC9\u6582\u6BAE\u6FC2\u7C3E\u7375\u4EE4\u4F36\u56F9\uF95F\u5CBA\u5DBA\u601C\u73B2\u7B2D\u7F9A\u7FCE\u8046\u901E\u9234\u96F6\u9748\u9818\u9F61\u4F8B\u6FA7\u79AE\u91B4\u96B7\u52DE\uF960\u6488\u64C4\u6AD3\u6F5E\u7018\u7210\u76E7\u8001\u8606\u865C\u8DEF\u8F05\u9732\u9B6F\u9DFA\u9E75\u788C\u797F\u7DA0\u83C9\u9304\u9E7F\u9E93\u8AD6\u58DF\u5F04\u6727\u7027\u74CF\u7C60\u807E\u5121\u7028\u7262\u78CA\u8CC2\u8CDA\u8CF4\u96F7\u4E86\u50DA\u5BEE\u5ED6\u6599\u71CE\u7642\u77AD\u804A\u84FC"],
      ["d7a1", "\u907C\u9B27\u9F8D\u58D8\u5A41\u5C62\u6A13\u6DDA\u6F0F\u763B\u7D2F\u7E37\u851E\u8938\u93E4\u964B\u5289\u65D2\u67F3\u69B4\u6D41\u6E9C\u700F\u7409\u7460\u7559\u7624\u786B\u8B2C\u985E\u516D\u622E\u9678\u4F96\u502B\u5D19\u6DEA\u7DB8\u8F2A\u5F8B\u6144\u6817\uF961\u9686\u52D2\u808B\u51DC\u51CC\u695E\u7A1C\u7DBE\u83F1\u9675\u4FDA\u5229\u5398\u540F\u550E\u5C65\u60A7\u674E\u68A8\u6D6C\u7281\u72F8\u7406\u7483\uF962\u75E2\u7C6C\u7F79\u7FB8\u8389\u88CF\u88E1\u91CC\u91D0\u96E2\u9BC9\u541D\u6F7E\u71D0\u7498\u85FA\u8EAA\u96A3\u9C57\u9E9F\u6797\u6DCB\u7433\u81E8\u9716\u782C"],
      ["d8a1", "\u7ACB\u7B20\u7C92\u6469\u746A\u75F2\u78BC\u78E8\u99AC\u9B54\u9EBB\u5BDE\u5E55\u6F20\u819C\u83AB\u9088\u4E07\u534D\u5A29\u5DD2\u5F4E\u6162\u633D\u6669\u66FC\u6EFF\u6F2B\u7063\u779E\u842C\u8513\u883B\u8F13\u9945\u9C3B\u551C\u62B9\u672B\u6CAB\u8309\u896A\u977A\u4EA1\u5984\u5FD8\u5FD9\u671B\u7DB2\u7F54\u8292\u832B\u83BD\u8F1E\u9099\u57CB\u59B9\u5A92\u5BD0\u6627\u679A\u6885\u6BCF\u7164\u7F75\u8CB7\u8CE3\u9081\u9B45\u8108\u8C8A\u964C\u9A40\u9EA5\u5B5F\u6C13\u731B\u76F2\u76DF\u840C\u51AA\u8993\u514D\u5195\u52C9\u68C9\u6C94\u7704\u7720\u7DBF\u7DEC\u9762\u9EB5\u6EC5"],
      ["d9a1", "\u8511\u51A5\u540D\u547D\u660E\u669D\u6927\u6E9F\u76BF\u7791\u8317\u84C2\u879F\u9169\u9298\u9CF4\u8882\u4FAE\u5192\u52DF\u59C6\u5E3D\u6155\u6478\u6479\u66AE\u67D0\u6A21\u6BCD\u6BDB\u725F\u7261\u7441\u7738\u77DB\u8017\u82BC\u8305\u8B00\u8B28\u8C8C\u6728\u6C90\u7267\u76EE\u7766\u7A46\u9DA9\u6B7F\u6C92\u5922\u6726\u8499\u536F\u5893\u5999\u5EDF\u63CF\u6634\u6773\u6E3A\u732B\u7AD7\u82D7\u9328\u52D9\u5DEB\u61AE\u61CB\u620A\u62C7\u64AB\u65E0\u6959\u6B66\u6BCB\u7121\u73F7\u755D\u7E46\u821E\u8302\u856A\u8AA3\u8CBF\u9727\u9D61\u58A8\u9ED8\u5011\u520E\u543B\u554F\u6587"],
      ["daa1", "\u6C76\u7D0A\u7D0B\u805E\u868A\u9580\u96EF\u52FF\u6C95\u7269\u5473\u5A9A\u5C3E\u5D4B\u5F4C\u5FAE\u672A\u68B6\u6963\u6E3C\u6E44\u7709\u7C73\u7F8E\u8587\u8B0E\u8FF7\u9761\u9EF4\u5CB7\u60B6\u610D\u61AB\u654F\u65FB\u65FC\u6C11\u6CEF\u739F\u73C9\u7DE1\u9594\u5BC6\u871C\u8B10\u525D\u535A\u62CD\u640F\u64B2\u6734\u6A38\u6CCA\u73C0\u749E\u7B94\u7C95\u7E1B\u818A\u8236\u8584\u8FEB\u96F9\u99C1\u4F34\u534A\u53CD\u53DB\u62CC\u642C\u6500\u6591\u69C3\u6CEE\u6F58\u73ED\u7554\u7622\u76E4\u76FC\u78D0\u78FB\u792C\u7D46\u822C\u87E0\u8FD4\u9812\u98EF\u52C3\u62D4\u64A5\u6E24\u6F51"],
      ["dba1", "\u767C\u8DCB\u91B1\u9262\u9AEE\u9B43\u5023\u508D\u574A\u59A8\u5C28\u5E47\u5F77\u623F\u653E\u65B9\u65C1\u6609\u678B\u699C\u6EC2\u78C5\u7D21\u80AA\u8180\u822B\u82B3\u84A1\u868C\u8A2A\u8B17\u90A6\u9632\u9F90\u500D\u4FF3\uF963\u57F9\u5F98\u62DC\u6392\u676F\u6E43\u7119\u76C3\u80CC\u80DA\u88F4\u88F5\u8919\u8CE0\u8F29\u914D\u966A\u4F2F\u4F70\u5E1B\u67CF\u6822\u767D\u767E\u9B44\u5E61\u6A0A\u7169\u71D4\u756A\uF964\u7E41\u8543\u85E9\u98DC\u4F10\u7B4F\u7F70\u95A5\u51E1\u5E06\u68B5\u6C3E\u6C4E\u6CDB\u72AF\u7BC4\u8303\u6CD5\u743A\u50FB\u5288\u58C1\u64D8\u6A97\u74A7\u7656"],
      ["dca1", "\u78A7\u8617\u95E2\u9739\uF965\u535E\u5F01\u8B8A\u8FA8\u8FAF\u908A\u5225\u77A5\u9C49\u9F08\u4E19\u5002\u5175\u5C5B\u5E77\u661E\u663A\u67C4\u68C5\u70B3\u7501\u75C5\u79C9\u7ADD\u8F27\u9920\u9A08\u4FDD\u5821\u5831\u5BF6\u666E\u6B65\u6D11\u6E7A\u6F7D\u73E4\u752B\u83E9\u88DC\u8913\u8B5C\u8F14\u4F0F\u50D5\u5310\u535C\u5B93\u5FA9\u670D\u798F\u8179\u832F\u8514\u8907\u8986\u8F39\u8F3B\u99A5\u9C12\u672C\u4E76\u4FF8\u5949\u5C01\u5CEF\u5CF0\u6367\u68D2\u70FD\u71A2\u742B\u7E2B\u84EC\u8702\u9022\u92D2\u9CF3\u4E0D\u4ED8\u4FEF\u5085\u5256\u526F\u5426\u5490\u57E0\u592B\u5A66"],
      ["dda1", "\u5B5A\u5B75\u5BCC\u5E9C\uF966\u6276\u6577\u65A7\u6D6E\u6EA5\u7236\u7B26\u7C3F\u7F36\u8150\u8151\u819A\u8240\u8299\u83A9\u8A03\u8CA0\u8CE6\u8CFB\u8D74\u8DBA\u90E8\u91DC\u961C\u9644\u99D9\u9CE7\u5317\u5206\u5429\u5674\u58B3\u5954\u596E\u5FFF\u61A4\u626E\u6610\u6C7E\u711A\u76C6\u7C89\u7CDE\u7D1B\u82AC\u8CC1\u96F0\uF967\u4F5B\u5F17\u5F7F\u62C2\u5D29\u670B\u68DA\u787C\u7E43\u9D6C\u4E15\u5099\u5315\u532A\u5351\u5983\u5A62\u5E87\u60B2\u618A\u6249\u6279\u6590\u6787\u69A7\u6BD4\u6BD6\u6BD7\u6BD8\u6CB8\uF968\u7435\u75FA\u7812\u7891\u79D5\u79D8\u7C83\u7DCB\u7FE1\u80A5"],
      ["dea1", "\u813E\u81C2\u83F2\u871A\u88E8\u8AB9\u8B6C\u8CBB\u9119\u975E\u98DB\u9F3B\u56AC\u5B2A\u5F6C\u658C\u6AB3\u6BAF\u6D5C\u6FF1\u7015\u725D\u73AD\u8CA7\u8CD3\u983B\u6191\u6C37\u8058\u9A01\u4E4D\u4E8B\u4E9B\u4ED5\u4F3A\u4F3C\u4F7F\u4FDF\u50FF\u53F2\u53F8\u5506\u55E3\u56DB\u58EB\u5962\u5A11\u5BEB\u5BFA\u5C04\u5DF3\u5E2B\u5F99\u601D\u6368\u659C\u65AF\u67F6\u67FB\u68AD\u6B7B\u6C99\u6CD7\u6E23\u7009\u7345\u7802\u793E\u7940\u7960\u79C1\u7BE9\u7D17\u7D72\u8086\u820D\u838E\u84D1\u86C7\u88DF\u8A50\u8A5E\u8B1D\u8CDC\u8D66\u8FAD\u90AA\u98FC\u99DF\u9E9D\u524A\uF969\u6714\uF96A"],
      ["dfa1", "\u5098\u522A\u5C71\u6563\u6C55\u73CA\u7523\u759D\u7B97\u849C\u9178\u9730\u4E77\u6492\u6BBA\u715E\u85A9\u4E09\uF96B\u6749\u68EE\u6E17\u829F\u8518\u886B\u63F7\u6F81\u9212\u98AF\u4E0A\u50B7\u50CF\u511F\u5546\u55AA\u5617\u5B40\u5C19\u5CE0\u5E38\u5E8A\u5EA0\u5EC2\u60F3\u6851\u6A61\u6E58\u723D\u7240\u72C0\u76F8\u7965\u7BB1\u7FD4\u88F3\u89F4\u8A73\u8C61\u8CDE\u971C\u585E\u74BD\u8CFD\u55C7\uF96C\u7A61\u7D22\u8272\u7272\u751F\u7525\uF96D\u7B19\u5885\u58FB\u5DBC\u5E8F\u5EB6\u5F90\u6055\u6292\u637F\u654D\u6691\u66D9\u66F8\u6816\u68F2\u7280\u745E\u7B6E\u7D6E\u7DD6\u7F72"],
      ["e0a1", "\u80E5\u8212\u85AF\u897F\u8A93\u901D\u92E4\u9ECD\u9F20\u5915\u596D\u5E2D\u60DC\u6614\u6673\u6790\u6C50\u6DC5\u6F5F\u77F3\u78A9\u84C6\u91CB\u932B\u4ED9\u50CA\u5148\u5584\u5B0B\u5BA3\u6247\u657E\u65CB\u6E32\u717D\u7401\u7444\u7487\u74BF\u766C\u79AA\u7DDA\u7E55\u7FA8\u817A\u81B3\u8239\u861A\u87EC\u8A75\u8DE3\u9078\u9291\u9425\u994D\u9BAE\u5368\u5C51\u6954\u6CC4\u6D29\u6E2B\u820C\u859B\u893B\u8A2D\u8AAA\u96EA\u9F67\u5261\u66B9\u6BB2\u7E96\u87FE\u8D0D\u9583\u965D\u651D\u6D89\u71EE\uF96E\u57CE\u59D3\u5BAC\u6027\u60FA\u6210\u661F\u665F\u7329\u73F9\u76DB\u7701\u7B6C"],
      ["e1a1", "\u8056\u8072\u8165\u8AA0\u9192\u4E16\u52E2\u6B72\u6D17\u7A05\u7B39\u7D30\uF96F\u8CB0\u53EC\u562F\u5851\u5BB5\u5C0F\u5C11\u5DE2\u6240\u6383\u6414\u662D\u68B3\u6CBC\u6D88\u6EAF\u701F\u70A4\u71D2\u7526\u758F\u758E\u7619\u7B11\u7BE0\u7C2B\u7D20\u7D39\u852C\u856D\u8607\u8A34\u900D\u9061\u90B5\u92B7\u97F6\u9A37\u4FD7\u5C6C\u675F\u6D91\u7C9F\u7E8C\u8B16\u8D16\u901F\u5B6B\u5DFD\u640D\u84C0\u905C\u98E1\u7387\u5B8B\u609A\u677E\u6DDE\u8A1F\u8AA6\u9001\u980C\u5237\uF970\u7051\u788E\u9396\u8870\u91D7\u4FEE\u53D7\u55FD\u56DA\u5782\u58FD\u5AC2\u5B88\u5CAB\u5CC0\u5E25\u6101"],
      ["e2a1", "\u620D\u624B\u6388\u641C\u6536\u6578\u6A39\u6B8A\u6C34\u6D19\u6F31\u71E7\u72E9\u7378\u7407\u74B2\u7626\u7761\u79C0\u7A57\u7AEA\u7CB9\u7D8F\u7DAC\u7E61\u7F9E\u8129\u8331\u8490\u84DA\u85EA\u8896\u8AB0\u8B90\u8F38\u9042\u9083\u916C\u9296\u92B9\u968B\u96A7\u96A8\u96D6\u9700\u9808\u9996\u9AD3\u9B1A\u53D4\u587E\u5919\u5B70\u5BBF\u6DD1\u6F5A\u719F\u7421\u74B9\u8085\u83FD\u5DE1\u5F87\u5FAA\u6042\u65EC\u6812\u696F\u6A53\u6B89\u6D35\u6DF3\u73E3\u76FE\u77AC\u7B4D\u7D14\u8123\u821C\u8340\u84F4\u8563\u8A62\u8AC4\u9187\u931E\u9806\u99B4\u620C\u8853\u8FF0\u9265\u5D07\u5D27"],
      ["e3a1", "\u5D69\u745F\u819D\u8768\u6FD5\u62FE\u7FD2\u8936\u8972\u4E1E\u4E58\u50E7\u52DD\u5347\u627F\u6607\u7E69\u8805\u965E\u4F8D\u5319\u5636\u59CB\u5AA4\u5C38\u5C4E\u5C4D\u5E02\u5F11\u6043\u65BD\u662F\u6642\u67BE\u67F4\u731C\u77E2\u793A\u7FC5\u8494\u84CD\u8996\u8A66\u8A69\u8AE1\u8C55\u8C7A\u57F4\u5BD4\u5F0F\u606F\u62ED\u690D\u6B96\u6E5C\u7184\u7BD2\u8755\u8B58\u8EFE\u98DF\u98FE\u4F38\u4F81\u4FE1\u547B\u5A20\u5BB8\u613C\u65B0\u6668\u71FC\u7533\u795E\u7D33\u814E\u81E3\u8398\u85AA\u85CE\u8703\u8A0A\u8EAB\u8F9B\uF971\u8FC5\u5931\u5BA4\u5BE6\u6089\u5BE9\u5C0B\u5FC3\u6C81"],
      ["e4a1", "\uF972\u6DF1\u700B\u751A\u82AF\u8AF6\u4EC0\u5341\uF973\u96D9\u6C0F\u4E9E\u4FC4\u5152\u555E\u5A25\u5CE8\u6211\u7259\u82BD\u83AA\u86FE\u8859\u8A1D\u963F\u96C5\u9913\u9D09\u9D5D\u580A\u5CB3\u5DBD\u5E44\u60E1\u6115\u63E1\u6A02\u6E25\u9102\u9354\u984E\u9C10\u9F77\u5B89\u5CB8\u6309\u664F\u6848\u773C\u96C1\u978D\u9854\u9B9F\u65A1\u8B01\u8ECB\u95BC\u5535\u5CA9\u5DD6\u5EB5\u6697\u764C\u83F4\u95C7\u58D3\u62BC\u72CE\u9D28\u4EF0\u592E\u600F\u663B\u6B83\u79E7\u9D26\u5393\u54C0\u57C3\u5D16\u611B\u66D6\u6DAF\u788D\u827E\u9698\u9744\u5384\u627C\u6396\u6DB2\u7E0A\u814B\u984D"],
      ["e5a1", "\u6AFB\u7F4C\u9DAF\u9E1A\u4E5F\u503B\u51B6\u591C\u60F9\u63F6\u6930\u723A\u8036\uF974\u91CE\u5F31\uF975\uF976\u7D04\u82E5\u846F\u84BB\u85E5\u8E8D\uF977\u4F6F\uF978\uF979\u58E4\u5B43\u6059\u63DA\u6518\u656D\u6698\uF97A\u694A\u6A23\u6D0B\u7001\u716C\u75D2\u760D\u79B3\u7A70\uF97B\u7F8A\uF97C\u8944\uF97D\u8B93\u91C0\u967D\uF97E\u990A\u5704\u5FA1\u65BC\u6F01\u7600\u79A6\u8A9E\u99AD\u9B5A\u9F6C\u5104\u61B6\u6291\u6A8D\u81C6\u5043\u5830\u5F66\u7109\u8A00\u8AFA\u5B7C\u8616\u4FFA\u513C\u56B4\u5944\u63A9\u6DF9\u5DAA\u696D\u5186\u4E88\u4F59\uF97F\uF980\uF981\u5982\uF982"],
      ["e6a1", "\uF983\u6B5F\u6C5D\uF984\u74B5\u7916\uF985\u8207\u8245\u8339\u8F3F\u8F5D\uF986\u9918\uF987\uF988\uF989\u4EA6\uF98A\u57DF\u5F79\u6613\uF98B\uF98C\u75AB\u7E79\u8B6F\uF98D\u9006\u9A5B\u56A5\u5827\u59F8\u5A1F\u5BB4\uF98E\u5EF6\uF98F\uF990\u6350\u633B\uF991\u693D\u6C87\u6CBF\u6D8E\u6D93\u6DF5\u6F14\uF992\u70DF\u7136\u7159\uF993\u71C3\u71D5\uF994\u784F\u786F\uF995\u7B75\u7DE3\uF996\u7E2F\uF997\u884D\u8EDF\uF998\uF999\uF99A\u925B\uF99B\u9CF6\uF99C\uF99D\uF99E\u6085\u6D85\uF99F\u71B1\uF9A0\uF9A1\u95B1\u53AD\uF9A2\uF9A3\uF9A4\u67D3\uF9A5\u708E\u7130\u7430\u8276\u82D2"],
      ["e7a1", "\uF9A6\u95BB\u9AE5\u9E7D\u66C4\uF9A7\u71C1\u8449\uF9A8\uF9A9\u584B\uF9AA\uF9AB\u5DB8\u5F71\uF9AC\u6620\u668E\u6979\u69AE\u6C38\u6CF3\u6E36\u6F41\u6FDA\u701B\u702F\u7150\u71DF\u7370\uF9AD\u745B\uF9AE\u74D4\u76C8\u7A4E\u7E93\uF9AF\uF9B0\u82F1\u8A60\u8FCE\uF9B1\u9348\uF9B2\u9719\uF9B3\uF9B4\u4E42\u502A\uF9B5\u5208\u53E1\u66F3\u6C6D\u6FCA\u730A\u777F\u7A62\u82AE\u85DD\u8602\uF9B6\u88D4\u8A63\u8B7D\u8C6B\uF9B7\u92B3\uF9B8\u9713\u9810\u4E94\u4F0D\u4FC9\u50B2\u5348\u543E\u5433\u55DA\u5862\u58BA\u5967\u5A1B\u5BE4\u609F\uF9B9\u61CA\u6556\u65FF\u6664\u68A7\u6C5A\u6FB3"],
      ["e8a1", "\u70CF\u71AC\u7352\u7B7D\u8708\u8AA4\u9C32\u9F07\u5C4B\u6C83\u7344\u7389\u923A\u6EAB\u7465\u761F\u7A69\u7E15\u860A\u5140\u58C5\u64C1\u74EE\u7515\u7670\u7FC1\u9095\u96CD\u9954\u6E26\u74E6\u7AA9\u7AAA\u81E5\u86D9\u8778\u8A1B\u5A49\u5B8C\u5B9B\u68A1\u6900\u6D63\u73A9\u7413\u742C\u7897\u7DE9\u7FEB\u8118\u8155\u839E\u8C4C\u962E\u9811\u66F0\u5F80\u65FA\u6789\u6C6A\u738B\u502D\u5A03\u6B6A\u77EE\u5916\u5D6C\u5DCD\u7325\u754F\uF9BA\uF9BB\u50E5\u51F9\u582F\u592D\u5996\u59DA\u5BE5\uF9BC\uF9BD\u5DA2\u62D7\u6416\u6493\u64FE\uF9BE\u66DC\uF9BF\u6A48\uF9C0\u71FF\u7464\uF9C1"],
      ["e9a1", "\u7A88\u7AAF\u7E47\u7E5E\u8000\u8170\uF9C2\u87EF\u8981\u8B20\u9059\uF9C3\u9080\u9952\u617E\u6B32\u6D74\u7E1F\u8925\u8FB1\u4FD1\u50AD\u5197\u52C7\u57C7\u5889\u5BB9\u5EB8\u6142\u6995\u6D8C\u6E67\u6EB6\u7194\u7462\u7528\u752C\u8073\u8338\u84C9\u8E0A\u9394\u93DE\uF9C4\u4E8E\u4F51\u5076\u512A\u53C8\u53CB\u53F3\u5B87\u5BD3\u5C24\u611A\u6182\u65F4\u725B\u7397\u7440\u76C2\u7950\u7991\u79B9\u7D06\u7FBD\u828B\u85D5\u865E\u8FC2\u9047\u90F5\u91EA\u9685\u96E8\u96E9\u52D6\u5F67\u65ED\u6631\u682F\u715C\u7A36\u90C1\u980A\u4E91\uF9C5\u6A52\u6B9E\u6F90\u7189\u8018\u82B8\u8553"],
      ["eaa1", "\u904B\u9695\u96F2\u97FB\u851A\u9B31\u4E90\u718A\u96C4\u5143\u539F\u54E1\u5713\u5712\u57A3\u5A9B\u5AC4\u5BC3\u6028\u613F\u63F4\u6C85\u6D39\u6E72\u6E90\u7230\u733F\u7457\u82D1\u8881\u8F45\u9060\uF9C6\u9662\u9858\u9D1B\u6708\u8D8A\u925E\u4F4D\u5049\u50DE\u5371\u570D\u59D4\u5A01\u5C09\u6170\u6690\u6E2D\u7232\u744B\u7DEF\u80C3\u840E\u8466\u853F\u875F\u885B\u8918\u8B02\u9055\u97CB\u9B4F\u4E73\u4F91\u5112\u516A\uF9C7\u552F\u55A9\u5B7A\u5BA5\u5E7C\u5E7D\u5EBE\u60A0\u60DF\u6108\u6109\u63C4\u6538\u6709\uF9C8\u67D4\u67DA\uF9C9\u6961\u6962\u6CB9\u6D27\uF9CA\u6E38\uF9CB"],
      ["eba1", "\u6FE1\u7336\u7337\uF9CC\u745C\u7531\uF9CD\u7652\uF9CE\uF9CF\u7DAD\u81FE\u8438\u88D5\u8A98\u8ADB\u8AED\u8E30\u8E42\u904A\u903E\u907A\u9149\u91C9\u936E\uF9D0\uF9D1\u5809\uF9D2\u6BD3\u8089\u80B2\uF9D3\uF9D4\u5141\u596B\u5C39\uF9D5\uF9D6\u6F64\u73A7\u80E4\u8D07\uF9D7\u9217\u958F\uF9D8\uF9D9\uF9DA\uF9DB\u807F\u620E\u701C\u7D68\u878D\uF9DC\u57A0\u6069\u6147\u6BB7\u8ABE\u9280\u96B1\u4E59\u541F\u6DEB\u852D\u9670\u97F3\u98EE\u63D6\u6CE3\u9091\u51DD\u61C9\u81BA\u9DF9\u4F9D\u501A\u5100\u5B9C\u610F\u61FF\u64EC\u6905\u6BC5\u7591\u77E3\u7FA9\u8264\u858F\u87FB\u8863\u8ABC"],
      ["eca1", "\u8B70\u91AB\u4E8C\u4EE5\u4F0A\uF9DD\uF9DE\u5937\u59E8\uF9DF\u5DF2\u5F1B\u5F5B\u6021\uF9E0\uF9E1\uF9E2\uF9E3\u723E\u73E5\uF9E4\u7570\u75CD\uF9E5\u79FB\uF9E6\u800C\u8033\u8084\u82E1\u8351\uF9E7\uF9E8\u8CBD\u8CB3\u9087\uF9E9\uF9EA\u98F4\u990C\uF9EB\uF9EC\u7037\u76CA\u7FCA\u7FCC\u7FFC\u8B1A\u4EBA\u4EC1\u5203\u5370\uF9ED\u54BD\u56E0\u59FB\u5BC5\u5F15\u5FCD\u6E6E\uF9EE\uF9EF\u7D6A\u8335\uF9F0\u8693\u8A8D\uF9F1\u976D\u9777\uF9F2\uF9F3\u4E00\u4F5A\u4F7E\u58F9\u65E5\u6EA2\u9038\u93B0\u99B9\u4EFB\u58EC\u598A\u59D9\u6041\uF9F4\uF9F5\u7A14\uF9F6\u834F\u8CC3\u5165\u5344"],
      ["eda1", "\uF9F7\uF9F8\uF9F9\u4ECD\u5269\u5B55\u82BF\u4ED4\u523A\u54A8\u59C9\u59FF\u5B50\u5B57\u5B5C\u6063\u6148\u6ECB\u7099\u716E\u7386\u74F7\u75B5\u78C1\u7D2B\u8005\u81EA\u8328\u8517\u85C9\u8AEE\u8CC7\u96CC\u4F5C\u52FA\u56BC\u65AB\u6628\u707C\u70B8\u7235\u7DBD\u828D\u914C\u96C0\u9D72\u5B71\u68E7\u6B98\u6F7A\u76DE\u5C91\u66AB\u6F5B\u7BB4\u7C2A\u8836\u96DC\u4E08\u4ED7\u5320\u5834\u58BB\u58EF\u596C\u5C07\u5E33\u5E84\u5F35\u638C\u66B2\u6756\u6A1F\u6AA3\u6B0C\u6F3F\u7246\uF9FA\u7350\u748B\u7AE0\u7CA7\u8178\u81DF\u81E7\u838A\u846C\u8523\u8594\u85CF\u88DD\u8D13\u91AC\u9577"],
      ["eea1", "\u969C\u518D\u54C9\u5728\u5BB0\u624D\u6750\u683D\u6893\u6E3D\u6ED3\u707D\u7E21\u88C1\u8CA1\u8F09\u9F4B\u9F4E\u722D\u7B8F\u8ACD\u931A\u4F47\u4F4E\u5132\u5480\u59D0\u5E95\u62B5\u6775\u696E\u6A17\u6CAE\u6E1A\u72D9\u732A\u75BD\u7BB8\u7D35\u82E7\u83F9\u8457\u85F7\u8A5B\u8CAF\u8E87\u9019\u90B8\u96CE\u9F5F\u52E3\u540A\u5AE1\u5BC2\u6458\u6575\u6EF4\u72C4\uF9FB\u7684\u7A4D\u7B1B\u7C4D\u7E3E\u7FDF\u837B\u8B2B\u8CCA\u8D64\u8DE1\u8E5F\u8FEA\u8FF9\u9069\u93D1\u4F43\u4F7A\u50B3\u5168\u5178\u524D\u526A\u5861\u587C\u5960\u5C08\u5C55\u5EDB\u609B\u6230\u6813\u6BBF\u6C08\u6FB1"],
      ["efa1", "\u714E\u7420\u7530\u7538\u7551\u7672\u7B4C\u7B8B\u7BAD\u7BC6\u7E8F\u8A6E\u8F3E\u8F49\u923F\u9293\u9322\u942B\u96FB\u985A\u986B\u991E\u5207\u622A\u6298\u6D59\u7664\u7ACA\u7BC0\u7D76\u5360\u5CBE\u5E97\u6F38\u70B9\u7C98\u9711\u9B8E\u9EDE\u63A5\u647A\u8776\u4E01\u4E95\u4EAD\u505C\u5075\u5448\u59C3\u5B9A\u5E40\u5EAD\u5EF7\u5F81\u60C5\u633A\u653F\u6574\u65CC\u6676\u6678\u67FE\u6968\u6A89\u6B63\u6C40\u6DC0\u6DE8\u6E1F\u6E5E\u701E\u70A1\u738E\u73FD\u753A\u775B\u7887\u798E\u7A0B\u7A7D\u7CBE\u7D8E\u8247\u8A02\u8AEA\u8C9E\u912D\u914A\u91D8\u9266\u92CC\u9320\u9706\u9756"],
      ["f0a1", "\u975C\u9802\u9F0E\u5236\u5291\u557C\u5824\u5E1D\u5F1F\u608C\u63D0\u68AF\u6FDF\u796D\u7B2C\u81CD\u85BA\u88FD\u8AF8\u8E44\u918D\u9664\u969B\u973D\u984C\u9F4A\u4FCE\u5146\u51CB\u52A9\u5632\u5F14\u5F6B\u63AA\u64CD\u65E9\u6641\u66FA\u66F9\u671D\u689D\u68D7\u69FD\u6F15\u6F6E\u7167\u71E5\u722A\u74AA\u773A\u7956\u795A\u79DF\u7A20\u7A95\u7C97\u7CDF\u7D44\u7E70\u8087\u85FB\u86A4\u8A54\u8ABF\u8D99\u8E81\u9020\u906D\u91E3\u963B\u96D5\u9CE5\u65CF\u7C07\u8DB3\u93C3\u5B58\u5C0A\u5352\u62D9\u731D\u5027\u5B97\u5F9E\u60B0\u616B\u68D5\u6DD9\u742E\u7A2E\u7D42\u7D9C\u7E31\u816B"],
      ["f1a1", "\u8E2A\u8E35\u937E\u9418\u4F50\u5750\u5DE6\u5EA7\u632B\u7F6A\u4E3B\u4F4F\u4F8F\u505A\u59DD\u80C4\u546A\u5468\u55FE\u594F\u5B99\u5DDE\u5EDA\u665D\u6731\u67F1\u682A\u6CE8\u6D32\u6E4A\u6F8D\u70B7\u73E0\u7587\u7C4C\u7D02\u7D2C\u7DA2\u821F\u86DB\u8A3B\u8A85\u8D70\u8E8A\u8F33\u9031\u914E\u9152\u9444\u99D0\u7AF9\u7CA5\u4FCA\u5101\u51C6\u57C8\u5BEF\u5CFB\u6659\u6A3D\u6D5A\u6E96\u6FEC\u710C\u756F\u7AE3\u8822\u9021\u9075\u96CB\u99FF\u8301\u4E2D\u4EF2\u8846\u91CD\u537D\u6ADB\u696B\u6C41\u847A\u589E\u618E\u66FE\u62EF\u70DD\u7511\u75C7\u7E52\u84B8\u8B49\u8D08\u4E4B\u53EA"],
      ["f2a1", "\u54AB\u5730\u5740\u5FD7\u6301\u6307\u646F\u652F\u65E8\u667A\u679D\u67B3\u6B62\u6C60\u6C9A\u6F2C\u77E5\u7825\u7949\u7957\u7D19\u80A2\u8102\u81F3\u829D\u82B7\u8718\u8A8C\uF9FC\u8D04\u8DBE\u9072\u76F4\u7A19\u7A37\u7E54\u8077\u5507\u55D4\u5875\u632F\u6422\u6649\u664B\u686D\u699B\u6B84\u6D25\u6EB1\u73CD\u7468\u74A1\u755B\u75B9\u76E1\u771E\u778B\u79E6\u7E09\u7E1D\u81FB\u852F\u8897\u8A3A\u8CD1\u8EEB\u8FB0\u9032\u93AD\u9663\u9673\u9707\u4F84\u53F1\u59EA\u5AC9\u5E19\u684E\u74C6\u75BE\u79E9\u7A92\u81A3\u86ED\u8CEA\u8DCC\u8FED\u659F\u6715\uF9FD\u57F7\u6F57\u7DDD\u8F2F"],
      ["f3a1", "\u93F6\u96C6\u5FB5\u61F2\u6F84\u4E14\u4F98\u501F\u53C9\u55DF\u5D6F\u5DEE\u6B21\u6B64\u78CB\u7B9A\uF9FE\u8E49\u8ECA\u906E\u6349\u643E\u7740\u7A84\u932F\u947F\u9F6A\u64B0\u6FAF\u71E6\u74A8\u74DA\u7AC4\u7C12\u7E82\u7CB2\u7E98\u8B9A\u8D0A\u947D\u9910\u994C\u5239\u5BDF\u64E6\u672D\u7D2E\u50ED\u53C3\u5879\u6158\u6159\u61FA\u65AC\u7AD9\u8B92\u8B96\u5009\u5021\u5275\u5531\u5A3C\u5EE0\u5F70\u6134\u655E\u660C\u6636\u66A2\u69CD\u6EC4\u6F32\u7316\u7621\u7A93\u8139\u8259\u83D6\u84BC\u50B5\u57F0\u5BC0\u5BE8\u5F69\u63A1\u7826\u7DB5\u83DC\u8521\u91C7\u91F5\u518A\u67F5\u7B56"],
      ["f4a1", "\u8CAC\u51C4\u59BB\u60BD\u8655\u501C\uF9FF\u5254\u5C3A\u617D\u621A\u62D3\u64F2\u65A5\u6ECC\u7620\u810A\u8E60\u965F\u96BB\u4EDF\u5343\u5598\u5929\u5DDD\u64C5\u6CC9\u6DFA\u7394\u7A7F\u821B\u85A6\u8CE4\u8E10\u9077\u91E7\u95E1\u9621\u97C6\u51F8\u54F2\u5586\u5FB9\u64A4\u6F88\u7DB4\u8F1F\u8F4D\u9435\u50C9\u5C16\u6CBE\u6DFB\u751B\u77BB\u7C3D\u7C64\u8A79\u8AC2\u581E\u59BE\u5E16\u6377\u7252\u758A\u776B\u8ADC\u8CBC\u8F12\u5EF3\u6674\u6DF8\u807D\u83C1\u8ACB\u9751\u9BD6\uFA00\u5243\u66FF\u6D95\u6EEF\u7DE0\u8AE6\u902E\u905E\u9AD4\u521D\u527F\u54E8\u6194\u6284\u62DB\u68A2"],
      ["f5a1", "\u6912\u695A\u6A35\u7092\u7126\u785D\u7901\u790E\u79D2\u7A0D\u8096\u8278\u82D5\u8349\u8549\u8C82\u8D85\u9162\u918B\u91AE\u4FC3\u56D1\u71ED\u77D7\u8700\u89F8\u5BF8\u5FD6\u6751\u90A8\u53E2\u585A\u5BF5\u60A4\u6181\u6460\u7E3D\u8070\u8525\u9283\u64AE\u50AC\u5D14\u6700\u589C\u62BD\u63A8\u690E\u6978\u6A1E\u6E6B\u76BA\u79CB\u82BB\u8429\u8ACF\u8DA8\u8FFD\u9112\u914B\u919C\u9310\u9318\u939A\u96DB\u9A36\u9C0D\u4E11\u755C\u795D\u7AFA\u7B51\u7BC9\u7E2E\u84C4\u8E59\u8E74\u8EF8\u9010\u6625\u693F\u7443\u51FA\u672E\u9EDC\u5145\u5FE0\u6C96\u87F2\u885D\u8877\u60B4\u81B5\u8403"],
      ["f6a1", "\u8D05\u53D6\u5439\u5634\u5A36\u5C31\u708A\u7FE0\u805A\u8106\u81ED\u8DA3\u9189\u9A5F\u9DF2\u5074\u4EC4\u53A0\u60FB\u6E2C\u5C64\u4F88\u5024\u55E4\u5CD9\u5E5F\u6065\u6894\u6CBB\u6DC4\u71BE\u75D4\u75F4\u7661\u7A1A\u7A49\u7DC7\u7DFB\u7F6E\u81F4\u86A9\u8F1C\u96C9\u99B3\u9F52\u5247\u52C5\u98ED\u89AA\u4E03\u67D2\u6F06\u4FB5\u5BE2\u6795\u6C88\u6D78\u741B\u7827\u91DD\u937C\u87C4\u79E4\u7A31\u5FEB\u4ED6\u54A4\u553E\u58AE\u59A5\u60F0\u6253\u62D6\u6736\u6955\u8235\u9640\u99B1\u99DD\u502C\u5353\u5544\u577C\uFA01\u6258\uFA02\u64E2\u666B\u67DD\u6FC1\u6FEF\u7422\u7438\u8A17"],
      ["f7a1", "\u9438\u5451\u5606\u5766\u5F48\u619A\u6B4E\u7058\u70AD\u7DBB\u8A95\u596A\u812B\u63A2\u7708\u803D\u8CAA\u5854\u642D\u69BB\u5B95\u5E11\u6E6F\uFA03\u8569\u514C\u53F0\u592A\u6020\u614B\u6B86\u6C70\u6CF0\u7B1E\u80CE\u82D4\u8DC6\u90B0\u98B1\uFA04\u64C7\u6FA4\u6491\u6504\u514E\u5410\u571F\u8A0E\u615F\u6876\uFA05\u75DB\u7B52\u7D71\u901A\u5806\u69CC\u817F\u892A\u9000\u9839\u5078\u5957\u59AC\u6295\u900F\u9B2A\u615D\u7279\u95D6\u5761\u5A46\u5DF4\u628A\u64AD\u64FA\u6777\u6CE2\u6D3E\u722C\u7436\u7834\u7F77\u82AD\u8DDB\u9817\u5224\u5742\u677F\u7248\u74E3\u8CA9\u8FA6\u9211"],
      ["f8a1", "\u962A\u516B\u53ED\u634C\u4F69\u5504\u6096\u6557\u6C9B\u6D7F\u724C\u72FD\u7A17\u8987\u8C9D\u5F6D\u6F8E\u70F9\u81A8\u610E\u4FBF\u504F\u6241\u7247\u7BC7\u7DE8\u7FE9\u904D\u97AD\u9A19\u8CB6\u576A\u5E73\u67B0\u840D\u8A55\u5420\u5B16\u5E63\u5EE2\u5F0A\u6583\u80BA\u853D\u9589\u965B\u4F48\u5305\u530D\u530F\u5486\u54FA\u5703\u5E03\u6016\u629B\u62B1\u6355\uFA06\u6CE1\u6D66\u75B1\u7832\u80DE\u812F\u82DE\u8461\u84B2\u888D\u8912\u900B\u92EA\u98FD\u9B91\u5E45\u66B4\u66DD\u7011\u7206\uFA07\u4FF5\u527D\u5F6A\u6153\u6753\u6A19\u6F02\u74E2\u7968\u8868\u8C79\u98C7\u98C4\u9A43"],
      ["f9a1", "\u54C1\u7A1F\u6953\u8AF7\u8C4A\u98A8\u99AE\u5F7C\u62AB\u75B2\u76AE\u88AB\u907F\u9642\u5339\u5F3C\u5FC5\u6CCC\u73CC\u7562\u758B\u7B46\u82FE\u999D\u4E4F\u903C\u4E0B\u4F55\u53A6\u590F\u5EC8\u6630\u6CB3\u7455\u8377\u8766\u8CC0\u9050\u971E\u9C15\u58D1\u5B78\u8650\u8B14\u9DB4\u5BD2\u6068\u608D\u65F1\u6C57\u6F22\u6FA3\u701A\u7F55\u7FF0\u9591\u9592\u9650\u97D3\u5272\u8F44\u51FD\u542B\u54B8\u5563\u558A\u6ABB\u6DB5\u7DD8\u8266\u929C\u9677\u9E79\u5408\u54C8\u76D2\u86E4\u95A4\u95D4\u965C\u4EA2\u4F09\u59EE\u5AE6\u5DF7\u6052\u6297\u676D\u6841\u6C86\u6E2F\u7F38\u809B\u822A"],
      ["faa1", "\uFA08\uFA09\u9805\u4EA5\u5055\u54B3\u5793\u595A\u5B69\u5BB3\u61C8\u6977\u6D77\u7023\u87F9\u89E3\u8A72\u8AE7\u9082\u99ED\u9AB8\u52BE\u6838\u5016\u5E78\u674F\u8347\u884C\u4EAB\u5411\u56AE\u73E6\u9115\u97FF\u9909\u9957\u9999\u5653\u589F\u865B\u8A31\u61B2\u6AF6\u737B\u8ED2\u6B47\u96AA\u9A57\u5955\u7200\u8D6B\u9769\u4FD4\u5CF4\u5F26\u61F8\u665B\u6CEB\u70AB\u7384\u73B9\u73FE\u7729\u774D\u7D43\u7D62\u7E23\u8237\u8852\uFA0A\u8CE2\u9249\u986F\u5B51\u7A74\u8840\u9801\u5ACC\u4FE0\u5354\u593E\u5CFD\u633E\u6D79\u72F9\u8105\u8107\u83A2\u92CF\u9830\u4EA8\u5144\u5211\u578B"],
      ["fba1", "\u5F62\u6CC2\u6ECE\u7005\u7050\u70AF\u7192\u73E9\u7469\u834A\u87A2\u8861\u9008\u90A2\u93A3\u99A8\u516E\u5F57\u60E0\u6167\u66B3\u8559\u8E4A\u91AF\u978B\u4E4E\u4E92\u547C\u58D5\u58FA\u597D\u5CB5\u5F27\u6236\u6248\u660A\u6667\u6BEB\u6D69\u6DCF\u6E56\u6EF8\u6F94\u6FE0\u6FE9\u705D\u72D0\u7425\u745A\u74E0\u7693\u795C\u7CCA\u7E1E\u80E1\u82A6\u846B\u84BF\u864E\u865F\u8774\u8B77\u8C6A\u93AC\u9800\u9865\u60D1\u6216\u9177\u5A5A\u660F\u6DF7\u6E3E\u743F\u9B42\u5FFD\u60DA\u7B0F\u54C4\u5F18\u6C5E\u6CD3\u6D2A\u70D8\u7D05\u8679\u8A0C\u9D3B\u5316\u548C\u5B05\u6A3A\u706B\u7575"],
      ["fca1", "\u798D\u79BE\u82B1\u83EF\u8A71\u8B41\u8CA8\u9774\uFA0B\u64F4\u652B\u78BA\u78BB\u7A6B\u4E38\u559A\u5950\u5BA6\u5E7B\u60A3\u63DB\u6B61\u6665\u6853\u6E19\u7165\u74B0\u7D08\u9084\u9A69\u9C25\u6D3B\u6ED1\u733E\u8C41\u95CA\u51F0\u5E4C\u5FA8\u604D\u60F6\u6130\u614C\u6643\u6644\u69A5\u6CC1\u6E5F\u6EC9\u6F62\u714C\u749C\u7687\u7BC1\u7C27\u8352\u8757\u9051\u968D\u9EC3\u532F\u56DE\u5EFB\u5F8A\u6062\u6094\u61F7\u6666\u6703\u6A9C\u6DEE\u6FAE\u7070\u736A\u7E6A\u81BE\u8334\u86D4\u8AA8\u8CC4\u5283\u7372\u5B96\u6A6B\u9404\u54EE\u5686\u5B5D\u6548\u6585\u66C9\u689F\u6D8D\u6DC6"],
      ["fda1", "\u723B\u80B4\u9175\u9A4D\u4FAF\u5019\u539A\u540E\u543C\u5589\u55C5\u5E3F\u5F8C\u673D\u7166\u73DD\u9005\u52DB\u52F3\u5864\u58CE\u7104\u718F\u71FB\u85B0\u8A13\u6688\u85A8\u55A7\u6684\u714A\u8431\u5349\u5599\u6BC1\u5F59\u5FBD\u63EE\u6689\u7147\u8AF1\u8F1D\u9EBE\u4F11\u643A\u70CB\u7566\u8667\u6064\u8B4E\u9DF8\u5147\u51F6\u5308\u6D36\u80F8\u9ED1\u6615\u6B23\u7098\u75D5\u5403\u5C79\u7D07\u8A16\u6B20\u6B3D\u6B46\u5438\u6070\u6D3D\u7FD5\u8208\u50D6\u51DE\u559C\u566B\u56CD\u59EC\u5B09\u5E0C\u6199\u6198\u6231\u665E\u66E6\u7199\u71B9\u71BA\u72A7\u79A7\u7A00\u7FB2\u8A70"]
    ];
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/tables/cp950.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["a140", "\u3000\uFF0C\u3001\u3002\uFF0E\u2027\uFF1B\uFF1A\uFF1F\uFF01\uFE30\u2026\u2025\uFE50\uFE51\uFE52\xB7\uFE54\uFE55\uFE56\uFE57\uFF5C\u2013\uFE31\u2014\uFE33\u2574\uFE34\uFE4F\uFF08\uFF09\uFE35\uFE36\uFF5B\uFF5D\uFE37\uFE38\u3014\u3015\uFE39\uFE3A\u3010\u3011\uFE3B\uFE3C\u300A\u300B\uFE3D\uFE3E\u3008\u3009\uFE3F\uFE40\u300C\u300D\uFE41\uFE42\u300E\u300F\uFE43\uFE44\uFE59\uFE5A"],
      ["a1a1", "\uFE5B\uFE5C\uFE5D\uFE5E\u2018\u2019\u201C\u201D\u301D\u301E\u2035\u2032\uFF03\uFF06\uFF0A\u203B\xA7\u3003\u25CB\u25CF\u25B3\u25B2\u25CE\u2606\u2605\u25C7\u25C6\u25A1\u25A0\u25BD\u25BC\u32A3\u2105\xAF\uFFE3\uFF3F\u02CD\uFE49\uFE4A\uFE4D\uFE4E\uFE4B\uFE4C\uFE5F\uFE60\uFE61\uFF0B\uFF0D\xD7\xF7\xB1\u221A\uFF1C\uFF1E\uFF1D\u2266\u2267\u2260\u221E\u2252\u2261\uFE62", 4, "\uFF5E\u2229\u222A\u22A5\u2220\u221F\u22BF\u33D2\u33D1\u222B\u222E\u2235\u2234\u2640\u2642\u2295\u2299\u2191\u2193\u2190\u2192\u2196\u2197\u2199\u2198\u2225\u2223\uFF0F"],
      ["a240", "\uFF3C\u2215\uFE68\uFF04\uFFE5\u3012\uFFE0\uFFE1\uFF05\uFF20\u2103\u2109\uFE69\uFE6A\uFE6B\u33D5\u339C\u339D\u339E\u33CE\u33A1\u338E\u338F\u33C4\xB0\u5159\u515B\u515E\u515D\u5161\u5163\u55E7\u74E9\u7CCE\u2581", 7, "\u258F\u258E\u258D\u258C\u258B\u258A\u2589\u253C\u2534\u252C\u2524\u251C\u2594\u2500\u2502\u2595\u250C\u2510\u2514\u2518\u256D"],
      ["a2a1", "\u256E\u2570\u256F\u2550\u255E\u256A\u2561\u25E2\u25E3\u25E5\u25E4\u2571\u2572\u2573\uFF10", 9, "\u2160", 9, "\u3021", 8, "\u5341\u5344\u5345\uFF21", 25, "\uFF41", 21],
      ["a340", "\uFF57\uFF58\uFF59\uFF5A\u0391", 16, "\u03A3", 6, "\u03B1", 16, "\u03C3", 6, "\u3105", 10],
      ["a3a1", "\u3110", 25, "\u02D9\u02C9\u02CA\u02C7\u02CB"],
      ["a3e1", "\u20AC"],
      ["a440", "\u4E00\u4E59\u4E01\u4E03\u4E43\u4E5D\u4E86\u4E8C\u4EBA\u513F\u5165\u516B\u51E0\u5200\u5201\u529B\u5315\u5341\u535C\u53C8\u4E09\u4E0B\u4E08\u4E0A\u4E2B\u4E38\u51E1\u4E45\u4E48\u4E5F\u4E5E\u4E8E\u4EA1\u5140\u5203\u52FA\u5343\u53C9\u53E3\u571F\u58EB\u5915\u5927\u5973\u5B50\u5B51\u5B53\u5BF8\u5C0F\u5C22\u5C38\u5C71\u5DDD\u5DE5\u5DF1\u5DF2\u5DF3\u5DFE\u5E72\u5EFE\u5F0B\u5F13\u624D"],
      ["a4a1", "\u4E11\u4E10\u4E0D\u4E2D\u4E30\u4E39\u4E4B\u5C39\u4E88\u4E91\u4E95\u4E92\u4E94\u4EA2\u4EC1\u4EC0\u4EC3\u4EC6\u4EC7\u4ECD\u4ECA\u4ECB\u4EC4\u5143\u5141\u5167\u516D\u516E\u516C\u5197\u51F6\u5206\u5207\u5208\u52FB\u52FE\u52FF\u5316\u5339\u5348\u5347\u5345\u535E\u5384\u53CB\u53CA\u53CD\u58EC\u5929\u592B\u592A\u592D\u5B54\u5C11\u5C24\u5C3A\u5C6F\u5DF4\u5E7B\u5EFF\u5F14\u5F15\u5FC3\u6208\u6236\u624B\u624E\u652F\u6587\u6597\u65A4\u65B9\u65E5\u66F0\u6708\u6728\u6B20\u6B62\u6B79\u6BCB\u6BD4\u6BDB\u6C0F\u6C34\u706B\u722A\u7236\u723B\u7247\u7259\u725B\u72AC\u738B\u4E19"],
      ["a540", "\u4E16\u4E15\u4E14\u4E18\u4E3B\u4E4D\u4E4F\u4E4E\u4EE5\u4ED8\u4ED4\u4ED5\u4ED6\u4ED7\u4EE3\u4EE4\u4ED9\u4EDE\u5145\u5144\u5189\u518A\u51AC\u51F9\u51FA\u51F8\u520A\u52A0\u529F\u5305\u5306\u5317\u531D\u4EDF\u534A\u5349\u5361\u5360\u536F\u536E\u53BB\u53EF\u53E4\u53F3\u53EC\u53EE\u53E9\u53E8\u53FC\u53F8\u53F5\u53EB\u53E6\u53EA\u53F2\u53F1\u53F0\u53E5\u53ED\u53FB\u56DB\u56DA\u5916"],
      ["a5a1", "\u592E\u5931\u5974\u5976\u5B55\u5B83\u5C3C\u5DE8\u5DE7\u5DE6\u5E02\u5E03\u5E73\u5E7C\u5F01\u5F18\u5F17\u5FC5\u620A\u6253\u6254\u6252\u6251\u65A5\u65E6\u672E\u672C\u672A\u672B\u672D\u6B63\u6BCD\u6C11\u6C10\u6C38\u6C41\u6C40\u6C3E\u72AF\u7384\u7389\u74DC\u74E6\u7518\u751F\u7528\u7529\u7530\u7531\u7532\u7533\u758B\u767D\u76AE\u76BF\u76EE\u77DB\u77E2\u77F3\u793A\u79BE\u7A74\u7ACB\u4E1E\u4E1F\u4E52\u4E53\u4E69\u4E99\u4EA4\u4EA6\u4EA5\u4EFF\u4F09\u4F19\u4F0A\u4F15\u4F0D\u4F10\u4F11\u4F0F\u4EF2\u4EF6\u4EFB\u4EF0\u4EF3\u4EFD\u4F01\u4F0B\u5149\u5147\u5146\u5148\u5168"],
      ["a640", "\u5171\u518D\u51B0\u5217\u5211\u5212\u520E\u5216\u52A3\u5308\u5321\u5320\u5370\u5371\u5409\u540F\u540C\u540A\u5410\u5401\u540B\u5404\u5411\u540D\u5408\u5403\u540E\u5406\u5412\u56E0\u56DE\u56DD\u5733\u5730\u5728\u572D\u572C\u572F\u5729\u5919\u591A\u5937\u5938\u5984\u5978\u5983\u597D\u5979\u5982\u5981\u5B57\u5B58\u5B87\u5B88\u5B85\u5B89\u5BFA\u5C16\u5C79\u5DDE\u5E06\u5E76\u5E74"],
      ["a6a1", "\u5F0F\u5F1B\u5FD9\u5FD6\u620E\u620C\u620D\u6210\u6263\u625B\u6258\u6536\u65E9\u65E8\u65EC\u65ED\u66F2\u66F3\u6709\u673D\u6734\u6731\u6735\u6B21\u6B64\u6B7B\u6C16\u6C5D\u6C57\u6C59\u6C5F\u6C60\u6C50\u6C55\u6C61\u6C5B\u6C4D\u6C4E\u7070\u725F\u725D\u767E\u7AF9\u7C73\u7CF8\u7F36\u7F8A\u7FBD\u8001\u8003\u800C\u8012\u8033\u807F\u8089\u808B\u808C\u81E3\u81EA\u81F3\u81FC\u820C\u821B\u821F\u826E\u8272\u827E\u866B\u8840\u884C\u8863\u897F\u9621\u4E32\u4EA8\u4F4D\u4F4F\u4F47\u4F57\u4F5E\u4F34\u4F5B\u4F55\u4F30\u4F50\u4F51\u4F3D\u4F3A\u4F38\u4F43\u4F54\u4F3C\u4F46\u4F63"],
      ["a740", "\u4F5C\u4F60\u4F2F\u4F4E\u4F36\u4F59\u4F5D\u4F48\u4F5A\u514C\u514B\u514D\u5175\u51B6\u51B7\u5225\u5224\u5229\u522A\u5228\u52AB\u52A9\u52AA\u52AC\u5323\u5373\u5375\u541D\u542D\u541E\u543E\u5426\u544E\u5427\u5446\u5443\u5433\u5448\u5442\u541B\u5429\u544A\u5439\u543B\u5438\u542E\u5435\u5436\u5420\u543C\u5440\u5431\u542B\u541F\u542C\u56EA\u56F0\u56E4\u56EB\u574A\u5751\u5740\u574D"],
      ["a7a1", "\u5747\u574E\u573E\u5750\u574F\u573B\u58EF\u593E\u599D\u5992\u59A8\u599E\u59A3\u5999\u5996\u598D\u59A4\u5993\u598A\u59A5\u5B5D\u5B5C\u5B5A\u5B5B\u5B8C\u5B8B\u5B8F\u5C2C\u5C40\u5C41\u5C3F\u5C3E\u5C90\u5C91\u5C94\u5C8C\u5DEB\u5E0C\u5E8F\u5E87\u5E8A\u5EF7\u5F04\u5F1F\u5F64\u5F62\u5F77\u5F79\u5FD8\u5FCC\u5FD7\u5FCD\u5FF1\u5FEB\u5FF8\u5FEA\u6212\u6211\u6284\u6297\u6296\u6280\u6276\u6289\u626D\u628A\u627C\u627E\u6279\u6273\u6292\u626F\u6298\u626E\u6295\u6293\u6291\u6286\u6539\u653B\u6538\u65F1\u66F4\u675F\u674E\u674F\u6750\u6751\u675C\u6756\u675E\u6749\u6746\u6760"],
      ["a840", "\u6753\u6757\u6B65\u6BCF\u6C42\u6C5E\u6C99\u6C81\u6C88\u6C89\u6C85\u6C9B\u6C6A\u6C7A\u6C90\u6C70\u6C8C\u6C68\u6C96\u6C92\u6C7D\u6C83\u6C72\u6C7E\u6C74\u6C86\u6C76\u6C8D\u6C94\u6C98\u6C82\u7076\u707C\u707D\u7078\u7262\u7261\u7260\u72C4\u72C2\u7396\u752C\u752B\u7537\u7538\u7682\u76EF\u77E3\u79C1\u79C0\u79BF\u7A76\u7CFB\u7F55\u8096\u8093\u809D\u8098\u809B\u809A\u80B2\u826F\u8292"],
      ["a8a1", "\u828B\u828D\u898B\u89D2\u8A00\u8C37\u8C46\u8C55\u8C9D\u8D64\u8D70\u8DB3\u8EAB\u8ECA\u8F9B\u8FB0\u8FC2\u8FC6\u8FC5\u8FC4\u5DE1\u9091\u90A2\u90AA\u90A6\u90A3\u9149\u91C6\u91CC\u9632\u962E\u9631\u962A\u962C\u4E26\u4E56\u4E73\u4E8B\u4E9B\u4E9E\u4EAB\u4EAC\u4F6F\u4F9D\u4F8D\u4F73\u4F7F\u4F6C\u4F9B\u4F8B\u4F86\u4F83\u4F70\u4F75\u4F88\u4F69\u4F7B\u4F96\u4F7E\u4F8F\u4F91\u4F7A\u5154\u5152\u5155\u5169\u5177\u5176\u5178\u51BD\u51FD\u523B\u5238\u5237\u523A\u5230\u522E\u5236\u5241\u52BE\u52BB\u5352\u5354\u5353\u5351\u5366\u5377\u5378\u5379\u53D6\u53D4\u53D7\u5473\u5475"],
      ["a940", "\u5496\u5478\u5495\u5480\u547B\u5477\u5484\u5492\u5486\u547C\u5490\u5471\u5476\u548C\u549A\u5462\u5468\u548B\u547D\u548E\u56FA\u5783\u5777\u576A\u5769\u5761\u5766\u5764\u577C\u591C\u5949\u5947\u5948\u5944\u5954\u59BE\u59BB\u59D4\u59B9\u59AE\u59D1\u59C6\u59D0\u59CD\u59CB\u59D3\u59CA\u59AF\u59B3\u59D2\u59C5\u5B5F\u5B64\u5B63\u5B97\u5B9A\u5B98\u5B9C\u5B99\u5B9B\u5C1A\u5C48\u5C45"],
      ["a9a1", "\u5C46\u5CB7\u5CA1\u5CB8\u5CA9\u5CAB\u5CB1\u5CB3\u5E18\u5E1A\u5E16\u5E15\u5E1B\u5E11\u5E78\u5E9A\u5E97\u5E9C\u5E95\u5E96\u5EF6\u5F26\u5F27\u5F29\u5F80\u5F81\u5F7F\u5F7C\u5FDD\u5FE0\u5FFD\u5FF5\u5FFF\u600F\u6014\u602F\u6035\u6016\u602A\u6015\u6021\u6027\u6029\u602B\u601B\u6216\u6215\u623F\u623E\u6240\u627F\u62C9\u62CC\u62C4\u62BF\u62C2\u62B9\u62D2\u62DB\u62AB\u62D3\u62D4\u62CB\u62C8\u62A8\u62BD\u62BC\u62D0\u62D9\u62C7\u62CD\u62B5\u62DA\u62B1\u62D8\u62D6\u62D7\u62C6\u62AC\u62CE\u653E\u65A7\u65BC\u65FA\u6614\u6613\u660C\u6606\u6602\u660E\u6600\u660F\u6615\u660A"],
      ["aa40", "\u6607\u670D\u670B\u676D\u678B\u6795\u6771\u679C\u6773\u6777\u6787\u679D\u6797\u676F\u6770\u677F\u6789\u677E\u6790\u6775\u679A\u6793\u677C\u676A\u6772\u6B23\u6B66\u6B67\u6B7F\u6C13\u6C1B\u6CE3\u6CE8\u6CF3\u6CB1\u6CCC\u6CE5\u6CB3\u6CBD\u6CBE\u6CBC\u6CE2\u6CAB\u6CD5\u6CD3\u6CB8\u6CC4\u6CB9\u6CC1\u6CAE\u6CD7\u6CC5\u6CF1\u6CBF\u6CBB\u6CE1\u6CDB\u6CCA\u6CAC\u6CEF\u6CDC\u6CD6\u6CE0"],
      ["aaa1", "\u7095\u708E\u7092\u708A\u7099\u722C\u722D\u7238\u7248\u7267\u7269\u72C0\u72CE\u72D9\u72D7\u72D0\u73A9\u73A8\u739F\u73AB\u73A5\u753D\u759D\u7599\u759A\u7684\u76C2\u76F2\u76F4\u77E5\u77FD\u793E\u7940\u7941\u79C9\u79C8\u7A7A\u7A79\u7AFA\u7CFE\u7F54\u7F8C\u7F8B\u8005\u80BA\u80A5\u80A2\u80B1\u80A1\u80AB\u80A9\u80B4\u80AA\u80AF\u81E5\u81FE\u820D\u82B3\u829D\u8299\u82AD\u82BD\u829F\u82B9\u82B1\u82AC\u82A5\u82AF\u82B8\u82A3\u82B0\u82BE\u82B7\u864E\u8671\u521D\u8868\u8ECB\u8FCE\u8FD4\u8FD1\u90B5\u90B8\u90B1\u90B6\u91C7\u91D1\u9577\u9580\u961C\u9640\u963F\u963B\u9644"],
      ["ab40", "\u9642\u96B9\u96E8\u9752\u975E\u4E9F\u4EAD\u4EAE\u4FE1\u4FB5\u4FAF\u4FBF\u4FE0\u4FD1\u4FCF\u4FDD\u4FC3\u4FB6\u4FD8\u4FDF\u4FCA\u4FD7\u4FAE\u4FD0\u4FC4\u4FC2\u4FDA\u4FCE\u4FDE\u4FB7\u5157\u5192\u5191\u51A0\u524E\u5243\u524A\u524D\u524C\u524B\u5247\u52C7\u52C9\u52C3\u52C1\u530D\u5357\u537B\u539A\u53DB\u54AC\u54C0\u54A8\u54CE\u54C9\u54B8\u54A6\u54B3\u54C7\u54C2\u54BD\u54AA\u54C1"],
      ["aba1", "\u54C4\u54C8\u54AF\u54AB\u54B1\u54BB\u54A9\u54A7\u54BF\u56FF\u5782\u578B\u57A0\u57A3\u57A2\u57CE\u57AE\u5793\u5955\u5951\u594F\u594E\u5950\u59DC\u59D8\u59FF\u59E3\u59E8\u5A03\u59E5\u59EA\u59DA\u59E6\u5A01\u59FB\u5B69\u5BA3\u5BA6\u5BA4\u5BA2\u5BA5\u5C01\u5C4E\u5C4F\u5C4D\u5C4B\u5CD9\u5CD2\u5DF7\u5E1D\u5E25\u5E1F\u5E7D\u5EA0\u5EA6\u5EFA\u5F08\u5F2D\u5F65\u5F88\u5F85\u5F8A\u5F8B\u5F87\u5F8C\u5F89\u6012\u601D\u6020\u6025\u600E\u6028\u604D\u6070\u6068\u6062\u6046\u6043\u606C\u606B\u606A\u6064\u6241\u62DC\u6316\u6309\u62FC\u62ED\u6301\u62EE\u62FD\u6307\u62F1\u62F7"],
      ["ac40", "\u62EF\u62EC\u62FE\u62F4\u6311\u6302\u653F\u6545\u65AB\u65BD\u65E2\u6625\u662D\u6620\u6627\u662F\u661F\u6628\u6631\u6624\u66F7\u67FF\u67D3\u67F1\u67D4\u67D0\u67EC\u67B6\u67AF\u67F5\u67E9\u67EF\u67C4\u67D1\u67B4\u67DA\u67E5\u67B8\u67CF\u67DE\u67F3\u67B0\u67D9\u67E2\u67DD\u67D2\u6B6A\u6B83\u6B86\u6BB5\u6BD2\u6BD7\u6C1F\u6CC9\u6D0B\u6D32\u6D2A\u6D41\u6D25\u6D0C\u6D31\u6D1E\u6D17"],
      ["aca1", "\u6D3B\u6D3D\u6D3E\u6D36\u6D1B\u6CF5\u6D39\u6D27\u6D38\u6D29\u6D2E\u6D35\u6D0E\u6D2B\u70AB\u70BA\u70B3\u70AC\u70AF\u70AD\u70B8\u70AE\u70A4\u7230\u7272\u726F\u7274\u72E9\u72E0\u72E1\u73B7\u73CA\u73BB\u73B2\u73CD\u73C0\u73B3\u751A\u752D\u754F\u754C\u754E\u754B\u75AB\u75A4\u75A5\u75A2\u75A3\u7678\u7686\u7687\u7688\u76C8\u76C6\u76C3\u76C5\u7701\u76F9\u76F8\u7709\u770B\u76FE\u76FC\u7707\u77DC\u7802\u7814\u780C\u780D\u7946\u7949\u7948\u7947\u79B9\u79BA\u79D1\u79D2\u79CB\u7A7F\u7A81\u7AFF\u7AFD\u7C7D\u7D02\u7D05\u7D00\u7D09\u7D07\u7D04\u7D06\u7F38\u7F8E\u7FBF\u8004"],
      ["ad40", "\u8010\u800D\u8011\u8036\u80D6\u80E5\u80DA\u80C3\u80C4\u80CC\u80E1\u80DB\u80CE\u80DE\u80E4\u80DD\u81F4\u8222\u82E7\u8303\u8305\u82E3\u82DB\u82E6\u8304\u82E5\u8302\u8309\u82D2\u82D7\u82F1\u8301\u82DC\u82D4\u82D1\u82DE\u82D3\u82DF\u82EF\u8306\u8650\u8679\u867B\u867A\u884D\u886B\u8981\u89D4\u8A08\u8A02\u8A03\u8C9E\u8CA0\u8D74\u8D73\u8DB4\u8ECD\u8ECC\u8FF0\u8FE6\u8FE2\u8FEA\u8FE5"],
      ["ada1", "\u8FED\u8FEB\u8FE4\u8FE8\u90CA\u90CE\u90C1\u90C3\u914B\u914A\u91CD\u9582\u9650\u964B\u964C\u964D\u9762\u9769\u97CB\u97ED\u97F3\u9801\u98A8\u98DB\u98DF\u9996\u9999\u4E58\u4EB3\u500C\u500D\u5023\u4FEF\u5026\u5025\u4FF8\u5029\u5016\u5006\u503C\u501F\u501A\u5012\u5011\u4FFA\u5000\u5014\u5028\u4FF1\u5021\u500B\u5019\u5018\u4FF3\u4FEE\u502D\u502A\u4FFE\u502B\u5009\u517C\u51A4\u51A5\u51A2\u51CD\u51CC\u51C6\u51CB\u5256\u525C\u5254\u525B\u525D\u532A\u537F\u539F\u539D\u53DF\u54E8\u5510\u5501\u5537\u54FC\u54E5\u54F2\u5506\u54FA\u5514\u54E9\u54ED\u54E1\u5509\u54EE\u54EA"],
      ["ae40", "\u54E6\u5527\u5507\u54FD\u550F\u5703\u5704\u57C2\u57D4\u57CB\u57C3\u5809\u590F\u5957\u5958\u595A\u5A11\u5A18\u5A1C\u5A1F\u5A1B\u5A13\u59EC\u5A20\u5A23\u5A29\u5A25\u5A0C\u5A09\u5B6B\u5C58\u5BB0\u5BB3\u5BB6\u5BB4\u5BAE\u5BB5\u5BB9\u5BB8\u5C04\u5C51\u5C55\u5C50\u5CED\u5CFD\u5CFB\u5CEA\u5CE8\u5CF0\u5CF6\u5D01\u5CF4\u5DEE\u5E2D\u5E2B\u5EAB\u5EAD\u5EA7\u5F31\u5F92\u5F91\u5F90\u6059"],
      ["aea1", "\u6063\u6065\u6050\u6055\u606D\u6069\u606F\u6084\u609F\u609A\u608D\u6094\u608C\u6085\u6096\u6247\u62F3\u6308\u62FF\u634E\u633E\u632F\u6355\u6342\u6346\u634F\u6349\u633A\u6350\u633D\u632A\u632B\u6328\u634D\u634C\u6548\u6549\u6599\u65C1\u65C5\u6642\u6649\u664F\u6643\u6652\u664C\u6645\u6641\u66F8\u6714\u6715\u6717\u6821\u6838\u6848\u6846\u6853\u6839\u6842\u6854\u6829\u68B3\u6817\u684C\u6851\u683D\u67F4\u6850\u6840\u683C\u6843\u682A\u6845\u6813\u6818\u6841\u6B8A\u6B89\u6BB7\u6C23\u6C27\u6C28\u6C26\u6C24\u6CF0\u6D6A\u6D95\u6D88\u6D87\u6D66\u6D78\u6D77\u6D59\u6D93"],
      ["af40", "\u6D6C\u6D89\u6D6E\u6D5A\u6D74\u6D69\u6D8C\u6D8A\u6D79\u6D85\u6D65\u6D94\u70CA\u70D8\u70E4\u70D9\u70C8\u70CF\u7239\u7279\u72FC\u72F9\u72FD\u72F8\u72F7\u7386\u73ED\u7409\u73EE\u73E0\u73EA\u73DE\u7554\u755D\u755C\u755A\u7559\u75BE\u75C5\u75C7\u75B2\u75B3\u75BD\u75BC\u75B9\u75C2\u75B8\u768B\u76B0\u76CA\u76CD\u76CE\u7729\u771F\u7720\u7728\u77E9\u7830\u7827\u7838\u781D\u7834\u7837"],
      ["afa1", "\u7825\u782D\u7820\u781F\u7832\u7955\u7950\u7960\u795F\u7956\u795E\u795D\u7957\u795A\u79E4\u79E3\u79E7\u79DF\u79E6\u79E9\u79D8\u7A84\u7A88\u7AD9\u7B06\u7B11\u7C89\u7D21\u7D17\u7D0B\u7D0A\u7D20\u7D22\u7D14\u7D10\u7D15\u7D1A\u7D1C\u7D0D\u7D19\u7D1B\u7F3A\u7F5F\u7F94\u7FC5\u7FC1\u8006\u8018\u8015\u8019\u8017\u803D\u803F\u80F1\u8102\u80F0\u8105\u80ED\u80F4\u8106\u80F8\u80F3\u8108\u80FD\u810A\u80FC\u80EF\u81ED\u81EC\u8200\u8210\u822A\u822B\u8228\u822C\u82BB\u832B\u8352\u8354\u834A\u8338\u8350\u8349\u8335\u8334\u834F\u8332\u8339\u8336\u8317\u8340\u8331\u8328\u8343"],
      ["b040", "\u8654\u868A\u86AA\u8693\u86A4\u86A9\u868C\u86A3\u869C\u8870\u8877\u8881\u8882\u887D\u8879\u8A18\u8A10\u8A0E\u8A0C\u8A15\u8A0A\u8A17\u8A13\u8A16\u8A0F\u8A11\u8C48\u8C7A\u8C79\u8CA1\u8CA2\u8D77\u8EAC\u8ED2\u8ED4\u8ECF\u8FB1\u9001\u9006\u8FF7\u9000\u8FFA\u8FF4\u9003\u8FFD\u9005\u8FF8\u9095\u90E1\u90DD\u90E2\u9152\u914D\u914C\u91D8\u91DD\u91D7\u91DC\u91D9\u9583\u9662\u9663\u9661"],
      ["b0a1", "\u965B\u965D\u9664\u9658\u965E\u96BB\u98E2\u99AC\u9AA8\u9AD8\u9B25\u9B32\u9B3C\u4E7E\u507A\u507D\u505C\u5047\u5043\u504C\u505A\u5049\u5065\u5076\u504E\u5055\u5075\u5074\u5077\u504F\u500F\u506F\u506D\u515C\u5195\u51F0\u526A\u526F\u52D2\u52D9\u52D8\u52D5\u5310\u530F\u5319\u533F\u5340\u533E\u53C3\u66FC\u5546\u556A\u5566\u5544\u555E\u5561\u5543\u554A\u5531\u5556\u554F\u5555\u552F\u5564\u5538\u552E\u555C\u552C\u5563\u5533\u5541\u5557\u5708\u570B\u5709\u57DF\u5805\u580A\u5806\u57E0\u57E4\u57FA\u5802\u5835\u57F7\u57F9\u5920\u5962\u5A36\u5A41\u5A49\u5A66\u5A6A\u5A40"],
      ["b140", "\u5A3C\u5A62\u5A5A\u5A46\u5A4A\u5B70\u5BC7\u5BC5\u5BC4\u5BC2\u5BBF\u5BC6\u5C09\u5C08\u5C07\u5C60\u5C5C\u5C5D\u5D07\u5D06\u5D0E\u5D1B\u5D16\u5D22\u5D11\u5D29\u5D14\u5D19\u5D24\u5D27\u5D17\u5DE2\u5E38\u5E36\u5E33\u5E37\u5EB7\u5EB8\u5EB6\u5EB5\u5EBE\u5F35\u5F37\u5F57\u5F6C\u5F69\u5F6B\u5F97\u5F99\u5F9E\u5F98\u5FA1\u5FA0\u5F9C\u607F\u60A3\u6089\u60A0\u60A8\u60CB\u60B4\u60E6\u60BD"],
      ["b1a1", "\u60C5\u60BB\u60B5\u60DC\u60BC\u60D8\u60D5\u60C6\u60DF\u60B8\u60DA\u60C7\u621A\u621B\u6248\u63A0\u63A7\u6372\u6396\u63A2\u63A5\u6377\u6367\u6398\u63AA\u6371\u63A9\u6389\u6383\u639B\u636B\u63A8\u6384\u6388\u6399\u63A1\u63AC\u6392\u638F\u6380\u637B\u6369\u6368\u637A\u655D\u6556\u6551\u6559\u6557\u555F\u654F\u6558\u6555\u6554\u659C\u659B\u65AC\u65CF\u65CB\u65CC\u65CE\u665D\u665A\u6664\u6668\u6666\u665E\u66F9\u52D7\u671B\u6881\u68AF\u68A2\u6893\u68B5\u687F\u6876\u68B1\u68A7\u6897\u68B0\u6883\u68C4\u68AD\u6886\u6885\u6894\u689D\u68A8\u689F\u68A1\u6882\u6B32\u6BBA"],
      ["b240", "\u6BEB\u6BEC\u6C2B\u6D8E\u6DBC\u6DF3\u6DD9\u6DB2\u6DE1\u6DCC\u6DE4\u6DFB\u6DFA\u6E05\u6DC7\u6DCB\u6DAF\u6DD1\u6DAE\u6DDE\u6DF9\u6DB8\u6DF7\u6DF5\u6DC5\u6DD2\u6E1A\u6DB5\u6DDA\u6DEB\u6DD8\u6DEA\u6DF1\u6DEE\u6DE8\u6DC6\u6DC4\u6DAA\u6DEC\u6DBF\u6DE6\u70F9\u7109\u710A\u70FD\u70EF\u723D\u727D\u7281\u731C\u731B\u7316\u7313\u7319\u7387\u7405\u740A\u7403\u7406\u73FE\u740D\u74E0\u74F6"],
      ["b2a1", "\u74F7\u751C\u7522\u7565\u7566\u7562\u7570\u758F\u75D4\u75D5\u75B5\u75CA\u75CD\u768E\u76D4\u76D2\u76DB\u7737\u773E\u773C\u7736\u7738\u773A\u786B\u7843\u784E\u7965\u7968\u796D\u79FB\u7A92\u7A95\u7B20\u7B28\u7B1B\u7B2C\u7B26\u7B19\u7B1E\u7B2E\u7C92\u7C97\u7C95\u7D46\u7D43\u7D71\u7D2E\u7D39\u7D3C\u7D40\u7D30\u7D33\u7D44\u7D2F\u7D42\u7D32\u7D31\u7F3D\u7F9E\u7F9A\u7FCC\u7FCE\u7FD2\u801C\u804A\u8046\u812F\u8116\u8123\u812B\u8129\u8130\u8124\u8202\u8235\u8237\u8236\u8239\u838E\u839E\u8398\u8378\u83A2\u8396\u83BD\u83AB\u8392\u838A\u8393\u8389\u83A0\u8377\u837B\u837C"],
      ["b340", "\u8386\u83A7\u8655\u5F6A\u86C7\u86C0\u86B6\u86C4\u86B5\u86C6\u86CB\u86B1\u86AF\u86C9\u8853\u889E\u8888\u88AB\u8892\u8896\u888D\u888B\u8993\u898F\u8A2A\u8A1D\u8A23\u8A25\u8A31\u8A2D\u8A1F\u8A1B\u8A22\u8C49\u8C5A\u8CA9\u8CAC\u8CAB\u8CA8\u8CAA\u8CA7\u8D67\u8D66\u8DBE\u8DBA\u8EDB\u8EDF\u9019\u900D\u901A\u9017\u9023\u901F\u901D\u9010\u9015\u901E\u9020\u900F\u9022\u9016\u901B\u9014"],
      ["b3a1", "\u90E8\u90ED\u90FD\u9157\u91CE\u91F5\u91E6\u91E3\u91E7\u91ED\u91E9\u9589\u966A\u9675\u9673\u9678\u9670\u9674\u9676\u9677\u966C\u96C0\u96EA\u96E9\u7AE0\u7ADF\u9802\u9803\u9B5A\u9CE5\u9E75\u9E7F\u9EA5\u9EBB\u50A2\u508D\u5085\u5099\u5091\u5080\u5096\u5098\u509A\u6700\u51F1\u5272\u5274\u5275\u5269\u52DE\u52DD\u52DB\u535A\u53A5\u557B\u5580\u55A7\u557C\u558A\u559D\u5598\u5582\u559C\u55AA\u5594\u5587\u558B\u5583\u55B3\u55AE\u559F\u553E\u55B2\u559A\u55BB\u55AC\u55B1\u557E\u5589\u55AB\u5599\u570D\u582F\u582A\u5834\u5824\u5830\u5831\u5821\u581D\u5820\u58F9\u58FA\u5960"],
      ["b440", "\u5A77\u5A9A\u5A7F\u5A92\u5A9B\u5AA7\u5B73\u5B71\u5BD2\u5BCC\u5BD3\u5BD0\u5C0A\u5C0B\u5C31\u5D4C\u5D50\u5D34\u5D47\u5DFD\u5E45\u5E3D\u5E40\u5E43\u5E7E\u5ECA\u5EC1\u5EC2\u5EC4\u5F3C\u5F6D\u5FA9\u5FAA\u5FA8\u60D1\u60E1\u60B2\u60B6\u60E0\u611C\u6123\u60FA\u6115\u60F0\u60FB\u60F4\u6168\u60F1\u610E\u60F6\u6109\u6100\u6112\u621F\u6249\u63A3\u638C\u63CF\u63C0\u63E9\u63C9\u63C6\u63CD"],
      ["b4a1", "\u63D2\u63E3\u63D0\u63E1\u63D6\u63ED\u63EE\u6376\u63F4\u63EA\u63DB\u6452\u63DA\u63F9\u655E\u6566\u6562\u6563\u6591\u6590\u65AF\u666E\u6670\u6674\u6676\u666F\u6691\u667A\u667E\u6677\u66FE\u66FF\u671F\u671D\u68FA\u68D5\u68E0\u68D8\u68D7\u6905\u68DF\u68F5\u68EE\u68E7\u68F9\u68D2\u68F2\u68E3\u68CB\u68CD\u690D\u6912\u690E\u68C9\u68DA\u696E\u68FB\u6B3E\u6B3A\u6B3D\u6B98\u6B96\u6BBC\u6BEF\u6C2E\u6C2F\u6C2C\u6E2F\u6E38\u6E54\u6E21\u6E32\u6E67\u6E4A\u6E20\u6E25\u6E23\u6E1B\u6E5B\u6E58\u6E24\u6E56\u6E6E\u6E2D\u6E26\u6E6F\u6E34\u6E4D\u6E3A\u6E2C\u6E43\u6E1D\u6E3E\u6ECB"],
      ["b540", "\u6E89\u6E19\u6E4E\u6E63\u6E44\u6E72\u6E69\u6E5F\u7119\u711A\u7126\u7130\u7121\u7136\u716E\u711C\u724C\u7284\u7280\u7336\u7325\u7334\u7329\u743A\u742A\u7433\u7422\u7425\u7435\u7436\u7434\u742F\u741B\u7426\u7428\u7525\u7526\u756B\u756A\u75E2\u75DB\u75E3\u75D9\u75D8\u75DE\u75E0\u767B\u767C\u7696\u7693\u76B4\u76DC\u774F\u77ED\u785D\u786C\u786F\u7A0D\u7A08\u7A0B\u7A05\u7A00\u7A98"],
      ["b5a1", "\u7A97\u7A96\u7AE5\u7AE3\u7B49\u7B56\u7B46\u7B50\u7B52\u7B54\u7B4D\u7B4B\u7B4F\u7B51\u7C9F\u7CA5\u7D5E\u7D50\u7D68\u7D55\u7D2B\u7D6E\u7D72\u7D61\u7D66\u7D62\u7D70\u7D73\u5584\u7FD4\u7FD5\u800B\u8052\u8085\u8155\u8154\u814B\u8151\u814E\u8139\u8146\u813E\u814C\u8153\u8174\u8212\u821C\u83E9\u8403\u83F8\u840D\u83E0\u83C5\u840B\u83C1\u83EF\u83F1\u83F4\u8457\u840A\u83F0\u840C\u83CC\u83FD\u83F2\u83CA\u8438\u840E\u8404\u83DC\u8407\u83D4\u83DF\u865B\u86DF\u86D9\u86ED\u86D4\u86DB\u86E4\u86D0\u86DE\u8857\u88C1\u88C2\u88B1\u8983\u8996\u8A3B\u8A60\u8A55\u8A5E\u8A3C\u8A41"],
      ["b640", "\u8A54\u8A5B\u8A50\u8A46\u8A34\u8A3A\u8A36\u8A56\u8C61\u8C82\u8CAF\u8CBC\u8CB3\u8CBD\u8CC1\u8CBB\u8CC0\u8CB4\u8CB7\u8CB6\u8CBF\u8CB8\u8D8A\u8D85\u8D81\u8DCE\u8DDD\u8DCB\u8DDA\u8DD1\u8DCC\u8DDB\u8DC6\u8EFB\u8EF8\u8EFC\u8F9C\u902E\u9035\u9031\u9038\u9032\u9036\u9102\u90F5\u9109\u90FE\u9163\u9165\u91CF\u9214\u9215\u9223\u9209\u921E\u920D\u9210\u9207\u9211\u9594\u958F\u958B\u9591"],
      ["b6a1", "\u9593\u9592\u958E\u968A\u968E\u968B\u967D\u9685\u9686\u968D\u9672\u9684\u96C1\u96C5\u96C4\u96C6\u96C7\u96EF\u96F2\u97CC\u9805\u9806\u9808\u98E7\u98EA\u98EF\u98E9\u98F2\u98ED\u99AE\u99AD\u9EC3\u9ECD\u9ED1\u4E82\u50AD\u50B5\u50B2\u50B3\u50C5\u50BE\u50AC\u50B7\u50BB\u50AF\u50C7\u527F\u5277\u527D\u52DF\u52E6\u52E4\u52E2\u52E3\u532F\u55DF\u55E8\u55D3\u55E6\u55CE\u55DC\u55C7\u55D1\u55E3\u55E4\u55EF\u55DA\u55E1\u55C5\u55C6\u55E5\u55C9\u5712\u5713\u585E\u5851\u5858\u5857\u585A\u5854\u586B\u584C\u586D\u584A\u5862\u5852\u584B\u5967\u5AC1\u5AC9\u5ACC\u5ABE\u5ABD\u5ABC"],
      ["b740", "\u5AB3\u5AC2\u5AB2\u5D69\u5D6F\u5E4C\u5E79\u5EC9\u5EC8\u5F12\u5F59\u5FAC\u5FAE\u611A\u610F\u6148\u611F\u60F3\u611B\u60F9\u6101\u6108\u614E\u614C\u6144\u614D\u613E\u6134\u6127\u610D\u6106\u6137\u6221\u6222\u6413\u643E\u641E\u642A\u642D\u643D\u642C\u640F\u641C\u6414\u640D\u6436\u6416\u6417\u6406\u656C\u659F\u65B0\u6697\u6689\u6687\u6688\u6696\u6684\u6698\u668D\u6703\u6994\u696D"],
      ["b7a1", "\u695A\u6977\u6960\u6954\u6975\u6930\u6982\u694A\u6968\u696B\u695E\u6953\u6979\u6986\u695D\u6963\u695B\u6B47\u6B72\u6BC0\u6BBF\u6BD3\u6BFD\u6EA2\u6EAF\u6ED3\u6EB6\u6EC2\u6E90\u6E9D\u6EC7\u6EC5\u6EA5\u6E98\u6EBC\u6EBA\u6EAB\u6ED1\u6E96\u6E9C\u6EC4\u6ED4\u6EAA\u6EA7\u6EB4\u714E\u7159\u7169\u7164\u7149\u7167\u715C\u716C\u7166\u714C\u7165\u715E\u7146\u7168\u7156\u723A\u7252\u7337\u7345\u733F\u733E\u746F\u745A\u7455\u745F\u745E\u7441\u743F\u7459\u745B\u745C\u7576\u7578\u7600\u75F0\u7601\u75F2\u75F1\u75FA\u75FF\u75F4\u75F3\u76DE\u76DF\u775B\u776B\u7766\u775E\u7763"],
      ["b840", "\u7779\u776A\u776C\u775C\u7765\u7768\u7762\u77EE\u788E\u78B0\u7897\u7898\u788C\u7889\u787C\u7891\u7893\u787F\u797A\u797F\u7981\u842C\u79BD\u7A1C\u7A1A\u7A20\u7A14\u7A1F\u7A1E\u7A9F\u7AA0\u7B77\u7BC0\u7B60\u7B6E\u7B67\u7CB1\u7CB3\u7CB5\u7D93\u7D79\u7D91\u7D81\u7D8F\u7D5B\u7F6E\u7F69\u7F6A\u7F72\u7FA9\u7FA8\u7FA4\u8056\u8058\u8086\u8084\u8171\u8170\u8178\u8165\u816E\u8173\u816B"],
      ["b8a1", "\u8179\u817A\u8166\u8205\u8247\u8482\u8477\u843D\u8431\u8475\u8466\u846B\u8449\u846C\u845B\u843C\u8435\u8461\u8463\u8469\u846D\u8446\u865E\u865C\u865F\u86F9\u8713\u8708\u8707\u8700\u86FE\u86FB\u8702\u8703\u8706\u870A\u8859\u88DF\u88D4\u88D9\u88DC\u88D8\u88DD\u88E1\u88CA\u88D5\u88D2\u899C\u89E3\u8A6B\u8A72\u8A73\u8A66\u8A69\u8A70\u8A87\u8A7C\u8A63\u8AA0\u8A71\u8A85\u8A6D\u8A62\u8A6E\u8A6C\u8A79\u8A7B\u8A3E\u8A68\u8C62\u8C8A\u8C89\u8CCA\u8CC7\u8CC8\u8CC4\u8CB2\u8CC3\u8CC2\u8CC5\u8DE1\u8DDF\u8DE8\u8DEF\u8DF3\u8DFA\u8DEA\u8DE4\u8DE6\u8EB2\u8F03\u8F09\u8EFE\u8F0A"],
      ["b940", "\u8F9F\u8FB2\u904B\u904A\u9053\u9042\u9054\u903C\u9055\u9050\u9047\u904F\u904E\u904D\u9051\u903E\u9041\u9112\u9117\u916C\u916A\u9169\u91C9\u9237\u9257\u9238\u923D\u9240\u923E\u925B\u924B\u9264\u9251\u9234\u9249\u924D\u9245\u9239\u923F\u925A\u9598\u9698\u9694\u9695\u96CD\u96CB\u96C9\u96CA\u96F7\u96FB\u96F9\u96F6\u9756\u9774\u9776\u9810\u9811\u9813\u980A\u9812\u980C\u98FC\u98F4"],
      ["b9a1", "\u98FD\u98FE\u99B3\u99B1\u99B4\u9AE1\u9CE9\u9E82\u9F0E\u9F13\u9F20\u50E7\u50EE\u50E5\u50D6\u50ED\u50DA\u50D5\u50CF\u50D1\u50F1\u50CE\u50E9\u5162\u51F3\u5283\u5282\u5331\u53AD\u55FE\u5600\u561B\u5617\u55FD\u5614\u5606\u5609\u560D\u560E\u55F7\u5616\u561F\u5608\u5610\u55F6\u5718\u5716\u5875\u587E\u5883\u5893\u588A\u5879\u5885\u587D\u58FD\u5925\u5922\u5924\u596A\u5969\u5AE1\u5AE6\u5AE9\u5AD7\u5AD6\u5AD8\u5AE3\u5B75\u5BDE\u5BE7\u5BE1\u5BE5\u5BE6\u5BE8\u5BE2\u5BE4\u5BDF\u5C0D\u5C62\u5D84\u5D87\u5E5B\u5E63\u5E55\u5E57\u5E54\u5ED3\u5ED6\u5F0A\u5F46\u5F70\u5FB9\u6147"],
      ["ba40", "\u613F\u614B\u6177\u6162\u6163\u615F\u615A\u6158\u6175\u622A\u6487\u6458\u6454\u64A4\u6478\u645F\u647A\u6451\u6467\u6434\u646D\u647B\u6572\u65A1\u65D7\u65D6\u66A2\u66A8\u669D\u699C\u69A8\u6995\u69C1\u69AE\u69D3\u69CB\u699B\u69B7\u69BB\u69AB\u69B4\u69D0\u69CD\u69AD\u69CC\u69A6\u69C3\u69A3\u6B49\u6B4C\u6C33\u6F33\u6F14\u6EFE\u6F13\u6EF4\u6F29\u6F3E\u6F20\u6F2C\u6F0F\u6F02\u6F22"],
      ["baa1", "\u6EFF\u6EEF\u6F06\u6F31\u6F38\u6F32\u6F23\u6F15\u6F2B\u6F2F\u6F88\u6F2A\u6EEC\u6F01\u6EF2\u6ECC\u6EF7\u7194\u7199\u717D\u718A\u7184\u7192\u723E\u7292\u7296\u7344\u7350\u7464\u7463\u746A\u7470\u746D\u7504\u7591\u7627\u760D\u760B\u7609\u7613\u76E1\u76E3\u7784\u777D\u777F\u7761\u78C1\u789F\u78A7\u78B3\u78A9\u78A3\u798E\u798F\u798D\u7A2E\u7A31\u7AAA\u7AA9\u7AED\u7AEF\u7BA1\u7B95\u7B8B\u7B75\u7B97\u7B9D\u7B94\u7B8F\u7BB8\u7B87\u7B84\u7CB9\u7CBD\u7CBE\u7DBB\u7DB0\u7D9C\u7DBD\u7DBE\u7DA0\u7DCA\u7DB4\u7DB2\u7DB1\u7DBA\u7DA2\u7DBF\u7DB5\u7DB8\u7DAD\u7DD2\u7DC7\u7DAC"],
      ["bb40", "\u7F70\u7FE0\u7FE1\u7FDF\u805E\u805A\u8087\u8150\u8180\u818F\u8188\u818A\u817F\u8182\u81E7\u81FA\u8207\u8214\u821E\u824B\u84C9\u84BF\u84C6\u84C4\u8499\u849E\u84B2\u849C\u84CB\u84B8\u84C0\u84D3\u8490\u84BC\u84D1\u84CA\u873F\u871C\u873B\u8722\u8725\u8734\u8718\u8755\u8737\u8729\u88F3\u8902\u88F4\u88F9\u88F8\u88FD\u88E8\u891A\u88EF\u8AA6\u8A8C\u8A9E\u8AA3\u8A8D\u8AA1\u8A93\u8AA4"],
      ["bba1", "\u8AAA\u8AA5\u8AA8\u8A98\u8A91\u8A9A\u8AA7\u8C6A\u8C8D\u8C8C\u8CD3\u8CD1\u8CD2\u8D6B\u8D99\u8D95\u8DFC\u8F14\u8F12\u8F15\u8F13\u8FA3\u9060\u9058\u905C\u9063\u9059\u905E\u9062\u905D\u905B\u9119\u9118\u911E\u9175\u9178\u9177\u9174\u9278\u9280\u9285\u9298\u9296\u927B\u9293\u929C\u92A8\u927C\u9291\u95A1\u95A8\u95A9\u95A3\u95A5\u95A4\u9699\u969C\u969B\u96CC\u96D2\u9700\u977C\u9785\u97F6\u9817\u9818\u98AF\u98B1\u9903\u9905\u990C\u9909\u99C1\u9AAF\u9AB0\u9AE6\u9B41\u9B42\u9CF4\u9CF6\u9CF3\u9EBC\u9F3B\u9F4A\u5104\u5100\u50FB\u50F5\u50F9\u5102\u5108\u5109\u5105\u51DC"],
      ["bc40", "\u5287\u5288\u5289\u528D\u528A\u52F0\u53B2\u562E\u563B\u5639\u5632\u563F\u5634\u5629\u5653\u564E\u5657\u5674\u5636\u562F\u5630\u5880\u589F\u589E\u58B3\u589C\u58AE\u58A9\u58A6\u596D\u5B09\u5AFB\u5B0B\u5AF5\u5B0C\u5B08\u5BEE\u5BEC\u5BE9\u5BEB\u5C64\u5C65\u5D9D\u5D94\u5E62\u5E5F\u5E61\u5EE2\u5EDA\u5EDF\u5EDD\u5EE3\u5EE0\u5F48\u5F71\u5FB7\u5FB5\u6176\u6167\u616E\u615D\u6155\u6182"],
      ["bca1", "\u617C\u6170\u616B\u617E\u61A7\u6190\u61AB\u618E\u61AC\u619A\u61A4\u6194\u61AE\u622E\u6469\u646F\u6479\u649E\u64B2\u6488\u6490\u64B0\u64A5\u6493\u6495\u64A9\u6492\u64AE\u64AD\u64AB\u649A\u64AC\u6499\u64A2\u64B3\u6575\u6577\u6578\u66AE\u66AB\u66B4\u66B1\u6A23\u6A1F\u69E8\u6A01\u6A1E\u6A19\u69FD\u6A21\u6A13\u6A0A\u69F3\u6A02\u6A05\u69ED\u6A11\u6B50\u6B4E\u6BA4\u6BC5\u6BC6\u6F3F\u6F7C\u6F84\u6F51\u6F66\u6F54\u6F86\u6F6D\u6F5B\u6F78\u6F6E\u6F8E\u6F7A\u6F70\u6F64\u6F97\u6F58\u6ED5\u6F6F\u6F60\u6F5F\u719F\u71AC\u71B1\u71A8\u7256\u729B\u734E\u7357\u7469\u748B\u7483"],
      ["bd40", "\u747E\u7480\u757F\u7620\u7629\u761F\u7624\u7626\u7621\u7622\u769A\u76BA\u76E4\u778E\u7787\u778C\u7791\u778B\u78CB\u78C5\u78BA\u78CA\u78BE\u78D5\u78BC\u78D0\u7A3F\u7A3C\u7A40\u7A3D\u7A37\u7A3B\u7AAF\u7AAE\u7BAD\u7BB1\u7BC4\u7BB4\u7BC6\u7BC7\u7BC1\u7BA0\u7BCC\u7CCA\u7DE0\u7DF4\u7DEF\u7DFB\u7DD8\u7DEC\u7DDD\u7DE8\u7DE3\u7DDA\u7DDE\u7DE9\u7D9E\u7DD9\u7DF2\u7DF9\u7F75\u7F77\u7FAF"],
      ["bda1", "\u7FE9\u8026\u819B\u819C\u819D\u81A0\u819A\u8198\u8517\u853D\u851A\u84EE\u852C\u852D\u8513\u8511\u8523\u8521\u8514\u84EC\u8525\u84FF\u8506\u8782\u8774\u8776\u8760\u8766\u8778\u8768\u8759\u8757\u874C\u8753\u885B\u885D\u8910\u8907\u8912\u8913\u8915\u890A\u8ABC\u8AD2\u8AC7\u8AC4\u8A95\u8ACB\u8AF8\u8AB2\u8AC9\u8AC2\u8ABF\u8AB0\u8AD6\u8ACD\u8AB6\u8AB9\u8ADB\u8C4C\u8C4E\u8C6C\u8CE0\u8CDE\u8CE6\u8CE4\u8CEC\u8CED\u8CE2\u8CE3\u8CDC\u8CEA\u8CE1\u8D6D\u8D9F\u8DA3\u8E2B\u8E10\u8E1D\u8E22\u8E0F\u8E29\u8E1F\u8E21\u8E1E\u8EBA\u8F1D\u8F1B\u8F1F\u8F29\u8F26\u8F2A\u8F1C\u8F1E"],
      ["be40", "\u8F25\u9069\u906E\u9068\u906D\u9077\u9130\u912D\u9127\u9131\u9187\u9189\u918B\u9183\u92C5\u92BB\u92B7\u92EA\u92AC\u92E4\u92C1\u92B3\u92BC\u92D2\u92C7\u92F0\u92B2\u95AD\u95B1\u9704\u9706\u9707\u9709\u9760\u978D\u978B\u978F\u9821\u982B\u981C\u98B3\u990A\u9913\u9912\u9918\u99DD\u99D0\u99DF\u99DB\u99D1\u99D5\u99D2\u99D9\u9AB7\u9AEE\u9AEF\u9B27\u9B45\u9B44\u9B77\u9B6F\u9D06\u9D09"],
      ["bea1", "\u9D03\u9EA9\u9EBE\u9ECE\u58A8\u9F52\u5112\u5118\u5114\u5110\u5115\u5180\u51AA\u51DD\u5291\u5293\u52F3\u5659\u566B\u5679\u5669\u5664\u5678\u566A\u5668\u5665\u5671\u566F\u566C\u5662\u5676\u58C1\u58BE\u58C7\u58C5\u596E\u5B1D\u5B34\u5B78\u5BF0\u5C0E\u5F4A\u61B2\u6191\u61A9\u618A\u61CD\u61B6\u61BE\u61CA\u61C8\u6230\u64C5\u64C1\u64CB\u64BB\u64BC\u64DA\u64C4\u64C7\u64C2\u64CD\u64BF\u64D2\u64D4\u64BE\u6574\u66C6\u66C9\u66B9\u66C4\u66C7\u66B8\u6A3D\u6A38\u6A3A\u6A59\u6A6B\u6A58\u6A39\u6A44\u6A62\u6A61\u6A4B\u6A47\u6A35\u6A5F\u6A48\u6B59\u6B77\u6C05\u6FC2\u6FB1\u6FA1"],
      ["bf40", "\u6FC3\u6FA4\u6FC1\u6FA7\u6FB3\u6FC0\u6FB9\u6FB6\u6FA6\u6FA0\u6FB4\u71BE\u71C9\u71D0\u71D2\u71C8\u71D5\u71B9\u71CE\u71D9\u71DC\u71C3\u71C4\u7368\u749C\u74A3\u7498\u749F\u749E\u74E2\u750C\u750D\u7634\u7638\u763A\u76E7\u76E5\u77A0\u779E\u779F\u77A5\u78E8\u78DA\u78EC\u78E7\u79A6\u7A4D\u7A4E\u7A46\u7A4C\u7A4B\u7ABA\u7BD9\u7C11\u7BC9\u7BE4\u7BDB\u7BE1\u7BE9\u7BE6\u7CD5\u7CD6\u7E0A"],
      ["bfa1", "\u7E11\u7E08\u7E1B\u7E23\u7E1E\u7E1D\u7E09\u7E10\u7F79\u7FB2\u7FF0\u7FF1\u7FEE\u8028\u81B3\u81A9\u81A8\u81FB\u8208\u8258\u8259\u854A\u8559\u8548\u8568\u8569\u8543\u8549\u856D\u856A\u855E\u8783\u879F\u879E\u87A2\u878D\u8861\u892A\u8932\u8925\u892B\u8921\u89AA\u89A6\u8AE6\u8AFA\u8AEB\u8AF1\u8B00\u8ADC\u8AE7\u8AEE\u8AFE\u8B01\u8B02\u8AF7\u8AED\u8AF3\u8AF6\u8AFC\u8C6B\u8C6D\u8C93\u8CF4\u8E44\u8E31\u8E34\u8E42\u8E39\u8E35\u8F3B\u8F2F\u8F38\u8F33\u8FA8\u8FA6\u9075\u9074\u9078\u9072\u907C\u907A\u9134\u9192\u9320\u9336\u92F8\u9333\u932F\u9322\u92FC\u932B\u9304\u931A"],
      ["c040", "\u9310\u9326\u9321\u9315\u932E\u9319\u95BB\u96A7\u96A8\u96AA\u96D5\u970E\u9711\u9716\u970D\u9713\u970F\u975B\u975C\u9766\u9798\u9830\u9838\u983B\u9837\u982D\u9839\u9824\u9910\u9928\u991E\u991B\u9921\u991A\u99ED\u99E2\u99F1\u9AB8\u9ABC\u9AFB\u9AED\u9B28\u9B91\u9D15\u9D23\u9D26\u9D28\u9D12\u9D1B\u9ED8\u9ED4\u9F8D\u9F9C\u512A\u511F\u5121\u5132\u52F5\u568E\u5680\u5690\u5685\u5687"],
      ["c0a1", "\u568F\u58D5\u58D3\u58D1\u58CE\u5B30\u5B2A\u5B24\u5B7A\u5C37\u5C68\u5DBC\u5DBA\u5DBD\u5DB8\u5E6B\u5F4C\u5FBD\u61C9\u61C2\u61C7\u61E6\u61CB\u6232\u6234\u64CE\u64CA\u64D8\u64E0\u64F0\u64E6\u64EC\u64F1\u64E2\u64ED\u6582\u6583\u66D9\u66D6\u6A80\u6A94\u6A84\u6AA2\u6A9C\u6ADB\u6AA3\u6A7E\u6A97\u6A90\u6AA0\u6B5C\u6BAE\u6BDA\u6C08\u6FD8\u6FF1\u6FDF\u6FE0\u6FDB\u6FE4\u6FEB\u6FEF\u6F80\u6FEC\u6FE1\u6FE9\u6FD5\u6FEE\u6FF0\u71E7\u71DF\u71EE\u71E6\u71E5\u71ED\u71EC\u71F4\u71E0\u7235\u7246\u7370\u7372\u74A9\u74B0\u74A6\u74A8\u7646\u7642\u764C\u76EA\u77B3\u77AA\u77B0\u77AC"],
      ["c140", "\u77A7\u77AD\u77EF\u78F7\u78FA\u78F4\u78EF\u7901\u79A7\u79AA\u7A57\u7ABF\u7C07\u7C0D\u7BFE\u7BF7\u7C0C\u7BE0\u7CE0\u7CDC\u7CDE\u7CE2\u7CDF\u7CD9\u7CDD\u7E2E\u7E3E\u7E46\u7E37\u7E32\u7E43\u7E2B\u7E3D\u7E31\u7E45\u7E41\u7E34\u7E39\u7E48\u7E35\u7E3F\u7E2F\u7F44\u7FF3\u7FFC\u8071\u8072\u8070\u806F\u8073\u81C6\u81C3\u81BA\u81C2\u81C0\u81BF\u81BD\u81C9\u81BE\u81E8\u8209\u8271\u85AA"],
      ["c1a1", "\u8584\u857E\u859C\u8591\u8594\u85AF\u859B\u8587\u85A8\u858A\u8667\u87C0\u87D1\u87B3\u87D2\u87C6\u87AB\u87BB\u87BA\u87C8\u87CB\u893B\u8936\u8944\u8938\u893D\u89AC\u8B0E\u8B17\u8B19\u8B1B\u8B0A\u8B20\u8B1D\u8B04\u8B10\u8C41\u8C3F\u8C73\u8CFA\u8CFD\u8CFC\u8CF8\u8CFB\u8DA8\u8E49\u8E4B\u8E48\u8E4A\u8F44\u8F3E\u8F42\u8F45\u8F3F\u907F\u907D\u9084\u9081\u9082\u9080\u9139\u91A3\u919E\u919C\u934D\u9382\u9328\u9375\u934A\u9365\u934B\u9318\u937E\u936C\u935B\u9370\u935A\u9354\u95CA\u95CB\u95CC\u95C8\u95C6\u96B1\u96B8\u96D6\u971C\u971E\u97A0\u97D3\u9846\u98B6\u9935\u9A01"],
      ["c240", "\u99FF\u9BAE\u9BAB\u9BAA\u9BAD\u9D3B\u9D3F\u9E8B\u9ECF\u9EDE\u9EDC\u9EDD\u9EDB\u9F3E\u9F4B\u53E2\u5695\u56AE\u58D9\u58D8\u5B38\u5F5D\u61E3\u6233\u64F4\u64F2\u64FE\u6506\u64FA\u64FB\u64F7\u65B7\u66DC\u6726\u6AB3\u6AAC\u6AC3\u6ABB\u6AB8\u6AC2\u6AAE\u6AAF\u6B5F\u6B78\u6BAF\u7009\u700B\u6FFE\u7006\u6FFA\u7011\u700F\u71FB\u71FC\u71FE\u71F8\u7377\u7375\u74A7\u74BF\u7515\u7656\u7658"],
      ["c2a1", "\u7652\u77BD\u77BF\u77BB\u77BC\u790E\u79AE\u7A61\u7A62\u7A60\u7AC4\u7AC5\u7C2B\u7C27\u7C2A\u7C1E\u7C23\u7C21\u7CE7\u7E54\u7E55\u7E5E\u7E5A\u7E61\u7E52\u7E59\u7F48\u7FF9\u7FFB\u8077\u8076\u81CD\u81CF\u820A\u85CF\u85A9\u85CD\u85D0\u85C9\u85B0\u85BA\u85B9\u85A6\u87EF\u87EC\u87F2\u87E0\u8986\u89B2\u89F4\u8B28\u8B39\u8B2C\u8B2B\u8C50\u8D05\u8E59\u8E63\u8E66\u8E64\u8E5F\u8E55\u8EC0\u8F49\u8F4D\u9087\u9083\u9088\u91AB\u91AC\u91D0\u9394\u938A\u9396\u93A2\u93B3\u93AE\u93AC\u93B0\u9398\u939A\u9397\u95D4\u95D6\u95D0\u95D5\u96E2\u96DC\u96D9\u96DB\u96DE\u9724\u97A3\u97A6"],
      ["c340", "\u97AD\u97F9\u984D\u984F\u984C\u984E\u9853\u98BA\u993E\u993F\u993D\u992E\u99A5\u9A0E\u9AC1\u9B03\u9B06\u9B4F\u9B4E\u9B4D\u9BCA\u9BC9\u9BFD\u9BC8\u9BC0\u9D51\u9D5D\u9D60\u9EE0\u9F15\u9F2C\u5133\u56A5\u58DE\u58DF\u58E2\u5BF5\u9F90\u5EEC\u61F2\u61F7\u61F6\u61F5\u6500\u650F\u66E0\u66DD\u6AE5\u6ADD\u6ADA\u6AD3\u701B\u701F\u7028\u701A\u701D\u7015\u7018\u7206\u720D\u7258\u72A2\u7378"],
      ["c3a1", "\u737A\u74BD\u74CA\u74E3\u7587\u7586\u765F\u7661\u77C7\u7919\u79B1\u7A6B\u7A69\u7C3E\u7C3F\u7C38\u7C3D\u7C37\u7C40\u7E6B\u7E6D\u7E79\u7E69\u7E6A\u7F85\u7E73\u7FB6\u7FB9\u7FB8\u81D8\u85E9\u85DD\u85EA\u85D5\u85E4\u85E5\u85F7\u87FB\u8805\u880D\u87F9\u87FE\u8960\u895F\u8956\u895E\u8B41\u8B5C\u8B58\u8B49\u8B5A\u8B4E\u8B4F\u8B46\u8B59\u8D08\u8D0A\u8E7C\u8E72\u8E87\u8E76\u8E6C\u8E7A\u8E74\u8F54\u8F4E\u8FAD\u908A\u908B\u91B1\u91AE\u93E1\u93D1\u93DF\u93C3\u93C8\u93DC\u93DD\u93D6\u93E2\u93CD\u93D8\u93E4\u93D7\u93E8\u95DC\u96B4\u96E3\u972A\u9727\u9761\u97DC\u97FB\u985E"],
      ["c440", "\u9858\u985B\u98BC\u9945\u9949\u9A16\u9A19\u9B0D\u9BE8\u9BE7\u9BD6\u9BDB\u9D89\u9D61\u9D72\u9D6A\u9D6C\u9E92\u9E97\u9E93\u9EB4\u52F8\u56A8\u56B7\u56B6\u56B4\u56BC\u58E4\u5B40\u5B43\u5B7D\u5BF6\u5DC9\u61F8\u61FA\u6518\u6514\u6519\u66E6\u6727\u6AEC\u703E\u7030\u7032\u7210\u737B\u74CF\u7662\u7665\u7926\u792A\u792C\u792B\u7AC7\u7AF6\u7C4C\u7C43\u7C4D\u7CEF\u7CF0\u8FAE\u7E7D\u7E7C"],
      ["c4a1", "\u7E82\u7F4C\u8000\u81DA\u8266\u85FB\u85F9\u8611\u85FA\u8606\u860B\u8607\u860A\u8814\u8815\u8964\u89BA\u89F8\u8B70\u8B6C\u8B66\u8B6F\u8B5F\u8B6B\u8D0F\u8D0D\u8E89\u8E81\u8E85\u8E82\u91B4\u91CB\u9418\u9403\u93FD\u95E1\u9730\u98C4\u9952\u9951\u99A8\u9A2B\u9A30\u9A37\u9A35\u9C13\u9C0D\u9E79\u9EB5\u9EE8\u9F2F\u9F5F\u9F63\u9F61\u5137\u5138\u56C1\u56C0\u56C2\u5914\u5C6C\u5DCD\u61FC\u61FE\u651D\u651C\u6595\u66E9\u6AFB\u6B04\u6AFA\u6BB2\u704C\u721B\u72A7\u74D6\u74D4\u7669\u77D3\u7C50\u7E8F\u7E8C\u7FBC\u8617\u862D\u861A\u8823\u8822\u8821\u881F\u896A\u896C\u89BD\u8B74"],
      ["c540", "\u8B77\u8B7D\u8D13\u8E8A\u8E8D\u8E8B\u8F5F\u8FAF\u91BA\u942E\u9433\u9435\u943A\u9438\u9432\u942B\u95E2\u9738\u9739\u9732\u97FF\u9867\u9865\u9957\u9A45\u9A43\u9A40\u9A3E\u9ACF\u9B54\u9B51\u9C2D\u9C25\u9DAF\u9DB4\u9DC2\u9DB8\u9E9D\u9EEF\u9F19\u9F5C\u9F66\u9F67\u513C\u513B\u56C8\u56CA\u56C9\u5B7F\u5DD4\u5DD2\u5F4E\u61FF\u6524\u6B0A\u6B61\u7051\u7058\u7380\u74E4\u758A\u766E\u766C"],
      ["c5a1", "\u79B3\u7C60\u7C5F\u807E\u807D\u81DF\u8972\u896F\u89FC\u8B80\u8D16\u8D17\u8E91\u8E93\u8F61\u9148\u9444\u9451\u9452\u973D\u973E\u97C3\u97C1\u986B\u9955\u9A55\u9A4D\u9AD2\u9B1A\u9C49\u9C31\u9C3E\u9C3B\u9DD3\u9DD7\u9F34\u9F6C\u9F6A\u9F94\u56CC\u5DD6\u6200\u6523\u652B\u652A\u66EC\u6B10\u74DA\u7ACA\u7C64\u7C63\u7C65\u7E93\u7E96\u7E94\u81E2\u8638\u863F\u8831\u8B8A\u9090\u908F\u9463\u9460\u9464\u9768\u986F\u995C\u9A5A\u9A5B\u9A57\u9AD3\u9AD4\u9AD1\u9C54\u9C57\u9C56\u9DE5\u9E9F\u9EF4\u56D1\u58E9\u652C\u705E\u7671\u7672\u77D7\u7F50\u7F88\u8836\u8839\u8862\u8B93\u8B92"],
      ["c640", "\u8B96\u8277\u8D1B\u91C0\u946A\u9742\u9748\u9744\u97C6\u9870\u9A5F\u9B22\u9B58\u9C5F\u9DF9\u9DFA\u9E7C\u9E7D\u9F07\u9F77\u9F72\u5EF3\u6B16\u7063\u7C6C\u7C6E\u883B\u89C0\u8EA1\u91C1\u9472\u9470\u9871\u995E\u9AD6\u9B23\u9ECC\u7064\u77DA\u8B9A\u9477\u97C9\u9A62\u9A65\u7E9C\u8B9C\u8EAA\u91C5\u947D\u947E\u947C\u9C77\u9C78\u9EF7\u8C54\u947F\u9E1A\u7228\u9A6A\u9B31\u9E1B\u9E1E\u7C72"],
      ["c940", "\u4E42\u4E5C\u51F5\u531A\u5382\u4E07\u4E0C\u4E47\u4E8D\u56D7\uFA0C\u5C6E\u5F73\u4E0F\u5187\u4E0E\u4E2E\u4E93\u4EC2\u4EC9\u4EC8\u5198\u52FC\u536C\u53B9\u5720\u5903\u592C\u5C10\u5DFF\u65E1\u6BB3\u6BCC\u6C14\u723F\u4E31\u4E3C\u4EE8\u4EDC\u4EE9\u4EE1\u4EDD\u4EDA\u520C\u531C\u534C\u5722\u5723\u5917\u592F\u5B81\u5B84\u5C12\u5C3B\u5C74\u5C73\u5E04\u5E80\u5E82\u5FC9\u6209\u6250\u6C15"],
      ["c9a1", "\u6C36\u6C43\u6C3F\u6C3B\u72AE\u72B0\u738A\u79B8\u808A\u961E\u4F0E\u4F18\u4F2C\u4EF5\u4F14\u4EF1\u4F00\u4EF7\u4F08\u4F1D\u4F02\u4F05\u4F22\u4F13\u4F04\u4EF4\u4F12\u51B1\u5213\u5209\u5210\u52A6\u5322\u531F\u534D\u538A\u5407\u56E1\u56DF\u572E\u572A\u5734\u593C\u5980\u597C\u5985\u597B\u597E\u5977\u597F\u5B56\u5C15\u5C25\u5C7C\u5C7A\u5C7B\u5C7E\u5DDF\u5E75\u5E84\u5F02\u5F1A\u5F74\u5FD5\u5FD4\u5FCF\u625C\u625E\u6264\u6261\u6266\u6262\u6259\u6260\u625A\u6265\u65EF\u65EE\u673E\u6739\u6738\u673B\u673A\u673F\u673C\u6733\u6C18\u6C46\u6C52\u6C5C\u6C4F\u6C4A\u6C54\u6C4B"],
      ["ca40", "\u6C4C\u7071\u725E\u72B4\u72B5\u738E\u752A\u767F\u7A75\u7F51\u8278\u827C\u8280\u827D\u827F\u864D\u897E\u9099\u9097\u9098\u909B\u9094\u9622\u9624\u9620\u9623\u4F56\u4F3B\u4F62\u4F49\u4F53\u4F64\u4F3E\u4F67\u4F52\u4F5F\u4F41\u4F58\u4F2D\u4F33\u4F3F\u4F61\u518F\u51B9\u521C\u521E\u5221\u52AD\u52AE\u5309\u5363\u5372\u538E\u538F\u5430\u5437\u542A\u5454\u5445\u5419\u541C\u5425\u5418"],
      ["caa1", "\u543D\u544F\u5441\u5428\u5424\u5447\u56EE\u56E7\u56E5\u5741\u5745\u574C\u5749\u574B\u5752\u5906\u5940\u59A6\u5998\u59A0\u5997\u598E\u59A2\u5990\u598F\u59A7\u59A1\u5B8E\u5B92\u5C28\u5C2A\u5C8D\u5C8F\u5C88\u5C8B\u5C89\u5C92\u5C8A\u5C86\u5C93\u5C95\u5DE0\u5E0A\u5E0E\u5E8B\u5E89\u5E8C\u5E88\u5E8D\u5F05\u5F1D\u5F78\u5F76\u5FD2\u5FD1\u5FD0\u5FED\u5FE8\u5FEE\u5FF3\u5FE1\u5FE4\u5FE3\u5FFA\u5FEF\u5FF7\u5FFB\u6000\u5FF4\u623A\u6283\u628C\u628E\u628F\u6294\u6287\u6271\u627B\u627A\u6270\u6281\u6288\u6277\u627D\u6272\u6274\u6537\u65F0\u65F4\u65F3\u65F2\u65F5\u6745\u6747"],
      ["cb40", "\u6759\u6755\u674C\u6748\u675D\u674D\u675A\u674B\u6BD0\u6C19\u6C1A\u6C78\u6C67\u6C6B\u6C84\u6C8B\u6C8F\u6C71\u6C6F\u6C69\u6C9A\u6C6D\u6C87\u6C95\u6C9C\u6C66\u6C73\u6C65\u6C7B\u6C8E\u7074\u707A\u7263\u72BF\u72BD\u72C3\u72C6\u72C1\u72BA\u72C5\u7395\u7397\u7393\u7394\u7392\u753A\u7539\u7594\u7595\u7681\u793D\u8034\u8095\u8099\u8090\u8092\u809C\u8290\u828F\u8285\u828E\u8291\u8293"],
      ["cba1", "\u828A\u8283\u8284\u8C78\u8FC9\u8FBF\u909F\u90A1\u90A5\u909E\u90A7\u90A0\u9630\u9628\u962F\u962D\u4E33\u4F98\u4F7C\u4F85\u4F7D\u4F80\u4F87\u4F76\u4F74\u4F89\u4F84\u4F77\u4F4C\u4F97\u4F6A\u4F9A\u4F79\u4F81\u4F78\u4F90\u4F9C\u4F94\u4F9E\u4F92\u4F82\u4F95\u4F6B\u4F6E\u519E\u51BC\u51BE\u5235\u5232\u5233\u5246\u5231\u52BC\u530A\u530B\u533C\u5392\u5394\u5487\u547F\u5481\u5491\u5482\u5488\u546B\u547A\u547E\u5465\u546C\u5474\u5466\u548D\u546F\u5461\u5460\u5498\u5463\u5467\u5464\u56F7\u56F9\u576F\u5772\u576D\u576B\u5771\u5770\u5776\u5780\u5775\u577B\u5773\u5774\u5762"],
      ["cc40", "\u5768\u577D\u590C\u5945\u59B5\u59BA\u59CF\u59CE\u59B2\u59CC\u59C1\u59B6\u59BC\u59C3\u59D6\u59B1\u59BD\u59C0\u59C8\u59B4\u59C7\u5B62\u5B65\u5B93\u5B95\u5C44\u5C47\u5CAE\u5CA4\u5CA0\u5CB5\u5CAF\u5CA8\u5CAC\u5C9F\u5CA3\u5CAD\u5CA2\u5CAA\u5CA7\u5C9D\u5CA5\u5CB6\u5CB0\u5CA6\u5E17\u5E14\u5E19\u5F28\u5F22\u5F23\u5F24\u5F54\u5F82\u5F7E\u5F7D\u5FDE\u5FE5\u602D\u6026\u6019\u6032\u600B"],
      ["cca1", "\u6034\u600A\u6017\u6033\u601A\u601E\u602C\u6022\u600D\u6010\u602E\u6013\u6011\u600C\u6009\u601C\u6214\u623D\u62AD\u62B4\u62D1\u62BE\u62AA\u62B6\u62CA\u62AE\u62B3\u62AF\u62BB\u62A9\u62B0\u62B8\u653D\u65A8\u65BB\u6609\u65FC\u6604\u6612\u6608\u65FB\u6603\u660B\u660D\u6605\u65FD\u6611\u6610\u66F6\u670A\u6785\u676C\u678E\u6792\u6776\u677B\u6798\u6786\u6784\u6774\u678D\u678C\u677A\u679F\u6791\u6799\u6783\u677D\u6781\u6778\u6779\u6794\u6B25\u6B80\u6B7E\u6BDE\u6C1D\u6C93\u6CEC\u6CEB\u6CEE\u6CD9\u6CB6\u6CD4\u6CAD\u6CE7\u6CB7\u6CD0\u6CC2\u6CBA\u6CC3\u6CC6\u6CED\u6CF2"],
      ["cd40", "\u6CD2\u6CDD\u6CB4\u6C8A\u6C9D\u6C80\u6CDE\u6CC0\u6D30\u6CCD\u6CC7\u6CB0\u6CF9\u6CCF\u6CE9\u6CD1\u7094\u7098\u7085\u7093\u7086\u7084\u7091\u7096\u7082\u709A\u7083\u726A\u72D6\u72CB\u72D8\u72C9\u72DC\u72D2\u72D4\u72DA\u72CC\u72D1\u73A4\u73A1\u73AD\u73A6\u73A2\u73A0\u73AC\u739D\u74DD\u74E8\u753F\u7540\u753E\u758C\u7598\u76AF\u76F3\u76F1\u76F0\u76F5\u77F8\u77FC\u77F9\u77FB\u77FA"],
      ["cda1", "\u77F7\u7942\u793F\u79C5\u7A78\u7A7B\u7AFB\u7C75\u7CFD\u8035\u808F\u80AE\u80A3\u80B8\u80B5\u80AD\u8220\u82A0\u82C0\u82AB\u829A\u8298\u829B\u82B5\u82A7\u82AE\u82BC\u829E\u82BA\u82B4\u82A8\u82A1\u82A9\u82C2\u82A4\u82C3\u82B6\u82A2\u8670\u866F\u866D\u866E\u8C56\u8FD2\u8FCB\u8FD3\u8FCD\u8FD6\u8FD5\u8FD7\u90B2\u90B4\u90AF\u90B3\u90B0\u9639\u963D\u963C\u963A\u9643\u4FCD\u4FC5\u4FD3\u4FB2\u4FC9\u4FCB\u4FC1\u4FD4\u4FDC\u4FD9\u4FBB\u4FB3\u4FDB\u4FC7\u4FD6\u4FBA\u4FC0\u4FB9\u4FEC\u5244\u5249\u52C0\u52C2\u533D\u537C\u5397\u5396\u5399\u5398\u54BA\u54A1\u54AD\u54A5\u54CF"],
      ["ce40", "\u54C3\u830D\u54B7\u54AE\u54D6\u54B6\u54C5\u54C6\u54A0\u5470\u54BC\u54A2\u54BE\u5472\u54DE\u54B0\u57B5\u579E\u579F\u57A4\u578C\u5797\u579D\u579B\u5794\u5798\u578F\u5799\u57A5\u579A\u5795\u58F4\u590D\u5953\u59E1\u59DE\u59EE\u5A00\u59F1\u59DD\u59FA\u59FD\u59FC\u59F6\u59E4\u59F2\u59F7\u59DB\u59E9\u59F3\u59F5\u59E0\u59FE\u59F4\u59ED\u5BA8\u5C4C\u5CD0\u5CD8\u5CCC\u5CD7\u5CCB\u5CDB"],
      ["cea1", "\u5CDE\u5CDA\u5CC9\u5CC7\u5CCA\u5CD6\u5CD3\u5CD4\u5CCF\u5CC8\u5CC6\u5CCE\u5CDF\u5CF8\u5DF9\u5E21\u5E22\u5E23\u5E20\u5E24\u5EB0\u5EA4\u5EA2\u5E9B\u5EA3\u5EA5\u5F07\u5F2E\u5F56\u5F86\u6037\u6039\u6054\u6072\u605E\u6045\u6053\u6047\u6049\u605B\u604C\u6040\u6042\u605F\u6024\u6044\u6058\u6066\u606E\u6242\u6243\u62CF\u630D\u630B\u62F5\u630E\u6303\u62EB\u62F9\u630F\u630C\u62F8\u62F6\u6300\u6313\u6314\u62FA\u6315\u62FB\u62F0\u6541\u6543\u65AA\u65BF\u6636\u6621\u6632\u6635\u661C\u6626\u6622\u6633\u662B\u663A\u661D\u6634\u6639\u662E\u670F\u6710\u67C1\u67F2\u67C8\u67BA"],
      ["cf40", "\u67DC\u67BB\u67F8\u67D8\u67C0\u67B7\u67C5\u67EB\u67E4\u67DF\u67B5\u67CD\u67B3\u67F7\u67F6\u67EE\u67E3\u67C2\u67B9\u67CE\u67E7\u67F0\u67B2\u67FC\u67C6\u67ED\u67CC\u67AE\u67E6\u67DB\u67FA\u67C9\u67CA\u67C3\u67EA\u67CB\u6B28\u6B82\u6B84\u6BB6\u6BD6\u6BD8\u6BE0\u6C20\u6C21\u6D28\u6D34\u6D2D\u6D1F\u6D3C\u6D3F\u6D12\u6D0A\u6CDA\u6D33\u6D04\u6D19\u6D3A\u6D1A\u6D11\u6D00\u6D1D\u6D42"],
      ["cfa1", "\u6D01\u6D18\u6D37\u6D03\u6D0F\u6D40\u6D07\u6D20\u6D2C\u6D08\u6D22\u6D09\u6D10\u70B7\u709F\u70BE\u70B1\u70B0\u70A1\u70B4\u70B5\u70A9\u7241\u7249\u724A\u726C\u7270\u7273\u726E\u72CA\u72E4\u72E8\u72EB\u72DF\u72EA\u72E6\u72E3\u7385\u73CC\u73C2\u73C8\u73C5\u73B9\u73B6\u73B5\u73B4\u73EB\u73BF\u73C7\u73BE\u73C3\u73C6\u73B8\u73CB\u74EC\u74EE\u752E\u7547\u7548\u75A7\u75AA\u7679\u76C4\u7708\u7703\u7704\u7705\u770A\u76F7\u76FB\u76FA\u77E7\u77E8\u7806\u7811\u7812\u7805\u7810\u780F\u780E\u7809\u7803\u7813\u794A\u794C\u794B\u7945\u7944\u79D5\u79CD\u79CF\u79D6\u79CE\u7A80"],
      ["d040", "\u7A7E\u7AD1\u7B00\u7B01\u7C7A\u7C78\u7C79\u7C7F\u7C80\u7C81\u7D03\u7D08\u7D01\u7F58\u7F91\u7F8D\u7FBE\u8007\u800E\u800F\u8014\u8037\u80D8\u80C7\u80E0\u80D1\u80C8\u80C2\u80D0\u80C5\u80E3\u80D9\u80DC\u80CA\u80D5\u80C9\u80CF\u80D7\u80E6\u80CD\u81FF\u8221\u8294\u82D9\u82FE\u82F9\u8307\u82E8\u8300\u82D5\u833A\u82EB\u82D6\u82F4\u82EC\u82E1\u82F2\u82F5\u830C\u82FB\u82F6\u82F0\u82EA"],
      ["d0a1", "\u82E4\u82E0\u82FA\u82F3\u82ED\u8677\u8674\u867C\u8673\u8841\u884E\u8867\u886A\u8869\u89D3\u8A04\u8A07\u8D72\u8FE3\u8FE1\u8FEE\u8FE0\u90F1\u90BD\u90BF\u90D5\u90C5\u90BE\u90C7\u90CB\u90C8\u91D4\u91D3\u9654\u964F\u9651\u9653\u964A\u964E\u501E\u5005\u5007\u5013\u5022\u5030\u501B\u4FF5\u4FF4\u5033\u5037\u502C\u4FF6\u4FF7\u5017\u501C\u5020\u5027\u5035\u502F\u5031\u500E\u515A\u5194\u5193\u51CA\u51C4\u51C5\u51C8\u51CE\u5261\u525A\u5252\u525E\u525F\u5255\u5262\u52CD\u530E\u539E\u5526\u54E2\u5517\u5512\u54E7\u54F3\u54E4\u551A\u54FF\u5504\u5508\u54EB\u5511\u5505\u54F1"],
      ["d140", "\u550A\u54FB\u54F7\u54F8\u54E0\u550E\u5503\u550B\u5701\u5702\u57CC\u5832\u57D5\u57D2\u57BA\u57C6\u57BD\u57BC\u57B8\u57B6\u57BF\u57C7\u57D0\u57B9\u57C1\u590E\u594A\u5A19\u5A16\u5A2D\u5A2E\u5A15\u5A0F\u5A17\u5A0A\u5A1E\u5A33\u5B6C\u5BA7\u5BAD\u5BAC\u5C03\u5C56\u5C54\u5CEC\u5CFF\u5CEE\u5CF1\u5CF7\u5D00\u5CF9\u5E29\u5E28\u5EA8\u5EAE\u5EAA\u5EAC\u5F33\u5F30\u5F67\u605D\u605A\u6067"],
      ["d1a1", "\u6041\u60A2\u6088\u6080\u6092\u6081\u609D\u6083\u6095\u609B\u6097\u6087\u609C\u608E\u6219\u6246\u62F2\u6310\u6356\u632C\u6344\u6345\u6336\u6343\u63E4\u6339\u634B\u634A\u633C\u6329\u6341\u6334\u6358\u6354\u6359\u632D\u6347\u6333\u635A\u6351\u6338\u6357\u6340\u6348\u654A\u6546\u65C6\u65C3\u65C4\u65C2\u664A\u665F\u6647\u6651\u6712\u6713\u681F\u681A\u6849\u6832\u6833\u683B\u684B\u684F\u6816\u6831\u681C\u6835\u682B\u682D\u682F\u684E\u6844\u6834\u681D\u6812\u6814\u6826\u6828\u682E\u684D\u683A\u6825\u6820\u6B2C\u6B2F\u6B2D\u6B31\u6B34\u6B6D\u8082\u6B88\u6BE6\u6BE4"],
      ["d240", "\u6BE8\u6BE3\u6BE2\u6BE7\u6C25\u6D7A\u6D63\u6D64\u6D76\u6D0D\u6D61\u6D92\u6D58\u6D62\u6D6D\u6D6F\u6D91\u6D8D\u6DEF\u6D7F\u6D86\u6D5E\u6D67\u6D60\u6D97\u6D70\u6D7C\u6D5F\u6D82\u6D98\u6D2F\u6D68\u6D8B\u6D7E\u6D80\u6D84\u6D16\u6D83\u6D7B\u6D7D\u6D75\u6D90\u70DC\u70D3\u70D1\u70DD\u70CB\u7F39\u70E2\u70D7\u70D2\u70DE\u70E0\u70D4\u70CD\u70C5\u70C6\u70C7\u70DA\u70CE\u70E1\u7242\u7278"],
      ["d2a1", "\u7277\u7276\u7300\u72FA\u72F4\u72FE\u72F6\u72F3\u72FB\u7301\u73D3\u73D9\u73E5\u73D6\u73BC\u73E7\u73E3\u73E9\u73DC\u73D2\u73DB\u73D4\u73DD\u73DA\u73D7\u73D8\u73E8\u74DE\u74DF\u74F4\u74F5\u7521\u755B\u755F\u75B0\u75C1\u75BB\u75C4\u75C0\u75BF\u75B6\u75BA\u768A\u76C9\u771D\u771B\u7710\u7713\u7712\u7723\u7711\u7715\u7719\u771A\u7722\u7727\u7823\u782C\u7822\u7835\u782F\u7828\u782E\u782B\u7821\u7829\u7833\u782A\u7831\u7954\u795B\u794F\u795C\u7953\u7952\u7951\u79EB\u79EC\u79E0\u79EE\u79ED\u79EA\u79DC\u79DE\u79DD\u7A86\u7A89\u7A85\u7A8B\u7A8C\u7A8A\u7A87\u7AD8\u7B10"],
      ["d340", "\u7B04\u7B13\u7B05\u7B0F\u7B08\u7B0A\u7B0E\u7B09\u7B12\u7C84\u7C91\u7C8A\u7C8C\u7C88\u7C8D\u7C85\u7D1E\u7D1D\u7D11\u7D0E\u7D18\u7D16\u7D13\u7D1F\u7D12\u7D0F\u7D0C\u7F5C\u7F61\u7F5E\u7F60\u7F5D\u7F5B\u7F96\u7F92\u7FC3\u7FC2\u7FC0\u8016\u803E\u8039\u80FA\u80F2\u80F9\u80F5\u8101\u80FB\u8100\u8201\u822F\u8225\u8333\u832D\u8344\u8319\u8351\u8325\u8356\u833F\u8341\u8326\u831C\u8322"],
      ["d3a1", "\u8342\u834E\u831B\u832A\u8308\u833C\u834D\u8316\u8324\u8320\u8337\u832F\u8329\u8347\u8345\u834C\u8353\u831E\u832C\u834B\u8327\u8348\u8653\u8652\u86A2\u86A8\u8696\u868D\u8691\u869E\u8687\u8697\u8686\u868B\u869A\u8685\u86A5\u8699\u86A1\u86A7\u8695\u8698\u868E\u869D\u8690\u8694\u8843\u8844\u886D\u8875\u8876\u8872\u8880\u8871\u887F\u886F\u8883\u887E\u8874\u887C\u8A12\u8C47\u8C57\u8C7B\u8CA4\u8CA3\u8D76\u8D78\u8DB5\u8DB7\u8DB6\u8ED1\u8ED3\u8FFE\u8FF5\u9002\u8FFF\u8FFB\u9004\u8FFC\u8FF6\u90D6\u90E0\u90D9\u90DA\u90E3\u90DF\u90E5\u90D8\u90DB\u90D7\u90DC\u90E4\u9150"],
      ["d440", "\u914E\u914F\u91D5\u91E2\u91DA\u965C\u965F\u96BC\u98E3\u9ADF\u9B2F\u4E7F\u5070\u506A\u5061\u505E\u5060\u5053\u504B\u505D\u5072\u5048\u504D\u5041\u505B\u504A\u5062\u5015\u5045\u505F\u5069\u506B\u5063\u5064\u5046\u5040\u506E\u5073\u5057\u5051\u51D0\u526B\u526D\u526C\u526E\u52D6\u52D3\u532D\u539C\u5575\u5576\u553C\u554D\u5550\u5534\u552A\u5551\u5562\u5536\u5535\u5530\u5552\u5545"],
      ["d4a1", "\u550C\u5532\u5565\u554E\u5539\u5548\u552D\u553B\u5540\u554B\u570A\u5707\u57FB\u5814\u57E2\u57F6\u57DC\u57F4\u5800\u57ED\u57FD\u5808\u57F8\u580B\u57F3\u57CF\u5807\u57EE\u57E3\u57F2\u57E5\u57EC\u57E1\u580E\u57FC\u5810\u57E7\u5801\u580C\u57F1\u57E9\u57F0\u580D\u5804\u595C\u5A60\u5A58\u5A55\u5A67\u5A5E\u5A38\u5A35\u5A6D\u5A50\u5A5F\u5A65\u5A6C\u5A53\u5A64\u5A57\u5A43\u5A5D\u5A52\u5A44\u5A5B\u5A48\u5A8E\u5A3E\u5A4D\u5A39\u5A4C\u5A70\u5A69\u5A47\u5A51\u5A56\u5A42\u5A5C\u5B72\u5B6E\u5BC1\u5BC0\u5C59\u5D1E\u5D0B\u5D1D\u5D1A\u5D20\u5D0C\u5D28\u5D0D\u5D26\u5D25\u5D0F"],
      ["d540", "\u5D30\u5D12\u5D23\u5D1F\u5D2E\u5E3E\u5E34\u5EB1\u5EB4\u5EB9\u5EB2\u5EB3\u5F36\u5F38\u5F9B\u5F96\u5F9F\u608A\u6090\u6086\u60BE\u60B0\u60BA\u60D3\u60D4\u60CF\u60E4\u60D9\u60DD\u60C8\u60B1\u60DB\u60B7\u60CA\u60BF\u60C3\u60CD\u60C0\u6332\u6365\u638A\u6382\u637D\u63BD\u639E\u63AD\u639D\u6397\u63AB\u638E\u636F\u6387\u6390\u636E\u63AF\u6375\u639C\u636D\u63AE\u637C\u63A4\u633B\u639F"],
      ["d5a1", "\u6378\u6385\u6381\u6391\u638D\u6370\u6553\u65CD\u6665\u6661\u665B\u6659\u665C\u6662\u6718\u6879\u6887\u6890\u689C\u686D\u686E\u68AE\u68AB\u6956\u686F\u68A3\u68AC\u68A9\u6875\u6874\u68B2\u688F\u6877\u6892\u687C\u686B\u6872\u68AA\u6880\u6871\u687E\u689B\u6896\u688B\u68A0\u6889\u68A4\u6878\u687B\u6891\u688C\u688A\u687D\u6B36\u6B33\u6B37\u6B38\u6B91\u6B8F\u6B8D\u6B8E\u6B8C\u6C2A\u6DC0\u6DAB\u6DB4\u6DB3\u6E74\u6DAC\u6DE9\u6DE2\u6DB7\u6DF6\u6DD4\u6E00\u6DC8\u6DE0\u6DDF\u6DD6\u6DBE\u6DE5\u6DDC\u6DDD\u6DDB\u6DF4\u6DCA\u6DBD\u6DED\u6DF0\u6DBA\u6DD5\u6DC2\u6DCF\u6DC9"],
      ["d640", "\u6DD0\u6DF2\u6DD3\u6DFD\u6DD7\u6DCD\u6DE3\u6DBB\u70FA\u710D\u70F7\u7117\u70F4\u710C\u70F0\u7104\u70F3\u7110\u70FC\u70FF\u7106\u7113\u7100\u70F8\u70F6\u710B\u7102\u710E\u727E\u727B\u727C\u727F\u731D\u7317\u7307\u7311\u7318\u730A\u7308\u72FF\u730F\u731E\u7388\u73F6\u73F8\u73F5\u7404\u7401\u73FD\u7407\u7400\u73FA\u73FC\u73FF\u740C\u740B\u73F4\u7408\u7564\u7563\u75CE\u75D2\u75CF"],
      ["d6a1", "\u75CB\u75CC\u75D1\u75D0\u768F\u7689\u76D3\u7739\u772F\u772D\u7731\u7732\u7734\u7733\u773D\u7725\u773B\u7735\u7848\u7852\u7849\u784D\u784A\u784C\u7826\u7845\u7850\u7964\u7967\u7969\u796A\u7963\u796B\u7961\u79BB\u79FA\u79F8\u79F6\u79F7\u7A8F\u7A94\u7A90\u7B35\u7B47\u7B34\u7B25\u7B30\u7B22\u7B24\u7B33\u7B18\u7B2A\u7B1D\u7B31\u7B2B\u7B2D\u7B2F\u7B32\u7B38\u7B1A\u7B23\u7C94\u7C98\u7C96\u7CA3\u7D35\u7D3D\u7D38\u7D36\u7D3A\u7D45\u7D2C\u7D29\u7D41\u7D47\u7D3E\u7D3F\u7D4A\u7D3B\u7D28\u7F63\u7F95\u7F9C\u7F9D\u7F9B\u7FCA\u7FCB\u7FCD\u7FD0\u7FD1\u7FC7\u7FCF\u7FC9\u801F"],
      ["d740", "\u801E\u801B\u8047\u8043\u8048\u8118\u8125\u8119\u811B\u812D\u811F\u812C\u811E\u8121\u8115\u8127\u811D\u8122\u8211\u8238\u8233\u823A\u8234\u8232\u8274\u8390\u83A3\u83A8\u838D\u837A\u8373\u83A4\u8374\u838F\u8381\u8395\u8399\u8375\u8394\u83A9\u837D\u8383\u838C\u839D\u839B\u83AA\u838B\u837E\u83A5\u83AF\u8388\u8397\u83B0\u837F\u83A6\u8387\u83AE\u8376\u839A\u8659\u8656\u86BF\u86B7"],
      ["d7a1", "\u86C2\u86C1\u86C5\u86BA\u86B0\u86C8\u86B9\u86B3\u86B8\u86CC\u86B4\u86BB\u86BC\u86C3\u86BD\u86BE\u8852\u8889\u8895\u88A8\u88A2\u88AA\u889A\u8891\u88A1\u889F\u8898\u88A7\u8899\u889B\u8897\u88A4\u88AC\u888C\u8893\u888E\u8982\u89D6\u89D9\u89D5\u8A30\u8A27\u8A2C\u8A1E\u8C39\u8C3B\u8C5C\u8C5D\u8C7D\u8CA5\u8D7D\u8D7B\u8D79\u8DBC\u8DC2\u8DB9\u8DBF\u8DC1\u8ED8\u8EDE\u8EDD\u8EDC\u8ED7\u8EE0\u8EE1\u9024\u900B\u9011\u901C\u900C\u9021\u90EF\u90EA\u90F0\u90F4\u90F2\u90F3\u90D4\u90EB\u90EC\u90E9\u9156\u9158\u915A\u9153\u9155\u91EC\u91F4\u91F1\u91F3\u91F8\u91E4\u91F9\u91EA"],
      ["d840", "\u91EB\u91F7\u91E8\u91EE\u957A\u9586\u9588\u967C\u966D\u966B\u9671\u966F\u96BF\u976A\u9804\u98E5\u9997\u509B\u5095\u5094\u509E\u508B\u50A3\u5083\u508C\u508E\u509D\u5068\u509C\u5092\u5082\u5087\u515F\u51D4\u5312\u5311\u53A4\u53A7\u5591\u55A8\u55A5\u55AD\u5577\u5645\u55A2\u5593\u5588\u558F\u55B5\u5581\u55A3\u5592\u55A4\u557D\u558C\u55A6\u557F\u5595\u55A1\u558E\u570C\u5829\u5837"],
      ["d8a1", "\u5819\u581E\u5827\u5823\u5828\u57F5\u5848\u5825\u581C\u581B\u5833\u583F\u5836\u582E\u5839\u5838\u582D\u582C\u583B\u5961\u5AAF\u5A94\u5A9F\u5A7A\u5AA2\u5A9E\u5A78\u5AA6\u5A7C\u5AA5\u5AAC\u5A95\u5AAE\u5A37\u5A84\u5A8A\u5A97\u5A83\u5A8B\u5AA9\u5A7B\u5A7D\u5A8C\u5A9C\u5A8F\u5A93\u5A9D\u5BEA\u5BCD\u5BCB\u5BD4\u5BD1\u5BCA\u5BCE\u5C0C\u5C30\u5D37\u5D43\u5D6B\u5D41\u5D4B\u5D3F\u5D35\u5D51\u5D4E\u5D55\u5D33\u5D3A\u5D52\u5D3D\u5D31\u5D59\u5D42\u5D39\u5D49\u5D38\u5D3C\u5D32\u5D36\u5D40\u5D45\u5E44\u5E41\u5F58\u5FA6\u5FA5\u5FAB\u60C9\u60B9\u60CC\u60E2\u60CE\u60C4\u6114"],
      ["d940", "\u60F2\u610A\u6116\u6105\u60F5\u6113\u60F8\u60FC\u60FE\u60C1\u6103\u6118\u611D\u6110\u60FF\u6104\u610B\u624A\u6394\u63B1\u63B0\u63CE\u63E5\u63E8\u63EF\u63C3\u649D\u63F3\u63CA\u63E0\u63F6\u63D5\u63F2\u63F5\u6461\u63DF\u63BE\u63DD\u63DC\u63C4\u63D8\u63D3\u63C2\u63C7\u63CC\u63CB\u63C8\u63F0\u63D7\u63D9\u6532\u6567\u656A\u6564\u655C\u6568\u6565\u658C\u659D\u659E\u65AE\u65D0\u65D2"],
      ["d9a1", "\u667C\u666C\u667B\u6680\u6671\u6679\u666A\u6672\u6701\u690C\u68D3\u6904\u68DC\u692A\u68EC\u68EA\u68F1\u690F\u68D6\u68F7\u68EB\u68E4\u68F6\u6913\u6910\u68F3\u68E1\u6907\u68CC\u6908\u6970\u68B4\u6911\u68EF\u68C6\u6914\u68F8\u68D0\u68FD\u68FC\u68E8\u690B\u690A\u6917\u68CE\u68C8\u68DD\u68DE\u68E6\u68F4\u68D1\u6906\u68D4\u68E9\u6915\u6925\u68C7\u6B39\u6B3B\u6B3F\u6B3C\u6B94\u6B97\u6B99\u6B95\u6BBD\u6BF0\u6BF2\u6BF3\u6C30\u6DFC\u6E46\u6E47\u6E1F\u6E49\u6E88\u6E3C\u6E3D\u6E45\u6E62\u6E2B\u6E3F\u6E41\u6E5D\u6E73\u6E1C\u6E33\u6E4B\u6E40\u6E51\u6E3B\u6E03\u6E2E\u6E5E"],
      ["da40", "\u6E68\u6E5C\u6E61\u6E31\u6E28\u6E60\u6E71\u6E6B\u6E39\u6E22\u6E30\u6E53\u6E65\u6E27\u6E78\u6E64\u6E77\u6E55\u6E79\u6E52\u6E66\u6E35\u6E36\u6E5A\u7120\u711E\u712F\u70FB\u712E\u7131\u7123\u7125\u7122\u7132\u711F\u7128\u713A\u711B\u724B\u725A\u7288\u7289\u7286\u7285\u728B\u7312\u730B\u7330\u7322\u7331\u7333\u7327\u7332\u732D\u7326\u7323\u7335\u730C\u742E\u742C\u7430\u742B\u7416"],
      ["daa1", "\u741A\u7421\u742D\u7431\u7424\u7423\u741D\u7429\u7420\u7432\u74FB\u752F\u756F\u756C\u75E7\u75DA\u75E1\u75E6\u75DD\u75DF\u75E4\u75D7\u7695\u7692\u76DA\u7746\u7747\u7744\u774D\u7745\u774A\u774E\u774B\u774C\u77DE\u77EC\u7860\u7864\u7865\u785C\u786D\u7871\u786A\u786E\u7870\u7869\u7868\u785E\u7862\u7974\u7973\u7972\u7970\u7A02\u7A0A\u7A03\u7A0C\u7A04\u7A99\u7AE6\u7AE4\u7B4A\u7B3B\u7B44\u7B48\u7B4C\u7B4E\u7B40\u7B58\u7B45\u7CA2\u7C9E\u7CA8\u7CA1\u7D58\u7D6F\u7D63\u7D53\u7D56\u7D67\u7D6A\u7D4F\u7D6D\u7D5C\u7D6B\u7D52\u7D54\u7D69\u7D51\u7D5F\u7D4E\u7F3E\u7F3F\u7F65"],
      ["db40", "\u7F66\u7FA2\u7FA0\u7FA1\u7FD7\u8051\u804F\u8050\u80FE\u80D4\u8143\u814A\u8152\u814F\u8147\u813D\u814D\u813A\u81E6\u81EE\u81F7\u81F8\u81F9\u8204\u823C\u823D\u823F\u8275\u833B\u83CF\u83F9\u8423\u83C0\u83E8\u8412\u83E7\u83E4\u83FC\u83F6\u8410\u83C6\u83C8\u83EB\u83E3\u83BF\u8401\u83DD\u83E5\u83D8\u83FF\u83E1\u83CB\u83CE\u83D6\u83F5\u83C9\u8409\u840F\u83DE\u8411\u8406\u83C2\u83F3"],
      ["dba1", "\u83D5\u83FA\u83C7\u83D1\u83EA\u8413\u83C3\u83EC\u83EE\u83C4\u83FB\u83D7\u83E2\u841B\u83DB\u83FE\u86D8\u86E2\u86E6\u86D3\u86E3\u86DA\u86EA\u86DD\u86EB\u86DC\u86EC\u86E9\u86D7\u86E8\u86D1\u8848\u8856\u8855\u88BA\u88D7\u88B9\u88B8\u88C0\u88BE\u88B6\u88BC\u88B7\u88BD\u88B2\u8901\u88C9\u8995\u8998\u8997\u89DD\u89DA\u89DB\u8A4E\u8A4D\u8A39\u8A59\u8A40\u8A57\u8A58\u8A44\u8A45\u8A52\u8A48\u8A51\u8A4A\u8A4C\u8A4F\u8C5F\u8C81\u8C80\u8CBA\u8CBE\u8CB0\u8CB9\u8CB5\u8D84\u8D80\u8D89\u8DD8\u8DD3\u8DCD\u8DC7\u8DD6\u8DDC\u8DCF\u8DD5\u8DD9\u8DC8\u8DD7\u8DC5\u8EEF\u8EF7\u8EFA"],
      ["dc40", "\u8EF9\u8EE6\u8EEE\u8EE5\u8EF5\u8EE7\u8EE8\u8EF6\u8EEB\u8EF1\u8EEC\u8EF4\u8EE9\u902D\u9034\u902F\u9106\u912C\u9104\u90FF\u90FC\u9108\u90F9\u90FB\u9101\u9100\u9107\u9105\u9103\u9161\u9164\u915F\u9162\u9160\u9201\u920A\u9225\u9203\u921A\u9226\u920F\u920C\u9200\u9212\u91FF\u91FD\u9206\u9204\u9227\u9202\u921C\u9224\u9219\u9217\u9205\u9216\u957B\u958D\u958C\u9590\u9687\u967E\u9688"],
      ["dca1", "\u9689\u9683\u9680\u96C2\u96C8\u96C3\u96F1\u96F0\u976C\u9770\u976E\u9807\u98A9\u98EB\u9CE6\u9EF9\u4E83\u4E84\u4EB6\u50BD\u50BF\u50C6\u50AE\u50C4\u50CA\u50B4\u50C8\u50C2\u50B0\u50C1\u50BA\u50B1\u50CB\u50C9\u50B6\u50B8\u51D7\u527A\u5278\u527B\u527C\u55C3\u55DB\u55CC\u55D0\u55CB\u55CA\u55DD\u55C0\u55D4\u55C4\u55E9\u55BF\u55D2\u558D\u55CF\u55D5\u55E2\u55D6\u55C8\u55F2\u55CD\u55D9\u55C2\u5714\u5853\u5868\u5864\u584F\u584D\u5849\u586F\u5855\u584E\u585D\u5859\u5865\u585B\u583D\u5863\u5871\u58FC\u5AC7\u5AC4\u5ACB\u5ABA\u5AB8\u5AB1\u5AB5\u5AB0\u5ABF\u5AC8\u5ABB\u5AC6"],
      ["dd40", "\u5AB7\u5AC0\u5ACA\u5AB4\u5AB6\u5ACD\u5AB9\u5A90\u5BD6\u5BD8\u5BD9\u5C1F\u5C33\u5D71\u5D63\u5D4A\u5D65\u5D72\u5D6C\u5D5E\u5D68\u5D67\u5D62\u5DF0\u5E4F\u5E4E\u5E4A\u5E4D\u5E4B\u5EC5\u5ECC\u5EC6\u5ECB\u5EC7\u5F40\u5FAF\u5FAD\u60F7\u6149\u614A\u612B\u6145\u6136\u6132\u612E\u6146\u612F\u614F\u6129\u6140\u6220\u9168\u6223\u6225\u6224\u63C5\u63F1\u63EB\u6410\u6412\u6409\u6420\u6424"],
      ["dda1", "\u6433\u6443\u641F\u6415\u6418\u6439\u6437\u6422\u6423\u640C\u6426\u6430\u6428\u6441\u6435\u642F\u640A\u641A\u6440\u6425\u6427\u640B\u63E7\u641B\u642E\u6421\u640E\u656F\u6592\u65D3\u6686\u668C\u6695\u6690\u668B\u668A\u6699\u6694\u6678\u6720\u6966\u695F\u6938\u694E\u6962\u6971\u693F\u6945\u696A\u6939\u6942\u6957\u6959\u697A\u6948\u6949\u6935\u696C\u6933\u693D\u6965\u68F0\u6978\u6934\u6969\u6940\u696F\u6944\u6976\u6958\u6941\u6974\u694C\u693B\u694B\u6937\u695C\u694F\u6951\u6932\u6952\u692F\u697B\u693C\u6B46\u6B45\u6B43\u6B42\u6B48\u6B41\u6B9B\uFA0D\u6BFB\u6BFC"],
      ["de40", "\u6BF9\u6BF7\u6BF8\u6E9B\u6ED6\u6EC8\u6E8F\u6EC0\u6E9F\u6E93\u6E94\u6EA0\u6EB1\u6EB9\u6EC6\u6ED2\u6EBD\u6EC1\u6E9E\u6EC9\u6EB7\u6EB0\u6ECD\u6EA6\u6ECF\u6EB2\u6EBE\u6EC3\u6EDC\u6ED8\u6E99\u6E92\u6E8E\u6E8D\u6EA4\u6EA1\u6EBF\u6EB3\u6ED0\u6ECA\u6E97\u6EAE\u6EA3\u7147\u7154\u7152\u7163\u7160\u7141\u715D\u7162\u7172\u7178\u716A\u7161\u7142\u7158\u7143\u714B\u7170\u715F\u7150\u7153"],
      ["dea1", "\u7144\u714D\u715A\u724F\u728D\u728C\u7291\u7290\u728E\u733C\u7342\u733B\u733A\u7340\u734A\u7349\u7444\u744A\u744B\u7452\u7451\u7457\u7440\u744F\u7450\u744E\u7442\u7446\u744D\u7454\u74E1\u74FF\u74FE\u74FD\u751D\u7579\u7577\u6983\u75EF\u760F\u7603\u75F7\u75FE\u75FC\u75F9\u75F8\u7610\u75FB\u75F6\u75ED\u75F5\u75FD\u7699\u76B5\u76DD\u7755\u775F\u7760\u7752\u7756\u775A\u7769\u7767\u7754\u7759\u776D\u77E0\u7887\u789A\u7894\u788F\u7884\u7895\u7885\u7886\u78A1\u7883\u7879\u7899\u7880\u7896\u787B\u797C\u7982\u797D\u7979\u7A11\u7A18\u7A19\u7A12\u7A17\u7A15\u7A22\u7A13"],
      ["df40", "\u7A1B\u7A10\u7AA3\u7AA2\u7A9E\u7AEB\u7B66\u7B64\u7B6D\u7B74\u7B69\u7B72\u7B65\u7B73\u7B71\u7B70\u7B61\u7B78\u7B76\u7B63\u7CB2\u7CB4\u7CAF\u7D88\u7D86\u7D80\u7D8D\u7D7F\u7D85\u7D7A\u7D8E\u7D7B\u7D83\u7D7C\u7D8C\u7D94\u7D84\u7D7D\u7D92\u7F6D\u7F6B\u7F67\u7F68\u7F6C\u7FA6\u7FA5\u7FA7\u7FDB\u7FDC\u8021\u8164\u8160\u8177\u815C\u8169\u815B\u8162\u8172\u6721\u815E\u8176\u8167\u816F"],
      ["dfa1", "\u8144\u8161\u821D\u8249\u8244\u8240\u8242\u8245\u84F1\u843F\u8456\u8476\u8479\u848F\u848D\u8465\u8451\u8440\u8486\u8467\u8430\u844D\u847D\u845A\u8459\u8474\u8473\u845D\u8507\u845E\u8437\u843A\u8434\u847A\u8443\u8478\u8432\u8445\u8429\u83D9\u844B\u842F\u8442\u842D\u845F\u8470\u8439\u844E\u844C\u8452\u846F\u84C5\u848E\u843B\u8447\u8436\u8433\u8468\u847E\u8444\u842B\u8460\u8454\u846E\u8450\u870B\u8704\u86F7\u870C\u86FA\u86D6\u86F5\u874D\u86F8\u870E\u8709\u8701\u86F6\u870D\u8705\u88D6\u88CB\u88CD\u88CE\u88DE\u88DB\u88DA\u88CC\u88D0\u8985\u899B\u89DF\u89E5\u89E4"],
      ["e040", "\u89E1\u89E0\u89E2\u89DC\u89E6\u8A76\u8A86\u8A7F\u8A61\u8A3F\u8A77\u8A82\u8A84\u8A75\u8A83\u8A81\u8A74\u8A7A\u8C3C\u8C4B\u8C4A\u8C65\u8C64\u8C66\u8C86\u8C84\u8C85\u8CCC\u8D68\u8D69\u8D91\u8D8C\u8D8E\u8D8F\u8D8D\u8D93\u8D94\u8D90\u8D92\u8DF0\u8DE0\u8DEC\u8DF1\u8DEE\u8DD0\u8DE9\u8DE3\u8DE2\u8DE7\u8DF2\u8DEB\u8DF4\u8F06\u8EFF\u8F01\u8F00\u8F05\u8F07\u8F08\u8F02\u8F0B\u9052\u903F"],
      ["e0a1", "\u9044\u9049\u903D\u9110\u910D\u910F\u9111\u9116\u9114\u910B\u910E\u916E\u916F\u9248\u9252\u9230\u923A\u9266\u9233\u9265\u925E\u9283\u922E\u924A\u9246\u926D\u926C\u924F\u9260\u9267\u926F\u9236\u9261\u9270\u9231\u9254\u9263\u9250\u9272\u924E\u9253\u924C\u9256\u9232\u959F\u959C\u959E\u959B\u9692\u9693\u9691\u9697\u96CE\u96FA\u96FD\u96F8\u96F5\u9773\u9777\u9778\u9772\u980F\u980D\u980E\u98AC\u98F6\u98F9\u99AF\u99B2\u99B0\u99B5\u9AAD\u9AAB\u9B5B\u9CEA\u9CED\u9CE7\u9E80\u9EFD\u50E6\u50D4\u50D7\u50E8\u50F3\u50DB\u50EA\u50DD\u50E4\u50D3\u50EC\u50F0\u50EF\u50E3\u50E0"],
      ["e140", "\u51D8\u5280\u5281\u52E9\u52EB\u5330\u53AC\u5627\u5615\u560C\u5612\u55FC\u560F\u561C\u5601\u5613\u5602\u55FA\u561D\u5604\u55FF\u55F9\u5889\u587C\u5890\u5898\u5886\u5881\u587F\u5874\u588B\u587A\u5887\u5891\u588E\u5876\u5882\u5888\u587B\u5894\u588F\u58FE\u596B\u5ADC\u5AEE\u5AE5\u5AD5\u5AEA\u5ADA\u5AED\u5AEB\u5AF3\u5AE2\u5AE0\u5ADB\u5AEC\u5ADE\u5ADD\u5AD9\u5AE8\u5ADF\u5B77\u5BE0"],
      ["e1a1", "\u5BE3\u5C63\u5D82\u5D80\u5D7D\u5D86\u5D7A\u5D81\u5D77\u5D8A\u5D89\u5D88\u5D7E\u5D7C\u5D8D\u5D79\u5D7F\u5E58\u5E59\u5E53\u5ED8\u5ED1\u5ED7\u5ECE\u5EDC\u5ED5\u5ED9\u5ED2\u5ED4\u5F44\u5F43\u5F6F\u5FB6\u612C\u6128\u6141\u615E\u6171\u6173\u6152\u6153\u6172\u616C\u6180\u6174\u6154\u617A\u615B\u6165\u613B\u616A\u6161\u6156\u6229\u6227\u622B\u642B\u644D\u645B\u645D\u6474\u6476\u6472\u6473\u647D\u6475\u6466\u64A6\u644E\u6482\u645E\u645C\u644B\u6453\u6460\u6450\u647F\u643F\u646C\u646B\u6459\u6465\u6477\u6573\u65A0\u66A1\u66A0\u669F\u6705\u6704\u6722\u69B1\u69B6\u69C9"],
      ["e240", "\u69A0\u69CE\u6996\u69B0\u69AC\u69BC\u6991\u6999\u698E\u69A7\u698D\u69A9\u69BE\u69AF\u69BF\u69C4\u69BD\u69A4\u69D4\u69B9\u69CA\u699A\u69CF\u69B3\u6993\u69AA\u69A1\u699E\u69D9\u6997\u6990\u69C2\u69B5\u69A5\u69C6\u6B4A\u6B4D\u6B4B\u6B9E\u6B9F\u6BA0\u6BC3\u6BC4\u6BFE\u6ECE\u6EF5\u6EF1\u6F03\u6F25\u6EF8\u6F37\u6EFB\u6F2E\u6F09\u6F4E\u6F19\u6F1A\u6F27\u6F18\u6F3B\u6F12\u6EED\u6F0A"],
      ["e2a1", "\u6F36\u6F73\u6EF9\u6EEE\u6F2D\u6F40\u6F30\u6F3C\u6F35\u6EEB\u6F07\u6F0E\u6F43\u6F05\u6EFD\u6EF6\u6F39\u6F1C\u6EFC\u6F3A\u6F1F\u6F0D\u6F1E\u6F08\u6F21\u7187\u7190\u7189\u7180\u7185\u7182\u718F\u717B\u7186\u7181\u7197\u7244\u7253\u7297\u7295\u7293\u7343\u734D\u7351\u734C\u7462\u7473\u7471\u7475\u7472\u7467\u746E\u7500\u7502\u7503\u757D\u7590\u7616\u7608\u760C\u7615\u7611\u760A\u7614\u76B8\u7781\u777C\u7785\u7782\u776E\u7780\u776F\u777E\u7783\u78B2\u78AA\u78B4\u78AD\u78A8\u787E\u78AB\u789E\u78A5\u78A0\u78AC\u78A2\u78A4\u7998\u798A\u798B\u7996\u7995\u7994\u7993"],
      ["e340", "\u7997\u7988\u7992\u7990\u7A2B\u7A4A\u7A30\u7A2F\u7A28\u7A26\u7AA8\u7AAB\u7AAC\u7AEE\u7B88\u7B9C\u7B8A\u7B91\u7B90\u7B96\u7B8D\u7B8C\u7B9B\u7B8E\u7B85\u7B98\u5284\u7B99\u7BA4\u7B82\u7CBB\u7CBF\u7CBC\u7CBA\u7DA7\u7DB7\u7DC2\u7DA3\u7DAA\u7DC1\u7DC0\u7DC5\u7D9D\u7DCE\u7DC4\u7DC6\u7DCB\u7DCC\u7DAF\u7DB9\u7D96\u7DBC\u7D9F\u7DA6\u7DAE\u7DA9\u7DA1\u7DC9\u7F73\u7FE2\u7FE3\u7FE5\u7FDE"],
      ["e3a1", "\u8024\u805D\u805C\u8189\u8186\u8183\u8187\u818D\u818C\u818B\u8215\u8497\u84A4\u84A1\u849F\u84BA\u84CE\u84C2\u84AC\u84AE\u84AB\u84B9\u84B4\u84C1\u84CD\u84AA\u849A\u84B1\u84D0\u849D\u84A7\u84BB\u84A2\u8494\u84C7\u84CC\u849B\u84A9\u84AF\u84A8\u84D6\u8498\u84B6\u84CF\u84A0\u84D7\u84D4\u84D2\u84DB\u84B0\u8491\u8661\u8733\u8723\u8728\u876B\u8740\u872E\u871E\u8721\u8719\u871B\u8743\u872C\u8741\u873E\u8746\u8720\u8732\u872A\u872D\u873C\u8712\u873A\u8731\u8735\u8742\u8726\u8727\u8738\u8724\u871A\u8730\u8711\u88F7\u88E7\u88F1\u88F2\u88FA\u88FE\u88EE\u88FC\u88F6\u88FB"],
      ["e440", "\u88F0\u88EC\u88EB\u899D\u89A1\u899F\u899E\u89E9\u89EB\u89E8\u8AAB\u8A99\u8A8B\u8A92\u8A8F\u8A96\u8C3D\u8C68\u8C69\u8CD5\u8CCF\u8CD7\u8D96\u8E09\u8E02\u8DFF\u8E0D\u8DFD\u8E0A\u8E03\u8E07\u8E06\u8E05\u8DFE\u8E00\u8E04\u8F10\u8F11\u8F0E\u8F0D\u9123\u911C\u9120\u9122\u911F\u911D\u911A\u9124\u9121\u911B\u917A\u9172\u9179\u9173\u92A5\u92A4\u9276\u929B\u927A\u92A0\u9294\u92AA\u928D"],
      ["e4a1", "\u92A6\u929A\u92AB\u9279\u9297\u927F\u92A3\u92EE\u928E\u9282\u9295\u92A2\u927D\u9288\u92A1\u928A\u9286\u928C\u9299\u92A7\u927E\u9287\u92A9\u929D\u928B\u922D\u969E\u96A1\u96FF\u9758\u977D\u977A\u977E\u9783\u9780\u9782\u977B\u9784\u9781\u977F\u97CE\u97CD\u9816\u98AD\u98AE\u9902\u9900\u9907\u999D\u999C\u99C3\u99B9\u99BB\u99BA\u99C2\u99BD\u99C7\u9AB1\u9AE3\u9AE7\u9B3E\u9B3F\u9B60\u9B61\u9B5F\u9CF1\u9CF2\u9CF5\u9EA7\u50FF\u5103\u5130\u50F8\u5106\u5107\u50F6\u50FE\u510B\u510C\u50FD\u510A\u528B\u528C\u52F1\u52EF\u5648\u5642\u564C\u5635\u5641\u564A\u5649\u5646\u5658"],
      ["e540", "\u565A\u5640\u5633\u563D\u562C\u563E\u5638\u562A\u563A\u571A\u58AB\u589D\u58B1\u58A0\u58A3\u58AF\u58AC\u58A5\u58A1\u58FF\u5AFF\u5AF4\u5AFD\u5AF7\u5AF6\u5B03\u5AF8\u5B02\u5AF9\u5B01\u5B07\u5B05\u5B0F\u5C67\u5D99\u5D97\u5D9F\u5D92\u5DA2\u5D93\u5D95\u5DA0\u5D9C\u5DA1\u5D9A\u5D9E\u5E69\u5E5D\u5E60\u5E5C\u7DF3\u5EDB\u5EDE\u5EE1\u5F49\u5FB2\u618B\u6183\u6179\u61B1\u61B0\u61A2\u6189"],
      ["e5a1", "\u619B\u6193\u61AF\u61AD\u619F\u6192\u61AA\u61A1\u618D\u6166\u61B3\u622D\u646E\u6470\u6496\u64A0\u6485\u6497\u649C\u648F\u648B\u648A\u648C\u64A3\u649F\u6468\u64B1\u6498\u6576\u657A\u6579\u657B\u65B2\u65B3\u66B5\u66B0\u66A9\u66B2\u66B7\u66AA\u66AF\u6A00\u6A06\u6A17\u69E5\u69F8\u6A15\u69F1\u69E4\u6A20\u69FF\u69EC\u69E2\u6A1B\u6A1D\u69FE\u6A27\u69F2\u69EE\u6A14\u69F7\u69E7\u6A40\u6A08\u69E6\u69FB\u6A0D\u69FC\u69EB\u6A09\u6A04\u6A18\u6A25\u6A0F\u69F6\u6A26\u6A07\u69F4\u6A16\u6B51\u6BA5\u6BA3\u6BA2\u6BA6\u6C01\u6C00\u6BFF\u6C02\u6F41\u6F26\u6F7E\u6F87\u6FC6\u6F92"],
      ["e640", "\u6F8D\u6F89\u6F8C\u6F62\u6F4F\u6F85\u6F5A\u6F96\u6F76\u6F6C\u6F82\u6F55\u6F72\u6F52\u6F50\u6F57\u6F94\u6F93\u6F5D\u6F00\u6F61\u6F6B\u6F7D\u6F67\u6F90\u6F53\u6F8B\u6F69\u6F7F\u6F95\u6F63\u6F77\u6F6A\u6F7B\u71B2\u71AF\u719B\u71B0\u71A0\u719A\u71A9\u71B5\u719D\u71A5\u719E\u71A4\u71A1\u71AA\u719C\u71A7\u71B3\u7298\u729A\u7358\u7352\u735E\u735F\u7360\u735D\u735B\u7361\u735A\u7359"],
      ["e6a1", "\u7362\u7487\u7489\u748A\u7486\u7481\u747D\u7485\u7488\u747C\u7479\u7508\u7507\u757E\u7625\u761E\u7619\u761D\u761C\u7623\u761A\u7628\u761B\u769C\u769D\u769E\u769B\u778D\u778F\u7789\u7788\u78CD\u78BB\u78CF\u78CC\u78D1\u78CE\u78D4\u78C8\u78C3\u78C4\u78C9\u799A\u79A1\u79A0\u799C\u79A2\u799B\u6B76\u7A39\u7AB2\u7AB4\u7AB3\u7BB7\u7BCB\u7BBE\u7BAC\u7BCE\u7BAF\u7BB9\u7BCA\u7BB5\u7CC5\u7CC8\u7CCC\u7CCB\u7DF7\u7DDB\u7DEA\u7DE7\u7DD7\u7DE1\u7E03\u7DFA\u7DE6\u7DF6\u7DF1\u7DF0\u7DEE\u7DDF\u7F76\u7FAC\u7FB0\u7FAD\u7FED\u7FEB\u7FEA\u7FEC\u7FE6\u7FE8\u8064\u8067\u81A3\u819F"],
      ["e740", "\u819E\u8195\u81A2\u8199\u8197\u8216\u824F\u8253\u8252\u8250\u824E\u8251\u8524\u853B\u850F\u8500\u8529\u850E\u8509\u850D\u851F\u850A\u8527\u851C\u84FB\u852B\u84FA\u8508\u850C\u84F4\u852A\u84F2\u8515\u84F7\u84EB\u84F3\u84FC\u8512\u84EA\u84E9\u8516\u84FE\u8528\u851D\u852E\u8502\u84FD\u851E\u84F6\u8531\u8526\u84E7\u84E8\u84F0\u84EF\u84F9\u8518\u8520\u8530\u850B\u8519\u852F\u8662"],
      ["e7a1", "\u8756\u8763\u8764\u8777\u87E1\u8773\u8758\u8754\u875B\u8752\u8761\u875A\u8751\u875E\u876D\u876A\u8750\u874E\u875F\u875D\u876F\u876C\u877A\u876E\u875C\u8765\u874F\u877B\u8775\u8762\u8767\u8769\u885A\u8905\u890C\u8914\u890B\u8917\u8918\u8919\u8906\u8916\u8911\u890E\u8909\u89A2\u89A4\u89A3\u89ED\u89F0\u89EC\u8ACF\u8AC6\u8AB8\u8AD3\u8AD1\u8AD4\u8AD5\u8ABB\u8AD7\u8ABE\u8AC0\u8AC5\u8AD8\u8AC3\u8ABA\u8ABD\u8AD9\u8C3E\u8C4D\u8C8F\u8CE5\u8CDF\u8CD9\u8CE8\u8CDA\u8CDD\u8CE7\u8DA0\u8D9C\u8DA1\u8D9B\u8E20\u8E23\u8E25\u8E24\u8E2E\u8E15\u8E1B\u8E16\u8E11\u8E19\u8E26\u8E27"],
      ["e840", "\u8E14\u8E12\u8E18\u8E13\u8E1C\u8E17\u8E1A\u8F2C\u8F24\u8F18\u8F1A\u8F20\u8F23\u8F16\u8F17\u9073\u9070\u906F\u9067\u906B\u912F\u912B\u9129\u912A\u9132\u9126\u912E\u9185\u9186\u918A\u9181\u9182\u9184\u9180\u92D0\u92C3\u92C4\u92C0\u92D9\u92B6\u92CF\u92F1\u92DF\u92D8\u92E9\u92D7\u92DD\u92CC\u92EF\u92C2\u92E8\u92CA\u92C8\u92CE\u92E6\u92CD\u92D5\u92C9\u92E0\u92DE\u92E7\u92D1\u92D3"],
      ["e8a1", "\u92B5\u92E1\u92C6\u92B4\u957C\u95AC\u95AB\u95AE\u95B0\u96A4\u96A2\u96D3\u9705\u9708\u9702\u975A\u978A\u978E\u9788\u97D0\u97CF\u981E\u981D\u9826\u9829\u9828\u9820\u981B\u9827\u98B2\u9908\u98FA\u9911\u9914\u9916\u9917\u9915\u99DC\u99CD\u99CF\u99D3\u99D4\u99CE\u99C9\u99D6\u99D8\u99CB\u99D7\u99CC\u9AB3\u9AEC\u9AEB\u9AF3\u9AF2\u9AF1\u9B46\u9B43\u9B67\u9B74\u9B71\u9B66\u9B76\u9B75\u9B70\u9B68\u9B64\u9B6C\u9CFC\u9CFA\u9CFD\u9CFF\u9CF7\u9D07\u9D00\u9CF9\u9CFB\u9D08\u9D05\u9D04\u9E83\u9ED3\u9F0F\u9F10\u511C\u5113\u5117\u511A\u5111\u51DE\u5334\u53E1\u5670\u5660\u566E"],
      ["e940", "\u5673\u5666\u5663\u566D\u5672\u565E\u5677\u571C\u571B\u58C8\u58BD\u58C9\u58BF\u58BA\u58C2\u58BC\u58C6\u5B17\u5B19\u5B1B\u5B21\u5B14\u5B13\u5B10\u5B16\u5B28\u5B1A\u5B20\u5B1E\u5BEF\u5DAC\u5DB1\u5DA9\u5DA7\u5DB5\u5DB0\u5DAE\u5DAA\u5DA8\u5DB2\u5DAD\u5DAF\u5DB4\u5E67\u5E68\u5E66\u5E6F\u5EE9\u5EE7\u5EE6\u5EE8\u5EE5\u5F4B\u5FBC\u619D\u61A8\u6196\u61C5\u61B4\u61C6\u61C1\u61CC\u61BA"],
      ["e9a1", "\u61BF\u61B8\u618C\u64D7\u64D6\u64D0\u64CF\u64C9\u64BD\u6489\u64C3\u64DB\u64F3\u64D9\u6533\u657F\u657C\u65A2\u66C8\u66BE\u66C0\u66CA\u66CB\u66CF\u66BD\u66BB\u66BA\u66CC\u6723\u6A34\u6A66\u6A49\u6A67\u6A32\u6A68\u6A3E\u6A5D\u6A6D\u6A76\u6A5B\u6A51\u6A28\u6A5A\u6A3B\u6A3F\u6A41\u6A6A\u6A64\u6A50\u6A4F\u6A54\u6A6F\u6A69\u6A60\u6A3C\u6A5E\u6A56\u6A55\u6A4D\u6A4E\u6A46\u6B55\u6B54\u6B56\u6BA7\u6BAA\u6BAB\u6BC8\u6BC7\u6C04\u6C03\u6C06\u6FAD\u6FCB\u6FA3\u6FC7\u6FBC\u6FCE\u6FC8\u6F5E\u6FC4\u6FBD\u6F9E\u6FCA\u6FA8\u7004\u6FA5\u6FAE\u6FBA\u6FAC\u6FAA\u6FCF\u6FBF\u6FB8"],
      ["ea40", "\u6FA2\u6FC9\u6FAB\u6FCD\u6FAF\u6FB2\u6FB0\u71C5\u71C2\u71BF\u71B8\u71D6\u71C0\u71C1\u71CB\u71D4\u71CA\u71C7\u71CF\u71BD\u71D8\u71BC\u71C6\u71DA\u71DB\u729D\u729E\u7369\u7366\u7367\u736C\u7365\u736B\u736A\u747F\u749A\u74A0\u7494\u7492\u7495\u74A1\u750B\u7580\u762F\u762D\u7631\u763D\u7633\u763C\u7635\u7632\u7630\u76BB\u76E6\u779A\u779D\u77A1\u779C\u779B\u77A2\u77A3\u7795\u7799"],
      ["eaa1", "\u7797\u78DD\u78E9\u78E5\u78EA\u78DE\u78E3\u78DB\u78E1\u78E2\u78ED\u78DF\u78E0\u79A4\u7A44\u7A48\u7A47\u7AB6\u7AB8\u7AB5\u7AB1\u7AB7\u7BDE\u7BE3\u7BE7\u7BDD\u7BD5\u7BE5\u7BDA\u7BE8\u7BF9\u7BD4\u7BEA\u7BE2\u7BDC\u7BEB\u7BD8\u7BDF\u7CD2\u7CD4\u7CD7\u7CD0\u7CD1\u7E12\u7E21\u7E17\u7E0C\u7E1F\u7E20\u7E13\u7E0E\u7E1C\u7E15\u7E1A\u7E22\u7E0B\u7E0F\u7E16\u7E0D\u7E14\u7E25\u7E24\u7F43\u7F7B\u7F7C\u7F7A\u7FB1\u7FEF\u802A\u8029\u806C\u81B1\u81A6\u81AE\u81B9\u81B5\u81AB\u81B0\u81AC\u81B4\u81B2\u81B7\u81A7\u81F2\u8255\u8256\u8257\u8556\u8545\u856B\u854D\u8553\u8561\u8558"],
      ["eb40", "\u8540\u8546\u8564\u8541\u8562\u8544\u8551\u8547\u8563\u853E\u855B\u8571\u854E\u856E\u8575\u8555\u8567\u8560\u858C\u8566\u855D\u8554\u8565\u856C\u8663\u8665\u8664\u879B\u878F\u8797\u8793\u8792\u8788\u8781\u8796\u8798\u8779\u8787\u87A3\u8785\u8790\u8791\u879D\u8784\u8794\u879C\u879A\u8789\u891E\u8926\u8930\u892D\u892E\u8927\u8931\u8922\u8929\u8923\u892F\u892C\u891F\u89F1\u8AE0"],
      ["eba1", "\u8AE2\u8AF2\u8AF4\u8AF5\u8ADD\u8B14\u8AE4\u8ADF\u8AF0\u8AC8\u8ADE\u8AE1\u8AE8\u8AFF\u8AEF\u8AFB\u8C91\u8C92\u8C90\u8CF5\u8CEE\u8CF1\u8CF0\u8CF3\u8D6C\u8D6E\u8DA5\u8DA7\u8E33\u8E3E\u8E38\u8E40\u8E45\u8E36\u8E3C\u8E3D\u8E41\u8E30\u8E3F\u8EBD\u8F36\u8F2E\u8F35\u8F32\u8F39\u8F37\u8F34\u9076\u9079\u907B\u9086\u90FA\u9133\u9135\u9136\u9193\u9190\u9191\u918D\u918F\u9327\u931E\u9308\u931F\u9306\u930F\u937A\u9338\u933C\u931B\u9323\u9312\u9301\u9346\u932D\u930E\u930D\u92CB\u931D\u92FA\u9325\u9313\u92F9\u92F7\u9334\u9302\u9324\u92FF\u9329\u9339\u9335\u932A\u9314\u930C"],
      ["ec40", "\u930B\u92FE\u9309\u9300\u92FB\u9316\u95BC\u95CD\u95BE\u95B9\u95BA\u95B6\u95BF\u95B5\u95BD\u96A9\u96D4\u970B\u9712\u9710\u9799\u9797\u9794\u97F0\u97F8\u9835\u982F\u9832\u9924\u991F\u9927\u9929\u999E\u99EE\u99EC\u99E5\u99E4\u99F0\u99E3\u99EA\u99E9\u99E7\u9AB9\u9ABF\u9AB4\u9ABB\u9AF6\u9AFA\u9AF9\u9AF7\u9B33\u9B80\u9B85\u9B87\u9B7C\u9B7E\u9B7B\u9B82\u9B93\u9B92\u9B90\u9B7A\u9B95"],
      ["eca1", "\u9B7D\u9B88\u9D25\u9D17\u9D20\u9D1E\u9D14\u9D29\u9D1D\u9D18\u9D22\u9D10\u9D19\u9D1F\u9E88\u9E86\u9E87\u9EAE\u9EAD\u9ED5\u9ED6\u9EFA\u9F12\u9F3D\u5126\u5125\u5122\u5124\u5120\u5129\u52F4\u5693\u568C\u568D\u5686\u5684\u5683\u567E\u5682\u567F\u5681\u58D6\u58D4\u58CF\u58D2\u5B2D\u5B25\u5B32\u5B23\u5B2C\u5B27\u5B26\u5B2F\u5B2E\u5B7B\u5BF1\u5BF2\u5DB7\u5E6C\u5E6A\u5FBE\u5FBB\u61C3\u61B5\u61BC\u61E7\u61E0\u61E5\u61E4\u61E8\u61DE\u64EF\u64E9\u64E3\u64EB\u64E4\u64E8\u6581\u6580\u65B6\u65DA\u66D2\u6A8D\u6A96\u6A81\u6AA5\u6A89\u6A9F\u6A9B\u6AA1\u6A9E\u6A87\u6A93\u6A8E"],
      ["ed40", "\u6A95\u6A83\u6AA8\u6AA4\u6A91\u6A7F\u6AA6\u6A9A\u6A85\u6A8C\u6A92\u6B5B\u6BAD\u6C09\u6FCC\u6FA9\u6FF4\u6FD4\u6FE3\u6FDC\u6FED\u6FE7\u6FE6\u6FDE\u6FF2\u6FDD\u6FE2\u6FE8\u71E1\u71F1\u71E8\u71F2\u71E4\u71F0\u71E2\u7373\u736E\u736F\u7497\u74B2\u74AB\u7490\u74AA\u74AD\u74B1\u74A5\u74AF\u7510\u7511\u7512\u750F\u7584\u7643\u7648\u7649\u7647\u76A4\u76E9\u77B5\u77AB\u77B2\u77B7\u77B6"],
      ["eda1", "\u77B4\u77B1\u77A8\u77F0\u78F3\u78FD\u7902\u78FB\u78FC\u78F2\u7905\u78F9\u78FE\u7904\u79AB\u79A8\u7A5C\u7A5B\u7A56\u7A58\u7A54\u7A5A\u7ABE\u7AC0\u7AC1\u7C05\u7C0F\u7BF2\u7C00\u7BFF\u7BFB\u7C0E\u7BF4\u7C0B\u7BF3\u7C02\u7C09\u7C03\u7C01\u7BF8\u7BFD\u7C06\u7BF0\u7BF1\u7C10\u7C0A\u7CE8\u7E2D\u7E3C\u7E42\u7E33\u9848\u7E38\u7E2A\u7E49\u7E40\u7E47\u7E29\u7E4C\u7E30\u7E3B\u7E36\u7E44\u7E3A\u7F45\u7F7F\u7F7E\u7F7D\u7FF4\u7FF2\u802C\u81BB\u81C4\u81CC\u81CA\u81C5\u81C7\u81BC\u81E9\u825B\u825A\u825C\u8583\u8580\u858F\u85A7\u8595\u85A0\u858B\u85A3\u857B\u85A4\u859A\u859E"],
      ["ee40", "\u8577\u857C\u8589\u85A1\u857A\u8578\u8557\u858E\u8596\u8586\u858D\u8599\u859D\u8581\u85A2\u8582\u8588\u8585\u8579\u8576\u8598\u8590\u859F\u8668\u87BE\u87AA\u87AD\u87C5\u87B0\u87AC\u87B9\u87B5\u87BC\u87AE\u87C9\u87C3\u87C2\u87CC\u87B7\u87AF\u87C4\u87CA\u87B4\u87B6\u87BF\u87B8\u87BD\u87DE\u87B2\u8935\u8933\u893C\u893E\u8941\u8952\u8937\u8942\u89AD\u89AF\u89AE\u89F2\u89F3\u8B1E"],
      ["eea1", "\u8B18\u8B16\u8B11\u8B05\u8B0B\u8B22\u8B0F\u8B12\u8B15\u8B07\u8B0D\u8B08\u8B06\u8B1C\u8B13\u8B1A\u8C4F\u8C70\u8C72\u8C71\u8C6F\u8C95\u8C94\u8CF9\u8D6F\u8E4E\u8E4D\u8E53\u8E50\u8E4C\u8E47\u8F43\u8F40\u9085\u907E\u9138\u919A\u91A2\u919B\u9199\u919F\u91A1\u919D\u91A0\u93A1\u9383\u93AF\u9364\u9356\u9347\u937C\u9358\u935C\u9376\u9349\u9350\u9351\u9360\u936D\u938F\u934C\u936A\u9379\u9357\u9355\u9352\u934F\u9371\u9377\u937B\u9361\u935E\u9363\u9367\u9380\u934E\u9359\u95C7\u95C0\u95C9\u95C3\u95C5\u95B7\u96AE\u96B0\u96AC\u9720\u971F\u9718\u971D\u9719\u979A\u97A1\u979C"],
      ["ef40", "\u979E\u979D\u97D5\u97D4\u97F1\u9841\u9844\u984A\u9849\u9845\u9843\u9925\u992B\u992C\u992A\u9933\u9932\u992F\u992D\u9931\u9930\u9998\u99A3\u99A1\u9A02\u99FA\u99F4\u99F7\u99F9\u99F8\u99F6\u99FB\u99FD\u99FE\u99FC\u9A03\u9ABE\u9AFE\u9AFD\u9B01\u9AFC\u9B48\u9B9A\u9BA8\u9B9E\u9B9B\u9BA6\u9BA1\u9BA5\u9BA4\u9B86\u9BA2\u9BA0\u9BAF\u9D33\u9D41\u9D67\u9D36\u9D2E\u9D2F\u9D31\u9D38\u9D30"],
      ["efa1", "\u9D45\u9D42\u9D43\u9D3E\u9D37\u9D40\u9D3D\u7FF5\u9D2D\u9E8A\u9E89\u9E8D\u9EB0\u9EC8\u9EDA\u9EFB\u9EFF\u9F24\u9F23\u9F22\u9F54\u9FA0\u5131\u512D\u512E\u5698\u569C\u5697\u569A\u569D\u5699\u5970\u5B3C\u5C69\u5C6A\u5DC0\u5E6D\u5E6E\u61D8\u61DF\u61ED\u61EE\u61F1\u61EA\u61F0\u61EB\u61D6\u61E9\u64FF\u6504\u64FD\u64F8\u6501\u6503\u64FC\u6594\u65DB\u66DA\u66DB\u66D8\u6AC5\u6AB9\u6ABD\u6AE1\u6AC6\u6ABA\u6AB6\u6AB7\u6AC7\u6AB4\u6AAD\u6B5E\u6BC9\u6C0B\u7007\u700C\u700D\u7001\u7005\u7014\u700E\u6FFF\u7000\u6FFB\u7026\u6FFC\u6FF7\u700A\u7201\u71FF\u71F9\u7203\u71FD\u7376"],
      ["f040", "\u74B8\u74C0\u74B5\u74C1\u74BE\u74B6\u74BB\u74C2\u7514\u7513\u765C\u7664\u7659\u7650\u7653\u7657\u765A\u76A6\u76BD\u76EC\u77C2\u77BA\u78FF\u790C\u7913\u7914\u7909\u7910\u7912\u7911\u79AD\u79AC\u7A5F\u7C1C\u7C29\u7C19\u7C20\u7C1F\u7C2D\u7C1D\u7C26\u7C28\u7C22\u7C25\u7C30\u7E5C\u7E50\u7E56\u7E63\u7E58\u7E62\u7E5F\u7E51\u7E60\u7E57\u7E53\u7FB5\u7FB3\u7FF7\u7FF8\u8075\u81D1\u81D2"],
      ["f0a1", "\u81D0\u825F\u825E\u85B4\u85C6\u85C0\u85C3\u85C2\u85B3\u85B5\u85BD\u85C7\u85C4\u85BF\u85CB\u85CE\u85C8\u85C5\u85B1\u85B6\u85D2\u8624\u85B8\u85B7\u85BE\u8669\u87E7\u87E6\u87E2\u87DB\u87EB\u87EA\u87E5\u87DF\u87F3\u87E4\u87D4\u87DC\u87D3\u87ED\u87D8\u87E3\u87A4\u87D7\u87D9\u8801\u87F4\u87E8\u87DD\u8953\u894B\u894F\u894C\u8946\u8950\u8951\u8949\u8B2A\u8B27\u8B23\u8B33\u8B30\u8B35\u8B47\u8B2F\u8B3C\u8B3E\u8B31\u8B25\u8B37\u8B26\u8B36\u8B2E\u8B24\u8B3B\u8B3D\u8B3A\u8C42\u8C75\u8C99\u8C98\u8C97\u8CFE\u8D04\u8D02\u8D00\u8E5C\u8E62\u8E60\u8E57\u8E56\u8E5E\u8E65\u8E67"],
      ["f140", "\u8E5B\u8E5A\u8E61\u8E5D\u8E69\u8E54\u8F46\u8F47\u8F48\u8F4B\u9128\u913A\u913B\u913E\u91A8\u91A5\u91A7\u91AF\u91AA\u93B5\u938C\u9392\u93B7\u939B\u939D\u9389\u93A7\u938E\u93AA\u939E\u93A6\u9395\u9388\u9399\u939F\u938D\u93B1\u9391\u93B2\u93A4\u93A8\u93B4\u93A3\u93A5\u95D2\u95D3\u95D1\u96B3\u96D7\u96DA\u5DC2\u96DF\u96D8\u96DD\u9723\u9722\u9725\u97AC\u97AE\u97A8\u97AB\u97A4\u97AA"],
      ["f1a1", "\u97A2\u97A5\u97D7\u97D9\u97D6\u97D8\u97FA\u9850\u9851\u9852\u98B8\u9941\u993C\u993A\u9A0F\u9A0B\u9A09\u9A0D\u9A04\u9A11\u9A0A\u9A05\u9A07\u9A06\u9AC0\u9ADC\u9B08\u9B04\u9B05\u9B29\u9B35\u9B4A\u9B4C\u9B4B\u9BC7\u9BC6\u9BC3\u9BBF\u9BC1\u9BB5\u9BB8\u9BD3\u9BB6\u9BC4\u9BB9\u9BBD\u9D5C\u9D53\u9D4F\u9D4A\u9D5B\u9D4B\u9D59\u9D56\u9D4C\u9D57\u9D52\u9D54\u9D5F\u9D58\u9D5A\u9E8E\u9E8C\u9EDF\u9F01\u9F00\u9F16\u9F25\u9F2B\u9F2A\u9F29\u9F28\u9F4C\u9F55\u5134\u5135\u5296\u52F7\u53B4\u56AB\u56AD\u56A6\u56A7\u56AA\u56AC\u58DA\u58DD\u58DB\u5912\u5B3D\u5B3E\u5B3F\u5DC3\u5E70"],
      ["f240", "\u5FBF\u61FB\u6507\u6510\u650D\u6509\u650C\u650E\u6584\u65DE\u65DD\u66DE\u6AE7\u6AE0\u6ACC\u6AD1\u6AD9\u6ACB\u6ADF\u6ADC\u6AD0\u6AEB\u6ACF\u6ACD\u6ADE\u6B60\u6BB0\u6C0C\u7019\u7027\u7020\u7016\u702B\u7021\u7022\u7023\u7029\u7017\u7024\u701C\u702A\u720C\u720A\u7207\u7202\u7205\u72A5\u72A6\u72A4\u72A3\u72A1\u74CB\u74C5\u74B7\u74C3\u7516\u7660\u77C9\u77CA\u77C4\u77F1\u791D\u791B"],
      ["f2a1", "\u7921\u791C\u7917\u791E\u79B0\u7A67\u7A68\u7C33\u7C3C\u7C39\u7C2C\u7C3B\u7CEC\u7CEA\u7E76\u7E75\u7E78\u7E70\u7E77\u7E6F\u7E7A\u7E72\u7E74\u7E68\u7F4B\u7F4A\u7F83\u7F86\u7FB7\u7FFD\u7FFE\u8078\u81D7\u81D5\u8264\u8261\u8263\u85EB\u85F1\u85ED\u85D9\u85E1\u85E8\u85DA\u85D7\u85EC\u85F2\u85F8\u85D8\u85DF\u85E3\u85DC\u85D1\u85F0\u85E6\u85EF\u85DE\u85E2\u8800\u87FA\u8803\u87F6\u87F7\u8809\u880C\u880B\u8806\u87FC\u8808\u87FF\u880A\u8802\u8962\u895A\u895B\u8957\u8961\u895C\u8958\u895D\u8959\u8988\u89B7\u89B6\u89F6\u8B50\u8B48\u8B4A\u8B40\u8B53\u8B56\u8B54\u8B4B\u8B55"],
      ["f340", "\u8B51\u8B42\u8B52\u8B57\u8C43\u8C77\u8C76\u8C9A\u8D06\u8D07\u8D09\u8DAC\u8DAA\u8DAD\u8DAB\u8E6D\u8E78\u8E73\u8E6A\u8E6F\u8E7B\u8EC2\u8F52\u8F51\u8F4F\u8F50\u8F53\u8FB4\u9140\u913F\u91B0\u91AD\u93DE\u93C7\u93CF\u93C2\u93DA\u93D0\u93F9\u93EC\u93CC\u93D9\u93A9\u93E6\u93CA\u93D4\u93EE\u93E3\u93D5\u93C4\u93CE\u93C0\u93D2\u93E7\u957D\u95DA\u95DB\u96E1\u9729\u972B\u972C\u9728\u9726"],
      ["f3a1", "\u97B3\u97B7\u97B6\u97DD\u97DE\u97DF\u985C\u9859\u985D\u9857\u98BF\u98BD\u98BB\u98BE\u9948\u9947\u9943\u99A6\u99A7\u9A1A\u9A15\u9A25\u9A1D\u9A24\u9A1B\u9A22\u9A20\u9A27\u9A23\u9A1E\u9A1C\u9A14\u9AC2\u9B0B\u9B0A\u9B0E\u9B0C\u9B37\u9BEA\u9BEB\u9BE0\u9BDE\u9BE4\u9BE6\u9BE2\u9BF0\u9BD4\u9BD7\u9BEC\u9BDC\u9BD9\u9BE5\u9BD5\u9BE1\u9BDA\u9D77\u9D81\u9D8A\u9D84\u9D88\u9D71\u9D80\u9D78\u9D86\u9D8B\u9D8C\u9D7D\u9D6B\u9D74\u9D75\u9D70\u9D69\u9D85\u9D73\u9D7B\u9D82\u9D6F\u9D79\u9D7F\u9D87\u9D68\u9E94\u9E91\u9EC0\u9EFC\u9F2D\u9F40\u9F41\u9F4D\u9F56\u9F57\u9F58\u5337\u56B2"],
      ["f440", "\u56B5\u56B3\u58E3\u5B45\u5DC6\u5DC7\u5EEE\u5EEF\u5FC0\u5FC1\u61F9\u6517\u6516\u6515\u6513\u65DF\u66E8\u66E3\u66E4\u6AF3\u6AF0\u6AEA\u6AE8\u6AF9\u6AF1\u6AEE\u6AEF\u703C\u7035\u702F\u7037\u7034\u7031\u7042\u7038\u703F\u703A\u7039\u7040\u703B\u7033\u7041\u7213\u7214\u72A8\u737D\u737C\u74BA\u76AB\u76AA\u76BE\u76ED\u77CC\u77CE\u77CF\u77CD\u77F2\u7925\u7923\u7927\u7928\u7924\u7929"],
      ["f4a1", "\u79B2\u7A6E\u7A6C\u7A6D\u7AF7\u7C49\u7C48\u7C4A\u7C47\u7C45\u7CEE\u7E7B\u7E7E\u7E81\u7E80\u7FBA\u7FFF\u8079\u81DB\u81D9\u820B\u8268\u8269\u8622\u85FF\u8601\u85FE\u861B\u8600\u85F6\u8604\u8609\u8605\u860C\u85FD\u8819\u8810\u8811\u8817\u8813\u8816\u8963\u8966\u89B9\u89F7\u8B60\u8B6A\u8B5D\u8B68\u8B63\u8B65\u8B67\u8B6D\u8DAE\u8E86\u8E88\u8E84\u8F59\u8F56\u8F57\u8F55\u8F58\u8F5A\u908D\u9143\u9141\u91B7\u91B5\u91B2\u91B3\u940B\u9413\u93FB\u9420\u940F\u9414\u93FE\u9415\u9410\u9428\u9419\u940D\u93F5\u9400\u93F7\u9407\u940E\u9416\u9412\u93FA\u9409\u93F8\u940A\u93FF"],
      ["f540", "\u93FC\u940C\u93F6\u9411\u9406\u95DE\u95E0\u95DF\u972E\u972F\u97B9\u97BB\u97FD\u97FE\u9860\u9862\u9863\u985F\u98C1\u98C2\u9950\u994E\u9959\u994C\u994B\u9953\u9A32\u9A34\u9A31\u9A2C\u9A2A\u9A36\u9A29\u9A2E\u9A38\u9A2D\u9AC7\u9ACA\u9AC6\u9B10\u9B12\u9B11\u9C0B\u9C08\u9BF7\u9C05\u9C12\u9BF8\u9C40\u9C07\u9C0E\u9C06\u9C17\u9C14\u9C09\u9D9F\u9D99\u9DA4\u9D9D\u9D92\u9D98\u9D90\u9D9B"],
      ["f5a1", "\u9DA0\u9D94\u9D9C\u9DAA\u9D97\u9DA1\u9D9A\u9DA2\u9DA8\u9D9E\u9DA3\u9DBF\u9DA9\u9D96\u9DA6\u9DA7\u9E99\u9E9B\u9E9A\u9EE5\u9EE4\u9EE7\u9EE6\u9F30\u9F2E\u9F5B\u9F60\u9F5E\u9F5D\u9F59\u9F91\u513A\u5139\u5298\u5297\u56C3\u56BD\u56BE\u5B48\u5B47\u5DCB\u5DCF\u5EF1\u61FD\u651B\u6B02\u6AFC\u6B03\u6AF8\u6B00\u7043\u7044\u704A\u7048\u7049\u7045\u7046\u721D\u721A\u7219\u737E\u7517\u766A\u77D0\u792D\u7931\u792F\u7C54\u7C53\u7CF2\u7E8A\u7E87\u7E88\u7E8B\u7E86\u7E8D\u7F4D\u7FBB\u8030\u81DD\u8618\u862A\u8626\u861F\u8623\u861C\u8619\u8627\u862E\u8621\u8620\u8629\u861E\u8625"],
      ["f640", "\u8829\u881D\u881B\u8820\u8824\u881C\u882B\u884A\u896D\u8969\u896E\u896B\u89FA\u8B79\u8B78\u8B45\u8B7A\u8B7B\u8D10\u8D14\u8DAF\u8E8E\u8E8C\u8F5E\u8F5B\u8F5D\u9146\u9144\u9145\u91B9\u943F\u943B\u9436\u9429\u943D\u943C\u9430\u9439\u942A\u9437\u942C\u9440\u9431\u95E5\u95E4\u95E3\u9735\u973A\u97BF\u97E1\u9864\u98C9\u98C6\u98C0\u9958\u9956\u9A39\u9A3D\u9A46\u9A44\u9A42\u9A41\u9A3A"],
      ["f6a1", "\u9A3F\u9ACD\u9B15\u9B17\u9B18\u9B16\u9B3A\u9B52\u9C2B\u9C1D\u9C1C\u9C2C\u9C23\u9C28\u9C29\u9C24\u9C21\u9DB7\u9DB6\u9DBC\u9DC1\u9DC7\u9DCA\u9DCF\u9DBE\u9DC5\u9DC3\u9DBB\u9DB5\u9DCE\u9DB9\u9DBA\u9DAC\u9DC8\u9DB1\u9DAD\u9DCC\u9DB3\u9DCD\u9DB2\u9E7A\u9E9C\u9EEB\u9EEE\u9EED\u9F1B\u9F18\u9F1A\u9F31\u9F4E\u9F65\u9F64\u9F92\u4EB9\u56C6\u56C5\u56CB\u5971\u5B4B\u5B4C\u5DD5\u5DD1\u5EF2\u6521\u6520\u6526\u6522\u6B0B\u6B08\u6B09\u6C0D\u7055\u7056\u7057\u7052\u721E\u721F\u72A9\u737F\u74D8\u74D5\u74D9\u74D7\u766D\u76AD\u7935\u79B4\u7A70\u7A71\u7C57\u7C5C\u7C59\u7C5B\u7C5A"],
      ["f740", "\u7CF4\u7CF1\u7E91\u7F4F\u7F87\u81DE\u826B\u8634\u8635\u8633\u862C\u8632\u8636\u882C\u8828\u8826\u882A\u8825\u8971\u89BF\u89BE\u89FB\u8B7E\u8B84\u8B82\u8B86\u8B85\u8B7F\u8D15\u8E95\u8E94\u8E9A\u8E92\u8E90\u8E96\u8E97\u8F60\u8F62\u9147\u944C\u9450\u944A\u944B\u944F\u9447\u9445\u9448\u9449\u9446\u973F\u97E3\u986A\u9869\u98CB\u9954\u995B\u9A4E\u9A53\u9A54\u9A4C\u9A4F\u9A48\u9A4A"],
      ["f7a1", "\u9A49\u9A52\u9A50\u9AD0\u9B19\u9B2B\u9B3B\u9B56\u9B55\u9C46\u9C48\u9C3F\u9C44\u9C39\u9C33\u9C41\u9C3C\u9C37\u9C34\u9C32\u9C3D\u9C36\u9DDB\u9DD2\u9DDE\u9DDA\u9DCB\u9DD0\u9DDC\u9DD1\u9DDF\u9DE9\u9DD9\u9DD8\u9DD6\u9DF5\u9DD5\u9DDD\u9EB6\u9EF0\u9F35\u9F33\u9F32\u9F42\u9F6B\u9F95\u9FA2\u513D\u5299\u58E8\u58E7\u5972\u5B4D\u5DD8\u882F\u5F4F\u6201\u6203\u6204\u6529\u6525\u6596\u66EB\u6B11\u6B12\u6B0F\u6BCA\u705B\u705A\u7222\u7382\u7381\u7383\u7670\u77D4\u7C67\u7C66\u7E95\u826C\u863A\u8640\u8639\u863C\u8631\u863B\u863E\u8830\u8832\u882E\u8833\u8976\u8974\u8973\u89FE"],
      ["f840", "\u8B8C\u8B8E\u8B8B\u8B88\u8C45\u8D19\u8E98\u8F64\u8F63\u91BC\u9462\u9455\u945D\u9457\u945E\u97C4\u97C5\u9800\u9A56\u9A59\u9B1E\u9B1F\u9B20\u9C52\u9C58\u9C50\u9C4A\u9C4D\u9C4B\u9C55\u9C59\u9C4C\u9C4E\u9DFB\u9DF7\u9DEF\u9DE3\u9DEB\u9DF8\u9DE4\u9DF6\u9DE1\u9DEE\u9DE6\u9DF2\u9DF0\u9DE2\u9DEC\u9DF4\u9DF3\u9DE8\u9DED\u9EC2\u9ED0\u9EF2\u9EF3\u9F06\u9F1C\u9F38\u9F37\u9F36\u9F43\u9F4F"],
      ["f8a1", "\u9F71\u9F70\u9F6E\u9F6F\u56D3\u56CD\u5B4E\u5C6D\u652D\u66ED\u66EE\u6B13\u705F\u7061\u705D\u7060\u7223\u74DB\u74E5\u77D5\u7938\u79B7\u79B6\u7C6A\u7E97\u7F89\u826D\u8643\u8838\u8837\u8835\u884B\u8B94\u8B95\u8E9E\u8E9F\u8EA0\u8E9D\u91BE\u91BD\u91C2\u946B\u9468\u9469\u96E5\u9746\u9743\u9747\u97C7\u97E5\u9A5E\u9AD5\u9B59\u9C63\u9C67\u9C66\u9C62\u9C5E\u9C60\u9E02\u9DFE\u9E07\u9E03\u9E06\u9E05\u9E00\u9E01\u9E09\u9DFF\u9DFD\u9E04\u9EA0\u9F1E\u9F46\u9F74\u9F75\u9F76\u56D4\u652E\u65B8\u6B18\u6B19\u6B17\u6B1A\u7062\u7226\u72AA\u77D8\u77D9\u7939\u7C69\u7C6B\u7CF6\u7E9A"],
      ["f940", "\u7E98\u7E9B\u7E99\u81E0\u81E1\u8646\u8647\u8648\u8979\u897A\u897C\u897B\u89FF\u8B98\u8B99\u8EA5\u8EA4\u8EA3\u946E\u946D\u946F\u9471\u9473\u9749\u9872\u995F\u9C68\u9C6E\u9C6D\u9E0B\u9E0D\u9E10\u9E0F\u9E12\u9E11\u9EA1\u9EF5\u9F09\u9F47\u9F78\u9F7B\u9F7A\u9F79\u571E\u7066\u7C6F\u883C\u8DB2\u8EA6\u91C3\u9474\u9478\u9476\u9475\u9A60\u9C74\u9C73\u9C71\u9C75\u9E14\u9E13\u9EF6\u9F0A"],
      ["f9a1", "\u9FA4\u7068\u7065\u7CF7\u866A\u883E\u883D\u883F\u8B9E\u8C9C\u8EA9\u8EC9\u974B\u9873\u9874\u98CC\u9961\u99AB\u9A64\u9A66\u9A67\u9B24\u9E15\u9E17\u9F48\u6207\u6B1E\u7227\u864C\u8EA8\u9482\u9480\u9481\u9A69\u9A68\u9B2E\u9E19\u7229\u864B\u8B9F\u9483\u9C79\u9EB7\u7675\u9A6B\u9C7A\u9E1D\u7069\u706A\u9EA4\u9F7E\u9F49\u9F98\u7881\u92B9\u88CF\u58BB\u6052\u7CA7\u5AFA\u2554\u2566\u2557\u2560\u256C\u2563\u255A\u2569\u255D\u2552\u2564\u2555\u255E\u256A\u2561\u2558\u2567\u255B\u2553\u2565\u2556\u255F\u256B\u2562\u2559\u2568\u255C\u2551\u2550\u256D\u256E\u2570\u256F\u2593"]
    ];
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/tables/big5-added.json"(exports2, module2) {
    module2.exports = [
      ["8740", "\u43F0\u4C32\u4603\u45A6\u4578\u{27267}\u4D77\u45B3\u{27CB1}\u4CE2\u{27CC5}\u3B95\u4736\u4744\u4C47\u4C40\u{242BF}\u{23617}\u{27352}\u{26E8B}\u{270D2}\u4C57\u{2A351}\u474F\u45DA\u4C85\u{27C6C}\u4D07\u4AA4\u46A1\u{26B23}\u7225\u{25A54}\u{21A63}\u{23E06}\u{23F61}\u664D\u56FB"],
      ["8767", "\u7D95\u591D\u{28BB9}\u3DF4\u9734\u{27BEF}\u5BDB\u{21D5E}\u5AA4\u3625\u{29EB0}\u5AD1\u5BB7\u5CFC\u676E\u8593\u{29945}\u7461\u749D\u3875\u{21D53}\u{2369E}\u{26021}\u3EEC"],
      ["87a1", "\u{258DE}\u3AF5\u7AFC\u9F97\u{24161}\u{2890D}\u{231EA}\u{20A8A}\u{2325E}\u430A\u8484\u9F96\u942F\u4930\u8613\u5896\u974A\u9218\u79D0\u7A32\u6660\u6A29\u889D\u744C\u7BC5\u6782\u7A2C\u524F\u9046\u34E6\u73C4\u{25DB9}\u74C6\u9FC7\u57B3\u492F\u544C\u4131\u{2368E}\u5818\u7A72\u{27B65}\u8B8F\u46AE\u{26E88}\u4181\u{25D99}\u7BAE\u{224BC}\u9FC8\u{224C1}\u{224C9}\u{224CC}\u9FC9\u8504\u{235BB}\u40B4\u9FCA\u44E1\u{2ADFF}\u62C1\u706E\u9FCB"],
      ["8840", "\u31C0", 4, "\u{2010C}\u31C5\u{200D1}\u{200CD}\u31C6\u31C7\u{200CB}\u{21FE8}\u31C8\u{200CA}\u31C9\u31CA\u31CB\u31CC\u{2010E}\u31CD\u31CE\u0100\xC1\u01CD\xC0\u0112\xC9\u011A\xC8\u014C\xD3\u01D1\xD2\u0FFF\xCA\u0304\u1EBE\u0FFF\xCA\u030C\u1EC0\xCA\u0101\xE1\u01CE\xE0\u0251\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA"],
      ["88a1", "\u01DC\xFC\u0FFF\xEA\u0304\u1EBF\u0FFF\xEA\u030C\u1EC1\xEA\u0261\u23DA\u23DB"],
      ["8940", "\u{2A3A9}\u{21145}"],
      ["8943", "\u650A"],
      ["8946", "\u4E3D\u6EDD\u9D4E\u91DF"],
      ["894c", "\u{27735}\u6491\u4F1A\u4F28\u4FA8\u5156\u5174\u519C\u51E4\u52A1\u52A8\u533B\u534E\u53D1\u53D8\u56E2\u58F0\u5904\u5907\u5932\u5934\u5B66\u5B9E\u5B9F\u5C9A\u5E86\u603B\u6589\u67FE\u6804\u6865\u6D4E\u70BC\u7535\u7EA4\u7EAC\u7EBA\u7EC7\u7ECF\u7EDF\u7F06\u7F37\u827A\u82CF\u836F\u89C6\u8BBE\u8BE2\u8F66\u8F67\u8F6E"],
      ["89a1", "\u7411\u7CFC\u7DCD\u6946\u7AC9\u5227"],
      ["89ab", "\u918C\u78B8\u915E\u80BC"],
      ["89b0", "\u8D0B\u80F6\u{209E7}"],
      ["89b5", "\u809F\u9EC7\u4CCD\u9DC9\u9E0C\u4C3E\u{29DF6}\u{2700E}\u9E0A\u{2A133}\u35C1"],
      ["89c1", "\u6E9A\u823E\u7519"],
      ["89c5", "\u4911\u9A6C\u9A8F\u9F99\u7987\u{2846C}\u{21DCA}\u{205D0}\u{22AE6}\u4E24\u4E81\u4E80\u4E87\u4EBF\u4EEB\u4F37\u344C\u4FBD\u3E48\u5003\u5088\u347D\u3493\u34A5\u5186\u5905\u51DB\u51FC\u5205\u4E89\u5279\u5290\u5327\u35C7\u53A9\u3551\u53B0\u3553\u53C2\u5423\u356D\u3572\u3681\u5493\u54A3\u54B4\u54B9\u54D0\u54EF\u5518\u5523\u5528\u3598\u553F\u35A5\u35BF\u55D7\u35C5"],
      ["8a40", "\u{27D84}\u5525"],
      ["8a43", "\u{20C42}\u{20D15}\u{2512B}\u5590\u{22CC6}\u39EC\u{20341}\u8E46\u{24DB8}\u{294E5}\u4053\u{280BE}\u777A\u{22C38}\u3A34\u47D5\u{2815D}\u{269F2}\u{24DEA}\u64DD\u{20D7C}\u{20FB4}\u{20CD5}\u{210F4}\u648D\u8E7E\u{20E96}\u{20C0B}\u{20F64}\u{22CA9}\u{28256}\u{244D3}"],
      ["8a64", "\u{20D46}\u{29A4D}\u{280E9}\u47F4\u{24EA7}\u{22CC2}\u9AB2\u3A67\u{295F4}\u3FED\u3506\u{252C7}\u{297D4}\u{278C8}\u{22D44}\u9D6E\u9815"],
      ["8a76", "\u43D9\u{260A5}\u64B4\u54E3\u{22D4C}\u{22BCA}\u{21077}\u39FB\u{2106F}"],
      ["8aa1", "\u{266DA}\u{26716}\u{279A0}\u64EA\u{25052}\u{20C43}\u8E68\u{221A1}\u{28B4C}\u{20731}"],
      ["8aac", "\u480B\u{201A9}\u3FFA\u5873\u{22D8D}"],
      ["8ab2", "\u{245C8}\u{204FC}\u{26097}\u{20F4C}\u{20D96}\u5579\u40BB\u43BA"],
      ["8abb", "\u4AB4\u{22A66}\u{2109D}\u81AA\u98F5\u{20D9C}\u6379\u39FE\u{22775}\u8DC0\u56A1\u647C\u3E43"],
      ["8ac9", "\u{2A601}\u{20E09}\u{22ACF}\u{22CC9}"],
      ["8ace", "\u{210C8}\u{239C2}\u3992\u3A06\u{2829B}\u3578\u{25E49}\u{220C7}\u5652\u{20F31}\u{22CB2}\u{29720}\u34BC\u6C3D\u{24E3B}"],
      ["8adf", "\u{27574}\u{22E8B}\u{22208}\u{2A65B}\u{28CCD}\u{20E7A}\u{20C34}\u{2681C}\u7F93\u{210CF}\u{22803}\u{22939}\u35FB\u{251E3}\u{20E8C}\u{20F8D}\u{20EAA}\u3F93\u{20F30}\u{20D47}\u{2114F}\u{20E4C}"],
      ["8af6", "\u{20EAB}\u{20BA9}\u{20D48}\u{210C0}\u{2113D}\u3FF9\u{22696}\u6432\u{20FAD}"],
      ["8b40", "\u{233F4}\u{27639}\u{22BCE}\u{20D7E}\u{20D7F}\u{22C51}\u{22C55}\u3A18\u{20E98}\u{210C7}\u{20F2E}\u{2A632}\u{26B50}\u{28CD2}\u{28D99}\u{28CCA}\u95AA\u54CC\u82C4\u55B9"],
      ["8b55", "\u{29EC3}\u9C26\u9AB6\u{2775E}\u{22DEE}\u7140\u816D\u80EC\u5C1C\u{26572}\u8134\u3797\u535F\u{280BD}\u91B6\u{20EFA}\u{20E0F}\u{20E77}\u{20EFB}\u35DD\u{24DEB}\u3609\u{20CD6}\u56AF\u{227B5}\u{210C9}\u{20E10}\u{20E78}\u{21078}\u{21148}\u{28207}\u{21455}\u{20E79}\u{24E50}\u{22DA4}\u5A54\u{2101D}\u{2101E}\u{210F5}\u{210F6}\u579C\u{20E11}"],
      ["8ba1", "\u{27694}\u{282CD}\u{20FB5}\u{20E7B}\u{2517E}\u3703\u{20FB6}\u{21180}\u{252D8}\u{2A2BD}\u{249DA}\u{2183A}\u{24177}\u{2827C}\u5899\u5268\u361A\u{2573D}\u7BB2\u5B68\u4800\u4B2C\u9F27\u49E7\u9C1F\u9B8D\u{25B74}\u{2313D}\u55FB\u35F2\u5689\u4E28\u5902\u{21BC1}\u{2F878}\u9751\u{20086}\u4E5B\u4EBB\u353E\u5C23\u5F51\u5FC4\u38FA\u624C\u6535\u6B7A\u6C35\u6C3A\u706C\u722B\u4E2C\u72AD\u{248E9}\u7F52\u793B\u7CF9\u7F53\u{2626A}\u34C1"],
      ["8bde", "\u{2634B}\u8002\u8080\u{26612}\u{26951}\u535D\u8864\u89C1\u{278B2}\u8BA0\u8D1D\u9485\u9578\u957F\u95E8\u{28E0F}\u97E6\u9875\u98CE\u98DE\u9963\u{29810}\u9C7C\u9E1F\u9EC4\u6B6F\uF907\u4E37\u{20087}\u961D\u6237\u94A2"],
      ["8c40", "\u503B\u6DFE\u{29C73}\u9FA6\u3DC9\u888F\u{2414E}\u7077\u5CF5\u4B20\u{251CD}\u3559\u{25D30}\u6122\u{28A32}\u8FA7\u91F6\u7191\u6719\u73BA\u{23281}\u{2A107}\u3C8B\u{21980}\u4B10\u78E4\u7402\u51AE\u{2870F}\u4009\u6A63\u{2A2BA}\u4223\u860F\u{20A6F}\u7A2A\u{29947}\u{28AEA}\u9755\u704D\u5324\u{2207E}\u93F4\u76D9\u{289E3}\u9FA7\u77DD\u4EA3\u4FF0\u50BC\u4E2F\u4F17\u9FA8\u5434\u7D8B\u5892\u58D0\u{21DB6}\u5E92\u5E99\u5FC2\u{22712}\u658B"],
      ["8ca1", "\u{233F9}\u6919\u6A43\u{23C63}\u6CFF"],
      ["8ca7", "\u7200\u{24505}\u738C\u3EDB\u{24A13}\u5B15\u74B9\u8B83\u{25CA4}\u{25695}\u7A93\u7BEC\u7CC3\u7E6C\u82F8\u8597\u9FA9\u8890\u9FAA\u8EB9\u9FAB\u8FCF\u855F\u99E0\u9221\u9FAC\u{28DB9}\u{2143F}\u4071\u42A2\u5A1A"],
      ["8cc9", "\u9868\u676B\u4276\u573D"],
      ["8cce", "\u85D6\u{2497B}\u82BF\u{2710D}\u4C81\u{26D74}\u5D7B\u{26B15}\u{26FBE}\u9FAD\u9FAE\u5B96\u9FAF\u66E7\u7E5B\u6E57\u79CA\u3D88\u44C3\u{23256}\u{22796}\u439A\u4536"],
      ["8ce6", "\u5CD5\u{23B1A}\u8AF9\u5C78\u3D12\u{23551}\u5D78\u9FB2\u7157\u4558\u{240EC}\u{21E23}\u4C77\u3978\u344A\u{201A4}\u{26C41}\u8ACC\u4FB4\u{20239}\u59BF\u816C\u9856\u{298FA}\u5F3B"],
      ["8d40", "\u{20B9F}"],
      ["8d42", "\u{221C1}\u{2896D}\u4102\u46BB\u{29079}\u3F07\u9FB3\u{2A1B5}\u40F8\u37D6\u46F7\u{26C46}\u417C\u{286B2}\u{273FF}\u456D\u38D4\u{2549A}\u4561\u451B\u4D89\u4C7B\u4D76\u45EA\u3FC8\u{24B0F}\u3661\u44DE\u44BD\u41ED\u5D3E\u5D48\u5D56\u3DFC\u380F\u5DA4\u5DB9\u3820\u3838\u5E42\u5EBD\u5F25\u5F83\u3908\u3914\u393F\u394D\u60D7\u613D\u5CE5\u3989\u61B7\u61B9\u61CF\u39B8\u622C\u6290\u62E5\u6318\u39F8\u56B1"],
      ["8da1", "\u3A03\u63E2\u63FB\u6407\u645A\u3A4B\u64C0\u5D15\u5621\u9F9F\u3A97\u6586\u3ABD\u65FF\u6653\u3AF2\u6692\u3B22\u6716\u3B42\u67A4\u6800\u3B58\u684A\u6884\u3B72\u3B71\u3B7B\u6909\u6943\u725C\u6964\u699F\u6985\u3BBC\u69D6\u3BDD\u6A65\u6A74\u6A71\u6A82\u3BEC\u6A99\u3BF2\u6AAB\u6AB5\u6AD4\u6AF6\u6B81\u6BC1\u6BEA\u6C75\u6CAA\u3CCB\u6D02\u6D06\u6D26\u6D81\u3CEF\u6DA4\u6DB1\u6E15\u6E18\u6E29\u6E86\u{289C0}\u6EBB\u6EE2\u6EDA\u9F7F\u6EE8\u6EE9\u6F24\u6F34\u3D46\u{23F41}\u6F81\u6FBE\u3D6A\u3D75\u71B7\u5C99\u3D8A\u702C\u3D91\u7050\u7054\u706F\u707F\u7089\u{20325}\u43C1\u35F1\u{20ED8}"],
      ["8e40", "\u{23ED7}\u57BE\u{26ED3}\u713E\u{257E0}\u364E\u69A2\u{28BE9}\u5B74\u7A49\u{258E1}\u{294D9}\u7A65\u7A7D\u{259AC}\u7ABB\u7AB0\u7AC2\u7AC3\u71D1\u{2648D}\u41CA\u7ADA\u7ADD\u7AEA\u41EF\u54B2\u{25C01}\u7B0B\u7B55\u7B29\u{2530E}\u{25CFE}\u7BA2\u7B6F\u839C\u{25BB4}\u{26C7F}\u7BD0\u8421\u7B92\u7BB8\u{25D20}\u3DAD\u{25C65}\u8492\u7BFA\u7C06\u7C35\u{25CC1}\u7C44\u7C83\u{24882}\u7CA6\u667D\u{24578}\u7CC9\u7CC7\u7CE6\u7C74\u7CF3\u7CF5\u7CCE"],
      ["8ea1", "\u7E67\u451D\u{26E44}\u7D5D\u{26ED6}\u748D\u7D89\u7DAB\u7135\u7DB3\u7DD2\u{24057}\u{26029}\u7DE4\u3D13\u7DF5\u{217F9}\u7DE5\u{2836D}\u7E1D\u{26121}\u{2615A}\u7E6E\u7E92\u432B\u946C\u7E27\u7F40\u7F41\u7F47\u7936\u{262D0}\u99E1\u7F97\u{26351}\u7FA3\u{21661}\u{20068}\u455C\u{23766}\u4503\u{2833A}\u7FFA\u{26489}\u8005\u8008\u801D\u8028\u802F\u{2A087}\u{26CC3}\u803B\u803C\u8061\u{22714}\u4989\u{26626}\u{23DE3}\u{266E8}\u6725\u80A7\u{28A48}\u8107\u811A\u58B0\u{226F6}\u6C7F\u{26498}\u{24FB8}\u64E7\u{2148A}\u8218\u{2185E}\u6A53\u{24A65}\u{24A95}\u447A\u8229\u{20B0D}\u{26A52}\u{23D7E}\u4FF9\u{214FD}\u84E2\u8362\u{26B0A}\u{249A7}\u{23530}\u{21773}\u{23DF8}\u82AA\u691B\u{2F994}\u41DB"],
      ["8f40", "\u854B\u82D0\u831A\u{20E16}\u{217B4}\u36C1\u{2317D}\u{2355A}\u827B\u82E2\u8318\u{23E8B}\u{26DA3}\u{26B05}\u{26B97}\u{235CE}\u3DBF\u831D\u55EC\u8385\u450B\u{26DA5}\u83AC\u83C1\u83D3\u347E\u{26ED4}\u6A57\u855A\u3496\u{26E42}\u{22EEF}\u8458\u{25BE4}\u8471\u3DD3\u44E4\u6AA7\u844A\u{23CB5}\u7958\u84A8\u{26B96}\u{26E77}\u{26E43}\u84DE\u840F\u8391\u44A0\u8493\u84E4\u{25C91}\u4240\u{25CC0}\u4543\u8534\u5AF2\u{26E99}\u4527\u8573\u4516\u67BF\u8616"],
      ["8fa1", "\u{28625}\u{2863B}\u85C1\u{27088}\u8602\u{21582}\u{270CD}\u{2F9B2}\u456A\u8628\u3648\u{218A2}\u53F7\u{2739A}\u867E\u8771\u{2A0F8}\u87EE\u{22C27}\u87B1\u87DA\u880F\u5661\u866C\u6856\u460F\u8845\u8846\u{275E0}\u{23DB9}\u{275E4}\u885E\u889C\u465B\u88B4\u88B5\u63C1\u88C5\u7777\u{2770F}\u8987\u898A\u89A6\u89A9\u89A7\u89BC\u{28A25}\u89E7\u{27924}\u{27ABD}\u8A9C\u7793\u91FE\u8A90\u{27A59}\u7AE9\u{27B3A}\u{23F8F}\u4713\u{27B38}\u717C\u8B0C\u8B1F\u{25430}\u{25565}\u8B3F\u8B4C\u8B4D\u8AA9\u{24A7A}\u8B90\u8B9B\u8AAF\u{216DF}\u4615\u884F\u8C9B\u{27D54}\u{27D8F}\u{2F9D4}\u3725\u{27D53}\u8CD6\u{27D98}\u{27DBD}\u8D12\u8D03\u{21910}\u8CDB\u705C\u8D11\u{24CC9}\u3ED0\u8D77"],
      ["9040", "\u8DA9\u{28002}\u{21014}\u{2498A}\u3B7C\u{281BC}\u{2710C}\u7AE7\u8EAD\u8EB6\u8EC3\u92D4\u8F19\u8F2D\u{28365}\u{28412}\u8FA5\u9303\u{2A29F}\u{20A50}\u8FB3\u492A\u{289DE}\u{2853D}\u{23DBB}\u5EF8\u{23262}\u8FF9\u{2A014}\u{286BC}\u{28501}\u{22325}\u3980\u{26ED7}\u9037\u{2853C}\u{27ABE}\u9061\u{2856C}\u{2860B}\u90A8\u{28713}\u90C4\u{286E6}\u90AE\u90FD\u9167\u3AF0\u91A9\u91C4\u7CAC\u{28933}\u{21E89}\u920E\u6C9F\u9241\u9262\u{255B9}\u92B9\u{28AC6}\u{23C9B}\u{28B0C}\u{255DB}"],
      ["90a1", "\u{20D31}\u932C\u936B\u{28AE1}\u{28BEB}\u708F\u5AC3\u{28AE2}\u{28AE5}\u4965\u9244\u{28BEC}\u{28C39}\u{28BFF}\u9373\u945B\u8EBC\u9585\u95A6\u9426\u95A0\u6FF6\u42B9\u{2267A}\u{286D8}\u{2127C}\u{23E2E}\u49DF\u6C1C\u967B\u9696\u416C\u96A3\u{26ED5}\u61DA\u96B6\u78F5\u{28AE0}\u96BD\u53CC\u49A1\u{26CB8}\u{20274}\u{26410}\u{290AF}\u{290E5}\u{24AD1}\u{21915}\u{2330A}\u9731\u8642\u9736\u4A0F\u453D\u4585\u{24AE9}\u7075\u5B41\u971B\u975C\u{291D5}\u9757\u5B4A\u{291EB}\u975F\u9425\u50D0\u{230B7}\u{230BC}\u9789\u979F\u97B1\u97BE\u97C0\u97D2\u97E0\u{2546C}\u97EE\u741C\u{29433}\u97FF\u97F5\u{2941D}\u{2797A}\u4AD1\u9834\u9833\u984B\u9866\u3B0E\u{27175}\u3D51\u{20630}\u{2415C}"],
      ["9140", "\u{25706}\u98CA\u98B7\u98C8\u98C7\u4AFF\u{26D27}\u{216D3}\u55B0\u98E1\u98E6\u98EC\u9378\u9939\u{24A29}\u4B72\u{29857}\u{29905}\u99F5\u9A0C\u9A3B\u9A10\u9A58\u{25725}\u36C4\u{290B1}\u{29BD5}\u9AE0\u9AE2\u{29B05}\u9AF4\u4C0E\u9B14\u9B2D\u{28600}\u5034\u9B34\u{269A8}\u38C3\u{2307D}\u9B50\u9B40\u{29D3E}\u5A45\u{21863}\u9B8E\u{2424B}\u9C02\u9BFF\u9C0C\u{29E68}\u9DD4\u{29FB7}\u{2A192}\u{2A1AB}\u{2A0E1}\u{2A123}\u{2A1DF}\u9D7E\u9D83\u{2A134}\u9E0E\u6888"],
      ["91a1", "\u9DC4\u{2215B}\u{2A193}\u{2A220}\u{2193B}\u{2A233}\u9D39\u{2A0B9}\u{2A2B4}\u9E90\u9E95\u9E9E\u9EA2\u4D34\u9EAA\u9EAF\u{24364}\u9EC1\u3B60\u39E5\u3D1D\u4F32\u37BE\u{28C2B}\u9F02\u9F08\u4B96\u9424\u{26DA2}\u9F17\u9F16\u9F39\u569F\u568A\u9F45\u99B8\u{2908B}\u97F2\u847F\u9F62\u9F69\u7ADC\u9F8E\u7216\u4BBE\u{24975}\u{249BB}\u7177\u{249F8}\u{24348}\u{24A51}\u739E\u{28BDA}\u{218FA}\u799F\u{2897E}\u{28E36}\u9369\u93F3\u{28A44}\u92EC\u9381\u93CB\u{2896C}\u{244B9}\u7217\u3EEB\u7772\u7A43\u70D0\u{24473}\u{243F8}\u717E\u{217EF}\u70A3\u{218BE}\u{23599}\u3EC7\u{21885}\u{2542F}\u{217F8}\u3722\u{216FB}\u{21839}\u36E1\u{21774}\u{218D1}\u{25F4B}\u3723\u{216C0}\u575B\u{24A25}\u{213FE}\u{212A8}"],
      ["9240", "\u{213C6}\u{214B6}\u8503\u{236A6}\u8503\u8455\u{24994}\u{27165}\u{23E31}\u{2555C}\u{23EFB}\u{27052}\u44F4\u{236EE}\u{2999D}\u{26F26}\u67F9\u3733\u3C15\u3DE7\u586C\u{21922}\u6810\u4057\u{2373F}\u{240E1}\u{2408B}\u{2410F}\u{26C21}\u54CB\u569E\u{266B1}\u5692\u{20FDF}\u{20BA8}\u{20E0D}\u93C6\u{28B13}\u939C\u4EF8\u512B\u3819\u{24436}\u4EBC\u{20465}\u{2037F}\u4F4B\u4F8A\u{25651}\u5A68\u{201AB}\u{203CB}\u3999\u{2030A}\u{20414}\u3435\u4F29\u{202C0}\u{28EB3}\u{20275}\u8ADA\u{2020C}\u4E98"],
      ["92a1", "\u50CD\u510D\u4FA2\u4F03\u{24A0E}\u{23E8A}\u4F42\u502E\u506C\u5081\u4FCC\u4FE5\u5058\u50FC\u5159\u515B\u515D\u515E\u6E76\u{23595}\u{23E39}\u{23EBF}\u6D72\u{21884}\u{23E89}\u51A8\u51C3\u{205E0}\u44DD\u{204A3}\u{20492}\u{20491}\u8D7A\u{28A9C}\u{2070E}\u5259\u52A4\u{20873}\u52E1\u936E\u467A\u718C\u{2438C}\u{20C20}\u{249AC}\u{210E4}\u69D1\u{20E1D}\u7479\u3EDE\u7499\u7414\u7456\u7398\u4B8E\u{24ABC}\u{2408D}\u53D0\u3584\u720F\u{240C9}\u55B4\u{20345}\u54CD\u{20BC6}\u571D\u925D\u96F4\u9366\u57DD\u578D\u577F\u363E\u58CB\u5A99\u{28A46}\u{216FA}\u{2176F}\u{21710}\u5A2C\u59B8\u928F\u5A7E\u5ACF\u5A12\u{25946}\u{219F3}\u{21861}\u{24295}\u36F5\u6D05\u7443\u5A21\u{25E83}"],
      ["9340", "\u5A81\u{28BD7}\u{20413}\u93E0\u748C\u{21303}\u7105\u4972\u9408\u{289FB}\u93BD\u37A0\u5C1E\u5C9E\u5E5E\u5E48\u{21996}\u{2197C}\u{23AEE}\u5ECD\u5B4F\u{21903}\u{21904}\u3701\u{218A0}\u36DD\u{216FE}\u36D3\u812A\u{28A47}\u{21DBA}\u{23472}\u{289A8}\u5F0C\u5F0E\u{21927}\u{217AB}\u5A6B\u{2173B}\u5B44\u8614\u{275FD}\u8860\u607E\u{22860}\u{2262B}\u5FDB\u3EB8\u{225AF}\u{225BE}\u{29088}\u{26F73}\u61C0\u{2003E}\u{20046}\u{2261B}\u6199\u6198\u6075\u{22C9B}\u{22D07}\u{246D4}\u{2914D}"],
      ["93a1", "\u6471\u{24665}\u{22B6A}\u3A29\u{22B22}\u{23450}\u{298EA}\u{22E78}\u6337\u{2A45B}\u64B6\u6331\u63D1\u{249E3}\u{22D67}\u62A4\u{22CA1}\u643B\u656B\u6972\u3BF4\u{2308E}\u{232AD}\u{24989}\u{232AB}\u550D\u{232E0}\u{218D9}\u{2943F}\u66CE\u{23289}\u{231B3}\u3AE0\u4190\u{25584}\u{28B22}\u{2558F}\u{216FC}\u{2555B}\u{25425}\u78EE\u{23103}\u{2182A}\u{23234}\u3464\u{2320F}\u{23182}\u{242C9}\u668E\u{26D24}\u666B\u4B93\u6630\u{27870}\u{21DEB}\u6663\u{232D2}\u{232E1}\u661E\u{25872}\u38D1\u{2383A}\u{237BC}\u3B99\u{237A2}\u{233FE}\u74D0\u3B96\u678F\u{2462A}\u68B6\u681E\u3BC4\u6ABE\u3863\u{237D5}\u{24487}\u6A33\u6A52\u6AC9\u6B05\u{21912}\u6511\u6898\u6A4C\u3BD7\u6A7A\u6B57\u{23FC0}\u{23C9A}\u93A0\u92F2\u{28BEA}\u{28ACB}"],
      ["9440", "\u9289\u{2801E}\u{289DC}\u9467\u6DA5\u6F0B\u{249EC}\u6D67\u{23F7F}\u3D8F\u6E04\u{2403C}\u5A3D\u6E0A\u5847\u6D24\u7842\u713B\u{2431A}\u{24276}\u70F1\u7250\u7287\u7294\u{2478F}\u{24725}\u5179\u{24AA4}\u{205EB}\u747A\u{23EF8}\u{2365F}\u{24A4A}\u{24917}\u{25FE1}\u3F06\u3EB1\u{24ADF}\u{28C23}\u{23F35}\u60A7\u3EF3\u74CC\u743C\u9387\u7437\u449F\u{26DEA}\u4551\u7583\u3F63\u{24CD9}\u{24D06}\u3F58\u7555\u7673\u{2A5C6}\u3B19\u7468\u{28ACC}\u{249AB}\u{2498E}\u3AFB"],
      ["94a1", "\u3DCD\u{24A4E}\u3EFF\u{249C5}\u{248F3}\u91FA\u5732\u9342\u{28AE3}\u{21864}\u50DF\u{25221}\u{251E7}\u7778\u{23232}\u770E\u770F\u777B\u{24697}\u{23781}\u3A5E\u{248F0}\u7438\u749B\u3EBF\u{24ABA}\u{24AC7}\u40C8\u{24A96}\u{261AE}\u9307\u{25581}\u781E\u788D\u7888\u78D2\u73D0\u7959\u{27741}\u{256E3}\u410E\u799B\u8496\u79A5\u6A2D\u{23EFA}\u7A3A\u79F4\u416E\u{216E6}\u4132\u9235\u79F1\u{20D4C}\u{2498C}\u{20299}\u{23DBA}\u{2176E}\u3597\u556B\u3570\u36AA\u{201D4}\u{20C0D}\u7AE2\u5A59\u{226F5}\u{25AAF}\u{25A9C}\u5A0D\u{2025B}\u78F0\u5A2A\u{25BC6}\u7AFE\u41F9\u7C5D\u7C6D\u4211\u{25BB3}\u{25EBC}\u{25EA6}\u7CCD\u{249F9}\u{217B0}\u7C8E\u7C7C\u7CAE\u6AB2\u7DDC\u7E07\u7DD3\u7F4E\u{26261}"],
      ["9540", "\u{2615C}\u{27B48}\u7D97\u{25E82}\u426A\u{26B75}\u{20916}\u67D6\u{2004E}\u{235CF}\u57C4\u{26412}\u{263F8}\u{24962}\u7FDD\u7B27\u{2082C}\u{25AE9}\u{25D43}\u7B0C\u{25E0E}\u99E6\u8645\u9A63\u6A1C\u{2343F}\u39E2\u{249F7}\u{265AD}\u9A1F\u{265A0}\u8480\u{27127}\u{26CD1}\u44EA\u8137\u4402\u80C6\u8109\u8142\u{267B4}\u98C3\u{26A42}\u8262\u8265\u{26A51}\u8453\u{26DA7}\u8610\u{2721B}\u5A86\u417F\u{21840}\u5B2B\u{218A1}\u5AE4\u{218D8}\u86A0\u{2F9BC}\u{23D8F}\u882D\u{27422}\u5A02"],
      ["95a1", "\u886E\u4F45\u8887\u88BF\u88E6\u8965\u894D\u{25683}\u8954\u{27785}\u{27784}\u{28BF5}\u{28BD9}\u{28B9C}\u{289F9}\u3EAD\u84A3\u46F5\u46CF\u37F2\u8A3D\u8A1C\u{29448}\u5F4D\u922B\u{24284}\u65D4\u7129\u70C4\u{21845}\u9D6D\u8C9F\u8CE9\u{27DDC}\u599A\u77C3\u59F0\u436E\u36D4\u8E2A\u8EA7\u{24C09}\u8F30\u8F4A\u42F4\u6C58\u6FBB\u{22321}\u489B\u6F79\u6E8B\u{217DA}\u9BE9\u36B5\u{2492F}\u90BB\u9097\u5571\u4906\u91BB\u9404\u{28A4B}\u4062\u{28AFC}\u9427\u{28C1D}\u{28C3B}\u84E5\u8A2B\u9599\u95A7\u9597\u9596\u{28D34}\u7445\u3EC2\u{248FF}\u{24A42}\u{243EA}\u3EE7\u{23225}\u968F\u{28EE7}\u{28E66}\u{28E65}\u3ECC\u{249ED}\u{24A78}\u{23FEE}\u7412\u746B\u3EFC\u9741\u{290B0}"],
      ["9640", "\u6847\u4A1D\u{29093}\u{257DF}\u975D\u9368\u{28989}\u{28C26}\u{28B2F}\u{263BE}\u92BA\u5B11\u8B69\u493C\u73F9\u{2421B}\u979B\u9771\u9938\u{20F26}\u5DC1\u{28BC5}\u{24AB2}\u981F\u{294DA}\u92F6\u{295D7}\u91E5\u44C0\u{28B50}\u{24A67}\u{28B64}\u98DC\u{28A45}\u3F00\u922A\u4925\u8414\u993B\u994D\u{27B06}\u3DFD\u999B\u4B6F\u99AA\u9A5C\u{28B65}\u{258C8}\u6A8F\u9A21\u5AFE\u9A2F\u{298F1}\u4B90\u{29948}\u99BC\u4BBD\u4B97\u937D\u5872\u{21302}\u5822\u{249B8}"],
      ["96a1", "\u{214E8}\u7844\u{2271F}\u{23DB8}\u68C5\u3D7D\u9458\u3927\u6150\u{22781}\u{2296B}\u6107\u9C4F\u9C53\u9C7B\u9C35\u9C10\u9B7F\u9BCF\u{29E2D}\u9B9F\u{2A1F5}\u{2A0FE}\u9D21\u4CAE\u{24104}\u9E18\u4CB0\u9D0C\u{2A1B4}\u{2A0ED}\u{2A0F3}\u{2992F}\u9DA5\u84BD\u{26E12}\u{26FDF}\u{26B82}\u85FC\u4533\u{26DA4}\u{26E84}\u{26DF0}\u8420\u85EE\u{26E00}\u{237D7}\u{26064}\u79E2\u{2359C}\u{23640}\u492D\u{249DE}\u3D62\u93DB\u92BE\u9348\u{202BF}\u78B9\u9277\u944D\u4FE4\u3440\u9064\u{2555D}\u783D\u7854\u78B6\u784B\u{21757}\u{231C9}\u{24941}\u369A\u4F72\u6FDA\u6FD9\u701E\u701E\u5414\u{241B5}\u57BB\u58F3\u578A\u9D16\u57D7\u7134\u34AF\u{241AC}\u71EB\u{26C40}\u{24F97}\u5B28\u{217B5}\u{28A49}"],
      ["9740", "\u610C\u5ACE\u5A0B\u42BC\u{24488}\u372C\u4B7B\u{289FC}\u93BB\u93B8\u{218D6}\u{20F1D}\u8472\u{26CC0}\u{21413}\u{242FA}\u{22C26}\u{243C1}\u5994\u{23DB7}\u{26741}\u7DA8\u{2615B}\u{260A4}\u{249B9}\u{2498B}\u{289FA}\u92E5\u73E2\u3EE9\u74B4\u{28B63}\u{2189F}\u3EE1\u{24AB3}\u6AD8\u73F3\u73FB\u3ED6\u{24A3E}\u{24A94}\u{217D9}\u{24A66}\u{203A7}\u{21424}\u{249E5}\u7448\u{24916}\u70A5\u{24976}\u9284\u73E6\u935F\u{204FE}\u9331\u{28ACE}\u{28A16}\u9386\u{28BE7}\u{255D5}\u4935\u{28A82}\u716B"],
      ["97a1", "\u{24943}\u{20CFF}\u56A4\u{2061A}\u{20BEB}\u{20CB8}\u5502\u79C4\u{217FA}\u7DFE\u{216C2}\u{24A50}\u{21852}\u452E\u9401\u370A\u{28AC0}\u{249AD}\u59B0\u{218BF}\u{21883}\u{27484}\u5AA1\u36E2\u{23D5B}\u36B0\u925F\u5A79\u{28A81}\u{21862}\u9374\u3CCD\u{20AB4}\u4A96\u398A\u50F4\u3D69\u3D4C\u{2139C}\u7175\u42FB\u{28218}\u6E0F\u{290E4}\u44EB\u6D57\u{27E4F}\u7067\u6CAF\u3CD6\u{23FED}\u{23E2D}\u6E02\u6F0C\u3D6F\u{203F5}\u7551\u36BC\u34C8\u4680\u3EDA\u4871\u59C4\u926E\u493E\u8F41\u{28C1C}\u{26BC0}\u5812\u57C8\u36D6\u{21452}\u70FE\u{24362}\u{24A71}\u{22FE3}\u{212B0}\u{223BD}\u68B9\u6967\u{21398}\u{234E5}\u{27BF4}\u{236DF}\u{28A83}\u{237D6}\u{233FA}\u{24C9F}\u6A1A\u{236AD}\u{26CB7}\u843E\u44DF\u44CE"],
      ["9840", "\u{26D26}\u{26D51}\u{26C82}\u{26FDE}\u6F17\u{27109}\u833D\u{2173A}\u83ED\u{26C80}\u{27053}\u{217DB}\u5989\u5A82\u{217B3}\u5A61\u5A71\u{21905}\u{241FC}\u372D\u59EF\u{2173C}\u36C7\u718E\u9390\u669A\u{242A5}\u5A6E\u5A2B\u{24293}\u6A2B\u{23EF9}\u{27736}\u{2445B}\u{242CA}\u711D\u{24259}\u{289E1}\u4FB0\u{26D28}\u5CC2\u{244CE}\u{27E4D}\u{243BD}\u6A0C\u{24256}\u{21304}\u70A6\u7133\u{243E9}\u3DA5\u6CDF\u{2F825}\u{24A4F}\u7E65\u59EB\u5D2F\u3DF3\u5F5C\u{24A5D}\u{217DF}\u7DA4\u8426"],
      ["98a1", "\u5485\u{23AFA}\u{23300}\u{20214}\u577E\u{208D5}\u{20619}\u3FE5\u{21F9E}\u{2A2B6}\u7003\u{2915B}\u5D70\u738F\u7CD3\u{28A59}\u{29420}\u4FC8\u7FE7\u72CD\u7310\u{27AF4}\u7338\u7339\u{256F6}\u7341\u7348\u3EA9\u{27B18}\u906C\u71F5\u{248F2}\u73E1\u81F6\u3ECA\u770C\u3ED1\u6CA2\u56FD\u7419\u741E\u741F\u3EE2\u3EF0\u3EF4\u3EFA\u74D3\u3F0E\u3F53\u7542\u756D\u7572\u758D\u3F7C\u75C8\u75DC\u3FC0\u764D\u3FD7\u7674\u3FDC\u767A\u{24F5C}\u7188\u5623\u8980\u5869\u401D\u7743\u4039\u6761\u4045\u35DB\u7798\u406A\u406F\u5C5E\u77BE\u77CB\u58F2\u7818\u70B9\u781C\u40A8\u7839\u7847\u7851\u7866\u8448\u{25535}\u7933\u6803\u7932\u4103"],
      ["9940", "\u4109\u7991\u7999\u8FBB\u7A06\u8FBC\u4167\u7A91\u41B2\u7ABC\u8279\u41C4\u7ACF\u7ADB\u41CF\u4E21\u7B62\u7B6C\u7B7B\u7C12\u7C1B\u4260\u427A\u7C7B\u7C9C\u428C\u7CB8\u4294\u7CED\u8F93\u70C0\u{20CCF}\u7DCF\u7DD4\u7DD0\u7DFD\u7FAE\u7FB4\u729F\u4397\u8020\u8025\u7B39\u802E\u8031\u8054\u3DCC\u57B4\u70A0\u80B7\u80E9\u43ED\u810C\u732A\u810E\u8112\u7560\u8114\u4401\u3B39\u8156\u8159\u815A"],
      ["99a1", "\u4413\u583A\u817C\u8184\u4425\u8193\u442D\u81A5\u57EF\u81C1\u81E4\u8254\u448F\u82A6\u8276\u82CA\u82D8\u82FF\u44B0\u8357\u9669\u698A\u8405\u70F5\u8464\u60E3\u8488\u4504\u84BE\u84E1\u84F8\u8510\u8538\u8552\u453B\u856F\u8570\u85E0\u4577\u8672\u8692\u86B2\u86EF\u9645\u878B\u4606\u4617\u88AE\u88FF\u8924\u8947\u8991\u{27967}\u8A29\u8A38\u8A94\u8AB4\u8C51\u8CD4\u8CF2\u8D1C\u4798\u585F\u8DC3\u47ED\u4EEE\u8E3A\u55D8\u5754\u8E71\u55F5\u8EB0\u4837\u8ECE\u8EE2\u8EE4\u8EED\u8EF2\u8FB7\u8FC1\u8FCA\u8FCC\u9033\u99C4\u48AD\u98E0\u9213\u491E\u9228\u9258\u926B\u92B1\u92AE\u92BF"],
      ["9a40", "\u92E3\u92EB\u92F3\u92F4\u92FD\u9343\u9384\u93AD\u4945\u4951\u9EBF\u9417\u5301\u941D\u942D\u943E\u496A\u9454\u9479\u952D\u95A2\u49A7\u95F4\u9633\u49E5\u67A0\u4A24\u9740\u4A35\u97B2\u97C2\u5654\u4AE4\u60E8\u98B9\u4B19\u98F1\u5844\u990E\u9919\u51B4\u991C\u9937\u9942\u995D\u9962\u4B70\u99C5\u4B9D\u9A3C\u9B0F\u7A83\u9B69\u9B81\u9BDD\u9BF1\u9BF4\u4C6D\u9C20\u376F\u{21BC2}\u9D49\u9C3A"],
      ["9aa1", "\u9EFE\u5650\u9D93\u9DBD\u9DC0\u9DFC\u94F6\u8FB6\u9E7B\u9EAC\u9EB1\u9EBD\u9EC6\u94DC\u9EE2\u9EF1\u9EF8\u7AC8\u9F44\u{20094}\u{202B7}\u{203A0}\u691A\u94C3\u59AC\u{204D7}\u5840\u94C1\u37B9\u{205D5}\u{20615}\u{20676}\u{216BA}\u5757\u7173\u{20AC2}\u{20ACD}\u{20BBF}\u546A\u{2F83B}\u{20BCB}\u549E\u{20BFB}\u{20C3B}\u{20C53}\u{20C65}\u{20C7C}\u60E7\u{20C8D}\u567A\u{20CB5}\u{20CDD}\u{20CED}\u{20D6F}\u{20DB2}\u{20DC8}\u6955\u9C2F\u87A5\u{20E04}\u{20E0E}\u{20ED7}\u{20F90}\u{20F2D}\u{20E73}\u5C20\u{20FBC}\u5E0B\u{2105C}\u{2104F}\u{21076}\u671E\u{2107B}\u{21088}\u{21096}\u3647\u{210BF}\u{210D3}\u{2112F}\u{2113B}\u5364\u84AD\u{212E3}\u{21375}\u{21336}\u8B81\u{21577}\u{21619}\u{217C3}\u{217C7}\u4E78\u70BB\u{2182D}\u{2196A}"],
      ["9b40", "\u{21A2D}\u{21A45}\u{21C2A}\u{21C70}\u{21CAC}\u{21EC8}\u62C3\u{21ED5}\u{21F15}\u7198\u6855\u{22045}\u69E9\u36C8\u{2227C}\u{223D7}\u{223FA}\u{2272A}\u{22871}\u{2294F}\u82FD\u{22967}\u{22993}\u{22AD5}\u89A5\u{22AE8}\u8FA0\u{22B0E}\u97B8\u{22B3F}\u9847\u9ABD\u{22C4C}"],
      ["9b62", "\u{22C88}\u{22CB7}\u{25BE8}\u{22D08}\u{22D12}\u{22DB7}\u{22D95}\u{22E42}\u{22F74}\u{22FCC}\u{23033}\u{23066}\u{2331F}\u{233DE}\u5FB1\u6648\u66BF\u{27A79}\u{23567}\u{235F3}\u7201\u{249BA}\u77D7\u{2361A}\u{23716}\u7E87\u{20346}\u58B5\u670E"],
      ["9ba1", "\u6918\u{23AA7}\u{27657}\u{25FE2}\u{23E11}\u{23EB9}\u{275FE}\u{2209A}\u48D0\u4AB8\u{24119}\u{28A9A}\u{242EE}\u{2430D}\u{2403B}\u{24334}\u{24396}\u{24A45}\u{205CA}\u51D2\u{20611}\u599F\u{21EA8}\u3BBE\u{23CFF}\u{24404}\u{244D6}\u5788\u{24674}\u399B\u{2472F}\u{285E8}\u{299C9}\u3762\u{221C3}\u8B5E\u{28B4E}\u99D6\u{24812}\u{248FB}\u{24A15}\u7209\u{24AC0}\u{20C78}\u5965\u{24EA5}\u{24F86}\u{20779}\u8EDA\u{2502C}\u528F\u573F\u7171\u{25299}\u{25419}\u{23F4A}\u{24AA7}\u55BC\u{25446}\u{2546E}\u{26B52}\u91D4\u3473\u{2553F}\u{27632}\u{2555E}\u4718\u{25562}\u{25566}\u{257C7}\u{2493F}\u{2585D}\u5066\u34FB\u{233CC}\u60DE\u{25903}\u477C\u{28948}\u{25AAE}\u{25B89}\u{25C06}\u{21D90}\u57A1\u7151\u6FB6\u{26102}\u{27C12}\u9056\u{261B2}\u{24F9A}\u8B62\u{26402}\u{2644A}"],
      ["9c40", "\u5D5B\u{26BF7}\u8F36\u{26484}\u{2191C}\u8AEA\u{249F6}\u{26488}\u{23FEF}\u{26512}\u4BC0\u{265BF}\u{266B5}\u{2271B}\u9465\u{257E1}\u6195\u5A27\u{2F8CD}\u4FBB\u56B9\u{24521}\u{266FC}\u4E6A\u{24934}\u9656\u6D8F\u{26CBD}\u3618\u8977\u{26799}\u{2686E}\u{26411}\u{2685E}\u71DF\u{268C7}\u7B42\u{290C0}\u{20A11}\u{26926}\u9104\u{26939}\u7A45\u9DF0\u{269FA}\u9A26\u{26A2D}\u365F\u{26469}\u{20021}\u7983\u{26A34}\u{26B5B}\u5D2C\u{23519}\u83CF\u{26B9D}\u46D0\u{26CA4}\u753B\u8865\u{26DAE}\u58B6"],
      ["9ca1", "\u371C\u{2258D}\u{2704B}\u{271CD}\u3C54\u{27280}\u{27285}\u9281\u{2217A}\u{2728B}\u9330\u{272E6}\u{249D0}\u6C39\u949F\u{27450}\u{20EF8}\u8827\u88F5\u{22926}\u{28473}\u{217B1}\u6EB8\u{24A2A}\u{21820}\u39A4\u36B9\u5C10\u79E3\u453F\u66B6\u{29CAD}\u{298A4}\u8943\u{277CC}\u{27858}\u56D6\u40DF\u{2160A}\u39A1\u{2372F}\u{280E8}\u{213C5}\u71AD\u8366\u{279DD}\u{291A8}\u5A67\u4CB7\u{270AF}\u{289AB}\u{279FD}\u{27A0A}\u{27B0B}\u{27D66}\u{2417A}\u7B43\u797E\u{28009}\u6FB5\u{2A2DF}\u6A03\u{28318}\u53A2\u{26E07}\u93BF\u6836\u975D\u{2816F}\u{28023}\u{269B5}\u{213ED}\u{2322F}\u{28048}\u5D85\u{28C30}\u{28083}\u5715\u9823\u{28949}\u5DAB\u{24988}\u65BE\u69D5\u53D2\u{24AA5}\u{23F81}\u3C11\u6736\u{28090}\u{280F4}\u{2812E}\u{21FA1}\u{2814F}"],
      ["9d40", "\u{28189}\u{281AF}\u{2821A}\u{28306}\u{2832F}\u{2838A}\u35CA\u{28468}\u{286AA}\u48FA\u63E6\u{28956}\u7808\u9255\u{289B8}\u43F2\u{289E7}\u43DF\u{289E8}\u{28B46}\u{28BD4}\u59F8\u{28C09}\u8F0B\u{28FC5}\u{290EC}\u7B51\u{29110}\u{2913C}\u3DF7\u{2915E}\u{24ACA}\u8FD0\u728F\u568B\u{294E7}\u{295E9}\u{295B0}\u{295B8}\u{29732}\u{298D1}\u{29949}\u{2996A}\u{299C3}\u{29A28}\u{29B0E}\u{29D5A}\u{29D9B}\u7E9F\u{29EF8}\u{29F23}\u4CA4\u9547\u{2A293}\u71A2\u{2A2FF}\u4D91\u9012\u{2A5CB}\u4D9C\u{20C9C}\u8FBE\u55C1"],
      ["9da1", "\u8FBA\u{224B0}\u8FB9\u{24A93}\u4509\u7E7F\u6F56\u6AB1\u4EEA\u34E4\u{28B2C}\u{2789D}\u373A\u8E80\u{217F5}\u{28024}\u{28B6C}\u{28B99}\u{27A3E}\u{266AF}\u3DEB\u{27655}\u{23CB7}\u{25635}\u{25956}\u4E9A\u{25E81}\u{26258}\u56BF\u{20E6D}\u8E0E\u5B6D\u{23E88}\u{24C9E}\u63DE\u62D0\u{217F6}\u{2187B}\u6530\u562D\u{25C4A}\u541A\u{25311}\u3DC6\u{29D98}\u4C7D\u5622\u561E\u7F49\u{25ED8}\u5975\u{23D40}\u8770\u4E1C\u{20FEA}\u{20D49}\u{236BA}\u8117\u9D5E\u8D18\u763B\u9C45\u764E\u77B9\u9345\u5432\u8148\u82F7\u5625\u8132\u8418\u80BD\u55EA\u7962\u5643\u5416\u{20E9D}\u35CE\u5605\u55F1\u66F1\u{282E2}\u362D\u7534\u55F0\u55BA\u5497\u5572\u{20C41}\u{20C96}\u5ED0\u{25148}\u{20E76}\u{22C62}"],
      ["9e40", "\u{20EA2}\u9EAB\u7D5A\u55DE\u{21075}\u629D\u976D\u5494\u8CCD\u71F6\u9176\u63FC\u63B9\u63FE\u5569\u{22B43}\u9C72\u{22EB3}\u519A\u34DF\u{20DA7}\u51A7\u544D\u551E\u5513\u7666\u8E2D\u{2688A}\u75B1\u80B6\u8804\u8786\u88C7\u81B6\u841C\u{210C1}\u44EC\u7304\u{24706}\u5B90\u830B\u{26893}\u567B\u{226F4}\u{27D2F}\u{241A3}\u{27D73}\u{26ED0}\u{272B6}\u9170\u{211D9}\u9208\u{23CFC}\u{2A6A9}\u{20EAC}\u{20EF9}\u7266\u{21CA2}\u474E\u{24FC2}\u{27FF9}\u{20FEB}\u40FA"],
      ["9ea1", "\u9C5D\u651F\u{22DA0}\u48F3\u{247E0}\u{29D7C}\u{20FEC}\u{20E0A}\u6062\u{275A3}\u{20FED}"],
      ["9ead", "\u{26048}\u{21187}\u71A3\u7E8E\u9D50\u4E1A\u4E04\u3577\u5B0D\u6CB2\u5367\u36AC\u39DC\u537D\u36A5\u{24618}\u589A\u{24B6E}\u822D\u544B\u57AA\u{25A95}\u{20979}"],
      ["9ec5", "\u3A52\u{22465}\u7374\u{29EAC}\u4D09\u9BED\u{23CFE}\u{29F30}\u4C5B\u{24FA9}\u{2959E}\u{29FDE}\u845C\u{23DB6}\u{272B2}\u{267B3}\u{23720}\u632E\u7D25\u{23EF7}\u{23E2C}\u3A2A\u9008\u52CC\u3E74\u367A\u45E9\u{2048E}\u7640\u5AF0\u{20EB6}\u787A\u{27F2E}\u58A7\u40BF\u567C\u9B8B\u5D74\u7654\u{2A434}\u9E85\u4CE1\u75F9\u37FB\u6119\u{230DA}\u{243F2}"],
      ["9ef5", "\u565D\u{212A9}\u57A7\u{24963}\u{29E06}\u5234\u{270AE}\u35AD\u6C4A\u9D7C"],
      ["9f40", "\u7C56\u9B39\u57DE\u{2176C}\u5C53\u64D3\u{294D0}\u{26335}\u{27164}\u86AD\u{20D28}\u{26D22}\u{24AE2}\u{20D71}"],
      ["9f4f", "\u51FE\u{21F0F}\u5D8E\u9703\u{21DD1}\u9E81\u904C\u7B1F\u9B02\u5CD1\u7BA3\u6268\u6335\u9AFF\u7BCF\u9B2A\u7C7E\u9B2E\u7C42\u7C86\u9C15\u7BFC\u9B09\u9F17\u9C1B\u{2493E}\u9F5A\u5573\u5BC3\u4FFD\u9E98\u4FF2\u5260\u3E06\u52D1\u5767\u5056\u59B7\u5E12\u97C8\u9DAB\u8F5C\u5469\u97B4\u9940\u97BA\u532C\u6130"],
      ["9fa1", "\u692C\u53DA\u9C0A\u9D02\u4C3B\u9641\u6980\u50A6\u7546\u{2176D}\u99DA\u5273"],
      ["9fae", "\u9159\u9681\u915C"],
      ["9fb2", "\u9151\u{28E97}\u637F\u{26D23}\u6ACA\u5611\u918E\u757A\u6285\u{203FC}\u734F\u7C70\u{25C21}\u{23CFD}"],
      ["9fc1", "\u{24919}\u76D6\u9B9D\u4E2A\u{20CD4}\u83BE\u8842"],
      ["9fc9", "\u5C4A\u69C0\u50ED\u577A\u521F\u5DF5\u4ECE\u6C31\u{201F2}\u4F39\u549C\u54DA\u529A\u8D82\u35FE\u5F0C\u35F3"],
      ["9fdb", "\u6B52\u917C\u9FA5\u9B97\u982E\u98B4\u9ABA\u9EA8\u9E84\u717A\u7B14"],
      ["9fe7", "\u6BFA\u8818\u7F78"],
      ["9feb", "\u5620\u{2A64A}\u8E77\u9F53"],
      ["9ff0", "\u8DD4\u8E4F\u9E1C\u8E01\u6282\u{2837D}\u8E28\u8E75\u7AD3\u{24A77}\u7A3E\u78D8\u6CEA\u8A67\u7607"],
      ["a040", "\u{28A5A}\u9F26\u6CCE\u87D6\u75C3\u{2A2B2}\u7853\u{2F840}\u8D0C\u72E2\u7371\u8B2D\u7302\u74F1\u8CEB\u{24ABB}\u862F\u5FBA\u88A0\u44B7"],
      ["a055", "\u{2183B}\u{26E05}"],
      ["a058", "\u8A7E\u{2251B}"],
      ["a05b", "\u60FD\u7667\u9AD7\u9D44\u936E\u9B8F\u87F5"],
      ["a063", "\u880F\u8CF7\u732C\u9721\u9BB0\u35D6\u72B2\u4C07\u7C51\u994A\u{26159}\u6159\u4C04\u9E96\u617D"],
      ["a073", "\u575F\u616F\u62A6\u6239\u62CE\u3A5C\u61E2\u53AA\u{233F5}\u6364\u6802\u35D2"],
      ["a0a1", "\u5D57\u{28BC2}\u8FDA\u{28E39}"],
      ["a0a6", "\u50D9\u{21D46}\u7906\u5332\u9638\u{20F3B}\u4065"],
      ["a0ae", "\u77FE"],
      ["a0b0", "\u7CC2\u{25F1A}\u7CDA\u7A2D\u8066\u8063\u7D4D\u7505\u74F2\u8994\u821A\u670C\u8062\u{27486}\u805B\u74F0\u8103\u7724\u8989\u{267CC}\u7553\u{26ED1}\u87A9\u87CE\u81C8\u878C\u8A49\u8CAD\u8B43\u772B\u74F8\u84DA\u3635\u69B2\u8DA6"],
      ["a0d4", "\u89A9\u7468\u6DB9\u87C1\u{24011}\u74E7\u3DDB\u7176\u60A4\u619C\u3CD1\u7162\u6077"],
      ["a0e2", "\u7F71\u{28B2D}\u7250\u60E9\u4B7E\u5220\u3C18\u{23CC7}\u{25ED7}\u{27656}\u{25531}\u{21944}\u{212FE}\u{29903}\u{26DDC}\u{270AD}\u5CC1\u{261AD}\u{28A0F}\u{23677}\u{200EE}\u{26846}\u{24F0E}\u4562\u5B1F\u{2634C}\u9F50\u9EA6\u{2626B}"],
      ["a3c0", "\u2400", 31, "\u2421"],
      ["c6a1", "\u2460", 9, "\u2474", 9, "\u2170", 9, "\u4E36\u4E3F\u4E85\u4EA0\u5182\u5196\u51AB\u52F9\u5338\u5369\u53B6\u590A\u5B80\u5DDB\u2F33\u5E7F\u5EF4\u5F50\u5F61\u6534\u65E0\u7592\u7676\u8FB5\u96B6\xA8\u02C6\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\uFF3B\uFF3D\u273D\u3041", 23],
      ["c740", "\u3059", 58, "\u30A1\u30A2\u30A3\u30A4"],
      ["c7a1", "\u30A5", 81, "\u0410", 5, "\u0401\u0416", 4],
      ["c840", "\u041B", 26, "\u0451\u0436", 25, "\u21E7\u21B8\u21B9\u31CF\u{200CC}\u4E5A\u{2008A}\u5202\u4491"],
      ["c8a1", "\u9FB0\u5188\u9FB1\u{27607}"],
      ["c8cd", "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u309B\u309C\u2E80\u2E84\u2E86\u2E87\u2E88\u2E8A\u2E8C\u2E8D\u2E95\u2E9C\u2E9D\u2EA5\u2EA7\u2EAA\u2EAC\u2EAE\u2EB6\u2EBC\u2EBE\u2EC6\u2ECA\u2ECC\u2ECD\u2ECF\u2ED6\u2ED7\u2EDE\u2EE3"],
      ["c8f5", "\u0283\u0250\u025B\u0254\u0275\u0153\xF8\u014B\u028A\u026A"],
      ["f9fe", "\uFFED"],
      ["fa40", "\u{20547}\u92DB\u{205DF}\u{23FC5}\u854C\u42B5\u73EF\u51B5\u3649\u{24942}\u{289E4}\u9344\u{219DB}\u82EE\u{23CC8}\u783C\u6744\u62DF\u{24933}\u{289AA}\u{202A0}\u{26BB3}\u{21305}\u4FAB\u{224ED}\u5008\u{26D29}\u{27A84}\u{23600}\u{24AB1}\u{22513}\u5029\u{2037E}\u5FA4\u{20380}\u{20347}\u6EDB\u{2041F}\u507D\u5101\u347A\u510E\u986C\u3743\u8416\u{249A4}\u{20487}\u5160\u{233B4}\u516A\u{20BFF}\u{220FC}\u{202E5}\u{22530}\u{2058E}\u{23233}\u{21983}\u5B82\u877D\u{205B3}\u{23C99}\u51B2\u51B8"],
      ["faa1", "\u9D34\u51C9\u51CF\u51D1\u3CDC\u51D3\u{24AA6}\u51B3\u51E2\u5342\u51ED\u83CD\u693E\u{2372D}\u5F7B\u520B\u5226\u523C\u52B5\u5257\u5294\u52B9\u52C5\u7C15\u8542\u52E0\u860D\u{26B13}\u5305\u{28ADE}\u5549\u6ED9\u{23F80}\u{20954}\u{23FEC}\u5333\u5344\u{20BE2}\u6CCB\u{21726}\u681B\u73D5\u604A\u3EAA\u38CC\u{216E8}\u71DD\u44A2\u536D\u5374\u{286AB}\u537E\u537F\u{21596}\u{21613}\u77E6\u5393\u{28A9B}\u53A0\u53AB\u53AE\u73A7\u{25772}\u3F59\u739C\u53C1\u53C5\u6C49\u4E49\u57FE\u53D9\u3AAB\u{20B8F}\u53E0\u{23FEB}\u{22DA3}\u53F6\u{20C77}\u5413\u7079\u552B\u6657\u6D5B\u546D\u{26B53}\u{20D74}\u555D\u548F\u54A4\u47A6\u{2170D}\u{20EDD}\u3DB4\u{20D4D}"],
      ["fb40", "\u{289BC}\u{22698}\u5547\u4CED\u542F\u7417\u5586\u55A9\u5605\u{218D7}\u{2403A}\u4552\u{24435}\u66B3\u{210B4}\u5637\u66CD\u{2328A}\u66A4\u66AD\u564D\u564F\u78F1\u56F1\u9787\u53FE\u5700\u56EF\u56ED\u{28B66}\u3623\u{2124F}\u5746\u{241A5}\u6C6E\u708B\u5742\u36B1\u{26C7E}\u57E6\u{21416}\u5803\u{21454}\u{24363}\u5826\u{24BF5}\u585C\u58AA\u3561\u58E0\u58DC\u{2123C}\u58FB\u5BFF\u5743\u{2A150}\u{24278}\u93D3\u35A1\u591F\u68A6\u36C3\u6E59"],
      ["fba1", "\u{2163E}\u5A24\u5553\u{21692}\u8505\u59C9\u{20D4E}\u{26C81}\u{26D2A}\u{217DC}\u59D9\u{217FB}\u{217B2}\u{26DA6}\u6D71\u{21828}\u{216D5}\u59F9\u{26E45}\u5AAB\u5A63\u36E6\u{249A9}\u5A77\u3708\u5A96\u7465\u5AD3\u{26FA1}\u{22554}\u3D85\u{21911}\u3732\u{216B8}\u5E83\u52D0\u5B76\u6588\u5B7C\u{27A0E}\u4004\u485D\u{20204}\u5BD5\u6160\u{21A34}\u{259CC}\u{205A5}\u5BF3\u5B9D\u4D10\u5C05\u{21B44}\u5C13\u73CE\u5C14\u{21CA5}\u{26B28}\u5C49\u48DD\u5C85\u5CE9\u5CEF\u5D8B\u{21DF9}\u{21E37}\u5D10\u5D18\u5D46\u{21EA4}\u5CBA\u5DD7\u82FC\u382D\u{24901}\u{22049}\u{22173}\u8287\u3836\u3BC2\u5E2E\u6A8A\u5E75\u5E7A\u{244BC}\u{20CD3}\u53A6\u4EB7\u5ED0\u53A8\u{21771}\u5E09\u5EF4\u{28482}"],
      ["fc40", "\u5EF9\u5EFB\u38A0\u5EFC\u683E\u941B\u5F0D\u{201C1}\u{2F894}\u3ADE\u48AE\u{2133A}\u5F3A\u{26888}\u{223D0}\u5F58\u{22471}\u5F63\u97BD\u{26E6E}\u5F72\u9340\u{28A36}\u5FA7\u5DB6\u3D5F\u{25250}\u{21F6A}\u{270F8}\u{22668}\u91D6\u{2029E}\u{28A29}\u6031\u6685\u{21877}\u3963\u3DC7\u3639\u5790\u{227B4}\u7971\u3E40\u609E\u60A4\u60B3\u{24982}\u{2498F}\u{27A53}\u74A4\u50E1\u5AA0\u6164\u8424\u6142\u{2F8A6}\u{26ED2}\u6181\u51F4\u{20656}\u6187\u5BAA\u{23FB7}"],
      ["fca1", "\u{2285F}\u61D3\u{28B9D}\u{2995D}\u61D0\u3932\u{22980}\u{228C1}\u6023\u615C\u651E\u638B\u{20118}\u62C5\u{21770}\u62D5\u{22E0D}\u636C\u{249DF}\u3A17\u6438\u63F8\u{2138E}\u{217FC}\u6490\u6F8A\u{22E36}\u9814\u{2408C}\u{2571D}\u64E1\u64E5\u947B\u3A66\u643A\u3A57\u654D\u6F16\u{24A28}\u{24A23}\u6585\u656D\u655F\u{2307E}\u65B5\u{24940}\u4B37\u65D1\u40D8\u{21829}\u65E0\u65E3\u5FDF\u{23400}\u6618\u{231F7}\u{231F8}\u6644\u{231A4}\u{231A5}\u664B\u{20E75}\u6667\u{251E6}\u6673\u6674\u{21E3D}\u{23231}\u{285F4}\u{231C8}\u{25313}\u77C5\u{228F7}\u99A4\u6702\u{2439C}\u{24A21}\u3B2B\u69FA\u{237C2}\u675E\u6767\u6762\u{241CD}\u{290ED}\u67D7\u44E9\u6822\u6E50\u923C\u6801\u{233E6}\u{26DA0}\u685D"],
      ["fd40", "\u{2346F}\u69E1\u6A0B\u{28ADF}\u6973\u68C3\u{235CD}\u6901\u6900\u3D32\u3A01\u{2363C}\u3B80\u67AC\u6961\u{28A4A}\u42FC\u6936\u6998\u3BA1\u{203C9}\u8363\u5090\u69F9\u{23659}\u{2212A}\u6A45\u{23703}\u6A9D\u3BF3\u67B1\u6AC8\u{2919C}\u3C0D\u6B1D\u{20923}\u60DE\u6B35\u6B74\u{227CD}\u6EB5\u{23ADB}\u{203B5}\u{21958}\u3740\u5421\u{23B5A}\u6BE1\u{23EFC}\u6BDC\u6C37\u{2248B}\u{248F1}\u{26B51}\u6C5A\u8226\u6C79\u{23DBC}\u44C5\u{23DBD}\u{241A4}\u{2490C}\u{24900}"],
      ["fda1", "\u{23CC9}\u36E5\u3CEB\u{20D32}\u9B83\u{231F9}\u{22491}\u7F8F\u6837\u{26D25}\u{26DA1}\u{26DEB}\u6D96\u6D5C\u6E7C\u6F04\u{2497F}\u{24085}\u{26E72}\u8533\u{26F74}\u51C7\u6C9C\u6E1D\u842E\u{28B21}\u6E2F\u{23E2F}\u7453\u{23F82}\u79CC\u6E4F\u5A91\u{2304B}\u6FF8\u370D\u6F9D\u{23E30}\u6EFA\u{21497}\u{2403D}\u4555\u93F0\u6F44\u6F5C\u3D4E\u6F74\u{29170}\u3D3B\u6F9F\u{24144}\u6FD3\u{24091}\u{24155}\u{24039}\u{23FF0}\u{23FB4}\u{2413F}\u51DF\u{24156}\u{24157}\u{24140}\u{261DD}\u704B\u707E\u70A7\u7081\u70CC\u70D5\u70D6\u70DF\u4104\u3DE8\u71B4\u7196\u{24277}\u712B\u7145\u5A88\u714A\u716E\u5C9C\u{24365}\u714F\u9362\u{242C1}\u712C\u{2445A}\u{24A27}\u{24A22}\u71BA\u{28BE8}\u70BD\u720E"],
      ["fe40", "\u9442\u7215\u5911\u9443\u7224\u9341\u{25605}\u722E\u7240\u{24974}\u68BD\u7255\u7257\u3E55\u{23044}\u680D\u6F3D\u7282\u732A\u732B\u{24823}\u{2882B}\u48ED\u{28804}\u7328\u732E\u73CF\u73AA\u{20C3A}\u{26A2E}\u73C9\u7449\u{241E2}\u{216E7}\u{24A24}\u6623\u36C5\u{249B7}\u{2498D}\u{249FB}\u73F7\u7415\u6903\u{24A26}\u7439\u{205C3}\u3ED7\u745C\u{228AD}\u7460\u{28EB2}\u7447\u73E4\u7476\u83B9\u746C\u3730\u7474\u93F1\u6A2C\u7482\u4953\u{24A8C}"],
      ["fea1", "\u{2415F}\u{24A79}\u{28B8F}\u5B46\u{28C03}\u{2189E}\u74C8\u{21988}\u750E\u74E9\u751E\u{28ED9}\u{21A4B}\u5BD7\u{28EAC}\u9385\u754D\u754A\u7567\u756E\u{24F82}\u3F04\u{24D13}\u758E\u745D\u759E\u75B4\u7602\u762C\u7651\u764F\u766F\u7676\u{263F5}\u7690\u81EF\u37F8\u{26911}\u{2690E}\u76A1\u76A5\u76B7\u76CC\u{26F9F}\u8462\u{2509D}\u{2517D}\u{21E1C}\u771E\u7726\u7740\u64AF\u{25220}\u7758\u{232AC}\u77AF\u{28964}\u{28968}\u{216C1}\u77F4\u7809\u{21376}\u{24A12}\u68CA\u78AF\u78C7\u78D3\u96A5\u792E\u{255E0}\u78D7\u7934\u78B1\u{2760C}\u8FB8\u8884\u{28B2B}\u{26083}\u{2261C}\u7986\u8900\u6902\u7980\u{25857}\u799D\u{27B39}\u793C\u79A9\u6E2A\u{27126}\u3EA8\u79C6\u{2910D}\u79D4"]
    ];
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/dbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // == Japanese/ShiftJIS ====================================================
      // All japanese encodings are based on JIS X set of standards:
      // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
      // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
      //              Has several variations in 1978, 1983, 1990 and 1997.
      // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
      // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
      //              2 planes, first is superset of 0208, second - revised 0212.
      //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
      // Byte encodings are:
      //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
      //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
      //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
      //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
      //               0x00-0x7F       - lower part of 0201
      //               0x8E, 0xA1-0xDF - upper part of 0201
      //               (0xA1-0xFE)x2   - 0208 plane (94x94).
      //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
      //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
      //               Used as-is in ISO2022 family.
      //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
      //                0201-1976 Roman, 0208-1978, 0208-1983.
      //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
      //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
      //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
      //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
      //
      // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
      //
      // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
      "shiftjis": {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      "csshiftjis": "shiftjis",
      "mskanji": "shiftjis",
      "sjis": "shiftjis",
      "windows31j": "shiftjis",
      "ms31j": "shiftjis",
      "xsjis": "shiftjis",
      "windows932": "shiftjis",
      "ms932": "shiftjis",
      "932": "shiftjis",
      "cp932": "shiftjis",
      "eucjp": {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 }
      },
      // TODO: KDDI extension to Shift_JIS
      // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
      // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
      // == Chinese/GBK ==========================================================
      // http://en.wikipedia.org/wiki/GBK
      // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
      // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
      "gb2312": "cp936",
      "gb231280": "cp936",
      "gb23121980": "cp936",
      "csgb2312": "cp936",
      "csiso58gb231280": "cp936",
      "euccn": "cp936",
      // Microsoft's CP936 is a subset and approximation of GBK.
      "windows936": "cp936",
      "ms936": "cp936",
      "936": "cp936",
      "cp936": {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
      "gbk": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      "xgbk": "gbk",
      "isoir58": "gbk",
      // GB18030 is an algorithmic extension of GBK.
      // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
      // http://icu-project.org/docs/papers/gb18030.html
      // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
      // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
      "gb18030": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "\u20AC": 41699 }
      },
      "chinese": "gb18030",
      // == Korean ===============================================================
      // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
      "windows949": "cp949",
      "ms949": "cp949",
      "949": "cp949",
      "cp949": {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      "cseuckr": "cp949",
      "csksc56011987": "cp949",
      "euckr": "cp949",
      "isoir149": "cp949",
      "korean": "cp949",
      "ksc56011987": "cp949",
      "ksc56011989": "cp949",
      "ksc5601": "cp949",
      // == Big5/Taiwan/Hong Kong ================================================
      // There are lots of tables for Big5 and cp950. Please see the following links for history:
      // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
      // Variations, in roughly number of defined chars:
      //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
      //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
      //  * Big5-2003 (Taiwan standard) almost superset of cp950.
      //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
      //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
      //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
      //    Plus, it has 4 combining sequences.
      //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
      //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
      //    Implementations are not consistent within browsers; sometimes labeled as just big5.
      //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
      //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
      //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
      //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
      //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
      // 
      // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
      // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
      "windows950": "cp950",
      "ms950": "cp950",
      "950": "cp950",
      "cp950": {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
      "big5": "big5hkscs",
      "big5hkscs": {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [
          // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
          // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
          // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
          36457,
          36463,
          36478,
          36523,
          36532,
          36557,
          36560,
          36695,
          36713,
          36718,
          36811,
          36862,
          36973,
          36986,
          37060,
          37084,
          37105,
          37311,
          37551,
          37552,
          37553,
          37554,
          37585,
          37959,
          38090,
          38361,
          38652,
          39285,
          39798,
          39800,
          39803,
          39878,
          39902,
          39916,
          39926,
          40002,
          40019,
          40034,
          40040,
          40043,
          40055,
          40124,
          40125,
          40144,
          40279,
          40282,
          40388,
          40431,
          40443,
          40617,
          40687,
          40701,
          40800,
          40907,
          41079,
          41180,
          41183,
          36812,
          37576,
          38468,
          38637,
          // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
          41636,
          41637,
          41639,
          41638,
          41676,
          41678
        ]
      },
      "cnbig5": "big5hkscs",
      "csbig5": "big5hkscs",
      "xxbig5": "big5hkscs"
    };
  }
});

// node_modules/mssql/node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/encodings/index.js"(exports2, module2) {
    "use strict";
    var modules = [
      require_internal4(),
      require_utf32(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (i = 0; i < modules.length; i++) {
      module2 = modules[i];
      for (enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports2[enc] = module2[enc];
    }
    var module2;
    var enc;
    var i;
  }
});

// node_modules/mssql/node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/lib/streams.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    module2.exports = function(stream_module) {
      var Transform = stream_module.Transform;
      function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false;
        Transform.call(this, options);
      }
      IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
      });
      IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != "string")
          return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length)
            this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length)
            this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on("error", cb);
        this.on("data", function(chunk) {
          chunks.push(chunk);
        });
        this.on("end", function() {
          cb(null, Buffer3.concat(chunks));
        });
        return this;
      };
      function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = "utf8";
        Transform.call(this, options);
      }
      IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
      });
      IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer3.isBuffer(chunk) && !(chunk instanceof Uint8Array))
          return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length)
            this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length)
            this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = "";
        this.on("error", cb);
        this.on("data", function(chunk) {
          res += chunk;
        });
        this.on("end", function() {
          cb(null, res);
        });
        return this;
      };
      return {
        IconvLiteEncoderStream,
        IconvLiteDecoderStream
      };
    };
  }
});

// node_modules/mssql/node_modules/iconv-lite/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/mssql/node_modules/iconv-lite/lib/index.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var iconv = module2.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "\uFFFD";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer3.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer3.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = require_encodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv.supportsStreams)
        return;
      var streams = require_streams()(stream_module2);
      iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
    if (false) {
      console.error("iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/text.js
var require_text = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/text.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Text = {
      id: 35,
      type: "TEXT",
      name: "Text",
      hasTableName: true,
      declaration: function() {
        return "text";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(value.length, 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        yield value;
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports2.default = Text;
    module2.exports = Text;
  }
});

// node_modules/mssql/node_modules/tedious/lib/guid-parser.js
var require_guid_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/guid-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.bufferToLowerCaseGuid = bufferToLowerCaseGuid;
    exports2.bufferToUpperCaseGuid = bufferToUpperCaseGuid;
    exports2.guidToArray = guidToArray;
    var UPPER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF", "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF", "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF", "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF", "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"];
    var LOWER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    function bufferToUpperCaseGuid(buffer) {
      return UPPER_CASE_MAP[buffer[3]] + UPPER_CASE_MAP[buffer[2]] + UPPER_CASE_MAP[buffer[1]] + UPPER_CASE_MAP[buffer[0]] + "-" + UPPER_CASE_MAP[buffer[5]] + UPPER_CASE_MAP[buffer[4]] + "-" + UPPER_CASE_MAP[buffer[7]] + UPPER_CASE_MAP[buffer[6]] + "-" + UPPER_CASE_MAP[buffer[8]] + UPPER_CASE_MAP[buffer[9]] + "-" + UPPER_CASE_MAP[buffer[10]] + UPPER_CASE_MAP[buffer[11]] + UPPER_CASE_MAP[buffer[12]] + UPPER_CASE_MAP[buffer[13]] + UPPER_CASE_MAP[buffer[14]] + UPPER_CASE_MAP[buffer[15]];
    }
    function bufferToLowerCaseGuid(buffer) {
      return LOWER_CASE_MAP[buffer[3]] + LOWER_CASE_MAP[buffer[2]] + LOWER_CASE_MAP[buffer[1]] + LOWER_CASE_MAP[buffer[0]] + "-" + LOWER_CASE_MAP[buffer[5]] + LOWER_CASE_MAP[buffer[4]] + "-" + LOWER_CASE_MAP[buffer[7]] + LOWER_CASE_MAP[buffer[6]] + "-" + LOWER_CASE_MAP[buffer[8]] + LOWER_CASE_MAP[buffer[9]] + "-" + LOWER_CASE_MAP[buffer[10]] + LOWER_CASE_MAP[buffer[11]] + LOWER_CASE_MAP[buffer[12]] + LOWER_CASE_MAP[buffer[13]] + LOWER_CASE_MAP[buffer[14]] + LOWER_CASE_MAP[buffer[15]];
    }
    var CHARCODEMAP = {};
    var hexDigits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"].map((d) => d.charCodeAt(0));
    for (let i = 0; i < hexDigits.length; i++) {
      const map = CHARCODEMAP[hexDigits[i]] = {};
      for (let j = 0; j < hexDigits.length; j++) {
        const hex = String.fromCharCode(hexDigits[i], hexDigits[j]);
        const value = parseInt(hex, 16);
        map[hexDigits[j]] = value;
      }
    }
    function guidToArray(guid) {
      return [CHARCODEMAP[guid.charCodeAt(6)][guid.charCodeAt(7)], CHARCODEMAP[guid.charCodeAt(4)][guid.charCodeAt(5)], CHARCODEMAP[guid.charCodeAt(2)][guid.charCodeAt(3)], CHARCODEMAP[guid.charCodeAt(0)][guid.charCodeAt(1)], CHARCODEMAP[guid.charCodeAt(11)][guid.charCodeAt(12)], CHARCODEMAP[guid.charCodeAt(9)][guid.charCodeAt(10)], CHARCODEMAP[guid.charCodeAt(16)][guid.charCodeAt(17)], CHARCODEMAP[guid.charCodeAt(14)][guid.charCodeAt(15)], CHARCODEMAP[guid.charCodeAt(19)][guid.charCodeAt(20)], CHARCODEMAP[guid.charCodeAt(21)][guid.charCodeAt(22)], CHARCODEMAP[guid.charCodeAt(24)][guid.charCodeAt(25)], CHARCODEMAP[guid.charCodeAt(26)][guid.charCodeAt(27)], CHARCODEMAP[guid.charCodeAt(28)][guid.charCodeAt(29)], CHARCODEMAP[guid.charCodeAt(30)][guid.charCodeAt(31)], CHARCODEMAP[guid.charCodeAt(32)][guid.charCodeAt(33)], CHARCODEMAP[guid.charCodeAt(34)][guid.charCodeAt(35)]];
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/uniqueidentifier.js
var require_uniqueidentifier = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/uniqueidentifier.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _guidParser = require_guid_parser();
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([16]);
    var UniqueIdentifier = {
      id: 36,
      type: "GUIDN",
      name: "UniqueIdentifier",
      declaration: function() {
        return "uniqueidentifier";
      },
      resolveLength: function() {
        return 16;
      },
      generateTypeInfo() {
        return Buffer.from([this.id, 16]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from((0, _guidParser.guidToArray)(parameter.value));
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
          throw new TypeError("Invalid GUID.");
        }
        return value;
      }
    };
    var _default = exports2.default = UniqueIdentifier;
    module2.exports = UniqueIdentifier;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/ntext.js
var require_ntext = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/ntext.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var NText = {
      id: 99,
      type: "NTEXT",
      name: "NText",
      hasTableName: true,
      declaration: function() {
        return "ntext";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Buffer.byteLength(parameter.value, "ucs2"), 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value.toString(), "ucs2");
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports2.default = NText;
    module2.exports = NText;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/varbinary.js
var require_varbinary = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/varbinary.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarBinary = {
      id: 165,
      type: "BIGVARBIN",
      name: "VarBinary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varbinary(" + length + ")";
        } else {
          return "varbinary(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (!Buffer.isBuffer(value)) {
          value = value.toString();
        }
        const length = Buffer.byteLength(value, "ucs2");
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (Buffer.isBuffer(value)) {
            yield value;
          } else {
            yield Buffer.from(value.toString(), "ucs2");
          }
        } else {
          if (!Buffer.isBuffer(value)) {
            value = value.toString();
          }
          const length = Buffer.byteLength(value, "ucs2");
          if (length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(length, 0);
            yield buffer;
            if (Buffer.isBuffer(value)) {
              yield value;
            } else {
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports2.default = VarBinary;
    module2.exports = VarBinary;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/varchar.js
var require_varchar = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/varchar.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarChar = {
      id: 167,
      type: "BIGVARCHR",
      name: "VarChar",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varchar(" + length + ")";
        } else {
          return "varchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(value.length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        if (parameter.length <= this.maximumLength) {
          yield value;
        } else {
          if (value.length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(value.length, 0);
            yield buffer;
            yield value;
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports2.default = VarChar;
    module2.exports = VarChar;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/binary.js
var require_binary = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/binary.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Binary = {
      id: 173,
      type: "BIGBinary",
      name: "Binary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        return "binary(" + length + ")";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(parameter.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value.slice(0, parameter.length !== void 0 ? Math.min(parameter.length, this.maximumLength) : this.maximumLength);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports2.default = Binary;
    module2.exports = Binary;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/char.js
var require_char = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/char.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Char = {
      id: 175,
      type: "BIGCHAR",
      name: "Char",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "char(" + length + ")";
        } else {
          return "char(" + this.maximumLength + ")";
        }
      },
      // ParameterData<any> is temporary solution. TODO: need to understand what type ParameterData<...> can be.
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value, "ascii");
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports2.default = Char;
    module2.exports = Char;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/nvarchar.js
var require_nvarchar = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/nvarchar.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var NVarChar = {
      id: 231,
      type: "NVARCHAR",
      name: "NVarChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.toString().length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "nvarchar(" + length + ")";
        } else {
          return "nvarchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          if (Buffer.isBuffer(value)) {
            return value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length * 2, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          let length;
          if (value instanceof Buffer) {
            length = value.length;
          } else {
            value = value.toString();
            length = Buffer.byteLength(value, "ucs2");
          }
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (value instanceof Buffer) {
            yield value;
          } else {
            value = value.toString();
            yield Buffer.from(value, "ucs2");
          }
        } else {
          if (value instanceof Buffer) {
            const length = value.length;
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield value;
            }
          } else {
            value = value.toString();
            const length = Buffer.byteLength(value, "ucs2");
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports2.default = NVarChar;
    module2.exports = NVarChar;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/nchar.js
var require_nchar = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/nchar.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var NChar = {
      id: 239,
      type: "NCHAR",
      name: "NChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (parameter.value != null) {
          length = value.toString().length || 1;
        } else if (parameter.value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "nchar(" + length + ")";
        } else {
          return "nchar(" + this.maximumLength + ")";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (parameter.value != null) {
          if (Buffer.isBuffer(parameter.value)) {
            return parameter.value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length * 2, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          value
        } = parameter;
        if (value instanceof Buffer) {
          const length = value.length;
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          const length = Buffer.byteLength(value.toString(), "ucs2");
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        if (value instanceof Buffer) {
          yield value;
        } else {
          yield Buffer.from(value, "ucs2");
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports2.default = NChar;
    module2.exports = NChar;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/xml.js
var require_xml = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/xml.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var XML = {
      id: 241,
      type: "XML",
      name: "Xml",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = XML;
    module2.exports = XML;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/time.js
var require_time = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/time.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Time = {
      id: 41,
      type: "TIMEN",
      name: "Time",
      declaration: function(parameter) {
        return "time(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([3]);
          case 3:
          case 4:
            return Buffer.from([4]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([5]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(16);
        const time = parameter.value;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((time.getUTCHours() * 60 + time.getUTCMinutes()) * 60 + time.getUTCSeconds()) * 1e3 + time.getUTCMilliseconds();
        } else {
          timestamp = ((time.getHours() * 60 + time.getMinutes()) * 60 + time.getSeconds()) * 1e3 + time.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, parameter.scale - 3);
        timestamp += (parameter.value.nanosecondDelta != null ? parameter.value.nanosecondDelta : 0) * Math.pow(10, parameter.scale);
        timestamp = Math.round(timestamp);
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid time.");
        }
        return value;
      }
    };
    var _default = exports2.default = Time;
    module2.exports = Time;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/date.js
var require_date = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/date.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _core = require_js_joda();
    var globalDate = global.Date;
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([3]);
    var Date2 = {
      id: 40,
      type: "DATEN",
      name: "Date",
      declaration: function() {
        return "date";
      },
      generateTypeInfo: function() {
        return Buffer.from([this.id]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        const buffer = Buffer.alloc(3);
        buffer.writeUIntLE(days, 0, 3);
        yield buffer;
      },
      // TODO: value is technically of type 'unknown'.
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof globalDate)) {
          value = new globalDate(globalDate.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = Date2;
    module2.exports = Date2;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/datetime2.js
var require_datetime2 = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/datetime2.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _core = require_js_joda();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTime2 = {
      id: 42,
      type: "DATETIME2N",
      name: "DateTime2",
      declaration: function(parameter) {
        return "datetime2(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter, _options) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([6]);
          case 3:
          case 4:
            return Buffer.from([7]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([8]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getUTCMilliseconds();
        } else {
          timestamp = ((value.getHours() * 60 + value.getMinutes()) * 60 + value.getSeconds()) * 1e3 + value.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        yield buffer.data;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = DateTime2;
    module2.exports = DateTime2;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/datetimeoffset.js
var require_datetimeoffset = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/datetimeoffset.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _core = require_js_joda();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTimeOffset7 = {
      id: 43,
      type: "DATETIMEOFFSETN",
      name: "DateTimeOffset",
      declaration: function(parameter) {
        return "datetimeoffset(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([8]);
          case 3:
          case 4:
            return Buffer.from([9]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([10]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getMilliseconds();
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        const date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        const offset = -value.getTimezoneOffset();
        buffer.writeInt16LE(offset);
        yield buffer.data;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports2.default = DateTimeOffset7;
    module2.exports = DateTimeOffset7;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/udt.js
var require_udt = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/udt.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var UDT = {
      id: 240,
      type: "UDTTYPE",
      name: "UDT",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = UDT;
    module2.exports = UDT;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/tvp.js
var require_tvp = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/tvp.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _errors = require_errors2();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TVP_ROW_TOKEN = Buffer.from([1]);
    var TVP_END_TOKEN = Buffer.from([0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var TVP = {
      id: 243,
      type: "TVPTYPE",
      name: "TVP",
      declaration: function(parameter) {
        const value = parameter.value;
        return value.name + " readonly";
      },
      generateTypeInfo(parameter) {
        const databaseName = "";
        const schema = parameter.value?.schema ?? "";
        const typeName = parameter.value?.name ?? "";
        const bufferLength = 1 + 1 + Buffer.byteLength(databaseName, "ucs2") + 1 + Buffer.byteLength(schema, "ucs2") + 1 + Buffer.byteLength(typeName, "ucs2");
        const buffer = new _writableTrackingBuffer.default(bufferLength, "ucs2");
        buffer.writeUInt8(this.id);
        buffer.writeBVarchar(databaseName);
        buffer.writeBVarchar(schema);
        buffer.writeBVarchar(typeName);
        return buffer.data;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          columns
        } = parameter.value;
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(columns.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          yield TVP_END_TOKEN;
          yield TVP_END_TOKEN;
          return;
        }
        const {
          columns,
          rows
        } = parameter.value;
        for (let i = 0, len = columns.length; i < len; i++) {
          const column = columns[i];
          const buff = Buffer.alloc(6);
          buff.writeUInt32LE(0, 0);
          buff.writeUInt16LE(0, 4);
          yield buff;
          yield column.type.generateTypeInfo(column);
          yield Buffer.from([0]);
        }
        yield TVP_END_TOKEN;
        for (let i = 0, length = rows.length; i < length; i++) {
          yield TVP_ROW_TOKEN;
          const row = rows[i];
          for (let k = 0, len2 = row.length; k < len2; k++) {
            const column = columns[k];
            const value = row[k];
            let paramValue;
            try {
              paramValue = column.type.validate(value, parameter.collation);
            } catch (error) {
              throw new _errors.InputError(`TVP column '${column.name}' has invalid data at row index ${i}`, {
                cause: error
              });
            }
            const param = {
              value: paramValue,
              length: column.length,
              scale: column.scale,
              precision: column.precision
            };
            yield column.type.generateParameterLength(param, options);
            yield* column.type.generateParameterData(param, options);
          }
        }
        yield TVP_END_TOKEN;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "object") {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.columns)) {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.rows)) {
          throw new TypeError("Invalid table.");
        }
        return value;
      }
    };
    var _default = exports2.default = TVP;
    module2.exports = TVP;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-types/sql-variant.js
var require_sql_variant = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-types/sql-variant.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Variant = {
      id: 98,
      type: "SSVARIANTTYPE",
      name: "Variant",
      declaration: function() {
        return "sql_variant";
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports2.default = Variant;
    module2.exports = Variant;
  }
});

// node_modules/mssql/node_modules/tedious/lib/data-type.js
var require_data_type = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/data-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.typeByName = exports2.TYPES = exports2.TYPE = void 0;
    var _null = _interopRequireDefault(require_null());
    var _tinyint = _interopRequireDefault(require_tinyint());
    var _bit = _interopRequireDefault(require_bit());
    var _smallint = _interopRequireDefault(require_smallint());
    var _int = _interopRequireDefault(require_int());
    var _smalldatetime = _interopRequireDefault(require_smalldatetime());
    var _real = _interopRequireDefault(require_real());
    var _money = _interopRequireDefault(require_money());
    var _datetime = _interopRequireDefault(require_datetime());
    var _float = _interopRequireDefault(require_float());
    var _decimal = _interopRequireDefault(require_decimal());
    var _numeric = _interopRequireDefault(require_numeric());
    var _smallmoney = _interopRequireDefault(require_smallmoney());
    var _bigint = _interopRequireDefault(require_bigint());
    var _image = _interopRequireDefault(require_image());
    var _text = _interopRequireDefault(require_text());
    var _uniqueidentifier = _interopRequireDefault(require_uniqueidentifier());
    var _intn = _interopRequireDefault(require_intn());
    var _ntext = _interopRequireDefault(require_ntext());
    var _bitn = _interopRequireDefault(require_bitn());
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _numericn = _interopRequireDefault(require_numericn());
    var _floatn = _interopRequireDefault(require_floatn());
    var _moneyn = _interopRequireDefault(require_moneyn());
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _varbinary = _interopRequireDefault(require_varbinary());
    var _varchar = _interopRequireDefault(require_varchar());
    var _binary = _interopRequireDefault(require_binary());
    var _char = _interopRequireDefault(require_char());
    var _nvarchar = _interopRequireDefault(require_nvarchar());
    var _nchar = _interopRequireDefault(require_nchar());
    var _xml = _interopRequireDefault(require_xml());
    var _time = _interopRequireDefault(require_time());
    var _date = _interopRequireDefault(require_date());
    var _datetime2 = _interopRequireDefault(require_datetime2());
    var _datetimeoffset = _interopRequireDefault(require_datetimeoffset());
    var _udt = _interopRequireDefault(require_udt());
    var _tvp = _interopRequireDefault(require_tvp());
    var _sqlVariant = _interopRequireDefault(require_sql_variant());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TYPE = exports2.TYPE = {
      [_null.default.id]: _null.default,
      [_tinyint.default.id]: _tinyint.default,
      [_bit.default.id]: _bit.default,
      [_smallint.default.id]: _smallint.default,
      [_int.default.id]: _int.default,
      [_smalldatetime.default.id]: _smalldatetime.default,
      [_real.default.id]: _real.default,
      [_money.default.id]: _money.default,
      [_datetime.default.id]: _datetime.default,
      [_float.default.id]: _float.default,
      [_decimal.default.id]: _decimal.default,
      [_numeric.default.id]: _numeric.default,
      [_smallmoney.default.id]: _smallmoney.default,
      [_bigint.default.id]: _bigint.default,
      [_image.default.id]: _image.default,
      [_text.default.id]: _text.default,
      [_uniqueidentifier.default.id]: _uniqueidentifier.default,
      [_intn.default.id]: _intn.default,
      [_ntext.default.id]: _ntext.default,
      [_bitn.default.id]: _bitn.default,
      [_decimaln.default.id]: _decimaln.default,
      [_numericn.default.id]: _numericn.default,
      [_floatn.default.id]: _floatn.default,
      [_moneyn.default.id]: _moneyn.default,
      [_datetimen.default.id]: _datetimen.default,
      [_varbinary.default.id]: _varbinary.default,
      [_varchar.default.id]: _varchar.default,
      [_binary.default.id]: _binary.default,
      [_char.default.id]: _char.default,
      [_nvarchar.default.id]: _nvarchar.default,
      [_nchar.default.id]: _nchar.default,
      [_xml.default.id]: _xml.default,
      [_time.default.id]: _time.default,
      [_date.default.id]: _date.default,
      [_datetime2.default.id]: _datetime2.default,
      [_datetimeoffset.default.id]: _datetimeoffset.default,
      [_udt.default.id]: _udt.default,
      [_tvp.default.id]: _tvp.default,
      [_sqlVariant.default.id]: _sqlVariant.default
    };
    var TYPES = exports2.TYPES = {
      TinyInt: _tinyint.default,
      Bit: _bit.default,
      SmallInt: _smallint.default,
      Int: _int.default,
      SmallDateTime: _smalldatetime.default,
      Real: _real.default,
      Money: _money.default,
      DateTime: _datetime.default,
      Float: _float.default,
      Decimal: _decimal.default,
      Numeric: _numeric.default,
      SmallMoney: _smallmoney.default,
      BigInt: _bigint.default,
      Image: _image.default,
      Text: _text.default,
      UniqueIdentifier: _uniqueidentifier.default,
      NText: _ntext.default,
      VarBinary: _varbinary.default,
      VarChar: _varchar.default,
      Binary: _binary.default,
      Char: _char.default,
      NVarChar: _nvarchar.default,
      NChar: _nchar.default,
      Xml: _xml.default,
      Time: _time.default,
      Date: _date.default,
      DateTime2: _datetime2.default,
      DateTimeOffset: _datetimeoffset.default,
      UDT: _udt.default,
      TVP: _tvp.default,
      Variant: _sqlVariant.default
    };
    var typeByName = exports2.typeByName = TYPES;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Result = exports2.NotEnoughDataError = void 0;
    exports2.readBVarByte = readBVarByte;
    exports2.readBVarChar = readBVarChar;
    exports2.readBigInt64LE = readBigInt64LE;
    exports2.readBigUInt64LE = readBigUInt64LE;
    exports2.readDoubleLE = readDoubleLE;
    exports2.readFloatLE = readFloatLE;
    exports2.readInt16LE = readInt16LE;
    exports2.readInt32LE = readInt32LE;
    exports2.readUInt16LE = readUInt16LE;
    exports2.readUInt24LE = readUInt24LE;
    exports2.readUInt32BE = readUInt32BE;
    exports2.readUInt32LE = readUInt32LE;
    exports2.readUInt40LE = readUInt40LE;
    exports2.readUInt8 = readUInt8;
    exports2.readUNumeric128LE = readUNumeric128LE;
    exports2.readUNumeric64LE = readUNumeric64LE;
    exports2.readUNumeric96LE = readUNumeric96LE;
    exports2.readUsVarByte = readUsVarByte;
    exports2.readUsVarChar = readUsVarChar;
    var Result = class {
      constructor(value, offset) {
        this.value = value;
        this.offset = offset;
      }
    };
    exports2.Result = Result;
    var NotEnoughDataError = class extends Error {
      byteCount;
      constructor(byteCount) {
        super();
        this.byteCount = byteCount;
      }
    };
    exports2.NotEnoughDataError = NotEnoughDataError;
    function readUInt8(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 1) {
        throw new NotEnoughDataError(offset + 1);
      }
      return new Result(buf.readUInt8(offset), offset + 1);
    }
    function readUInt16LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 2) {
        throw new NotEnoughDataError(offset + 2);
      }
      return new Result(buf.readUInt16LE(offset), offset + 2);
    }
    function readInt16LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 2) {
        throw new NotEnoughDataError(offset + 2);
      }
      return new Result(buf.readInt16LE(offset), offset + 2);
    }
    function readUInt24LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 3) {
        throw new NotEnoughDataError(offset + 3);
      }
      return new Result(buf.readUIntLE(offset, 3), offset + 3);
    }
    function readUInt32LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readUInt32LE(offset), offset + 4);
    }
    function readUInt32BE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readUInt32BE(offset), offset + 4);
    }
    function readUInt40LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 5) {
        throw new NotEnoughDataError(offset + 5);
      }
      return new Result(buf.readUIntLE(offset, 5), offset + 5);
    }
    function readInt32LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readInt32LE(offset), offset + 4);
    }
    function readBigUInt64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readBigUInt64LE(offset), offset + 8);
    }
    function readBigInt64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readBigInt64LE(offset), offset + 8);
    }
    function readFloatLE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readFloatLE(offset), offset + 4);
    }
    function readDoubleLE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readDoubleLE(offset), offset + 8);
    }
    function readBVarChar(buf, offset) {
      offset = +offset;
      let charCount;
      ({
        offset,
        value: charCount
      } = readUInt8(buf, offset));
      const byteLength = charCount * 2;
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.toString("ucs2", offset, offset + byteLength), offset + byteLength);
    }
    function readBVarByte(buf, offset) {
      offset = +offset;
      let byteLength;
      ({
        offset,
        value: byteLength
      } = readUInt8(buf, offset));
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
    }
    function readUsVarChar(buf, offset) {
      offset = +offset;
      let charCount;
      ({
        offset,
        value: charCount
      } = readUInt16LE(buf, offset));
      const byteLength = charCount * 2;
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.toString("ucs2", offset, offset + byteLength), offset + byteLength);
    }
    function readUsVarByte(buf, offset) {
      offset = +offset;
      let byteLength;
      ({
        offset,
        value: byteLength
      } = readUInt16LE(buf, offset));
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
    }
    function readUNumeric64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      const low = buf.readUInt32LE(offset);
      const high = buf.readUInt32LE(offset + 4);
      return new Result(4294967296 * high + low, offset + 8);
    }
    function readUNumeric96LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 12) {
        throw new NotEnoughDataError(offset + 12);
      }
      const dword1 = buf.readUInt32LE(offset);
      const dword2 = buf.readUInt32LE(offset + 4);
      const dword3 = buf.readUInt32LE(offset + 8);
      return new Result(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3, offset + 12);
    }
    function readUNumeric128LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 16) {
        throw new NotEnoughDataError(offset + 16);
      }
      const dword1 = buf.readUInt32LE(offset);
      const dword2 = buf.readUInt32LE(offset + 4);
      const dword3 = buf.readUInt32LE(offset + 8);
      const dword4 = buf.readUInt32LE(offset + 12);
      return new Result(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3 + 4294967296 * 4294967296 * 4294967296 * dword4, offset + 16);
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/metadata-parser.js
var require_metadata_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/metadata-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.readCollation = readCollation;
    exports2.readMetadata = readMetadata;
    var _collation = require_collation();
    var _dataType = require_data_type();
    var _sprintfJs = require_sprintf();
    var _helpers = require_helpers3();
    function readCollation(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 5) {
        throw new _helpers.NotEnoughDataError(offset + 5);
      }
      const collation = _collation.Collation.fromBuffer(buf.slice(offset, offset + 5));
      return new _helpers.Result(collation, offset + 5);
    }
    function readSchema(buf, offset) {
      offset = +offset;
      let schemaPresent;
      ({
        offset,
        value: schemaPresent
      } = (0, _helpers.readUInt8)(buf, offset));
      if (schemaPresent !== 1) {
        return new _helpers.Result(void 0, offset);
      }
      let dbname;
      ({
        offset,
        value: dbname
      } = (0, _helpers.readBVarChar)(buf, offset));
      let owningSchema;
      ({
        offset,
        value: owningSchema
      } = (0, _helpers.readBVarChar)(buf, offset));
      let xmlSchemaCollection;
      ({
        offset,
        value: xmlSchemaCollection
      } = (0, _helpers.readUsVarChar)(buf, offset));
      return new _helpers.Result({
        dbname,
        owningSchema,
        xmlSchemaCollection
      }, offset);
    }
    function readUDTInfo(buf, offset) {
      let maxByteSize;
      ({
        offset,
        value: maxByteSize
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let dbname;
      ({
        offset,
        value: dbname
      } = (0, _helpers.readBVarChar)(buf, offset));
      let owningSchema;
      ({
        offset,
        value: owningSchema
      } = (0, _helpers.readBVarChar)(buf, offset));
      let typeName;
      ({
        offset,
        value: typeName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let assemblyName;
      ({
        offset,
        value: assemblyName
      } = (0, _helpers.readUsVarChar)(buf, offset));
      return new _helpers.Result({
        maxByteSize,
        dbname,
        owningSchema,
        typeName,
        assemblyName
      }, offset);
    }
    function readMetadata(buf, offset, options) {
      let userType;
      ({
        offset,
        value: userType
      } = (options.tdsVersion < "7_2" ? _helpers.readUInt16LE : _helpers.readUInt32LE)(buf, offset));
      let flags;
      ({
        offset,
        value: flags
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let typeNumber;
      ({
        offset,
        value: typeNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const type = _dataType.TYPE[typeNumber];
      if (!type) {
        throw new Error((0, _sprintfJs.sprintf)("Unrecognised data type 0x%02X", typeNumber));
      }
      switch (type.name) {
        case "Null":
        case "TinyInt":
        case "SmallInt":
        case "Int":
        case "BigInt":
        case "Real":
        case "Float":
        case "SmallMoney":
        case "Money":
        case "Bit":
        case "SmallDateTime":
        case "DateTime":
        case "Date":
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        case "IntN":
        case "FloatN":
        case "MoneyN":
        case "BitN":
        case "UniqueIdentifier":
        case "DateTimeN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Variant": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "VarChar":
        case "Char":
        case "NVarChar":
        case "NChar": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          let collation;
          ({
            offset,
            value: collation
          } = readCollation(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Text":
        case "NText": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          let collation;
          ({
            offset,
            value: collation
          } = readCollation(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "VarBinary":
        case "Binary": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Image": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Xml": {
          let schema;
          ({
            offset,
            value: schema
          } = readSchema(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema,
            udtInfo: void 0
          }, offset);
        }
        case "Time":
        case "DateTime2":
        case "DateTimeOffset": {
          let scale;
          ({
            offset,
            value: scale
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale,
            dataLength: void 0,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "NumericN":
        case "DecimalN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          let precision;
          ({
            offset,
            value: precision
          } = (0, _helpers.readUInt8)(buf, offset));
          let scale;
          ({
            offset,
            value: scale
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision,
            scale,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "UDT": {
          let udtInfo;
          ({
            offset,
            value: udtInfo
          } = readUDTInfo(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema: void 0,
            udtInfo
          }, offset);
        }
        default:
          throw new Error((0, _sprintfJs.sprintf)("Unrecognised type %s", type.name));
      }
    }
    function metadataParse(parser, options, callback) {
      (async () => {
        while (true) {
          let result;
          try {
            result = readMetadata(parser.buffer, parser.position, options);
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = result.offset;
          return callback(result.value);
        }
      })();
    }
    var _default = exports2.default = metadataParse;
    module2.exports = metadataParse;
    module2.exports.readCollation = readCollation;
    module2.exports.readMetadata = readMetadata;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/colmetadata-token-parser.js
var require_colmetadata_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/colmetadata-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _metadataParser = require_metadata_parser();
    var _token = require_token();
    var _helpers = require_helpers3();
    function readTableName(buf, offset, metadata, options) {
      if (!metadata.type.hasTableName) {
        return new _helpers.Result(void 0, offset);
      }
      if (options.tdsVersion < "7_2") {
        return (0, _helpers.readUsVarChar)(buf, offset);
      }
      let numberOfTableNameParts;
      ({
        offset,
        value: numberOfTableNameParts
      } = (0, _helpers.readUInt8)(buf, offset));
      const tableName = [];
      for (let i = 0; i < numberOfTableNameParts; i++) {
        let tableNamePart;
        ({
          offset,
          value: tableNamePart
        } = (0, _helpers.readUsVarChar)(buf, offset));
        tableName.push(tableNamePart);
      }
      return new _helpers.Result(tableName, offset);
    }
    function readColumnName(buf, offset, index, metadata, options) {
      let colName;
      ({
        offset,
        value: colName
      } = (0, _helpers.readBVarChar)(buf, offset));
      if (options.columnNameReplacer) {
        return new _helpers.Result(options.columnNameReplacer(colName, index, metadata), offset);
      } else if (options.camelCaseColumns) {
        return new _helpers.Result(colName.replace(/^[A-Z]/, function(s) {
          return s.toLowerCase();
        }), offset);
      } else {
        return new _helpers.Result(colName, offset);
      }
    }
    function readColumn(buf, offset, options, index) {
      let metadata;
      ({
        offset,
        value: metadata
      } = (0, _metadataParser.readMetadata)(buf, offset, options));
      let tableName;
      ({
        offset,
        value: tableName
      } = readTableName(buf, offset, metadata, options));
      let colName;
      ({
        offset,
        value: colName
      } = readColumnName(buf, offset, index, metadata, options));
      return new _helpers.Result({
        userType: metadata.userType,
        flags: metadata.flags,
        type: metadata.type,
        collation: metadata.collation,
        precision: metadata.precision,
        scale: metadata.scale,
        udtInfo: metadata.udtInfo,
        dataLength: metadata.dataLength,
        schema: metadata.schema,
        colName,
        tableName
      }, offset);
    }
    async function colMetadataParser(parser) {
      let columnCount;
      while (true) {
        let offset;
        try {
          ({
            offset,
            value: columnCount
          } = (0, _helpers.readUInt16LE)(parser.buffer, parser.position));
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            await parser.waitForChunk();
            continue;
          }
          throw err;
        }
        parser.position = offset;
        break;
      }
      const columns = [];
      for (let i = 0; i < columnCount; i++) {
        while (true) {
          let column;
          let offset;
          try {
            ({
              offset,
              value: column
            } = readColumn(parser.buffer, parser.position, parser.options, i));
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = offset;
          columns.push(column);
          break;
        }
      }
      return new _token.ColMetadataToken(columns);
    }
    var _default = exports2.default = colMetadataParser;
    module2.exports = colMetadataParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/done-token-parser.js
var require_done_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/done-token-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.doneInProcParser = doneInProcParser;
    exports2.doneParser = doneParser;
    exports2.doneProcParser = doneProcParser;
    var _token = require_token();
    var _helpers = require_helpers3();
    var STATUS = {
      MORE: 1,
      ERROR: 2,
      // This bit is not yet in use by SQL Server, so is not exposed in the returned token
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    function readToken(buf, offset, options) {
      let status;
      ({
        offset,
        value: status
      } = (0, _helpers.readUInt16LE)(buf, offset));
      const more = !!(status & STATUS.MORE);
      const sqlError = !!(status & STATUS.ERROR);
      const rowCountValid = !!(status & STATUS.COUNT);
      const attention = !!(status & STATUS.ATTN);
      const serverError = !!(status & STATUS.SRVERROR);
      let curCmd;
      ({
        offset,
        value: curCmd
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let rowCount;
      ({
        offset,
        value: rowCount
      } = (options.tdsVersion < "7_2" ? _helpers.readUInt32LE : _helpers.readBigUInt64LE)(buf, offset));
      return new _helpers.Result({
        more,
        sqlError,
        attention,
        serverError,
        rowCount: rowCountValid ? Number(rowCount) : void 0,
        curCmd
      }, offset);
    }
    function doneParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneToken(value), offset);
    }
    function doneInProcParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneInProcToken(value), offset);
    }
    function doneProcParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneProcToken(value), offset);
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/env-change-token-parser.js
var require_env_change_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/env-change-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _collation = require_collation();
    var _token = require_token();
    var _helpers = require_helpers3();
    var types = {
      1: {
        name: "DATABASE",
        event: "databaseChange"
      },
      2: {
        name: "LANGUAGE",
        event: "languageChange"
      },
      3: {
        name: "CHARSET",
        event: "charsetChange"
      },
      4: {
        name: "PACKET_SIZE",
        event: "packetSizeChange"
      },
      7: {
        name: "SQL_COLLATION",
        event: "sqlCollationChange"
      },
      8: {
        name: "BEGIN_TXN",
        event: "beginTransaction"
      },
      9: {
        name: "COMMIT_TXN",
        event: "commitTransaction"
      },
      10: {
        name: "ROLLBACK_TXN",
        event: "rollbackTransaction"
      },
      13: {
        name: "DATABASE_MIRRORING_PARTNER",
        event: "partnerNode"
      },
      17: {
        name: "TXN_ENDED"
      },
      18: {
        name: "RESET_CONNECTION",
        event: "resetConnection"
      },
      20: {
        name: "ROUTING_CHANGE",
        event: "routingChange"
      }
    };
    function _readNewAndOldValue(buf, offset, length, type) {
      switch (type.name) {
        case "DATABASE":
        case "LANGUAGE":
        case "CHARSET":
        case "PACKET_SIZE":
        case "DATABASE_MIRRORING_PARTNER": {
          let newValue;
          ({
            offset,
            value: newValue
          } = (0, _helpers.readBVarChar)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readBVarChar)(buf, offset));
          switch (type.name) {
            case "PACKET_SIZE":
              return new _helpers.Result(new _token.PacketSizeEnvChangeToken(parseInt(newValue), parseInt(oldValue)), offset);
            case "DATABASE":
              return new _helpers.Result(new _token.DatabaseEnvChangeToken(newValue, oldValue), offset);
            case "LANGUAGE":
              return new _helpers.Result(new _token.LanguageEnvChangeToken(newValue, oldValue), offset);
            case "CHARSET":
              return new _helpers.Result(new _token.CharsetEnvChangeToken(newValue, oldValue), offset);
            case "DATABASE_MIRRORING_PARTNER":
              return new _helpers.Result(new _token.DatabaseMirroringPartnerEnvChangeToken(newValue, oldValue), offset);
          }
          throw new Error("unreachable");
        }
        case "SQL_COLLATION":
        case "BEGIN_TXN":
        case "COMMIT_TXN":
        case "ROLLBACK_TXN":
        case "RESET_CONNECTION": {
          let newValue;
          ({
            offset,
            value: newValue
          } = (0, _helpers.readBVarByte)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readBVarByte)(buf, offset));
          switch (type.name) {
            case "SQL_COLLATION": {
              const newCollation = newValue.length ? _collation.Collation.fromBuffer(newValue) : void 0;
              const oldCollation = oldValue.length ? _collation.Collation.fromBuffer(oldValue) : void 0;
              return new _helpers.Result(new _token.CollationChangeToken(newCollation, oldCollation), offset);
            }
            case "BEGIN_TXN":
              return new _helpers.Result(new _token.BeginTransactionEnvChangeToken(newValue, oldValue), offset);
            case "COMMIT_TXN":
              return new _helpers.Result(new _token.CommitTransactionEnvChangeToken(newValue, oldValue), offset);
            case "ROLLBACK_TXN":
              return new _helpers.Result(new _token.RollbackTransactionEnvChangeToken(newValue, oldValue), offset);
            case "RESET_CONNECTION":
              return new _helpers.Result(new _token.ResetConnectionEnvChangeToken(newValue, oldValue), offset);
          }
          throw new Error("unreachable");
        }
        case "ROUTING_CHANGE": {
          let routePacket;
          ({
            offset,
            value: routePacket
          } = (0, _helpers.readUsVarByte)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readUsVarByte)(buf, offset));
          const protocol = routePacket.readUInt8(0);
          if (protocol !== 0) {
            throw new Error("Unknown protocol byte in routing change event");
          }
          const port = routePacket.readUInt16LE(1);
          const serverLen = routePacket.readUInt16LE(3);
          const server = routePacket.toString("ucs2", 5, 5 + serverLen * 2);
          const newValue = {
            protocol,
            port,
            server
          };
          return new _helpers.Result(new _token.RoutingEnvChangeToken(newValue, oldValue), offset);
        }
        default: {
          console.error("Tedious > Unsupported ENVCHANGE type " + type.name);
          return new _helpers.Result(void 0, offset + length - 1);
        }
      }
    }
    function envChangeParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      let typeNumber;
      ({
        offset,
        value: typeNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const type = types[typeNumber];
      if (!type) {
        console.error("Tedious > Unsupported ENVCHANGE type " + typeNumber);
        return new _helpers.Result(void 0, offset + tokenLength - 1);
      }
      return _readNewAndOldValue(buf, offset, tokenLength, type);
    }
    var _default = exports2.default = envChangeParser;
    module2.exports = envChangeParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/infoerror-token-parser.js
var require_infoerror_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/infoerror-token-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.errorParser = errorParser;
    exports2.infoParser = infoParser;
    var _helpers = require_helpers3();
    var _token = require_token();
    function readToken(buf, offset, options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < tokenLength + offset) {
        throw new _helpers.NotEnoughDataError(tokenLength + offset);
      }
      let number;
      ({
        offset,
        value: number
      } = (0, _helpers.readUInt32LE)(buf, offset));
      let state;
      ({
        offset,
        value: state
      } = (0, _helpers.readUInt8)(buf, offset));
      let clazz;
      ({
        offset,
        value: clazz
      } = (0, _helpers.readUInt8)(buf, offset));
      let message;
      ({
        offset,
        value: message
      } = (0, _helpers.readUsVarChar)(buf, offset));
      let serverName;
      ({
        offset,
        value: serverName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let procName;
      ({
        offset,
        value: procName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let lineNumber;
      ({
        offset,
        value: lineNumber
      } = options.tdsVersion < "7_2" ? (0, _helpers.readUInt16LE)(buf, offset) : (0, _helpers.readUInt32LE)(buf, offset));
      return new _helpers.Result({
        "number": number,
        "state": state,
        "class": clazz,
        "message": message,
        "serverName": serverName,
        "procName": procName,
        "lineNumber": lineNumber
      }, offset);
    }
    function infoParser(buf, offset, options) {
      let data;
      ({
        offset,
        value: data
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.InfoMessageToken(data), offset);
    }
    function errorParser(buf, offset, options) {
      let data;
      ({
        offset,
        value: data
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.ErrorMessageToken(data), offset);
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/fedauth-info-parser.js
var require_fedauth_info_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/fedauth-info-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _helpers = require_helpers3();
    var _token = require_token();
    var FEDAUTHINFOID = {
      STSURL: 1,
      SPN: 2
    };
    function readFedAuthInfo(data) {
      let offset = 0;
      let spn, stsurl;
      const countOfInfoIDs = data.readUInt32LE(offset);
      offset += 4;
      for (let i = 0; i < countOfInfoIDs; i++) {
        const fedauthInfoID = data.readUInt8(offset);
        offset += 1;
        const fedAuthInfoDataLen = data.readUInt32LE(offset);
        offset += 4;
        const fedAuthInfoDataOffset = data.readUInt32LE(offset);
        offset += 4;
        switch (fedauthInfoID) {
          case FEDAUTHINFOID.SPN:
            spn = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
            break;
          case FEDAUTHINFOID.STSURL:
            stsurl = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
            break;
          default:
            break;
        }
      }
      return {
        spn,
        stsurl
      };
    }
    function fedAuthInfoParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt32LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const data = buf.slice(offset, offset + tokenLength);
      offset += tokenLength;
      const {
        spn,
        stsurl
      } = readFedAuthInfo(data);
      return new _helpers.Result(new _token.FedAuthInfoToken(spn, stsurl), offset);
    }
    var _default = exports2.default = fedAuthInfoParser;
    module2.exports = fedAuthInfoParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/feature-ext-ack-parser.js
var require_feature_ext_ack_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/feature-ext-ack-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _helpers = require_helpers3();
    var _token = require_token();
    var FEATURE_ID = {
      SESSIONRECOVERY: 1,
      FEDAUTH: 2,
      COLUMNENCRYPTION: 4,
      GLOBALTRANSACTIONS: 5,
      AZURESQLSUPPORT: 8,
      UTF8_SUPPORT: 10,
      TERMINATOR: 255
    };
    function featureExtAckParser(buf, offset, _options) {
      let fedAuth;
      let utf8Support;
      while (true) {
        let featureId;
        ({
          value: featureId,
          offset
        } = (0, _helpers.readUInt8)(buf, offset));
        if (featureId === FEATURE_ID.TERMINATOR) {
          return new _helpers.Result(new _token.FeatureExtAckToken(fedAuth, utf8Support), offset);
        }
        let featureAckDataLen;
        ({
          value: featureAckDataLen,
          offset
        } = (0, _helpers.readUInt32LE)(buf, offset));
        if (buf.length < offset + featureAckDataLen) {
          throw new _helpers.NotEnoughDataError(offset + featureAckDataLen);
        }
        const featureData = buf.slice(offset, offset + featureAckDataLen);
        offset += featureAckDataLen;
        switch (featureId) {
          case FEATURE_ID.FEDAUTH:
            fedAuth = featureData;
            break;
          case FEATURE_ID.UTF8_SUPPORT:
            utf8Support = !!featureData[0];
            break;
        }
      }
    }
    var _default = exports2.default = featureExtAckParser;
    module2.exports = featureExtAckParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/loginack-token-parser.js
var require_loginack_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/loginack-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var _tdsVersions = require_tds_versions();
    var _helpers = require_helpers3();
    var interfaceTypes = {
      0: "SQL_DFLT",
      1: "SQL_TSQL"
    };
    function loginAckParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < tokenLength + offset) {
        throw new _helpers.NotEnoughDataError(tokenLength + offset);
      }
      let interfaceNumber;
      ({
        offset,
        value: interfaceNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const interfaceType = interfaceTypes[interfaceNumber];
      let tdsVersionNumber;
      ({
        offset,
        value: tdsVersionNumber
      } = (0, _helpers.readUInt32BE)(buf, offset));
      const tdsVersion = _tdsVersions.versionsByValue[tdsVersionNumber];
      let progName;
      ({
        offset,
        value: progName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let major;
      ({
        offset,
        value: major
      } = (0, _helpers.readUInt8)(buf, offset));
      let minor;
      ({
        offset,
        value: minor
      } = (0, _helpers.readUInt8)(buf, offset));
      let buildNumHi;
      ({
        offset,
        value: buildNumHi
      } = (0, _helpers.readUInt8)(buf, offset));
      let buildNumLow;
      ({
        offset,
        value: buildNumLow
      } = (0, _helpers.readUInt8)(buf, offset));
      return new _helpers.Result(new _token.LoginAckToken({
        interface: interfaceType,
        tdsVersion,
        progName,
        progVersion: {
          major,
          minor,
          buildNumHi,
          buildNumLow
        }
      }), offset);
    }
    var _default = exports2.default = loginAckParser;
    module2.exports = loginAckParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/order-token-parser.js
var require_order_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/order-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var _helpers = require_helpers3();
    function orderParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const orderColumns = [];
      for (let i = 0; i < tokenLength; i += 2) {
        let column;
        ({
          offset,
          value: column
        } = (0, _helpers.readUInt16LE)(buf, offset));
        orderColumns.push(column);
      }
      return new _helpers.Result(new _token.OrderToken(orderColumns), offset);
    }
    var _default = exports2.default = orderParser;
    module2.exports = orderParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/returnstatus-token-parser.js
var require_returnstatus_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/returnstatus-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _helpers = require_helpers3();
    var _token = require_token();
    function returnStatusParser(buf, offset, _options) {
      let value;
      ({
        value,
        offset
      } = (0, _helpers.readInt32LE)(buf, offset));
      return new _helpers.Result(new _token.ReturnStatusToken(value), offset);
    }
    var _default = exports2.default = returnStatusParser;
    module2.exports = returnStatusParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/value-parser.js
var require_value_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/value-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isPLPStream = isPLPStream;
    exports2.readPLPStream = readPLPStream;
    exports2.readValue = readValue;
    var _metadataParser = require_metadata_parser();
    var _dataType = require_data_type();
    var _iconvLite = _interopRequireDefault(require_lib3());
    var _sprintfJs = require_sprintf();
    var _guidParser = require_guid_parser();
    var _helpers = require_helpers3();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL = (1 << 16) - 1;
    var MAX = (1 << 16) - 1;
    var THREE_AND_A_THIRD = 3 + 1 / 3;
    var MONEY_DIVISOR = 1e4;
    var PLP_NULL = 0xFFFFFFFFFFFFFFFFn;
    var UNKNOWN_PLP_LEN = 0xFFFFFFFFFFFFFFFEn;
    var DEFAULT_ENCODING = "utf8";
    function readTinyInt(buf, offset) {
      return (0, _helpers.readUInt8)(buf, offset);
    }
    function readSmallInt(buf, offset) {
      return (0, _helpers.readInt16LE)(buf, offset);
    }
    function readInt(buf, offset) {
      return (0, _helpers.readInt32LE)(buf, offset);
    }
    function readBigInt(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readBigInt64LE)(buf, offset));
      return new _helpers.Result(value.toString(), offset);
    }
    function readReal(buf, offset) {
      return (0, _helpers.readFloatLE)(buf, offset);
    }
    function readFloat(buf, offset) {
      return (0, _helpers.readDoubleLE)(buf, offset);
    }
    function readSmallMoney(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readInt32LE)(buf, offset));
      return new _helpers.Result(value / MONEY_DIVISOR, offset);
    }
    function readMoney(buf, offset) {
      let high;
      ({
        offset,
        value: high
      } = (0, _helpers.readInt32LE)(buf, offset));
      let low;
      ({
        offset,
        value: low
      } = (0, _helpers.readUInt32LE)(buf, offset));
      return new _helpers.Result((low + 4294967296 * high) / MONEY_DIVISOR, offset);
    }
    function readBit(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readUInt8)(buf, offset));
      return new _helpers.Result(!!value, offset);
    }
    function readValue(buf, offset, metadata, options) {
      const type = metadata.type;
      switch (type.name) {
        case "Null":
          return new _helpers.Result(null, offset);
        case "TinyInt": {
          return readTinyInt(buf, offset);
        }
        case "SmallInt": {
          return readSmallInt(buf, offset);
        }
        case "Int": {
          return readInt(buf, offset);
        }
        case "BigInt": {
          return readBigInt(buf, offset);
        }
        case "IntN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 1:
              return readTinyInt(buf, offset);
            case 2:
              return readSmallInt(buf, offset);
            case 4:
              return readInt(buf, offset);
            case 8:
              return readBigInt(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for IntN");
          }
        }
        case "Real": {
          return readReal(buf, offset);
        }
        case "Float": {
          return readFloat(buf, offset);
        }
        case "FloatN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readReal(buf, offset);
            case 8:
              return readFloat(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for FloatN");
          }
        }
        case "SmallMoney": {
          return readSmallMoney(buf, offset);
        }
        case "Money":
          return readMoney(buf, offset);
        case "MoneyN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readSmallMoney(buf, offset);
            case 8:
              return readMoney(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for MoneyN");
          }
        }
        case "Bit": {
          return readBit(buf, offset);
        }
        case "BitN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 1:
              return readBit(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for BitN");
          }
        }
        case "VarChar":
        case "Char": {
          const codepage = metadata.collation.codepage;
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readChars(buf, offset, dataLength, codepage);
        }
        case "NVarChar":
        case "NChar": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readNChars(buf, offset, dataLength);
        }
        case "VarBinary":
        case "Binary": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readBinary(buf, offset, dataLength);
        }
        case "Text": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readChars(buf, offset, dataLength, metadata.collation.codepage);
        }
        case "NText": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readNChars(buf, offset, dataLength);
        }
        case "Image": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readBinary(buf, offset, dataLength);
        }
        case "SmallDateTime": {
          return readSmallDateTime(buf, offset, options.useUTC);
        }
        case "DateTime": {
          return readDateTime(buf, offset, options.useUTC);
        }
        case "DateTimeN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readSmallDateTime(buf, offset, options.useUTC);
            case 8:
              return readDateTime(buf, offset, options.useUTC);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for DateTimeN");
          }
        }
        case "Time": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readTime(buf, offset, dataLength, metadata.scale, options.useUTC);
        }
        case "Date": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDate(buf, offset, options.useUTC);
        }
        case "DateTime2": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDateTime2(buf, offset, dataLength, metadata.scale, options.useUTC);
        }
        case "DateTimeOffset": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDateTimeOffset(buf, offset, dataLength, metadata.scale);
        }
        case "NumericN":
        case "DecimalN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readNumeric(buf, offset, dataLength, metadata.precision, metadata.scale);
        }
        case "UniqueIdentifier": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 16:
              return readUniqueIdentifier(buf, offset, options);
            default:
              throw new Error((0, _sprintfJs.sprintf)("Unsupported guid size %d", dataLength - 1));
          }
        }
        case "Variant": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readVariant(buf, offset, options, dataLength);
        }
        default: {
          throw new Error("Invalid type!");
        }
      }
    }
    function isPLPStream(metadata) {
      switch (metadata.type.name) {
        case "VarChar":
        case "NVarChar":
        case "VarBinary": {
          return metadata.dataLength === MAX;
        }
        case "Xml": {
          return true;
        }
        case "UDT": {
          return true;
        }
      }
    }
    function readUniqueIdentifier(buf, offset, options) {
      let data;
      ({
        value: data,
        offset
      } = readBinary(buf, offset, 16));
      return new _helpers.Result(options.lowerCaseGuids ? (0, _guidParser.bufferToLowerCaseGuid)(data) : (0, _guidParser.bufferToUpperCaseGuid)(data), offset);
    }
    function readNumeric(buf, offset, dataLength, _precision, scale) {
      let sign;
      ({
        offset,
        value: sign
      } = (0, _helpers.readUInt8)(buf, offset));
      sign = sign === 1 ? 1 : -1;
      let value;
      if (dataLength === 5) {
        ({
          offset,
          value
        } = (0, _helpers.readUInt32LE)(buf, offset));
      } else if (dataLength === 9) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric64LE)(buf, offset));
      } else if (dataLength === 13) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric96LE)(buf, offset));
      } else if (dataLength === 17) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric128LE)(buf, offset));
      } else {
        throw new Error((0, _sprintfJs.sprintf)("Unsupported numeric dataLength %d", dataLength));
      }
      return new _helpers.Result(value * sign / Math.pow(10, scale), offset);
    }
    function readVariant(buf, offset, options, dataLength) {
      let baseType;
      ({
        value: baseType,
        offset
      } = (0, _helpers.readUInt8)(buf, offset));
      const type = _dataType.TYPE[baseType];
      let propBytes;
      ({
        value: propBytes,
        offset
      } = (0, _helpers.readUInt8)(buf, offset));
      dataLength = dataLength - propBytes - 2;
      switch (type.name) {
        case "UniqueIdentifier":
          return readUniqueIdentifier(buf, offset, options);
        case "Bit":
          return readBit(buf, offset);
        case "TinyInt":
          return readTinyInt(buf, offset);
        case "SmallInt":
          return readSmallInt(buf, offset);
        case "Int":
          return readInt(buf, offset);
        case "BigInt":
          return readBigInt(buf, offset);
        case "SmallDateTime":
          return readSmallDateTime(buf, offset, options.useUTC);
        case "DateTime":
          return readDateTime(buf, offset, options.useUTC);
        case "Real":
          return readReal(buf, offset);
        case "Float":
          return readFloat(buf, offset);
        case "SmallMoney":
          return readSmallMoney(buf, offset);
        case "Money":
          return readMoney(buf, offset);
        case "Date":
          return readDate(buf, offset, options.useUTC);
        case "Time": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readTime(buf, offset, dataLength, scale, options.useUTC);
        }
        case "DateTime2": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readDateTime2(buf, offset, dataLength, scale, options.useUTC);
        }
        case "DateTimeOffset": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readDateTimeOffset(buf, offset, dataLength, scale);
        }
        case "VarBinary":
        case "Binary": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          return readBinary(buf, offset, dataLength);
        }
        case "NumericN":
        case "DecimalN": {
          let precision;
          ({
            value: precision,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readNumeric(buf, offset, dataLength, precision, scale);
        }
        case "VarChar":
        case "Char": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          let collation;
          ({
            value: collation,
            offset
          } = (0, _metadataParser.readCollation)(buf, offset));
          return readChars(buf, offset, dataLength, collation.codepage);
        }
        case "NVarChar":
        case "NChar": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          ({
            offset
          } = (0, _metadataParser.readCollation)(buf, offset));
          return readNChars(buf, offset, dataLength);
        }
        default:
          throw new Error("Invalid type!");
      }
    }
    function readBinary(buf, offset, dataLength) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(buf.slice(offset, offset + dataLength), offset + dataLength);
    }
    function readChars(buf, offset, dataLength, codepage) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(_iconvLite.default.decode(buf.slice(offset, offset + dataLength), codepage ?? DEFAULT_ENCODING), offset + dataLength);
    }
    function readNChars(buf, offset, dataLength) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(buf.toString("ucs2", offset, offset + dataLength), offset + dataLength);
    }
    async function readPLPStream(parser) {
      while (parser.buffer.length < parser.position + 8) {
        await parser.waitForChunk();
      }
      const expectedLength = parser.buffer.readBigUInt64LE(parser.position);
      parser.position += 8;
      if (expectedLength === PLP_NULL) {
        return null;
      }
      const chunks = [];
      let currentLength = 0;
      while (true) {
        while (parser.buffer.length < parser.position + 4) {
          await parser.waitForChunk();
        }
        const chunkLength = parser.buffer.readUInt32LE(parser.position);
        parser.position += 4;
        if (!chunkLength) {
          break;
        }
        while (parser.buffer.length < parser.position + chunkLength) {
          await parser.waitForChunk();
        }
        chunks.push(parser.buffer.slice(parser.position, parser.position + chunkLength));
        parser.position += chunkLength;
        currentLength += chunkLength;
      }
      if (expectedLength !== UNKNOWN_PLP_LEN) {
        if (currentLength !== Number(expectedLength)) {
          throw new Error("Partially Length-prefixed Bytes unmatched lengths : expected " + expectedLength + ", but got " + currentLength + " bytes");
        }
      }
      return chunks;
    }
    function readSmallDateTime(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let minutes;
      ({
        offset,
        value: minutes
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let value;
      if (useUTC) {
        value = new Date(Date.UTC(1900, 0, 1 + days, 0, minutes));
      } else {
        value = new Date(1900, 0, 1 + days, 0, minutes);
      }
      return new _helpers.Result(value, offset);
    }
    function readDateTime(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readInt32LE)(buf, offset));
      let threeHundredthsOfSecond;
      ({
        offset,
        value: threeHundredthsOfSecond
      } = (0, _helpers.readInt32LE)(buf, offset));
      const milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);
      let value;
      if (useUTC) {
        value = new Date(Date.UTC(1900, 0, 1 + days, 0, 0, 0, milliseconds));
      } else {
        value = new Date(1900, 0, 1 + days, 0, 0, 0, milliseconds);
      }
      return new _helpers.Result(value, offset);
    }
    function readTime(buf, offset, dataLength, scale, useUTC) {
      let value;
      switch (dataLength) {
        case 3: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt24LE)(buf, offset));
          break;
        }
        case 4: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt32LE)(buf, offset));
          break;
        }
        case 5: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt40LE)(buf, offset));
          break;
        }
        default: {
          throw new Error("unreachable");
        }
      }
      if (scale < 7) {
        for (let i = scale; i < 7; i++) {
          value *= 10;
        }
      }
      let date;
      if (useUTC) {
        date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 1e4));
      } else {
        date = new Date(1970, 0, 1, 0, 0, 0, value / 1e4);
      }
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: value % 1e4 / Math.pow(10, 7)
      });
      return new _helpers.Result(date, offset);
    }
    function readDate(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      if (useUTC) {
        return new _helpers.Result(new Date(Date.UTC(2e3, 0, days - 730118)), offset);
      } else {
        return new _helpers.Result(new Date(2e3, 0, days - 730118), offset);
      }
    }
    function readDateTime2(buf, offset, dataLength, scale, useUTC) {
      let time;
      ({
        offset,
        value: time
      } = readTime(buf, offset, dataLength - 3, scale, useUTC));
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      let date;
      if (useUTC) {
        date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
      } else {
        date = new Date(2e3, 0, days - 730118, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
      }
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: time.nanosecondsDelta
      });
      return new _helpers.Result(date, offset);
    }
    function readDateTimeOffset(buf, offset, dataLength, scale) {
      let time;
      ({
        offset,
        value: time
      } = readTime(buf, offset, dataLength - 5, scale, true));
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      ({
        offset
      } = (0, _helpers.readUInt16LE)(buf, offset));
      const date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: time.nanosecondsDelta
      });
      return new _helpers.Result(date, offset);
    }
    module2.exports.readValue = readValue;
    module2.exports.isPLPStream = isPLPStream;
    module2.exports.readPLPStream = readPLPStream;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/returnvalue-token-parser.js
var require_returnvalue_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/returnvalue-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var _metadataParser = require_metadata_parser();
    var _valueParser = require_value_parser();
    var _helpers = require_helpers3();
    var iconv = _interopRequireWildcard(require_lib3());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    async function returnParser(parser) {
      let paramName;
      let paramOrdinal;
      let metadata;
      while (true) {
        const buf = parser.buffer;
        let offset = parser.position;
        try {
          ({
            offset,
            value: paramOrdinal
          } = (0, _helpers.readUInt16LE)(buf, offset));
          ({
            offset,
            value: paramName
          } = (0, _helpers.readBVarChar)(buf, offset));
          ({
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          ({
            offset,
            value: metadata
          } = (0, _metadataParser.readMetadata)(buf, offset, parser.options));
          if (paramName.charAt(0) === "@") {
            paramName = paramName.slice(1);
          }
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            await parser.waitForChunk();
            continue;
          }
          throw err;
        }
        parser.position = offset;
        break;
      }
      let value;
      while (true) {
        const buf = parser.buffer;
        let offset = parser.position;
        if ((0, _valueParser.isPLPStream)(metadata)) {
          const chunks = await (0, _valueParser.readPLPStream)(parser);
          if (chunks === null) {
            value = chunks;
          } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
            value = Buffer.concat(chunks).toString("ucs2");
          } else if (metadata.type.name === "VarChar") {
            value = iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? "utf8");
          } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
            value = Buffer.concat(chunks);
          }
        } else {
          try {
            ({
              value,
              offset
            } = (0, _valueParser.readValue)(buf, offset, metadata, parser.options));
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = offset;
        }
        break;
      }
      return new _token.ReturnValueToken({
        paramOrdinal,
        paramName,
        metadata,
        value
      });
    }
    var _default = exports2.default = returnParser;
    module2.exports = returnParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/row-token-parser.js
var require_row_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/row-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var iconv = _interopRequireWildcard(require_lib3());
    var _valueParser = require_value_parser();
    var _helpers = require_helpers3();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    async function rowParser(parser) {
      const columns = [];
      for (const metadata of parser.colMetadata) {
        while (true) {
          if ((0, _valueParser.isPLPStream)(metadata)) {
            const chunks = await (0, _valueParser.readPLPStream)(parser);
            if (chunks === null) {
              columns.push({
                value: chunks,
                metadata
              });
            } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
              columns.push({
                value: Buffer.concat(chunks).toString("ucs2"),
                metadata
              });
            } else if (metadata.type.name === "VarChar") {
              columns.push({
                value: iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? "utf8"),
                metadata
              });
            } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
              columns.push({
                value: Buffer.concat(chunks),
                metadata
              });
            }
          } else {
            let result;
            try {
              result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
            } catch (err) {
              if (err instanceof _helpers.NotEnoughDataError) {
                await parser.waitForChunk();
                continue;
              }
              throw err;
            }
            parser.position = result.offset;
            columns.push({
              value: result.value,
              metadata
            });
          }
          break;
        }
      }
      if (parser.options.useColumnNames) {
        const columnsMap = /* @__PURE__ */ Object.create(null);
        columns.forEach((column) => {
          const colName = column.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column;
          }
        });
        return new _token.RowToken(columnsMap);
      } else {
        return new _token.RowToken(columns);
      }
    }
    var _default = exports2.default = rowParser;
    module2.exports = rowParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/nbcrow-token-parser.js
var require_nbcrow_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/nbcrow-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var iconv = _interopRequireWildcard(require_lib3());
    var _valueParser = require_value_parser();
    var _helpers = require_helpers3();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    async function nbcRowParser(parser) {
      const colMetadata = parser.colMetadata;
      const columns = [];
      const bitmap = [];
      const bitmapByteLength = Math.ceil(colMetadata.length / 8);
      while (parser.buffer.length - parser.position < bitmapByteLength) {
        await parser.waitForChunk();
      }
      const bytes = parser.buffer.slice(parser.position, parser.position + bitmapByteLength);
      parser.position += bitmapByteLength;
      for (let i = 0, len = bytes.length; i < len; i++) {
        const byte = bytes[i];
        bitmap.push(byte & 1 ? true : false);
        bitmap.push(byte & 2 ? true : false);
        bitmap.push(byte & 4 ? true : false);
        bitmap.push(byte & 8 ? true : false);
        bitmap.push(byte & 16 ? true : false);
        bitmap.push(byte & 32 ? true : false);
        bitmap.push(byte & 64 ? true : false);
        bitmap.push(byte & 128 ? true : false);
      }
      for (let i = 0; i < colMetadata.length; i++) {
        const metadata = colMetadata[i];
        if (bitmap[i]) {
          columns.push({
            value: null,
            metadata
          });
          continue;
        }
        while (true) {
          if ((0, _valueParser.isPLPStream)(metadata)) {
            const chunks = await (0, _valueParser.readPLPStream)(parser);
            if (chunks === null) {
              columns.push({
                value: chunks,
                metadata
              });
            } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
              columns.push({
                value: Buffer.concat(chunks).toString("ucs2"),
                metadata
              });
            } else if (metadata.type.name === "VarChar") {
              columns.push({
                value: iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? "utf8"),
                metadata
              });
            } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
              columns.push({
                value: Buffer.concat(chunks),
                metadata
              });
            }
          } else {
            let result;
            try {
              result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
            } catch (err) {
              if (err instanceof _helpers.NotEnoughDataError) {
                await parser.waitForChunk();
                continue;
              }
              throw err;
            }
            parser.position = result.offset;
            columns.push({
              value: result.value,
              metadata
            });
          }
          break;
        }
      }
      if (parser.options.useColumnNames) {
        const columnsMap = /* @__PURE__ */ Object.create(null);
        columns.forEach((column) => {
          const colName = column.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column;
          }
        });
        return new _token.NBCRowToken(columnsMap);
      } else {
        return new _token.NBCRowToken(columns);
      }
    }
    var _default = exports2.default = nbcRowParser;
    module2.exports = nbcRowParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/sspi-token-parser.js
var require_sspi_token_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/sspi-token-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _helpers = require_helpers3();
    var _token = require_token();
    function parseChallenge(buffer) {
      const challenge = {};
      challenge.magic = buffer.slice(0, 8).toString("utf8");
      challenge.type = buffer.readInt32LE(8);
      challenge.domainLen = buffer.readInt16LE(12);
      challenge.domainMax = buffer.readInt16LE(14);
      challenge.domainOffset = buffer.readInt32LE(16);
      challenge.flags = buffer.readInt32LE(20);
      challenge.nonce = buffer.slice(24, 32);
      challenge.zeroes = buffer.slice(32, 40);
      challenge.targetLen = buffer.readInt16LE(40);
      challenge.targetMax = buffer.readInt16LE(42);
      challenge.targetOffset = buffer.readInt32LE(44);
      challenge.oddData = buffer.slice(48, 56);
      challenge.domain = buffer.slice(56, 56 + challenge.domainLen).toString("ucs2");
      challenge.target = buffer.slice(56 + challenge.domainLen, 56 + challenge.domainLen + challenge.targetLen);
      return challenge;
    }
    function sspiParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const data = buf.slice(offset, offset + tokenLength);
      offset += tokenLength;
      return new _helpers.Result(new _token.SSPIToken(parseChallenge(data), data), offset);
    }
    var _default = exports2.default = sspiParser;
    module2.exports = sspiParser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/stream-parser.js
var require_stream_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/stream-parser.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _token = require_token();
    var _colmetadataTokenParser = _interopRequireDefault(require_colmetadata_token_parser());
    var _doneTokenParser = require_done_token_parser();
    var _envChangeTokenParser = _interopRequireDefault(require_env_change_token_parser());
    var _infoerrorTokenParser = require_infoerror_token_parser();
    var _fedauthInfoParser = _interopRequireDefault(require_fedauth_info_parser());
    var _featureExtAckParser = _interopRequireDefault(require_feature_ext_ack_parser());
    var _loginackTokenParser = _interopRequireDefault(require_loginack_token_parser());
    var _orderTokenParser = _interopRequireDefault(require_order_token_parser());
    var _returnstatusTokenParser = _interopRequireDefault(require_returnstatus_token_parser());
    var _returnvalueTokenParser = _interopRequireDefault(require_returnvalue_token_parser());
    var _rowTokenParser = _interopRequireDefault(require_row_token_parser());
    var _nbcrowTokenParser = _interopRequireDefault(require_nbcrow_token_parser());
    var _sspiTokenParser = _interopRequireDefault(require_sspi_token_parser());
    var _helpers = require_helpers3();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = class _Parser {
      debug;
      colMetadata;
      options;
      iterator;
      buffer;
      position;
      static async *parseTokens(iterable, debug, options, colMetadata = []) {
        const parser = new _Parser(iterable, debug, options);
        parser.colMetadata = colMetadata;
        while (true) {
          try {
            await parser.waitForChunk();
          } catch (err) {
            if (parser.position === parser.buffer.length) {
              return;
            }
            throw err;
          }
          while (parser.buffer.length >= parser.position + 1) {
            const type = parser.buffer.readUInt8(parser.position);
            parser.position += 1;
            const token = parser.readToken(type);
            if (token !== void 0) {
              yield token;
            }
          }
        }
      }
      readToken(type) {
        switch (type) {
          case _token.TYPE.DONE: {
            return this.readDoneToken();
          }
          case _token.TYPE.DONEPROC: {
            return this.readDoneProcToken();
          }
          case _token.TYPE.DONEINPROC: {
            return this.readDoneInProcToken();
          }
          case _token.TYPE.ERROR: {
            return this.readErrorToken();
          }
          case _token.TYPE.INFO: {
            return this.readInfoToken();
          }
          case _token.TYPE.ENVCHANGE: {
            return this.readEnvChangeToken();
          }
          case _token.TYPE.LOGINACK: {
            return this.readLoginAckToken();
          }
          case _token.TYPE.RETURNSTATUS: {
            return this.readReturnStatusToken();
          }
          case _token.TYPE.ORDER: {
            return this.readOrderToken();
          }
          case _token.TYPE.FEDAUTHINFO: {
            return this.readFedAuthInfoToken();
          }
          case _token.TYPE.SSPI: {
            return this.readSSPIToken();
          }
          case _token.TYPE.COLMETADATA: {
            return this.readColMetadataToken();
          }
          case _token.TYPE.RETURNVALUE: {
            return this.readReturnValueToken();
          }
          case _token.TYPE.ROW: {
            return this.readRowToken();
          }
          case _token.TYPE.NBCROW: {
            return this.readNbcRowToken();
          }
          case _token.TYPE.FEATUREEXTACK: {
            return this.readFeatureExtAckToken();
          }
          default: {
            throw new Error("Unknown type: " + type);
          }
        }
      }
      readFeatureExtAckToken() {
        let result;
        try {
          result = (0, _featureExtAckParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readFeatureExtAckToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      async readNbcRowToken() {
        return await (0, _nbcrowTokenParser.default)(this);
      }
      async readReturnValueToken() {
        return await (0, _returnvalueTokenParser.default)(this);
      }
      async readColMetadataToken() {
        const token = await (0, _colmetadataTokenParser.default)(this);
        this.colMetadata = token.columns;
        return token;
      }
      readSSPIToken() {
        let result;
        try {
          result = (0, _sspiTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readSSPIToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readFedAuthInfoToken() {
        let result;
        try {
          result = (0, _fedauthInfoParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readFedAuthInfoToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readOrderToken() {
        let result;
        try {
          result = (0, _orderTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readOrderToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readReturnStatusToken() {
        let result;
        try {
          result = (0, _returnstatusTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readReturnStatusToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readLoginAckToken() {
        let result;
        try {
          result = (0, _loginackTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readLoginAckToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readEnvChangeToken() {
        let result;
        try {
          result = (0, _envChangeTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readEnvChangeToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readRowToken() {
        return (0, _rowTokenParser.default)(this);
      }
      readInfoToken() {
        let result;
        try {
          result = (0, _infoerrorTokenParser.infoParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readInfoToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readErrorToken() {
        let result;
        try {
          result = (0, _infoerrorTokenParser.errorParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readErrorToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneInProcToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneInProcParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneInProcToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneProcToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneProcParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneProcToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      constructor(iterable, debug, options) {
        this.debug = debug;
        this.colMetadata = [];
        this.options = options;
        this.iterator = (iterable[Symbol.asyncIterator] || iterable[Symbol.iterator]).call(iterable);
        this.buffer = Buffer.alloc(0);
        this.position = 0;
      }
      async waitForChunk() {
        const result = await this.iterator.next();
        if (result.done) {
          throw new Error("unexpected end of data");
        }
        if (this.position === this.buffer.length) {
          this.buffer = result.value;
        } else {
          this.buffer = Buffer.concat([this.buffer.slice(this.position), result.value]);
        }
        this.position = 0;
      }
    };
    var _default = exports2.default = Parser;
    module2.exports = Parser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/token-stream-parser.js
var require_token_stream_parser = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/token-stream-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Parser = void 0;
    var _events = require("events");
    var _streamParser = _interopRequireDefault(require_stream_parser());
    var _stream = require("stream");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = class extends _events.EventEmitter {
      constructor(message, debug, handler, options) {
        super();
        this.debug = debug;
        this.options = options;
        this.parser = _stream.Readable.from(_streamParser.default.parseTokens(message, this.debug, this.options));
        this.parser.on("data", (token) => {
          debug.token(token);
          handler[token.handlerName](token);
        });
        this.parser.on("drain", () => {
          this.emit("drain");
        });
        this.parser.on("end", () => {
          this.emit("end");
        });
      }
      pause() {
        return this.parser.pause();
      }
      resume() {
        return this.parser.resume();
      }
    };
    exports2.Parser = Parser;
  }
});

// node_modules/mssql/node_modules/tedious/lib/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/transaction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Transaction = exports2.OPERATION_TYPE = exports2.ISOLATION_LEVEL = void 0;
    exports2.assertValidIsolationLevel = assertValidIsolationLevel;
    exports2.isolationLevelByValue = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OPERATION_TYPE = exports2.OPERATION_TYPE = {
      TM_GET_DTC_ADDRESS: 0,
      TM_PROPAGATE_XACT: 1,
      TM_BEGIN_XACT: 5,
      TM_PROMOTE_XACT: 6,
      TM_COMMIT_XACT: 7,
      TM_ROLLBACK_XACT: 8,
      TM_SAVE_XACT: 9
    };
    var ISOLATION_LEVEL = exports2.ISOLATION_LEVEL = {
      NO_CHANGE: 0,
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
    var isolationLevelByValue = exports2.isolationLevelByValue = {};
    for (const name in ISOLATION_LEVEL) {
      const value = ISOLATION_LEVEL[name];
      isolationLevelByValue[value] = name;
    }
    function assertValidIsolationLevel(isolationLevel, name) {
      if (typeof isolationLevel !== "number") {
        throw new TypeError(`The "${name}" ${name.includes(".") ? "property" : "argument"} must be of type number. Received type ${typeof isolationLevel} (${isolationLevel})`);
      }
      if (!Number.isInteger(isolationLevel)) {
        throw new RangeError(`The value of "${name}" is out of range. It must be an integer. Received: ${isolationLevel}`);
      }
      if (!(isolationLevel >= 0 && isolationLevel <= 5)) {
        throw new RangeError(`The value of "${name}" is out of range. It must be >= 0 && <= 5. Received: ${isolationLevel}`);
      }
    }
    var Transaction = class {
      constructor(name, isolationLevel = ISOLATION_LEVEL.NO_CHANGE) {
        this.name = name;
        this.isolationLevel = isolationLevel;
        this.outstandingRequestCount = 1;
      }
      beginPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ucs2");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_BEGIN_XACT);
        buffer.writeUInt8(this.isolationLevel);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Begin Transaction: name=" + this.name + ", isolationLevel=" + isolationLevelByValue[this.isolationLevel];
          }
        };
      }
      commitPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_COMMIT_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Commit Transaction: name=" + this.name;
          }
        };
      }
      rollbackPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_ROLLBACK_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Rollback Transaction: name=" + this.name;
          }
        };
      }
      savePayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_SAVE_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Save Transaction: name=" + this.name;
          }
        };
      }
      isolationLevelToTSQL() {
        switch (this.isolationLevel) {
          case ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "READ UNCOMMITTED";
          case ISOLATION_LEVEL.READ_COMMITTED:
            return "READ COMMITTED";
          case ISOLATION_LEVEL.REPEATABLE_READ:
            return "REPEATABLE READ";
          case ISOLATION_LEVEL.SERIALIZABLE:
            return "SERIALIZABLE";
          case ISOLATION_LEVEL.SNAPSHOT:
            return "SNAPSHOT";
        }
        return "";
      }
    };
    exports2.Transaction = Transaction;
  }
});

// node_modules/mssql/node_modules/tedious/lib/connector.js
var require_connector = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/connector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.connectInParallel = connectInParallel;
    exports2.connectInSequence = connectInSequence;
    exports2.lookupAllAddresses = lookupAllAddresses;
    var _net = _interopRequireDefault(require("net"));
    var _nodeUrl = _interopRequireDefault(require("node:url"));
    var _abortError = _interopRequireDefault(require_abort_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function connectInParallel(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      return await new Promise((resolve, reject) => {
        const sockets = new Array(addresses.length);
        const errors = [];
        function onError(err) {
          errors.push(err);
          this.removeListener("error", onError);
          this.removeListener("connect", onConnect);
          this.destroy();
          if (errors.length === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            reject(new AggregateError(errors, "Could not connect (parallel)"));
          }
        }
        function onConnect() {
          signal.removeEventListener("abort", onAbort);
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            if (this === socket) {
              continue;
            }
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          resolve(this);
        }
        const onAbort = () => {
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          reject(new _abortError.default());
        };
        for (let i = 0, len = addresses.length; i < len; i++) {
          const socket = sockets[i] = _net.default.connect({
            ...options,
            host: addresses[i].address,
            family: addresses[i].family
          });
          socket.on("error", onError);
          socket.on("connect", onConnect);
        }
        signal.addEventListener("abort", onAbort, {
          once: true
        });
      });
    }
    async function connectInSequence(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const errors = [];
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      for (const address of addresses) {
        try {
          return await new Promise((resolve, reject) => {
            const socket = _net.default.connect({
              ...options,
              host: address.address,
              family: address.family
            });
            const onAbort = () => {
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(new _abortError.default());
            };
            const onError = (err) => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(err);
            };
            const onConnect = () => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              resolve(socket);
            };
            signal.addEventListener("abort", onAbort, {
              once: true
            });
            socket.on("error", onError);
            socket.on("connect", onConnect);
          });
        } catch (err) {
          if (err instanceof Error && err.name === "AbortError") {
            throw err;
          }
          errors.push(err);
          continue;
        }
      }
      throw new AggregateError(errors, "Could not connect (sequence)");
    }
    async function lookupAllAddresses(host, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      if (_net.default.isIPv6(host)) {
        return [{
          address: host,
          family: 6
        }];
      } else if (_net.default.isIPv4(host)) {
        return [{
          address: host,
          family: 4
        }];
      } else {
        return await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          signal.addEventListener("abort", onAbort);
          const domainInASCII = _nodeUrl.default.domainToASCII(host);
          lookup(domainInASCII === "" ? host : domainInASCII, {
            all: true
          }, (err, addresses) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses);
          });
        });
      }
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/library.js
var require_library = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/library.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.name = void 0;
    var name = exports2.name = "Tedious";
  }
});

// node_modules/mssql/node_modules/tedious/lib/ntlm.js
var require_ntlm = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/ntlm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createNTLMRequest = createNTLMRequest;
    var NTLMFlags = {
      NTLM_NegotiateUnicode: 1,
      NTLM_NegotiateOEM: 2,
      NTLM_RequestTarget: 4,
      NTLM_Unknown9: 8,
      NTLM_NegotiateSign: 16,
      NTLM_NegotiateSeal: 32,
      NTLM_NegotiateDatagram: 64,
      NTLM_NegotiateLanManagerKey: 128,
      NTLM_Unknown8: 256,
      NTLM_NegotiateNTLM: 512,
      NTLM_NegotiateNTOnly: 1024,
      NTLM_Anonymous: 2048,
      NTLM_NegotiateOemDomainSupplied: 4096,
      NTLM_NegotiateOemWorkstationSupplied: 8192,
      NTLM_Unknown6: 16384,
      NTLM_NegotiateAlwaysSign: 32768,
      NTLM_TargetTypeDomain: 65536,
      NTLM_TargetTypeServer: 131072,
      NTLM_TargetTypeShare: 262144,
      NTLM_NegotiateExtendedSecurity: 524288,
      NTLM_NegotiateIdentify: 1048576,
      NTLM_Unknown5: 2097152,
      NTLM_RequestNonNTSessionKey: 4194304,
      NTLM_NegotiateTargetInfo: 8388608,
      NTLM_Unknown4: 16777216,
      NTLM_NegotiateVersion: 33554432,
      NTLM_Unknown3: 67108864,
      NTLM_Unknown2: 134217728,
      NTLM_Unknown1: 268435456,
      NTLM_Negotiate128: 536870912,
      NTLM_NegotiateKeyExchange: 1073741824,
      NTLM_Negotiate56: 2147483648
    };
    function createNTLMRequest(options) {
      const domain = escape(options.domain.toUpperCase());
      const workstation = options.workstation ? escape(options.workstation.toUpperCase()) : "";
      let type1flags = NTLMFlags.NTLM_NegotiateUnicode + NTLMFlags.NTLM_NegotiateOEM + NTLMFlags.NTLM_RequestTarget + NTLMFlags.NTLM_NegotiateNTLM + NTLMFlags.NTLM_NegotiateOemDomainSupplied + NTLMFlags.NTLM_NegotiateOemWorkstationSupplied + NTLMFlags.NTLM_NegotiateAlwaysSign + NTLMFlags.NTLM_NegotiateVersion + NTLMFlags.NTLM_NegotiateExtendedSecurity + NTLMFlags.NTLM_Negotiate128 + NTLMFlags.NTLM_Negotiate56;
      if (workstation === "") {
        type1flags -= NTLMFlags.NTLM_NegotiateOemWorkstationSupplied;
      }
      const fixedData = Buffer.alloc(40);
      const buffers = [fixedData];
      let offset = 0;
      offset += fixedData.write("NTLMSSP", offset, 7, "ascii");
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt32LE(1, offset);
      offset = fixedData.writeUInt32LE(type1flags, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length + workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length, offset);
      offset = fixedData.writeUInt8(5, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt16LE(2195, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      fixedData.writeUInt8(15, offset);
      buffers.push(Buffer.from(workstation, "ascii"));
      buffers.push(Buffer.from(domain, "ascii"));
      return Buffer.concat(buffers);
    }
  }
});

// node_modules/mssql/node_modules/tedious/lib/bulk-load-payload.js
var require_bulk_load_payload = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/bulk-load-payload.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BulkLoadPayload = void 0;
    var BulkLoadPayload = class {
      constructor(bulkLoad) {
        this.bulkLoad = bulkLoad;
        this.iterator = this.bulkLoad.rowToPacketTransform[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterator;
      }
      toString(indent = "") {
        return indent + "BulkLoad";
      }
    };
    exports2.BulkLoadPayload = BulkLoadPayload;
  }
});

// node_modules/mssql/node_modules/tedious/lib/special-stored-procedure.js
var require_special_stored_procedure = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/special-stored-procedure.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var procedures = {
      Sp_Cursor: 1,
      Sp_CursorOpen: 2,
      Sp_CursorPrepare: 3,
      Sp_CursorExecute: 4,
      Sp_CursorPrepExec: 5,
      Sp_CursorUnprepare: 6,
      Sp_CursorFetch: 7,
      Sp_CursorOption: 8,
      Sp_CursorClose: 9,
      Sp_ExecuteSql: 10,
      Sp_Prepare: 11,
      Sp_Execute: 12,
      Sp_PrepExec: 13,
      Sp_PrepExecRpc: 14,
      Sp_Unprepare: 15
    };
    var _default = exports2.default = procedures;
    module2.exports = procedures;
  }
});

// node_modules/mssql/node_modules/tedious/package.json
var require_package = __commonJS({
  "node_modules/mssql/node_modules/tedious/package.json"(exports2, module2) {
    module2.exports = {
      author: "Mike D Pilsbury <mike.pilsbury@gmail.com>",
      contributors: [
        "Alex Robson",
        "Arthur Schreiber",
        "Bret Copeland <bret@atlantisflight.org> (https://github.com/bretcope)",
        "Bryan Ross <bryan@rossipedia.com> (https://github.com/rossipedia)",
        "Ciaran Jessup <ciaranj@gmail.com>",
        "Cort Fritz <cfritz@caa.com>",
        "lastonesky",
        "Patrik Simek <patrik@patriksimek.cz>",
        "Phil Dodderidge <pdodde@poyntz.com>",
        "Zach Aller"
      ],
      name: "tedious",
      description: "A TDS driver, for connecting to MS SQLServer databases.",
      keywords: [
        "sql",
        "database",
        "mssql",
        "sqlserver",
        "sql-server",
        "tds",
        "msnodesql",
        "azure"
      ],
      homepage: "https://github.com/tediousjs/tedious",
      bugs: "https://github.com/tediousjs/tedious/issues",
      license: "MIT",
      version: "18.6.2",
      main: "./lib/tedious.js",
      types: "./lib/tedious.d.ts",
      repository: {
        type: "git",
        url: "https://github.com/tediousjs/tedious.git"
      },
      engines: {
        node: ">=18"
      },
      publishConfig: {
        tag: "next",
        provenance: true
      },
      dependencies: {
        "@azure/core-auth": "^1.7.2",
        "@azure/identity": "^4.2.1",
        "@azure/keyvault-keys": "^4.4.0",
        "@js-joda/core": "^5.6.1",
        "@types/node": ">=18",
        bl: "^6.0.11",
        "iconv-lite": "^0.6.3",
        "js-md4": "^0.3.2",
        "native-duplexpair": "^1.0.0",
        "sprintf-js": "^1.1.3"
      },
      devDependencies: {
        "@babel/cli": "^7.23.9",
        "@babel/core": "^7.23.9",
        "@babel/node": "^7.23.9",
        "@babel/preset-env": "^7.23.9",
        "@babel/preset-typescript": "^7.23.3",
        "@babel/register": "^7.23.7",
        "@types/async": "^3.2.24",
        "@types/bl": "^5.1.0",
        "@types/chai": "^4.3.12",
        "@types/depd": "^1.1.36",
        "@types/lru-cache": "^5.1.1",
        "@types/mocha": "^10.0.6",
        "@types/sprintf-js": "^1.1.4",
        "@typescript-eslint/eslint-plugin": "^7.0.2",
        "@typescript-eslint/parser": "^7.0.2",
        async: "^3.2.5",
        "babel-plugin-istanbul": "^6.1.1",
        chai: "^4.4.1",
        codecov: "^3.8.3",
        eslint: "^8.57.0",
        mitm: "^1.7.2",
        mocha: "^10.3.0",
        nyc: "^15.1.0",
        rimraf: "^5.0.5",
        "semantic-release": "^22.0.12",
        sinon: "^15.2.0",
        typedoc: "^0.26.5",
        typescript: "^5.5.4"
      },
      scripts: {
        docs: "typedoc",
        lint: "eslint src test --ext .js,.ts && tsc",
        test: "mocha --forbid-only test/unit test/unit/token test/unit/tracking-buffer",
        "test-integration": "mocha --forbid-only test/integration/",
        "test-all": "mocha --forbid-only test/unit/ test/unit/token/ test/unit/tracking-buffer test/integration/",
        "build:types": "tsc --project tsconfig.build-types.json",
        build: "rimraf lib && babel src --out-dir lib --extensions .js,.ts && npm run build:types",
        prepublish: "npm run build",
        "semantic-release": "semantic-release"
      },
      babel: {
        sourceMaps: "both",
        ignore: [
          "./src/**/*.d.ts"
        ],
        presets: [
          [
            "@babel/preset-env",
            {
              targets: {
                node: 18
              }
            }
          ],
          [
            "@babel/preset-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ],
        plugins: [
          [
            "@babel/transform-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ]
      },
      mocha: {
        require: "test/setup.js",
        timeout: 5e3,
        extension: [
          "js",
          "ts"
        ]
      },
      nyc: {
        sourceMap: false,
        instrument: false,
        extension: [
          ".ts"
        ]
      }
    };
  }
});

// node_modules/mssql/node_modules/tedious/lib/token/handler.js
var require_handler = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/token/handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UnexpectedTokenError = exports2.TokenHandler = exports2.RequestTokenHandler = exports2.Login7TokenHandler = exports2.InitialSqlTokenHandler = exports2.AttentionTokenHandler = void 0;
    var _request = _interopRequireDefault(require_request2());
    var _errors = require_errors2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UnexpectedTokenError = class extends Error {
      constructor(handler, token) {
        super("Unexpected token `" + token.name + "` in `" + handler.constructor.name + "`");
      }
    };
    exports2.UnexpectedTokenError = UnexpectedTokenError;
    var TokenHandler = class {
      onInfoMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onErrorMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSSPI(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLanguageChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCharsetChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSqlCollationChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRoutingChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onPacketSizeChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onResetConnection(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onBeginTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCommitTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRollbackTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFedAuthInfo(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFeatureExtAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLoginAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onColMetadata(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onOrder(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRow(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnStatus(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnValue(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneInProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDone(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseMirroringPartner(token) {
        throw new UnexpectedTokenError(this, token);
      }
    };
    exports2.TokenHandler = TokenHandler;
    var InitialSqlTokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        this.connection.emit("error", new Error("Received 'columnMetadata' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onOrder(token) {
        this.connection.emit("error", new Error("Received 'order' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onRow(token) {
        this.connection.emit("error", new Error("Received 'row' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onReturnStatus(token) {
      }
      onReturnValue(token) {
      }
      onDoneProc(token) {
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports2.InitialSqlTokenHandler = InitialSqlTokenHandler;
    var Login7TokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        this.loginAckReceived = false;
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        const error = new _errors.ConnectionError(token.message, "ELOGIN");
        const isLoginErrorTransient = this.connection.transientErrorLookup.isTransientError(token.number);
        if (isLoginErrorTransient && this.connection.curTransientRetryCount !== this.connection.config.options.maxRetriesOnTransientErrors) {
          error.isTransient = true;
        }
        this.connection.loginError = error;
      }
      onSSPI(token) {
        if (token.ntlmpacket) {
          this.connection.ntlmpacket = token.ntlmpacket;
          this.connection.ntlmpacketBuffer = token.ntlmpacketBuffer;
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onFedAuthInfo(token) {
        this.fedAuthInfoToken = token;
      }
      onFeatureExtAck(token) {
        const {
          authentication: authentication2
        } = this.connection.config;
        if (authentication2.type === "azure-active-directory-password" || authentication2.type === "azure-active-directory-access-token" || authentication2.type === "azure-active-directory-msi-vm" || authentication2.type === "azure-active-directory-msi-app-service" || authentication2.type === "azure-active-directory-service-principal-secret" || authentication2.type === "azure-active-directory-default") {
          if (token.fedAuth === void 0) {
            this.connection.loginError = new _errors.ConnectionError("Did not receive Active Directory authentication acknowledgement");
          } else if (token.fedAuth.length !== 0) {
            this.connection.loginError = new _errors.ConnectionError(`Active Directory authentication acknowledgment for ${authentication2.type} authentication method includes extra data`);
          }
        } else if (token.fedAuth === void 0 && token.utf8Support === void 0) {
          this.connection.loginError = new _errors.ConnectionError("Received acknowledgement for unknown feature");
        } else if (token.fedAuth) {
          this.connection.loginError = new _errors.ConnectionError("Did not request Active Directory authentication, but received the acknowledgment");
        }
      }
      onLoginAck(token) {
        if (!token.tdsVersion) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unknown TDS version.", "ETDS");
          return;
        }
        if (!token.interface) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unsupported interface.", "EINTERFACENOTSUPP");
          return;
        }
        this.connection.config.options.tdsVersion = token.tdsVersion;
        this.loginAckReceived = true;
      }
      onRoutingChange(token) {
        const [server] = token.newValue.server.split("\\");
        this.routingData = {
          server,
          port: token.newValue.port
        };
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onDatabaseMirroringPartner(token) {
      }
    };
    exports2.Login7TokenHandler = Login7TokenHandler;
    var RequestTokenHandler = class extends TokenHandler {
      constructor(connection, request) {
        super();
        this.connection = connection;
        this.request = request;
        this.errors = [];
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        if (!this.request.canceled) {
          const error = new _errors.RequestError(token.message, "EREQUEST");
          error.number = token.number;
          error.state = token.state;
          error.class = token.class;
          error.serverName = token.serverName;
          error.procName = token.procName;
          error.lineNumber = token.lineNumber;
          this.errors.push(error);
          this.request.error = error;
          if (this.request instanceof _request.default && this.errors.length > 1) {
            this.request.error = new AggregateError(this.errors);
          }
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.useColumnNames) {
            const columns = /* @__PURE__ */ Object.create(null);
            for (let j = 0, len = token.columns.length; j < len; j++) {
              const col = token.columns[j];
              if (columns[col.colName] == null) {
                columns[col.colName] = col;
              }
            }
            this.request.emit("columnMetadata", columns);
          } else {
            this.request.emit("columnMetadata", token.columns);
          }
        }
      }
      onOrder(token) {
        if (!this.request.canceled) {
          this.request.emit("order", token.orderColumns);
        }
      }
      onRow(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.rowCollectionOnRequestCompletion) {
            this.request.rows.push(token.columns);
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst.push(token.columns);
          }
          this.request.emit("row", token.columns);
        }
      }
      onReturnStatus(token) {
        if (!this.request.canceled) {
          this.connection.procReturnStatusValue = token.value;
        }
      }
      onReturnValue(token) {
        if (!this.request.canceled) {
          this.request.emit("returnValue", token.paramName, token.value, token.metadata);
        }
      }
      onDoneProc(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("doneProc", token.rowCount, token.more, this.connection.procReturnStatusValue, this.request.rst);
          this.connection.procReturnStatusValue = void 0;
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDoneInProc(token) {
        if (!this.request.canceled) {
          this.request.emit("doneInProc", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDone(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("done", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports2.RequestTokenHandler = RequestTokenHandler;
    var AttentionTokenHandler = class extends TokenHandler {
      /**
       * Returns whether an attention acknowledgement was received.
       */
      constructor(connection, request) {
        super();
        this.connection = connection;
        this.request = request;
        this.attentionReceived = false;
      }
      onDone(token) {
        if (token.attention) {
          this.attentionReceived = true;
        }
      }
    };
    exports2.AttentionTokenHandler = AttentionTokenHandler;
  }
});

// node_modules/mssql/node_modules/tedious/lib/connection.js
var require_connection = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/connection.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    var _os = _interopRequireDefault(require("os"));
    var tls = _interopRequireWildcard(require("tls"));
    var net = _interopRequireWildcard(require("net"));
    var _dns = _interopRequireDefault(require("dns"));
    var _constants = _interopRequireDefault(require("constants"));
    var _stream = require("stream");
    var _identity = require_commonjs8();
    var _coreAuth = require_commonjs9();
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _debug = _interopRequireDefault(require_debug3());
    var _events = require("events");
    var _instanceLookup = require_instance_lookup();
    var _transientErrorLookup = require_transient_error_lookup();
    var _packet = require_packet();
    var _preloginPayload = _interopRequireDefault(require_prelogin_payload());
    var _login7Payload = _interopRequireDefault(require_login7_payload());
    var _ntlmPayload = _interopRequireDefault(require_ntlm_payload());
    var _request = _interopRequireDefault(require_request2());
    var _rpcrequestPayload = _interopRequireDefault(require_rpcrequest_payload());
    var _sqlbatchPayload = _interopRequireDefault(require_sqlbatch_payload());
    var _messageIo = _interopRequireDefault(require_message_io());
    var _tokenStreamParser = require_token_stream_parser();
    var _transaction = require_transaction2();
    var _errors = require_errors2();
    var _connector = require_connector();
    var _library = require_library();
    var _tdsVersions = require_tds_versions();
    var _message = _interopRequireDefault(require_message());
    var _ntlm = require_ntlm();
    var _dataType = require_data_type();
    var _bulkLoadPayload = require_bulk_load_payload();
    var _specialStoredProcedure = _interopRequireDefault(require_special_stored_procedure());
    var _package = require_package();
    var _url = require("url");
    var _handler = require_handler();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var KEEP_ALIVE_INITIAL_DELAY = 30 * 1e3;
    var DEFAULT_CONNECT_TIMEOUT = 15 * 1e3;
    var DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1e3;
    var DEFAULT_CANCEL_TIMEOUT = 5 * 1e3;
    var DEFAULT_CONNECT_RETRY_INTERVAL = 500;
    var DEFAULT_PACKET_SIZE = 4 * 1024;
    var DEFAULT_TEXTSIZE = 2147483647;
    var DEFAULT_DATEFIRST = 7;
    var DEFAULT_PORT = 1433;
    var DEFAULT_TDS_VERSION = "7_4";
    var DEFAULT_LANGUAGE = "us_english";
    var DEFAULT_DATEFORMAT = "mdy";
    var CLEANUP_TYPE = {
      NORMAL: 0,
      REDIRECT: 1,
      RETRY: 2
    };
    var Connection = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      _cancelAfterRequestSent;
      /**
       * @private
       */
      /**
       * Note: be aware of the different options field:
       * 1. config.authentication.options
       * 2. config.options
       *
       * ```js
       * const { Connection } = require('tedious');
       *
       * const config = {
       *  "authentication": {
       *    ...,
       *    "options": {...}
       *  },
       *  "options": {...}
       * };
       *
       * const connection = new Connection(config);
       * ```
       *
       * @param config
       */
      constructor(config) {
        super();
        if (typeof config !== "object" || config === null) {
          throw new TypeError('The "config" argument is required and must be of type Object.');
        }
        if (typeof config.server !== "string") {
          throw new TypeError('The "config.server" property is required and must be of type string.');
        }
        this.fedAuthRequired = false;
        let authentication2;
        if (config.authentication !== void 0) {
          if (typeof config.authentication !== "object" || config.authentication === null) {
            throw new TypeError('The "config.authentication" property must be of type Object.');
          }
          const type = config.authentication.type;
          const options = config.authentication.options === void 0 ? {} : config.authentication.options;
          if (typeof type !== "string") {
            throw new TypeError('The "config.authentication.type" property must be of type string.');
          }
          if (type !== "default" && type !== "ntlm" && type !== "token-credential" && type !== "azure-active-directory-password" && type !== "azure-active-directory-access-token" && type !== "azure-active-directory-msi-vm" && type !== "azure-active-directory-msi-app-service" && type !== "azure-active-directory-service-principal-secret" && type !== "azure-active-directory-default") {
            throw new TypeError('The "type" property must one of "default", "ntlm", "token-credential", "azure-active-directory-password", "azure-active-directory-access-token", "azure-active-directory-default", "azure-active-directory-msi-vm" or "azure-active-directory-msi-app-service" or "azure-active-directory-service-principal-secret".');
          }
          if (typeof options !== "object" || options === null) {
            throw new TypeError('The "config.authentication.options" property must be of type object.');
          }
          if (type === "ntlm") {
            if (typeof options.domain !== "string") {
              throw new TypeError('The "config.authentication.options.domain" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication2 = {
              type: "ntlm",
              options: {
                userName: options.userName,
                password: options.password,
                domain: options.domain && options.domain.toUpperCase()
              }
            };
          } else if (type === "token-credential") {
            if (!(0, _coreAuth.isTokenCredential)(options.credential)) {
              throw new TypeError('The "config.authentication.options.credential" property must be an instance of the token credential class.');
            }
            authentication2 = {
              type: "token-credential",
              options: {
                credential: options.credential
              }
            };
          } else if (type === "azure-active-directory-password") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            if (options.tenantId !== void 0 && typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication2 = {
              type: "azure-active-directory-password",
              options: {
                userName: options.userName,
                password: options.password,
                tenantId: options.tenantId,
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-access-token") {
            if (typeof options.token !== "string") {
              throw new TypeError('The "config.authentication.options.token" property must be of type string.');
            }
            authentication2 = {
              type: "azure-active-directory-access-token",
              options: {
                token: options.token
              }
            };
          } else if (type === "azure-active-directory-msi-vm") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication2 = {
              type: "azure-active-directory-msi-vm",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-default") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication2 = {
              type: "azure-active-directory-default",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-msi-app-service") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication2 = {
              type: "azure-active-directory-msi-app-service",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-service-principal-secret") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (typeof options.clientSecret !== "string") {
              throw new TypeError('The "config.authentication.options.clientSecret" property must be of type string.');
            }
            if (typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication2 = {
              type: "azure-active-directory-service-principal-secret",
              options: {
                clientId: options.clientId,
                clientSecret: options.clientSecret,
                tenantId: options.tenantId
              }
            };
          } else {
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication2 = {
              type: "default",
              options: {
                userName: options.userName,
                password: options.password
              }
            };
          }
        } else {
          authentication2 = {
            type: "default",
            options: {
              userName: void 0,
              password: void 0
            }
          };
        }
        this.config = {
          server: config.server,
          authentication: authentication2,
          options: {
            abortTransactionOnError: false,
            appName: void 0,
            camelCaseColumns: false,
            cancelTimeout: DEFAULT_CANCEL_TIMEOUT,
            columnEncryptionKeyCacheTTL: 2 * 60 * 60 * 1e3,
            // Units: milliseconds
            columnEncryptionSetting: false,
            columnNameReplacer: void 0,
            connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,
            connectTimeout: DEFAULT_CONNECT_TIMEOUT,
            connector: void 0,
            connectionIsolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            cryptoCredentialsDetails: {},
            database: void 0,
            datefirst: DEFAULT_DATEFIRST,
            dateFormat: DEFAULT_DATEFORMAT,
            debug: {
              data: false,
              packet: false,
              payload: false,
              token: false
            },
            enableAnsiNull: true,
            enableAnsiNullDefault: true,
            enableAnsiPadding: true,
            enableAnsiWarnings: true,
            enableArithAbort: true,
            enableConcatNullYieldsNull: true,
            enableCursorCloseOnCommit: null,
            enableImplicitTransactions: false,
            enableNumericRoundabort: false,
            enableQuotedIdentifier: true,
            encrypt: true,
            fallbackToDefaultDb: false,
            encryptionKeyStoreProviders: void 0,
            instanceName: void 0,
            isolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            language: DEFAULT_LANGUAGE,
            localAddress: void 0,
            maxRetriesOnTransientErrors: 3,
            multiSubnetFailover: false,
            packetSize: DEFAULT_PACKET_SIZE,
            port: DEFAULT_PORT,
            readOnlyIntent: false,
            requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,
            rowCollectionOnDone: false,
            rowCollectionOnRequestCompletion: false,
            serverName: void 0,
            serverSupportsColumnEncryption: false,
            tdsVersion: DEFAULT_TDS_VERSION,
            textsize: DEFAULT_TEXTSIZE,
            trustedServerNameAE: void 0,
            trustServerCertificate: false,
            useColumnNames: false,
            useUTC: true,
            workstationId: void 0,
            lowerCaseGuids: false
          }
        };
        if (config.options) {
          if (config.options.port && config.options.instanceName) {
            throw new Error("Port and instanceName are mutually exclusive, but " + config.options.port + " and " + config.options.instanceName + " provided");
          }
          if (config.options.abortTransactionOnError !== void 0) {
            if (typeof config.options.abortTransactionOnError !== "boolean" && config.options.abortTransactionOnError !== null) {
              throw new TypeError('The "config.options.abortTransactionOnError" property must be of type string or null.');
            }
            this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;
          }
          if (config.options.appName !== void 0) {
            if (typeof config.options.appName !== "string") {
              throw new TypeError('The "config.options.appName" property must be of type string.');
            }
            this.config.options.appName = config.options.appName;
          }
          if (config.options.camelCaseColumns !== void 0) {
            if (typeof config.options.camelCaseColumns !== "boolean") {
              throw new TypeError('The "config.options.camelCaseColumns" property must be of type boolean.');
            }
            this.config.options.camelCaseColumns = config.options.camelCaseColumns;
          }
          if (config.options.cancelTimeout !== void 0) {
            if (typeof config.options.cancelTimeout !== "number") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type number.');
            }
            this.config.options.cancelTimeout = config.options.cancelTimeout;
          }
          if (config.options.columnNameReplacer) {
            if (typeof config.options.columnNameReplacer !== "function") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type function.');
            }
            this.config.options.columnNameReplacer = config.options.columnNameReplacer;
          }
          if (config.options.connectionIsolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.connectionIsolationLevel, "config.options.connectionIsolationLevel");
            this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;
          }
          if (config.options.connectTimeout !== void 0) {
            if (typeof config.options.connectTimeout !== "number") {
              throw new TypeError('The "config.options.connectTimeout" property must be of type number.');
            }
            this.config.options.connectTimeout = config.options.connectTimeout;
          }
          if (config.options.connector !== void 0) {
            if (typeof config.options.connector !== "function") {
              throw new TypeError('The "config.options.connector" property must be a function.');
            }
            this.config.options.connector = config.options.connector;
          }
          if (config.options.cryptoCredentialsDetails !== void 0) {
            if (typeof config.options.cryptoCredentialsDetails !== "object" || config.options.cryptoCredentialsDetails === null) {
              throw new TypeError('The "config.options.cryptoCredentialsDetails" property must be of type Object.');
            }
            this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;
          }
          if (config.options.database !== void 0) {
            if (typeof config.options.database !== "string") {
              throw new TypeError('The "config.options.database" property must be of type string.');
            }
            this.config.options.database = config.options.database;
          }
          if (config.options.datefirst !== void 0) {
            if (typeof config.options.datefirst !== "number" && config.options.datefirst !== null) {
              throw new TypeError('The "config.options.datefirst" property must be of type number.');
            }
            if (config.options.datefirst !== null && (config.options.datefirst < 1 || config.options.datefirst > 7)) {
              throw new RangeError('The "config.options.datefirst" property must be >= 1 and <= 7');
            }
            this.config.options.datefirst = config.options.datefirst;
          }
          if (config.options.dateFormat !== void 0) {
            if (typeof config.options.dateFormat !== "string" && config.options.dateFormat !== null) {
              throw new TypeError('The "config.options.dateFormat" property must be of type string or null.');
            }
            this.config.options.dateFormat = config.options.dateFormat;
          }
          if (config.options.debug) {
            if (config.options.debug.data !== void 0) {
              if (typeof config.options.debug.data !== "boolean") {
                throw new TypeError('The "config.options.debug.data" property must be of type boolean.');
              }
              this.config.options.debug.data = config.options.debug.data;
            }
            if (config.options.debug.packet !== void 0) {
              if (typeof config.options.debug.packet !== "boolean") {
                throw new TypeError('The "config.options.debug.packet" property must be of type boolean.');
              }
              this.config.options.debug.packet = config.options.debug.packet;
            }
            if (config.options.debug.payload !== void 0) {
              if (typeof config.options.debug.payload !== "boolean") {
                throw new TypeError('The "config.options.debug.payload" property must be of type boolean.');
              }
              this.config.options.debug.payload = config.options.debug.payload;
            }
            if (config.options.debug.token !== void 0) {
              if (typeof config.options.debug.token !== "boolean") {
                throw new TypeError('The "config.options.debug.token" property must be of type boolean.');
              }
              this.config.options.debug.token = config.options.debug.token;
            }
          }
          if (config.options.enableAnsiNull !== void 0) {
            if (typeof config.options.enableAnsiNull !== "boolean" && config.options.enableAnsiNull !== null) {
              throw new TypeError('The "config.options.enableAnsiNull" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNull = config.options.enableAnsiNull;
          }
          if (config.options.enableAnsiNullDefault !== void 0) {
            if (typeof config.options.enableAnsiNullDefault !== "boolean" && config.options.enableAnsiNullDefault !== null) {
              throw new TypeError('The "config.options.enableAnsiNullDefault" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;
          }
          if (config.options.enableAnsiPadding !== void 0) {
            if (typeof config.options.enableAnsiPadding !== "boolean" && config.options.enableAnsiPadding !== null) {
              throw new TypeError('The "config.options.enableAnsiPadding" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;
          }
          if (config.options.enableAnsiWarnings !== void 0) {
            if (typeof config.options.enableAnsiWarnings !== "boolean" && config.options.enableAnsiWarnings !== null) {
              throw new TypeError('The "config.options.enableAnsiWarnings" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;
          }
          if (config.options.enableArithAbort !== void 0) {
            if (typeof config.options.enableArithAbort !== "boolean" && config.options.enableArithAbort !== null) {
              throw new TypeError('The "config.options.enableArithAbort" property must be of type boolean or null.');
            }
            this.config.options.enableArithAbort = config.options.enableArithAbort;
          }
          if (config.options.enableConcatNullYieldsNull !== void 0) {
            if (typeof config.options.enableConcatNullYieldsNull !== "boolean" && config.options.enableConcatNullYieldsNull !== null) {
              throw new TypeError('The "config.options.enableConcatNullYieldsNull" property must be of type boolean or null.');
            }
            this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;
          }
          if (config.options.enableCursorCloseOnCommit !== void 0) {
            if (typeof config.options.enableCursorCloseOnCommit !== "boolean" && config.options.enableCursorCloseOnCommit !== null) {
              throw new TypeError('The "config.options.enableCursorCloseOnCommit" property must be of type boolean or null.');
            }
            this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;
          }
          if (config.options.enableImplicitTransactions !== void 0) {
            if (typeof config.options.enableImplicitTransactions !== "boolean" && config.options.enableImplicitTransactions !== null) {
              throw new TypeError('The "config.options.enableImplicitTransactions" property must be of type boolean or null.');
            }
            this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;
          }
          if (config.options.enableNumericRoundabort !== void 0) {
            if (typeof config.options.enableNumericRoundabort !== "boolean" && config.options.enableNumericRoundabort !== null) {
              throw new TypeError('The "config.options.enableNumericRoundabort" property must be of type boolean or null.');
            }
            this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;
          }
          if (config.options.enableQuotedIdentifier !== void 0) {
            if (typeof config.options.enableQuotedIdentifier !== "boolean" && config.options.enableQuotedIdentifier !== null) {
              throw new TypeError('The "config.options.enableQuotedIdentifier" property must be of type boolean or null.');
            }
            this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;
          }
          if (config.options.encrypt !== void 0) {
            if (typeof config.options.encrypt !== "boolean") {
              if (config.options.encrypt !== "strict") {
                throw new TypeError('The "encrypt" property must be set to "strict", or of type boolean.');
              }
            }
            this.config.options.encrypt = config.options.encrypt;
          }
          if (config.options.fallbackToDefaultDb !== void 0) {
            if (typeof config.options.fallbackToDefaultDb !== "boolean") {
              throw new TypeError('The "config.options.fallbackToDefaultDb" property must be of type boolean.');
            }
            this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;
          }
          if (config.options.instanceName !== void 0) {
            if (typeof config.options.instanceName !== "string") {
              throw new TypeError('The "config.options.instanceName" property must be of type string.');
            }
            this.config.options.instanceName = config.options.instanceName;
            this.config.options.port = void 0;
          }
          if (config.options.isolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.isolationLevel, "config.options.isolationLevel");
            this.config.options.isolationLevel = config.options.isolationLevel;
          }
          if (config.options.language !== void 0) {
            if (typeof config.options.language !== "string" && config.options.language !== null) {
              throw new TypeError('The "config.options.language" property must be of type string or null.');
            }
            this.config.options.language = config.options.language;
          }
          if (config.options.localAddress !== void 0) {
            if (typeof config.options.localAddress !== "string") {
              throw new TypeError('The "config.options.localAddress" property must be of type string.');
            }
            this.config.options.localAddress = config.options.localAddress;
          }
          if (config.options.multiSubnetFailover !== void 0) {
            if (typeof config.options.multiSubnetFailover !== "boolean") {
              throw new TypeError('The "config.options.multiSubnetFailover" property must be of type boolean.');
            }
            this.config.options.multiSubnetFailover = config.options.multiSubnetFailover;
          }
          if (config.options.packetSize !== void 0) {
            if (typeof config.options.packetSize !== "number") {
              throw new TypeError('The "config.options.packetSize" property must be of type number.');
            }
            this.config.options.packetSize = config.options.packetSize;
          }
          if (config.options.port !== void 0) {
            if (typeof config.options.port !== "number") {
              throw new TypeError('The "config.options.port" property must be of type number.');
            }
            if (config.options.port <= 0 || config.options.port >= 65536) {
              throw new RangeError('The "config.options.port" property must be > 0 and < 65536');
            }
            this.config.options.port = config.options.port;
            this.config.options.instanceName = void 0;
          }
          if (config.options.readOnlyIntent !== void 0) {
            if (typeof config.options.readOnlyIntent !== "boolean") {
              throw new TypeError('The "config.options.readOnlyIntent" property must be of type boolean.');
            }
            this.config.options.readOnlyIntent = config.options.readOnlyIntent;
          }
          if (config.options.requestTimeout !== void 0) {
            if (typeof config.options.requestTimeout !== "number") {
              throw new TypeError('The "config.options.requestTimeout" property must be of type number.');
            }
            this.config.options.requestTimeout = config.options.requestTimeout;
          }
          if (config.options.maxRetriesOnTransientErrors !== void 0) {
            if (typeof config.options.maxRetriesOnTransientErrors !== "number") {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be of type number.');
            }
            if (config.options.maxRetriesOnTransientErrors < 0) {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be equal or greater than 0.');
            }
            this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;
          }
          if (config.options.connectionRetryInterval !== void 0) {
            if (typeof config.options.connectionRetryInterval !== "number") {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be of type number.');
            }
            if (config.options.connectionRetryInterval <= 0) {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be greater than 0.');
            }
            this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;
          }
          if (config.options.rowCollectionOnDone !== void 0) {
            if (typeof config.options.rowCollectionOnDone !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnDone" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;
          }
          if (config.options.rowCollectionOnRequestCompletion !== void 0) {
            if (typeof config.options.rowCollectionOnRequestCompletion !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnRequestCompletion" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;
          }
          if (config.options.tdsVersion !== void 0) {
            if (typeof config.options.tdsVersion !== "string") {
              throw new TypeError('The "config.options.tdsVersion" property must be of type string.');
            }
            this.config.options.tdsVersion = config.options.tdsVersion;
          }
          if (config.options.textsize !== void 0) {
            if (typeof config.options.textsize !== "number" && config.options.textsize !== null) {
              throw new TypeError('The "config.options.textsize" property must be of type number or null.');
            }
            if (config.options.textsize > 2147483647) {
              throw new TypeError(`The "config.options.textsize" can't be greater than 2147483647.`);
            } else if (config.options.textsize < -1) {
              throw new TypeError(`The "config.options.textsize" can't be smaller than -1.`);
            }
            this.config.options.textsize = config.options.textsize | 0;
          }
          if (config.options.trustServerCertificate !== void 0) {
            if (typeof config.options.trustServerCertificate !== "boolean") {
              throw new TypeError('The "config.options.trustServerCertificate" property must be of type boolean.');
            }
            this.config.options.trustServerCertificate = config.options.trustServerCertificate;
          }
          if (config.options.serverName !== void 0) {
            if (typeof config.options.serverName !== "string") {
              throw new TypeError('The "config.options.serverName" property must be of type string.');
            }
            this.config.options.serverName = config.options.serverName;
          }
          if (config.options.useColumnNames !== void 0) {
            if (typeof config.options.useColumnNames !== "boolean") {
              throw new TypeError('The "config.options.useColumnNames" property must be of type boolean.');
            }
            this.config.options.useColumnNames = config.options.useColumnNames;
          }
          if (config.options.useUTC !== void 0) {
            if (typeof config.options.useUTC !== "boolean") {
              throw new TypeError('The "config.options.useUTC" property must be of type boolean.');
            }
            this.config.options.useUTC = config.options.useUTC;
          }
          if (config.options.workstationId !== void 0) {
            if (typeof config.options.workstationId !== "string") {
              throw new TypeError('The "config.options.workstationId" property must be of type string.');
            }
            this.config.options.workstationId = config.options.workstationId;
          }
          if (config.options.lowerCaseGuids !== void 0) {
            if (typeof config.options.lowerCaseGuids !== "boolean") {
              throw new TypeError('The "config.options.lowerCaseGuids" property must be of type boolean.');
            }
            this.config.options.lowerCaseGuids = config.options.lowerCaseGuids;
          }
        }
        this.secureContextOptions = this.config.options.cryptoCredentialsDetails;
        if (this.secureContextOptions.secureOptions === void 0) {
          this.secureContextOptions = Object.create(this.secureContextOptions, {
            secureOptions: {
              value: _constants.default.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
            }
          });
        }
        this.debug = this.createDebug();
        this.inTransaction = false;
        this.transactionDescriptors = [Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])];
        this.transactionDepth = 0;
        this.isSqlBatch = false;
        this.closed = false;
        this.messageBuffer = Buffer.alloc(0);
        this.curTransientRetryCount = 0;
        this.transientErrorLookup = new _transientErrorLookup.TransientErrorLookup();
        this.state = this.STATE.INITIALIZED;
        this._cancelAfterRequestSent = () => {
          this.messageIo.sendMessage(_packet.TYPE.ATTENTION);
          this.createCancelTimer();
        };
      }
      connect(connectListener) {
        if (this.state !== this.STATE.INITIALIZED) {
          throw new _errors.ConnectionError("`.connect` can not be called on a Connection in `" + this.state.name + "` state.");
        }
        if (connectListener) {
          const onConnect = (err) => {
            this.removeListener("error", onError);
            connectListener(err);
          };
          const onError = (err) => {
            this.removeListener("connect", onConnect);
            connectListener(err);
          };
          this.once("connect", onConnect);
          this.once("error", onError);
        }
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * The server has reported that the charset has changed.
       */
      /**
       * The attempt to connect and validate has completed.
       */
      /**
       * The server has reported that the active database has changed.
       * This may be as a result of a successful login, or a `use` statement.
       */
      /**
       * A debug message is available. It may be logged or ignored.
       */
      /**
       * Internal error occurs.
       */
      /**
       * The server has issued an error message.
       */
      /**
       * The connection has ended.
       *
       * This may be as a result of the client calling [[close]], the server
       * closing the connection, or a network error.
       */
      /**
       * The server has issued an information message.
       */
      /**
       * The server has reported that the language has changed.
       */
      /**
       * The connection was reset.
       */
      /**
       * A secure connection has been established.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * Closes the connection to the database.
       *
       * The [[Event_end]] will be emitted once the connection has been closed.
       */
      close() {
        this.transitionTo(this.STATE.FINAL);
      }
      /**
       * @private
       */
      initialiseConnection() {
        const signal = this.createConnectTimer();
        if (this.config.options.port) {
          return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
        } else {
          return (0, _instanceLookup.instanceLookup)({
            server: this.config.server,
            instanceName: this.config.options.instanceName,
            timeout: this.config.options.connectTimeout,
            signal
          }).then((port) => {
            process.nextTick(() => {
              this.connectOnPort(port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
            });
          }, (err) => {
            this.clearConnectTimer();
            if (signal.aborted) {
              return;
            }
            process.nextTick(() => {
              this.emit("connect", new _errors.ConnectionError(err.message, "EINSTLOOKUP", {
                cause: err
              }));
            });
          });
        }
      }
      /**
       * @private
       */
      cleanupConnection(cleanupType) {
        if (!this.closed) {
          this.clearConnectTimer();
          this.clearRequestTimer();
          this.clearRetryTimer();
          this.closeConnection();
          if (cleanupType === CLEANUP_TYPE.REDIRECT) {
            this.emit("rerouting");
          } else if (cleanupType !== CLEANUP_TYPE.RETRY) {
            process.nextTick(() => {
              this.emit("end");
            });
          }
          const request = this.request;
          if (request) {
            const err = new _errors.RequestError("Connection closed before request completed.", "ECLOSE");
            request.callback(err);
            this.request = void 0;
          }
          this.closed = true;
          this.loginError = void 0;
        }
      }
      /**
       * @private
       */
      createDebug() {
        const debug = new _debug.default(this.config.options.debug);
        debug.on("debug", (message) => {
          this.emit("debug", message);
        });
        return debug;
      }
      /**
       * @private
       */
      createTokenStreamParser(message, handler) {
        return new _tokenStreamParser.Parser(message, this.debug, handler, this.config.options);
      }
      socketHandlingForSendPreLogin(socket) {
        socket.on("error", (error) => {
          this.socketError(error);
        });
        socket.on("close", () => {
          this.socketClose();
        });
        socket.on("end", () => {
          this.socketEnd();
        });
        socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);
        this.messageIo = new _messageIo.default(socket, this.config.options.packetSize, this.debug);
        this.messageIo.on("secure", (cleartext) => {
          this.emit("secure", cleartext);
        });
        this.socket = socket;
        this.closed = false;
        this.debug.log("connected to " + this.config.server + ":" + this.config.options.port);
        this.sendPreLogin();
        this.transitionTo(this.STATE.SENT_PRELOGIN);
      }
      wrapWithTls(socket, signal) {
        signal.throwIfAborted();
        return new Promise((resolve, reject) => {
          const secureContext = tls.createSecureContext(this.secureContextOptions);
          const serverName = !net.isIP(this.config.server) ? this.config.server : "";
          const encryptOptions = {
            host: this.config.server,
            socket,
            ALPNProtocols: ["tds/8.0"],
            secureContext,
            servername: this.config.options.serverName ? this.config.options.serverName : serverName
          };
          const encryptsocket = tls.connect(encryptOptions);
          const onAbort = () => {
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(signal.reason);
          };
          const onError = (err) => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(err);
          };
          const onConnect = () => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            resolve(encryptsocket);
          };
          signal.addEventListener("abort", onAbort, {
            once: true
          });
          encryptsocket.on("error", onError);
          encryptsocket.on("secureConnect", onConnect);
        });
      }
      connectOnPort(port, multiSubnetFailover, signal, customConnector) {
        const connectOpts = {
          host: this.routingData ? this.routingData.server : this.config.server,
          port: this.routingData ? this.routingData.port : port,
          localAddress: this.config.options.localAddress
        };
        const connect = customConnector || (multiSubnetFailover ? _connector.connectInParallel : _connector.connectInSequence);
        (async () => {
          let socket = await connect(connectOpts, _dns.default.lookup, signal);
          if (this.config.options.encrypt === "strict") {
            try {
              socket = await this.wrapWithTls(socket, signal);
            } catch (err) {
              socket.end();
              throw err;
            }
          }
          this.socketHandlingForSendPreLogin(socket);
        })().catch((err) => {
          this.clearConnectTimer();
          if (signal.aborted) {
            return;
          }
          process.nextTick(() => {
            this.socketError(err);
          });
        });
      }
      /**
       * @private
       */
      closeConnection() {
        if (this.socket) {
          this.socket.destroy();
        }
      }
      /**
       * @private
       */
      createConnectTimer() {
        const controller = new AbortController();
        this.connectTimer = setTimeout(() => {
          controller.abort();
          this.connectTimeout();
        }, this.config.options.connectTimeout);
        return controller.signal;
      }
      /**
       * @private
       */
      createCancelTimer() {
        this.clearCancelTimer();
        const timeout = this.config.options.cancelTimeout;
        if (timeout > 0) {
          this.cancelTimer = setTimeout(() => {
            this.cancelTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRequestTimer() {
        this.clearRequestTimer();
        const request = this.request;
        const timeout = request.timeout !== void 0 ? request.timeout : this.config.options.requestTimeout;
        if (timeout) {
          this.requestTimer = setTimeout(() => {
            this.requestTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRetryTimer() {
        this.clearRetryTimer();
        this.retryTimer = setTimeout(() => {
          this.retryTimeout();
        }, this.config.options.connectionRetryInterval);
      }
      /**
       * @private
       */
      connectTimeout() {
        const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
        const server = this.routingData ? this.routingData.server : this.config.server;
        const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
        const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
        const message = `Failed to connect to ${server}${port}${routingMessage} in ${this.config.options.connectTimeout}ms`;
        this.debug.log(message);
        this.emit("connect", new _errors.ConnectionError(message, "ETIMEOUT"));
        this.connectTimer = void 0;
        this.dispatchEvent("connectTimeout");
      }
      /**
       * @private
       */
      cancelTimeout() {
        const message = `Failed to cancel request in ${this.config.options.cancelTimeout}ms`;
        this.debug.log(message);
        this.dispatchEvent("socketError", new _errors.ConnectionError(message, "ETIMEOUT"));
      }
      /**
       * @private
       */
      requestTimeout() {
        this.requestTimer = void 0;
        const request = this.request;
        request.cancel();
        const timeout = request.timeout !== void 0 ? request.timeout : this.config.options.requestTimeout;
        const message = "Timeout: Request failed to complete in " + timeout + "ms";
        request.error = new _errors.RequestError(message, "ETIMEOUT");
      }
      /**
       * @private
       */
      retryTimeout() {
        this.retryTimer = void 0;
        this.emit("retry");
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * @private
       */
      clearConnectTimer() {
        if (this.connectTimer) {
          clearTimeout(this.connectTimer);
          this.connectTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearCancelTimer() {
        if (this.cancelTimer) {
          clearTimeout(this.cancelTimer);
          this.cancelTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRequestTimer() {
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
          this.requestTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRetryTimer() {
        if (this.retryTimer) {
          clearTimeout(this.retryTimer);
          this.retryTimer = void 0;
        }
      }
      /**
       * @private
       */
      transitionTo(newState) {
        if (this.state === newState) {
          this.debug.log("State is already " + newState.name);
          return;
        }
        if (this.state && this.state.exit) {
          this.state.exit.call(this, newState);
        }
        this.debug.log("State change: " + (this.state ? this.state.name : "undefined") + " -> " + newState.name);
        this.state = newState;
        if (this.state.enter) {
          this.state.enter.apply(this);
        }
      }
      /**
       * @private
       */
      getEventHandler(eventName) {
        const handler = this.state.events[eventName];
        if (!handler) {
          throw new Error(`No event '${eventName}' in state '${this.state.name}'`);
        }
        return handler;
      }
      /**
       * @private
       */
      dispatchEvent(eventName, ...args) {
        const handler = this.state.events[eventName];
        if (handler) {
          handler.apply(this, args);
        } else {
          this.emit("error", new Error(`No event '${eventName}' in state '${this.state.name}'`));
          this.close();
        }
      }
      /**
       * @private
       */
      socketError(error) {
        if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {
          const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
          const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
          const message = `Failed to connect to ${server}${port}${routingMessage} - ${error.message}`;
          this.debug.log(message);
          this.emit("connect", new _errors.ConnectionError(message, "ESOCKET", {
            cause: error
          }));
        } else {
          const message = `Connection lost - ${error.message}`;
          this.debug.log(message);
          this.emit("error", new _errors.ConnectionError(message, "ESOCKET", {
            cause: error
          }));
        }
        this.dispatchEvent("socketError", error);
      }
      /**
       * @private
       */
      socketEnd() {
        this.debug.log("socket ended");
        if (this.state !== this.STATE.FINAL) {
          const error = new Error("socket hang up");
          error.code = "ECONNRESET";
          this.socketError(error);
        }
      }
      /**
       * @private
       */
      socketClose() {
        this.debug.log("connection to " + this.config.server + ":" + this.config.options.port + " closed");
        if (this.state === this.STATE.REROUTING) {
          this.debug.log("Rerouting to " + this.routingData.server + ":" + this.routingData.port);
          this.dispatchEvent("reconnect");
        } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? this.routingData.port : this.config.options.port;
          this.debug.log("Retry after transient failure connecting to " + server + ":" + port);
          this.dispatchEvent("retry");
        } else {
          this.transitionTo(this.STATE.FINAL);
        }
      }
      /**
       * @private
       */
      sendPreLogin() {
        const [, major, minor, build] = /^(\d+)\.(\d+)\.(\d+)/.exec(_package.version) ?? ["0.0.0", "0", "0", "0"];
        const payload = new _preloginPayload.default({
          // If encrypt setting is set to 'strict', then we should have already done the encryption before calling
          // this function. Therefore, the encrypt will be set to false here.
          // Otherwise, we will set encrypt here based on the encrypt Boolean value from the configuration.
          encrypt: typeof this.config.options.encrypt === "boolean" && this.config.options.encrypt,
          version: {
            major: Number(major),
            minor: Number(minor),
            build: Number(build),
            subbuild: 0
          }
        });
        this.messageIo.sendMessage(_packet.TYPE.PRELOGIN, payload.data);
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendLogin7Packet() {
        const payload = new _login7Payload.default({
          tdsVersion: _tdsVersions.versions[this.config.options.tdsVersion],
          packetSize: this.config.options.packetSize,
          clientProgVer: 0,
          clientPid: process.pid,
          connectionId: 0,
          clientTimeZone: (/* @__PURE__ */ new Date()).getTimezoneOffset(),
          clientLcid: 1033
        });
        const {
          authentication: authentication2
        } = this.config;
        switch (authentication2.type) {
          case "azure-active-directory-password":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "default"
            };
            break;
          case "azure-active-directory-access-token":
            payload.fedAuth = {
              type: "SECURITYTOKEN",
              echo: this.fedAuthRequired,
              fedAuthToken: authentication2.options.token
            };
            break;
          case "token-credential":
          case "azure-active-directory-msi-vm":
          case "azure-active-directory-default":
          case "azure-active-directory-msi-app-service":
          case "azure-active-directory-service-principal-secret":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "integrated"
            };
            break;
          case "ntlm":
            payload.sspi = (0, _ntlm.createNTLMRequest)({
              domain: authentication2.options.domain
            });
            break;
          default:
            payload.userName = authentication2.options.userName;
            payload.password = authentication2.options.password;
        }
        payload.hostname = this.config.options.workstationId || _os.default.hostname();
        payload.serverName = this.routingData ? this.routingData.server : this.config.server;
        payload.appName = this.config.options.appName || "Tedious";
        payload.libraryName = _library.name;
        payload.language = this.config.options.language;
        payload.database = this.config.options.database;
        payload.clientId = Buffer.from([1, 2, 3, 4, 5, 6]);
        payload.readOnlyIntent = this.config.options.readOnlyIntent;
        payload.initDbFatal = !this.config.options.fallbackToDefaultDb;
        this.routingData = void 0;
        this.messageIo.sendMessage(_packet.TYPE.LOGIN7, payload.toBuffer());
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendFedAuthTokenMessage(token) {
        const accessTokenLen = Buffer.byteLength(token, "ucs2");
        const data = Buffer.alloc(8 + accessTokenLen);
        let offset = 0;
        offset = data.writeUInt32LE(accessTokenLen + 4, offset);
        offset = data.writeUInt32LE(accessTokenLen, offset);
        data.write(token, offset, "ucs2");
        this.messageIo.sendMessage(_packet.TYPE.FEDAUTH_TOKEN, data);
        this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
      }
      /**
       * @private
       */
      sendInitialSql() {
        const payload = new _sqlbatchPayload.default(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);
        const message = new _message.default({
          type: _packet.TYPE.SQL_BATCH
        });
        this.messageIo.outgoingMessageStream.write(message);
        _stream.Readable.from(payload).pipe(message);
      }
      /**
       * @private
       */
      getInitialSql() {
        const options = [];
        if (this.config.options.enableAnsiNull === true) {
          options.push("set ansi_nulls on");
        } else if (this.config.options.enableAnsiNull === false) {
          options.push("set ansi_nulls off");
        }
        if (this.config.options.enableAnsiNullDefault === true) {
          options.push("set ansi_null_dflt_on on");
        } else if (this.config.options.enableAnsiNullDefault === false) {
          options.push("set ansi_null_dflt_on off");
        }
        if (this.config.options.enableAnsiPadding === true) {
          options.push("set ansi_padding on");
        } else if (this.config.options.enableAnsiPadding === false) {
          options.push("set ansi_padding off");
        }
        if (this.config.options.enableAnsiWarnings === true) {
          options.push("set ansi_warnings on");
        } else if (this.config.options.enableAnsiWarnings === false) {
          options.push("set ansi_warnings off");
        }
        if (this.config.options.enableArithAbort === true) {
          options.push("set arithabort on");
        } else if (this.config.options.enableArithAbort === false) {
          options.push("set arithabort off");
        }
        if (this.config.options.enableConcatNullYieldsNull === true) {
          options.push("set concat_null_yields_null on");
        } else if (this.config.options.enableConcatNullYieldsNull === false) {
          options.push("set concat_null_yields_null off");
        }
        if (this.config.options.enableCursorCloseOnCommit === true) {
          options.push("set cursor_close_on_commit on");
        } else if (this.config.options.enableCursorCloseOnCommit === false) {
          options.push("set cursor_close_on_commit off");
        }
        if (this.config.options.datefirst !== null) {
          options.push(`set datefirst ${this.config.options.datefirst}`);
        }
        if (this.config.options.dateFormat !== null) {
          options.push(`set dateformat ${this.config.options.dateFormat}`);
        }
        if (this.config.options.enableImplicitTransactions === true) {
          options.push("set implicit_transactions on");
        } else if (this.config.options.enableImplicitTransactions === false) {
          options.push("set implicit_transactions off");
        }
        if (this.config.options.language !== null) {
          options.push(`set language ${this.config.options.language}`);
        }
        if (this.config.options.enableNumericRoundabort === true) {
          options.push("set numeric_roundabort on");
        } else if (this.config.options.enableNumericRoundabort === false) {
          options.push("set numeric_roundabort off");
        }
        if (this.config.options.enableQuotedIdentifier === true) {
          options.push("set quoted_identifier on");
        } else if (this.config.options.enableQuotedIdentifier === false) {
          options.push("set quoted_identifier off");
        }
        if (this.config.options.textsize !== null) {
          options.push(`set textsize ${this.config.options.textsize}`);
        }
        if (this.config.options.connectionIsolationLevel !== null) {
          options.push(`set transaction isolation level ${this.getIsolationLevelText(this.config.options.connectionIsolationLevel)}`);
        }
        if (this.config.options.abortTransactionOnError === true) {
          options.push("set xact_abort on");
        } else if (this.config.options.abortTransactionOnError === false) {
          options.push("set xact_abort off");
        }
        return options.join("\n");
      }
      /**
       * @private
       */
      processedInitialSql() {
        this.clearConnectTimer();
        this.emit("connect");
      }
      /**
       * Execute the SQL batch represented by [[Request]].
       * There is no param support, and unlike [[Request.execSql]],
       * it is not likely that SQL Server will reuse the execution plan it generates for the SQL.
       *
       * In almost all cases, [[Request.execSql]] will be a better choice.
       *
       * @param request A [[Request]] object representing the request.
       */
      execSqlBatch(request) {
        this.makeRequest(request, _packet.TYPE.SQL_BATCH, new _sqlbatchPayload.default(request.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));
      }
      /**
       *  Execute the SQL represented by [[Request]].
       *
       * As `sp_executesql` is used to execute the SQL, if the same SQL is executed multiples times
       * using this function, the SQL Server query optimizer is likely to reuse the execution plan it generates
       * for the first execution. This may also result in SQL server treating the request like a stored procedure
       * which can result in the [[Event_doneInProc]] or [[Event_doneProc]] events being emitted instead of the
       * [[Event_done]] event you might expect. Using [[execSqlBatch]] will prevent this from occurring but may have a negative performance impact.
       *
       * Beware of the way that scoping rules apply, and how they may [affect local temp tables](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)
       * If you're running in to scoping issues, then [[execSqlBatch]] may be a better choice.
       * See also [issue #24](https://github.com/pekim/tedious/issues/24)
       *
       * @param request A [[Request]] object representing the request.
       */
      execSql(request) {
        try {
          request.validateParameters(this.databaseCollation);
        } catch (error) {
          request.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request.callback(error);
          });
          return;
        }
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "statement",
          value: request.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        if (request.parameters.length) {
          parameters.push({
            type: _dataType.TYPES.NVarChar,
            name: "params",
            value: request.makeParamsParameter(request.parameters),
            output: false,
            length: void 0,
            precision: void 0,
            scale: void 0
          });
          parameters.push(...request.parameters);
        }
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_ExecuteSql, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Creates a new BulkLoad instance.
       *
       * @param table The name of the table to bulk-insert into.
       * @param options A set of bulk load options.
       */
      newBulkLoad(table, callbackOrOptions, callback) {
        let options;
        if (callback === void 0) {
          callback = callbackOrOptions;
          options = {};
        } else {
          options = callbackOrOptions;
        }
        if (typeof options !== "object") {
          throw new TypeError('"options" argument must be an object');
        }
        return new _bulkLoad.default(table, this.databaseCollation, this.config.options, options, callback);
      }
      /**
       * Execute a [[BulkLoad]].
       *
       * ```js
       * // We want to perform a bulk load into a table with the following format:
       * // CREATE TABLE employees (first_name nvarchar(255), last_name nvarchar(255), day_of_birth date);
       *
       * const bulkLoad = connection.newBulkLoad('employees', (err, rowCount) => {
       *   // ...
       * });
       *
       * // First, we need to specify the columns that we want to write to,
       * // and their definitions. These definitions must match the actual table,
       * // otherwise the bulk load will fail.
       * bulkLoad.addColumn('first_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('last_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('date_of_birth', TYPES.Date, { nullable: false });
       *
       * // Execute a bulk load with a predefined list of rows.
       * //
       * // Note that these rows are held in memory until the
       * // bulk load was performed, so if you need to write a large
       * // number of rows (e.g. by reading from a CSV file),
       * // passing an `AsyncIterable` is advisable to keep memory usage low.
       * connection.execBulkLoad(bulkLoad, [
       *   { 'first_name': 'Steve', 'last_name': 'Jobs', 'day_of_birth': new Date('02-24-1955') },
       *   { 'first_name': 'Bill', 'last_name': 'Gates', 'day_of_birth': new Date('10-28-1955') }
       * ]);
       * ```
       *
       * @param bulkLoad A previously created [[BulkLoad]].
       * @param rows A [[Iterable]] or [[AsyncIterable]] that contains the rows that should be bulk loaded.
       */
      execBulkLoad(bulkLoad, rows) {
        bulkLoad.executionStarted = true;
        if (rows) {
          if (bulkLoad.streamingMode) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that was put in streaming mode.");
          }
          if (bulkLoad.firstRowWritten) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that already has rows written to it.");
          }
          const rowStream = _stream.Readable.from(rows);
          rowStream.on("error", (err) => {
            bulkLoad.rowToPacketTransform.destroy(err);
          });
          bulkLoad.rowToPacketTransform.on("error", (err) => {
            rowStream.destroy(err);
          });
          rowStream.pipe(bulkLoad.rowToPacketTransform);
        } else if (!bulkLoad.streamingMode) {
          bulkLoad.rowToPacketTransform.end();
        }
        const onCancel = () => {
          request.cancel();
        };
        const payload = new _bulkLoadPayload.BulkLoadPayload(bulkLoad);
        const request = new _request.default(bulkLoad.getBulkInsertSql(), (error) => {
          bulkLoad.removeListener("cancel", onCancel);
          if (error) {
            if (error.code === "UNKNOWN") {
              error.message += " This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.";
            }
            bulkLoad.error = error;
            bulkLoad.callback(error);
            return;
          }
          this.makeRequest(bulkLoad, _packet.TYPE.BULK_LOAD, payload);
        });
        bulkLoad.once("cancel", onCancel);
        this.execSqlBatch(request);
      }
      /**
       * Prepare the SQL represented by the request.
       *
       * The request can then be used in subsequent calls to
       * [[execute]] and [[unprepare]]
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type. Parameter values are ignored.
       */
      prepare(request) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          value: void 0,
          output: true,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "params",
          value: request.parameters.length ? request.makeParamsParameter(request.parameters) : null,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "stmt",
          value: request.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        request.preparing = true;
        request.on("returnValue", (name, value) => {
          if (name === "handle") {
            request.handle = value;
          } else {
            request.error = new _errors.RequestError(`Tedious > Unexpected output parameter ${name} from sp_prepare`);
          }
        });
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Prepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Release the SQL Server resources associated with a previously prepared request.
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type.
       *   Parameter values are ignored.
       */
      unprepare(request) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          // TODO: Abort if `request.handle` is not set
          value: request.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Unprepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Execute previously prepared SQL, using the supplied parameters.
       *
       * @param request A previously prepared [[Request]].
       * @param parameters  An object whose names correspond to the names of
       *   parameters that were added to the [[Request]] before it was prepared.
       *   The object's values are passed as the parameters' values when the
       *   request is executed.
       */
      execute(request, parameters) {
        const executeParameters = [];
        executeParameters.push({
          type: _dataType.TYPES.Int,
          name: "",
          // TODO: Abort if `request.handle` is not set
          value: request.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        try {
          for (let i = 0, len = request.parameters.length; i < len; i++) {
            const parameter = request.parameters[i];
            executeParameters.push({
              ...parameter,
              value: parameter.type.validate(parameters ? parameters[parameter.name] : null, this.databaseCollation)
            });
          }
        } catch (error) {
          request.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request.callback(error);
          });
          return;
        }
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Execute, executeParameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Call a stored procedure represented by [[Request]].
       *
       * @param request A [[Request]] object representing the request.
       */
      callProcedure(request) {
        try {
          request.validateParameters(this.databaseCollation);
        } catch (error) {
          request.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request.callback(error);
          });
          return;
        }
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request.sqlTextOrProcedure, request.parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Start a transaction.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`
       *   is present.
       * @param isolationLevel The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      beginTransaction(callback, name = "", isolationLevel = this.config.options.isolationLevel) {
        (0, _transaction.assertValidIsolationLevel)(isolationLevel, "isolationLevel");
        const transaction = new _transaction.Transaction(name, isolationLevel);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SET TRANSACTION ISOLATION LEVEL " + transaction.isolationLevelToTSQL() + ";BEGIN TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            if (this.transactionDepth === 1) {
              this.inTransaction = true;
            }
            callback(err);
          }));
        }
        const request = new _request.default(void 0, (err) => {
          return callback(err, this.currentTransactionDescriptor());
        });
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Commit a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`is present.
       */
      commitTransaction(callback, name = "") {
        const transaction = new _transaction.Transaction(name);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("COMMIT TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request = new _request.default(void 0, callback);
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Rollback a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      rollbackTransaction(callback, name = "") {
        const transaction = new _transaction.Transaction(name);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("ROLLBACK TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request = new _request.default(void 0, callback);
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Set a savepoint within a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.\
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      saveTransaction(callback, name) {
        const transaction = new _transaction.Transaction(name);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SAVE TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            callback(err);
          }));
        }
        const request = new _request.default(void 0, callback);
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));
      }
      /**
       * Run the given callback after starting a transaction, and commit or
       * rollback the transaction afterwards.
       *
       * This is a helper that employs [[beginTransaction]], [[commitTransaction]],
       * [[rollbackTransaction]], and [[saveTransaction]] to greatly simplify the
       * use of database transactions and automatically handle transaction nesting.
       *
       * @param cb
       * @param isolationLevel
       *   The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      transaction(cb, isolationLevel) {
        if (typeof cb !== "function") {
          throw new TypeError("`cb` must be a function");
        }
        const useSavepoint = this.inTransaction;
        const name = "_tedious_" + _crypto.default.randomBytes(10).toString("hex");
        const txDone = (err, done, ...args) => {
          if (err) {
            if (this.inTransaction && this.state === this.STATE.LOGGED_IN) {
              this.rollbackTransaction((txErr) => {
                done(txErr || err, ...args);
              }, name);
            } else {
              done(err, ...args);
            }
          } else if (useSavepoint) {
            if (this.config.options.tdsVersion < "7_2") {
              this.transactionDepth--;
            }
            done(null, ...args);
          } else {
            this.commitTransaction((txErr) => {
              done(txErr, ...args);
            }, name);
          }
        };
        if (useSavepoint) {
          return this.saveTransaction((err) => {
            if (err) {
              return cb(err);
            }
            if (isolationLevel) {
              return this.execSqlBatch(new _request.default("SET transaction isolation level " + this.getIsolationLevelText(isolationLevel), (err2) => {
                return cb(err2, txDone);
              }));
            } else {
              return cb(null, txDone);
            }
          }, name);
        } else {
          return this.beginTransaction((err) => {
            if (err) {
              return cb(err);
            }
            return cb(null, txDone);
          }, name, isolationLevel);
        }
      }
      /**
       * @private
       */
      makeRequest(request, packetType, payload) {
        if (this.state !== this.STATE.LOGGED_IN) {
          const message = "Requests can only be made in the " + this.STATE.LOGGED_IN.name + " state, not the " + this.state.name + " state";
          this.debug.log(message);
          request.callback(new _errors.RequestError(message, "EINVALIDSTATE"));
        } else if (request.canceled) {
          process.nextTick(() => {
            request.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
          });
        } else {
          if (packetType === _packet.TYPE.SQL_BATCH) {
            this.isSqlBatch = true;
          } else {
            this.isSqlBatch = false;
          }
          this.request = request;
          request.connection = this;
          request.rowCount = 0;
          request.rows = [];
          request.rst = [];
          const onCancel = () => {
            payloadStream.unpipe(message);
            payloadStream.destroy(new _errors.RequestError("Canceled.", "ECANCEL"));
            message.ignore = true;
            message.end();
            if (request instanceof _request.default && request.paused) {
              request.resume();
            }
          };
          request.once("cancel", onCancel);
          this.createRequestTimer();
          const message = new _message.default({
            type: packetType,
            resetConnection: this.resetConnectionOnNextRequest
          });
          this.messageIo.outgoingMessageStream.write(message);
          this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);
          message.once("finish", () => {
            request.removeListener("cancel", onCancel);
            request.once("cancel", this._cancelAfterRequestSent);
            this.resetConnectionOnNextRequest = false;
            this.debug.payload(function() {
              return payload.toString("  ");
            });
          });
          const payloadStream = _stream.Readable.from(payload);
          payloadStream.once("error", (error) => {
            payloadStream.unpipe(message);
            request.error ??= error;
            message.ignore = true;
            message.end();
          });
          payloadStream.pipe(message);
        }
      }
      /**
       * Cancel currently executed request.
       */
      cancel() {
        if (!this.request) {
          return false;
        }
        if (this.request.canceled) {
          return false;
        }
        this.request.cancel();
        return true;
      }
      /**
       * Reset the connection to its initial state.
       * Can be useful for connection pool implementations.
       *
       * @param callback
       */
      reset(callback) {
        const request = new _request.default(this.getInitialSql(), (err) => {
          if (this.config.options.tdsVersion < "7_2") {
            this.inTransaction = false;
          }
          callback(err);
        });
        this.resetConnectionOnNextRequest = true;
        this.execSqlBatch(request);
      }
      /**
       * @private
       */
      currentTransactionDescriptor() {
        return this.transactionDescriptors[this.transactionDescriptors.length - 1];
      }
      /**
       * @private
       */
      getIsolationLevelText(isolationLevel) {
        switch (isolationLevel) {
          case _transaction.ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "read uncommitted";
          case _transaction.ISOLATION_LEVEL.REPEATABLE_READ:
            return "repeatable read";
          case _transaction.ISOLATION_LEVEL.SERIALIZABLE:
            return "serializable";
          case _transaction.ISOLATION_LEVEL.SNAPSHOT:
            return "snapshot";
          default:
            return "read committed";
        }
      }
    };
    function isTransientError(error) {
      if (error instanceof AggregateError) {
        error = error.errors[0];
      }
      return error instanceof _errors.ConnectionError && !!error.isTransient;
    }
    var _default = exports2.default = Connection;
    module2.exports = Connection;
    Connection.prototype.STATE = {
      INITIALIZED: {
        name: "Initialized",
        events: {}
      },
      CONNECTING: {
        name: "Connecting",
        enter: function() {
          this.initialiseConnection();
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_PRELOGIN: {
        name: "SentPrelogin",
        enter: function() {
          (async () => {
            let messageBuffer = Buffer.alloc(0);
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            for await (const data of message) {
              messageBuffer = Buffer.concat([messageBuffer, data]);
            }
            const preloginPayload = new _preloginPayload.default(messageBuffer);
            this.debug.payload(function() {
              return preloginPayload.toString("  ");
            });
            if (preloginPayload.fedAuthRequired === 1) {
              this.fedAuthRequired = true;
            }
            if ("strict" !== this.config.options.encrypt && (preloginPayload.encryptionString === "ON" || preloginPayload.encryptionString === "REQ")) {
              if (!this.config.options.encrypt) {
                this.emit("connect", new _errors.ConnectionError("Server requires encryption, set 'encrypt' config option to true.", "EENCRYPT"));
                return this.close();
              }
              try {
                this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);
                await this.messageIo.startTls(this.secureContextOptions, this.config.options.serverName ? this.config.options.serverName : this.routingData?.server ?? this.config.server, this.config.options.trustServerCertificate);
              } catch (err) {
                return this.socketError(err);
              }
            }
            this.sendLogin7Packet();
            const {
              authentication: authentication2
            } = this.config;
            switch (authentication2.type) {
              case "token-credential":
              case "azure-active-directory-password":
              case "azure-active-directory-msi-vm":
              case "azure-active-directory-msi-app-service":
              case "azure-active-directory-service-principal-secret":
              case "azure-active-directory-default":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_FEDAUTH);
                break;
              case "ntlm":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);
                break;
              default:
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
                break;
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      REROUTING: {
        name: "ReRouting",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.REDIRECT);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          reconnect: function() {
            this.transitionTo(this.STATE.CONNECTING);
          }
        }
      },
      TRANSIENT_FAILURE_RETRY: {
        name: "TRANSIENT_FAILURE_RETRY",
        enter: function() {
          this.curTransientRetryCount++;
          this.cleanupConnection(CLEANUP_TYPE.RETRY);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          retry: function() {
            this.createRetryTimer();
          }
        }
      },
      SENT_TLSSSLNEGOTIATION: {
        name: "SentTLSSSLNegotiation",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_STANDARD_LOGIN: {
        name: "SentLogin7WithStandardLogin",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_NTLM: {
        name: "SentLogin7WithNTLMLogin",
        enter: function() {
          (async () => {
            while (true) {
              let message;
              try {
                message = await this.messageIo.readMessage();
              } catch (err) {
                return this.socketError(err);
              }
              const handler = new _handler.Login7TokenHandler(this);
              const tokenStreamParser = this.createTokenStreamParser(message, handler);
              await (0, _events.once)(tokenStreamParser, "end");
              if (handler.loginAckReceived) {
                if (handler.routingData) {
                  this.routingData = handler.routingData;
                  return this.transitionTo(this.STATE.REROUTING);
                } else {
                  return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
                }
              } else if (this.ntlmpacket) {
                const authentication2 = this.config.authentication;
                const payload = new _ntlmPayload.default({
                  domain: authentication2.options.domain,
                  userName: authentication2.options.userName,
                  password: authentication2.options.password,
                  ntlmpacket: this.ntlmpacket
                });
                this.messageIo.sendMessage(_packet.TYPE.NTLMAUTH_PKT, payload.data);
                this.debug.payload(function() {
                  return payload.toString("  ");
                });
                this.ntlmpacket = void 0;
              } else if (this.loginError) {
                if (isTransientError(this.loginError)) {
                  this.debug.log("Initiating retry on transient error");
                  return this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
                } else {
                  this.emit("connect", this.loginError);
                  return this.transitionTo(this.STATE.FINAL);
                }
              } else {
                this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
                return this.transitionTo(this.STATE.FINAL);
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_FEDAUTH: {
        name: "SentLogin7Withfedauth",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
              return;
            }
            const fedAuthInfoToken = handler.fedAuthInfoToken;
            if (fedAuthInfoToken && fedAuthInfoToken.stsurl && fedAuthInfoToken.spn) {
              const authentication2 = this.config.authentication;
              const tokenScope = new _url.URL("/.default", fedAuthInfoToken.spn).toString();
              let credentials;
              switch (authentication2.type) {
                case "token-credential":
                  credentials = authentication2.options.credential;
                  break;
                case "azure-active-directory-password":
                  credentials = new _identity.UsernamePasswordCredential(authentication2.options.tenantId ?? "common", authentication2.options.clientId, authentication2.options.userName, authentication2.options.password);
                  break;
                case "azure-active-directory-msi-vm":
                case "azure-active-directory-msi-app-service":
                  const msiArgs = authentication2.options.clientId ? [authentication2.options.clientId, {}] : [{}];
                  credentials = new _identity.ManagedIdentityCredential(...msiArgs);
                  break;
                case "azure-active-directory-default":
                  const args = authentication2.options.clientId ? {
                    managedIdentityClientId: authentication2.options.clientId
                  } : {};
                  credentials = new _identity.DefaultAzureCredential(args);
                  break;
                case "azure-active-directory-service-principal-secret":
                  credentials = new _identity.ClientSecretCredential(authentication2.options.tenantId, authentication2.options.clientId, authentication2.options.clientSecret);
                  break;
              }
              let tokenResponse;
              try {
                tokenResponse = await credentials.getToken(tokenScope);
              } catch (err) {
                this.loginError = new AggregateError([new _errors.ConnectionError("Security token could not be authenticated or authorized.", "EFEDAUTH"), err]);
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
                return;
              }
              if (tokenResponse === null) {
                this.loginError = new AggregateError([new _errors.ConnectionError("Security token could not be authenticated or authorized.", "EFEDAUTH")]);
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
                return;
              }
              this.sendFedAuthTokenMessage(tokenResponse.token);
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN_SENDING_INITIAL_SQL: {
        name: "LoggedInSendingInitialSql",
        enter: function() {
          (async () => {
            this.sendInitialSql();
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.InitialSqlTokenHandler(this));
            await (0, _events.once)(tokenStreamParser, "end");
            this.transitionTo(this.STATE.LOGGED_IN);
            this.processedInitialSql();
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function socketError() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN: {
        name: "LoggedIn",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_CLIENT_REQUEST: {
        name: "SentClientRequest",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            this.clearRequestTimer();
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.RequestTokenHandler(this, this.request));
            if (this.request?.canceled && this.cancelTimer) {
              return this.transitionTo(this.STATE.SENT_ATTENTION);
            }
            const onResume = () => {
              tokenStreamParser.resume();
            };
            const onPause = () => {
              tokenStreamParser.pause();
              this.request?.once("resume", onResume);
            };
            this.request?.on("pause", onPause);
            if (this.request instanceof _request.default && this.request.paused) {
              onPause();
            }
            const onCancel = () => {
              tokenStreamParser.removeListener("end", onEndOfMessage);
              if (this.request instanceof _request.default && this.request.paused) {
                this.request.resume();
              }
              this.request?.removeListener("pause", onPause);
              this.request?.removeListener("resume", onResume);
              this.transitionTo(this.STATE.SENT_ATTENTION);
            };
            const onEndOfMessage = () => {
              this.request?.removeListener("cancel", this._cancelAfterRequestSent);
              this.request?.removeListener("cancel", onCancel);
              this.request?.removeListener("pause", onPause);
              this.request?.removeListener("resume", onResume);
              this.transitionTo(this.STATE.LOGGED_IN);
              const sqlRequest = this.request;
              this.request = void 0;
              if (this.config.options.tdsVersion < "7_2" && sqlRequest.error && this.isSqlBatch) {
                this.inTransaction = false;
              }
              sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);
            };
            tokenStreamParser.once("end", onEndOfMessage);
            this.request?.once("cancel", onCancel);
          })();
        },
        exit: function(nextState) {
          this.clearRequestTimer();
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      SENT_ATTENTION: {
        name: "SentAttention",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.AttentionTokenHandler(this, this.request);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.attentionReceived) {
              this.clearCancelTimer();
              const sqlRequest = this.request;
              this.request = void 0;
              this.transitionTo(this.STATE.LOGGED_IN);
              if (sqlRequest.error && sqlRequest.error instanceof _errors.RequestError && sqlRequest.error.code === "ETIMEOUT") {
                sqlRequest.callback(sqlRequest.error);
              } else {
                sqlRequest.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      FINAL: {
        name: "Final",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.NORMAL);
        },
        events: {
          connectTimeout: function() {
          },
          message: function() {
          },
          socketError: function() {
          }
        }
      }
    };
  }
});

// node_modules/mssql/node_modules/tedious/lib/tedious.js
var require_tedious = __commonJS({
  "node_modules/mssql/node_modules/tedious/lib/tedious.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BulkLoad", {
      enumerable: true,
      get: function() {
        return _bulkLoad.default;
      }
    });
    Object.defineProperty(exports2, "Connection", {
      enumerable: true,
      get: function() {
        return _connection.default;
      }
    });
    Object.defineProperty(exports2, "ConnectionError", {
      enumerable: true,
      get: function() {
        return _errors.ConnectionError;
      }
    });
    Object.defineProperty(exports2, "ISOLATION_LEVEL", {
      enumerable: true,
      get: function() {
        return _transaction.ISOLATION_LEVEL;
      }
    });
    Object.defineProperty(exports2, "Request", {
      enumerable: true,
      get: function() {
        return _request.default;
      }
    });
    Object.defineProperty(exports2, "RequestError", {
      enumerable: true,
      get: function() {
        return _errors.RequestError;
      }
    });
    Object.defineProperty(exports2, "TDS_VERSION", {
      enumerable: true,
      get: function() {
        return _tdsVersions.versions;
      }
    });
    Object.defineProperty(exports2, "TYPES", {
      enumerable: true,
      get: function() {
        return _dataType.TYPES;
      }
    });
    exports2.connect = connect;
    exports2.library = void 0;
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _connection = _interopRequireDefault(require_connection());
    var _request = _interopRequireDefault(require_request2());
    var _library = require_library();
    var _errors = require_errors2();
    var _dataType = require_data_type();
    var _transaction = require_transaction2();
    var _tdsVersions = require_tds_versions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var library = exports2.library = {
      name: _library.name
    };
    function connect(config, connectListener) {
      const connection = new _connection.default(config);
      connection.connect(connectListener);
      return connection;
    }
  }
});

// node_modules/mssql/lib/tedious/connection-pool.js
var require_connection_pool2 = __commonJS({
  "node_modules/mssql/lib/tedious/connection-pool.js"(exports2, module2) {
    "use strict";
    var tds = require_tedious();
    var debug = require_src()("mssql:tedi");
    var BaseConnectionPool = require_connection_pool();
    var { IDS } = require_utils2();
    var shared = require_shared();
    var ConnectionError = require_connection_error();
    var ConnectionPool2 = class extends BaseConnectionPool {
      _config() {
        const cfg = {
          server: this.config.server,
          options: Object.assign({
            encrypt: typeof this.config.encrypt === "boolean" ? this.config.encrypt : true,
            trustServerCertificate: typeof this.config.trustServerCertificate === "boolean" ? this.config.trustServerCertificate : false
          }, this.config.options),
          authentication: Object.assign({
            type: this.config.domain !== void 0 ? "ntlm" : this.config.authentication_type !== void 0 ? this.config.authentication_type : "default",
            options: Object.entries({
              userName: this.config.user,
              password: this.config.password,
              domain: this.config.domain,
              clientId: this.config.clientId,
              clientSecret: this.config.clientSecret,
              tenantId: this.config.tenantId,
              token: this.config.token,
              msiEndpoint: this.config.msiEndpoint,
              msiSecret: this.config.msiSecret
            }).reduce((acc, [key, val]) => {
              if (typeof val !== "undefined") {
                return { ...acc, [key]: val };
              }
              return acc;
            }, {})
          }, this.config.authentication)
        };
        cfg.options.database = cfg.options.database || this.config.database;
        cfg.options.port = cfg.options.port || this.config.port;
        cfg.options.connectTimeout = cfg.options.connectTimeout ?? this.config.connectionTimeout ?? this.config.timeout ?? 15e3;
        cfg.options.requestTimeout = cfg.options.requestTimeout ?? this.config.requestTimeout ?? this.config.timeout ?? 15e3;
        cfg.options.tdsVersion = cfg.options.tdsVersion || "7_4";
        cfg.options.rowCollectionOnDone = cfg.options.rowCollectionOnDone || false;
        cfg.options.rowCollectionOnRequestCompletion = cfg.options.rowCollectionOnRequestCompletion || false;
        cfg.options.useColumnNames = cfg.options.useColumnNames || false;
        cfg.options.appName = cfg.options.appName || "node-mssql";
        if (cfg.options.instanceName)
          delete cfg.options.port;
        if (isNaN(cfg.options.requestTimeout))
          cfg.options.requestTimeout = 15e3;
        if (cfg.options.requestTimeout === Infinity || cfg.options.requestTimeout < 0)
          cfg.options.requestTimeout = 0;
        if (!cfg.options.debug && this.config.debug) {
          cfg.options.debug = {
            packet: true,
            token: true,
            data: true,
            payload: true
          };
        }
        return cfg;
      }
      _poolCreate() {
        return new shared.Promise((resolve, reject) => {
          const resolveOnce = (v) => {
            resolve(v);
            resolve = reject = () => {
            };
          };
          const rejectOnce = (e) => {
            reject(e);
            resolve = reject = () => {
            };
          };
          let tedious;
          try {
            tedious = new tds.Connection(this._config());
          } catch (err) {
            rejectOnce(err);
            return;
          }
          tedious.connect((err) => {
            if (err) {
              err = new ConnectionError(err);
              return rejectOnce(err);
            }
            debug("connection(%d): established", IDS.get(tedious));
            this.collation = tedious.databaseCollation;
            resolveOnce(tedious);
          });
          IDS.add(tedious, "Connection");
          debug("pool(%d): connection #%d created", IDS.get(this), IDS.get(tedious));
          debug("connection(%d): establishing", IDS.get(tedious));
          tedious.on("end", () => {
            const err = new ConnectionError("The connection ended without ever completing the connection");
            rejectOnce(err);
          });
          tedious.on("error", (err) => {
            if (err.code === "ESOCKET") {
              tedious.hasError = true;
            } else {
              this.emit("error", err);
            }
            rejectOnce(err);
          });
          if (this.config.debug) {
            tedious.on("debug", this.emit.bind(this, "debug", tedious));
          }
          if (typeof this.config.beforeConnect === "function") {
            this.config.beforeConnect(tedious);
          }
        });
      }
      _poolValidate(tedious) {
        if (tedious && !tedious.closed && !tedious.hasError) {
          return !this.config.validateConnection || new shared.Promise((resolve) => {
            const req = new tds.Request("SELECT 1;", (err) => {
              resolve(!err);
            });
            tedious.execSql(req);
          });
        }
        return false;
      }
      _poolDestroy(tedious) {
        return new shared.Promise((resolve, reject) => {
          if (!tedious) {
            resolve();
            return;
          }
          debug("connection(%d): destroying", IDS.get(tedious));
          if (tedious.closed) {
            debug("connection(%d): already closed", IDS.get(tedious));
            resolve();
          } else {
            tedious.once("end", () => {
              debug("connection(%d): destroyed", IDS.get(tedious));
              resolve();
            });
            tedious.close();
          }
        });
      }
    };
    module2.exports = ConnectionPool2;
  }
});

// node_modules/mssql/lib/tedious/transaction.js
var require_transaction3 = __commonJS({
  "node_modules/mssql/lib/tedious/transaction.js"(exports2, module2) {
    "use strict";
    var debug = require_src()("mssql:tedi");
    var BaseTransaction = require_transaction();
    var { IDS } = require_utils2();
    var TransactionError = require_transaction_error();
    var Transaction = class extends BaseTransaction {
      constructor(parent) {
        super(parent);
        this._abort = () => {
          if (!this._rollbackRequested) {
            const pc = this._acquiredConnection;
            setImmediate(this.parent.release.bind(this.parent), pc);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            this._aborted = true;
            this.emit("rollback", true);
          }
        };
      }
      _begin(isolationLevel, callback) {
        super._begin(isolationLevel, (err) => {
          if (err)
            return callback(err);
          debug("transaction(%d): begin", IDS.get(this));
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2)
              return callback(err2);
            this._acquiredConnection = connection;
            this._acquiredConnection.on("rollbackTransaction", this._abort);
            this._acquiredConfig = config;
            connection.beginTransaction((err3) => {
              if (err3)
                err3 = new TransactionError(err3);
              debug("transaction(%d): begun", IDS.get(this));
              callback(err3);
            }, this.name, this.isolationLevel);
          });
        });
      }
      _commit(callback) {
        super._commit((err) => {
          if (err)
            return callback(err);
          debug("transaction(%d): commit", IDS.get(this));
          this._acquiredConnection.commitTransaction((err2) => {
            if (err2)
              err2 = new TransactionError(err2);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this.parent.release(this._acquiredConnection);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            if (!err2)
              debug("transaction(%d): commited", IDS.get(this));
            callback(err2);
          });
        });
      }
      _rollback(callback) {
        super._rollback((err) => {
          if (err)
            return callback(err);
          debug("transaction(%d): rollback", IDS.get(this));
          this._acquiredConnection.rollbackTransaction((err2) => {
            if (err2)
              err2 = new TransactionError(err2);
            this._acquiredConnection.removeListener("rollbackTransaction", this._abort);
            this.parent.release(this._acquiredConnection);
            this._acquiredConnection = null;
            this._acquiredConfig = null;
            if (!err2)
              debug("transaction(%d): rolled back", IDS.get(this));
            callback(err2);
          });
        });
      }
    };
    module2.exports = Transaction;
  }
});

// node_modules/mssql/lib/udt.js
var require_udt2 = __commonJS({
  "node_modules/mssql/lib/udt.js"(exports2, module2) {
    "use strict";
    var Point = class {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.z = null;
        this.m = null;
      }
    };
    var parsePoints = (buffer, count, isGeometryPoint) => {
      const points = [];
      if (count < 1) {
        return points;
      }
      if (isGeometryPoint) {
        for (let i = 1; i <= count; i++) {
          const point = new Point();
          points.push(point);
          point.x = buffer.readDoubleLE(buffer.position);
          point.y = buffer.readDoubleLE(buffer.position + 8);
          buffer.position += 16;
        }
      } else {
        for (let i = 1; i <= count; i++) {
          const point = new Point();
          points.push(point);
          point.lat = buffer.readDoubleLE(buffer.position);
          point.lng = buffer.readDoubleLE(buffer.position + 8);
          point.x = point.lat;
          point.y = point.lng;
          buffer.position += 16;
        }
      }
      return points;
    };
    var parseZ = (buffer, points) => {
      if (points < 1) {
        return;
      }
      points.forEach((point) => {
        point.z = buffer.readDoubleLE(buffer.position);
        buffer.position += 8;
      });
    };
    var parseM = (buffer, points) => {
      if (points < 1) {
        return;
      }
      points.forEach((point) => {
        point.m = buffer.readDoubleLE(buffer.position);
        buffer.position += 8;
      });
    };
    var parseFigures = (buffer, count, properties) => {
      const figures = [];
      if (count < 1) {
        return figures;
      }
      if (properties.P) {
        figures.push({
          attribute: 1,
          pointOffset: 0
        });
      } else if (properties.L) {
        figures.push({
          attribute: 1,
          pointOffset: 0
        });
      } else {
        for (let i = 1; i <= count; i++) {
          figures.push({
            attribute: buffer.readUInt8(buffer.position),
            pointOffset: buffer.readInt32LE(buffer.position + 1)
          });
          buffer.position += 5;
        }
      }
      return figures;
    };
    var parseShapes = (buffer, count, properties) => {
      const shapes = [];
      if (count < 1) {
        return shapes;
      }
      if (properties.P) {
        shapes.push({
          parentOffset: -1,
          figureOffset: 0,
          type: 1
        });
      } else if (properties.L) {
        shapes.push({
          parentOffset: -1,
          figureOffset: 0,
          type: 2
        });
      } else {
        for (let i = 1; i <= count; i++) {
          shapes.push({
            parentOffset: buffer.readInt32LE(buffer.position),
            figureOffset: buffer.readInt32LE(buffer.position + 4),
            type: buffer.readUInt8(buffer.position + 8)
          });
          buffer.position += 9;
        }
      }
      return shapes;
    };
    var parseSegments = (buffer, count) => {
      const segments = [];
      if (count < 1) {
        return segments;
      }
      for (let i = 1; i <= count; i++) {
        segments.push({ type: buffer.readUInt8(buffer.position) });
        buffer.position++;
      }
      return segments;
    };
    var parseGeography = (buffer, isUsingGeometryPoints) => {
      const srid = buffer.readInt32LE(0);
      if (srid === -1) {
        return null;
      }
      const value = {
        srid,
        version: buffer.readUInt8(4)
      };
      const flags = buffer.readUInt8(5);
      buffer.position = 6;
      const properties = {
        Z: (flags & 1 << 0) > 0,
        M: (flags & 1 << 1) > 0,
        V: (flags & 1 << 2) > 0,
        P: (flags & 1 << 3) > 0,
        L: (flags & 1 << 4) > 0
      };
      if (value.version === 2) {
        properties.H = (flags & 1 << 3) > 0;
      }
      let numberOfPoints;
      if (properties.P) {
        numberOfPoints = 1;
      } else if (properties.L) {
        numberOfPoints = 2;
      } else {
        numberOfPoints = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints);
      if (properties.Z) {
        parseZ(buffer, value.points);
      }
      if (properties.M) {
        parseM(buffer, value.points);
      }
      let numberOfFigures;
      if (properties.P) {
        numberOfFigures = 1;
      } else if (properties.L) {
        numberOfFigures = 1;
      } else {
        numberOfFigures = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.figures = parseFigures(buffer, numberOfFigures, properties);
      let numberOfShapes;
      if (properties.P) {
        numberOfShapes = 1;
      } else if (properties.L) {
        numberOfShapes = 1;
      } else {
        numberOfShapes = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
      }
      value.shapes = parseShapes(buffer, numberOfShapes, properties);
      if (value.version === 2 && buffer.position < buffer.length) {
        const numberOfSegments = buffer.readUInt32LE(buffer.position);
        buffer.position += 4;
        value.segments = parseSegments(buffer, numberOfSegments);
      } else {
        value.segments = [];
      }
      return value;
    };
    module2.exports.PARSERS = {
      geography(buffer) {
        return parseGeography(
          buffer,
          /* isUsingGeometryPoints: */
          false
        );
      },
      geometry(buffer) {
        return parseGeography(
          buffer,
          /* isUsingGeometryPoints: */
          true
        );
      }
    };
  }
});

// node_modules/mssql/lib/tedious/request.js
var require_request3 = __commonJS({
  "node_modules/mssql/lib/tedious/request.js"(exports2, module2) {
    "use strict";
    var tds = require_tedious();
    var debug = require_src()("mssql:tedi");
    var BaseRequest = require_request();
    var RequestError = require_request_error();
    var { IDS, objectHasProperty } = require_utils2();
    var { TYPES, DECLARATIONS, declare, cast } = require_datatypes();
    var Table = require_table();
    var { PARSERS: UDT } = require_udt2();
    var { valueHandler } = require_shared();
    var JSON_COLUMN_ID = "JSON_F52E2B61-18A1-11d1-B105-00805F49916B";
    var XML_COLUMN_ID = "XML_F52E2B61-18A1-11d1-B105-00805F49916B";
    var N_TYPES = {
      BitN: 104,
      DateTimeN: 111,
      DecimalN: 106,
      FloatN: 109,
      IntN: 38,
      MoneyN: 110,
      NumericN: 108
    };
    var getTediousType = function(type) {
      switch (type) {
        case TYPES.VarChar:
          return tds.TYPES.VarChar;
        case TYPES.NVarChar:
          return tds.TYPES.NVarChar;
        case TYPES.Text:
          return tds.TYPES.Text;
        case TYPES.Int:
          return tds.TYPES.Int;
        case TYPES.BigInt:
          return tds.TYPES.BigInt;
        case TYPES.TinyInt:
          return tds.TYPES.TinyInt;
        case TYPES.SmallInt:
          return tds.TYPES.SmallInt;
        case TYPES.Bit:
          return tds.TYPES.Bit;
        case TYPES.Float:
          return tds.TYPES.Float;
        case TYPES.Decimal:
          return tds.TYPES.Decimal;
        case TYPES.Numeric:
          return tds.TYPES.Numeric;
        case TYPES.Real:
          return tds.TYPES.Real;
        case TYPES.Money:
          return tds.TYPES.Money;
        case TYPES.SmallMoney:
          return tds.TYPES.SmallMoney;
        case TYPES.Time:
          return tds.TYPES.Time;
        case TYPES.Date:
          return tds.TYPES.Date;
        case TYPES.DateTime:
          return tds.TYPES.DateTime;
        case TYPES.DateTime2:
          return tds.TYPES.DateTime2;
        case TYPES.DateTimeOffset:
          return tds.TYPES.DateTimeOffset;
        case TYPES.SmallDateTime:
          return tds.TYPES.SmallDateTime;
        case TYPES.UniqueIdentifier:
          return tds.TYPES.UniqueIdentifier;
        case TYPES.Xml:
          return tds.TYPES.NVarChar;
        case TYPES.Char:
          return tds.TYPES.Char;
        case TYPES.NChar:
          return tds.TYPES.NChar;
        case TYPES.NText:
          return tds.TYPES.NVarChar;
        case TYPES.Image:
          return tds.TYPES.Image;
        case TYPES.Binary:
          return tds.TYPES.Binary;
        case TYPES.VarBinary:
          return tds.TYPES.VarBinary;
        case TYPES.UDT:
        case TYPES.Geography:
        case TYPES.Geometry:
          return tds.TYPES.UDT;
        case TYPES.TVP:
          return tds.TYPES.TVP;
        case TYPES.Variant:
          return tds.TYPES.Variant;
        default:
          return type;
      }
    };
    var getMssqlType = function(type, length) {
      if (typeof type !== "object")
        return void 0;
      switch (type) {
        case tds.TYPES.Char:
          return TYPES.Char;
        case tds.TYPES.NChar:
          return TYPES.NChar;
        case tds.TYPES.VarChar:
          return TYPES.VarChar;
        case tds.TYPES.NVarChar:
          return TYPES.NVarChar;
        case tds.TYPES.Text:
          return TYPES.Text;
        case tds.TYPES.NText:
          return TYPES.NText;
        case tds.TYPES.Int:
          return TYPES.Int;
        case tds.TYPES.BigInt:
          return TYPES.BigInt;
        case tds.TYPES.TinyInt:
          return TYPES.TinyInt;
        case tds.TYPES.SmallInt:
          return TYPES.SmallInt;
        case tds.TYPES.Bit:
          return TYPES.Bit;
        case tds.TYPES.Float:
          return TYPES.Float;
        case tds.TYPES.Real:
          return TYPES.Real;
        case tds.TYPES.Money:
          return TYPES.Money;
        case tds.TYPES.SmallMoney:
          return TYPES.SmallMoney;
        case tds.TYPES.Numeric:
          return TYPES.Numeric;
        case tds.TYPES.Decimal:
          return TYPES.Decimal;
        case tds.TYPES.DateTime:
          return TYPES.DateTime;
        case tds.TYPES.Time:
          return TYPES.Time;
        case tds.TYPES.Date:
          return TYPES.Date;
        case tds.TYPES.DateTime2:
          return TYPES.DateTime2;
        case tds.TYPES.DateTimeOffset:
          return TYPES.DateTimeOffset;
        case tds.TYPES.SmallDateTime:
          return TYPES.SmallDateTime;
        case tds.TYPES.UniqueIdentifier:
          return TYPES.UniqueIdentifier;
        case tds.TYPES.Image:
          return TYPES.Image;
        case tds.TYPES.Binary:
          return TYPES.Binary;
        case tds.TYPES.VarBinary:
          return TYPES.VarBinary;
        case tds.TYPES.Xml:
          return TYPES.Xml;
        case tds.TYPES.UDT:
          return TYPES.UDT;
        case tds.TYPES.TVP:
          return TYPES.TVP;
        case tds.TYPES.Variant:
          return TYPES.Variant;
        default:
          switch (type.id) {
            case N_TYPES.BitN:
              return TYPES.Bit;
            case N_TYPES.NumericN:
              return TYPES.Numeric;
            case N_TYPES.DecimalN:
              return TYPES.Decimal;
            case N_TYPES.IntN:
              if (length === 8)
                return TYPES.BigInt;
              if (length === 4)
                return TYPES.Int;
              if (length === 2)
                return TYPES.SmallInt;
              return TYPES.TinyInt;
            case N_TYPES.FloatN:
              if (length === 8)
                return TYPES.Float;
              return TYPES.Real;
            case N_TYPES.MoneyN:
              if (length === 8)
                return TYPES.Money;
              return TYPES.SmallMoney;
            case N_TYPES.DateTimeN:
              if (length === 8)
                return TYPES.DateTime;
              return TYPES.SmallDateTime;
          }
      }
    };
    var createColumns = function(metadata, arrayRowMode) {
      let out = {};
      if (arrayRowMode)
        out = [];
      for (let index = 0, length = metadata.length; index < length; index++) {
        const column = metadata[index];
        const outColumn = {
          index,
          name: column.colName,
          length: column.dataLength,
          type: getMssqlType(column.type, column.dataLength),
          scale: column.scale,
          precision: column.precision,
          nullable: !!(column.flags & 1),
          caseSensitive: !!(column.flags & 2),
          identity: !!(column.flags & 16),
          readOnly: !(column.flags & 12)
        };
        if (column.udtInfo) {
          outColumn.udt = {
            name: column.udtInfo.typeName,
            database: column.udtInfo.dbname,
            schema: column.udtInfo.owningSchema,
            assembly: column.udtInfo.assemblyName
          };
          if (DECLARATIONS[column.udtInfo.typeName]) {
            outColumn.type = DECLARATIONS[column.udtInfo.typeName];
          }
        }
        if (arrayRowMode) {
          out.push(outColumn);
        } else {
          out[column.colName] = outColumn;
        }
      }
      return out;
    };
    var valueCorrection = function(value, metadata) {
      const type = getMssqlType(metadata.type);
      if (valueHandler.has(type)) {
        return valueHandler.get(type)(value);
      } else if (metadata.type === tds.TYPES.UDT && value != null) {
        if (UDT[metadata.udtInfo.typeName]) {
          return UDT[metadata.udtInfo.typeName](value);
        } else {
          return value;
        }
      } else {
        return value;
      }
    };
    var parameterCorrection = function(value) {
      if (value instanceof Table) {
        const tvp = {
          name: value.name,
          schema: value.schema,
          columns: [],
          rows: value.rows
        };
        for (const col of value.columns) {
          tvp.columns.push({
            name: col.name,
            type: getTediousType(col.type),
            length: col.length,
            scale: col.scale,
            precision: col.precision
          });
        }
        return tvp;
      } else {
        return value;
      }
    };
    var Request = class extends BaseRequest {
      /*
      Execute specified sql batch.
      */
      _batch(batch, callback) {
        this._isBatch = true;
        this._query(batch, callback);
      }
      /*
      Bulk load.
      */
      _bulk(table, options, callback) {
        super._bulk(table, options, (err) => {
          if (err)
            return callback(err);
          try {
            table._makeBulk();
          } catch (e) {
            return callback(new RequestError(e, "EREQUEST"));
          }
          if (!table.name) {
            return callback(new RequestError("Table name must be specified for bulk insert.", "ENAME"));
          }
          if (table.name.charAt(0) === "@") {
            return callback(new RequestError("You can't use table variables for bulk insert.", "ENAME"));
          }
          const errors = [];
          const errorHandlers = {};
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection) => {
            const callbackWithRelease = (err3, ...args) => {
              try {
                this.parent.release(connection);
              } catch (e) {
              }
              callback(err3, ...args);
            };
            if (err2)
              return callbackWithRelease(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              return callbackWithRelease(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            const done = (err3, rowCount) => {
              if (err3 && (!errors.length || errors.length && err3.message !== errors[errors.length - 1].message)) {
                err3 = new RequestError(err3, "EREQUEST");
                if (this.stream)
                  this.emit("error", err3);
                errors.push(err3);
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                hasReturned = true;
                if (this.stream) {
                  callbackWithRelease(null, rowCount);
                } else {
                  callbackWithRelease(error, rowCount);
                }
              }
            };
            const bulk = connection.newBulkLoad(table.path, options, done);
            for (const col of table.columns) {
              bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision });
            }
            if (table.create) {
              const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path;
              const req = new tds.Request(`if object_id('${objectid.replace(/'/g, "''")}') is null ${table.declare()}`, (err3) => {
                if (err3)
                  return done(err3);
                connection.execBulkLoad(bulk, table.rows);
              });
              this._setCurrentRequest(req);
              connection.execSqlBatch(req);
            } else {
              connection.execBulkLoad(bulk, table.rows);
            }
          });
        });
      }
      /*
      Execute specified sql command.
      */
      _query(command, callback) {
        super._query(command, (err) => {
          if (err)
            return callback(err);
          const recordsets = [];
          const recordsetcolumns = [];
          const errors = [];
          const errorHandlers = {};
          const output = {};
          const rowsAffected = [];
          let columns = {};
          let recordset = [];
          let batchLastRow = null;
          let batchHasOutput = false;
          let isChunkedRecordset = false;
          let chunksBuffer = null;
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2)
              return callback(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            let row;
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              this.parent.release(connection);
              return callback(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            debug("request(%d): query", IDS.get(this), command);
            const req = new tds.Request(command, (err3) => {
              (err3?.errors ? err3.errors : [err3]).forEach((e, i, { length }) => {
                if (e && (!errors.length || errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message)) {
                  e = new RequestError(e, "EREQUEST");
                  if (this.stream)
                    this.emit("error", e);
                  errors.push(e);
                }
              });
              if (batchHasOutput) {
                if (!this.stream)
                  batchLastRow = recordsets.pop()[0];
                for (const name in batchLastRow) {
                  const value = batchLastRow[name];
                  if (name !== "___return___") {
                    output[name] = value;
                  }
                }
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                this.parent.release(connection);
                hasReturned = true;
                if (error) {
                  debug("request(%d): failed", IDS.get(this), error);
                } else {
                  debug("request(%d): completed", IDS.get(this));
                }
                if (this.stream) {
                  callback(null, null, output, rowsAffected, recordsetcolumns);
                } else {
                  callback(error, recordsets, output, rowsAffected, recordsetcolumns);
                }
              }
            });
            this._setCurrentRequest(req);
            req.on("columnMetadata", (metadata) => {
              columns = createColumns(metadata, this.arrayRowMode);
              isChunkedRecordset = false;
              if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
                isChunkedRecordset = true;
                chunksBuffer = [];
              }
              if (this.stream) {
                if (this._isBatch) {
                  if (!columns.___return___) {
                    this.emit("recordset", columns);
                  }
                } else {
                  this.emit("recordset", columns);
                }
              }
              if (this.arrayRowMode)
                recordsetcolumns.push(columns);
            });
            const doneHandler = (rowCount, more) => {
              if (rowCount != null) {
                rowsAffected.push(rowCount);
                if (this.stream) {
                  this.emit("rowsaffected", rowCount);
                }
              }
              if (Object.keys(columns).length === 0)
                return;
              if (isChunkedRecordset) {
                const concatenatedChunks = chunksBuffer.join("");
                if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
                  try {
                    if (concatenatedChunks === "") {
                      row = null;
                    } else {
                      row = JSON.parse(concatenatedChunks);
                    }
                  } catch (ex) {
                    row = null;
                    const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                    if (this.stream)
                      this.emit("error", ex2);
                    errors.push(ex2);
                  }
                } else {
                  row = {};
                  row[Object.keys(columns)[0]] = concatenatedChunks;
                }
                chunksBuffer = null;
                if (this.stream) {
                  this.emit("row", row);
                } else {
                  recordset.push(row);
                }
              }
              if (!this.stream) {
                Object.defineProperty(recordset, "columns", {
                  enumerable: false,
                  configurable: true,
                  value: columns
                });
                Object.defineProperty(recordset, "toTable", {
                  enumerable: false,
                  configurable: true,
                  value(name) {
                    return Table.fromRecordset(this, name);
                  }
                });
                recordsets.push(recordset);
              }
              recordset = [];
              columns = {};
            };
            req.on("doneInProc", doneHandler);
            req.on("done", doneHandler);
            req.on("returnValue", (parameterName, value, metadata) => {
              output[parameterName] = value;
            });
            req.on("row", (columns2) => {
              if (!recordset)
                recordset = [];
              if (isChunkedRecordset) {
                return chunksBuffer.push(columns2[0].value);
              }
              if (this.arrayRowMode) {
                row = [];
              } else {
                row = {};
              }
              for (const col of columns2) {
                col.value = valueCorrection(col.value, col.metadata);
                if (this.arrayRowMode) {
                  row.push(col.value);
                } else {
                  const exi = row[col.metadata.colName];
                  if (exi !== void 0) {
                    if (exi instanceof Array) {
                      exi.push(col.value);
                    } else {
                      row[col.metadata.colName] = [exi, col.value];
                    }
                  } else {
                    row[col.metadata.colName] = col.value;
                  }
                }
              }
              if (this.stream) {
                if (this._isBatch) {
                  if (row.___return___) {
                    batchLastRow = row;
                  } else {
                    this.emit("row", row);
                  }
                } else {
                  this.emit("row", row);
                }
              } else {
                recordset.push(row);
              }
            });
            if (this._isBatch) {
              if (Object.keys(this.parameters).length) {
                for (const name in this.parameters) {
                  if (!objectHasProperty(this.parameters, name)) {
                    continue;
                  }
                  const param = this.parameters[name];
                  try {
                    param.value = getTediousType(param.type).validate(param.value, this.parent.collation);
                  } catch (e) {
                    e.message = `Validation failed for parameter '${name}'. ${e.message}`;
                    const err3 = new RequestError(e, "EPARAM");
                    this.parent.release(connection);
                    return callback(err3);
                  }
                }
                const declarations = [];
                for (const name in this.parameters) {
                  if (!objectHasProperty(this.parameters, name)) {
                    continue;
                  }
                  const param = this.parameters[name];
                  declarations.push(`@${name} ${declare(param.type, param)}`);
                }
                const assigns = [];
                for (const name in this.parameters) {
                  if (!objectHasProperty(this.parameters, name)) {
                    continue;
                  }
                  const param = this.parameters[name];
                  assigns.push(`@${name} = ${cast(param.value, param.type, param)}`);
                }
                const selects = [];
                for (const name in this.parameters) {
                  if (!objectHasProperty(this.parameters, name)) {
                    continue;
                  }
                  const param = this.parameters[name];
                  if (param.io === 2) {
                    selects.push(`@${name} as [${name}]`);
                  }
                }
                batchHasOutput = selects.length > 0;
                req.sqlTextOrProcedure = `declare ${declarations.join(", ")};select ${assigns.join(", ")};${req.sqlTextOrProcedure};${batchHasOutput ? `select 1 as [___return___], ${selects.join(", ")}` : ""}`;
              }
            } else {
              for (const name in this.parameters) {
                if (!objectHasProperty(this.parameters, name)) {
                  continue;
                }
                const param = this.parameters[name];
                if (param.io === 1) {
                  req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
                } else {
                  req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
                }
              }
            }
            try {
              connection[this._isBatch ? "execSqlBatch" : "execSql"](req);
            } catch (error) {
              handleError(true, connection, error);
            }
          });
        });
      }
      /*
      Execute stored procedure with specified parameters.
      */
      _execute(procedure, callback) {
        super._execute(procedure, (err) => {
          if (err)
            return callback(err);
          const recordsets = [];
          const recordsetcolumns = [];
          const errors = [];
          const errorHandlers = {};
          const output = {};
          const rowsAffected = [];
          let columns = {};
          let recordset = [];
          let returnValue = 0;
          let isChunkedRecordset = false;
          let chunksBuffer = null;
          let hasReturned = false;
          const handleError = (doReturn, connection, info) => {
            let err2 = new Error(info.message);
            err2.info = info;
            err2 = new RequestError(err2, "EREQUEST");
            if (this.stream) {
              this.emit("error", err2);
            } else {
              if (doReturn && !hasReturned) {
                if (connection) {
                  for (const event in errorHandlers) {
                    connection.removeListener(event, errorHandlers[event]);
                  }
                  this.parent.release(connection);
                }
                hasReturned = true;
                callback(err2);
              }
            }
            errors.push(err2);
          };
          const handleInfo = (msg) => {
            this.emit("info", {
              message: msg.message,
              number: msg.number,
              state: msg.state,
              class: msg.class,
              lineNumber: msg.lineNumber,
              serverName: msg.serverName,
              procName: msg.procName
            });
          };
          this.parent.acquire(this, (err2, connection, config) => {
            if (err2)
              return callback(err2);
            debug("connection(%d): borrowed to request #%d", IDS.get(connection), IDS.get(this));
            let row;
            if (this.canceled) {
              debug("request(%d): canceled", IDS.get(this));
              this.parent.release(connection);
              return callback(new RequestError("Canceled.", "ECANCEL"));
            }
            this._cancel = () => {
              debug("request(%d): cancel", IDS.get(this));
              connection.cancel();
            };
            connection.on("infoMessage", errorHandlers.infoMessage = handleInfo);
            connection.on("errorMessage", errorHandlers.errorMessage = handleError.bind(null, false, connection));
            connection.on("error", errorHandlers.error = handleError.bind(null, true, connection));
            if (debug.enabled) {
              const params = Object.keys(this.parameters).map((k) => this.parameters[k]);
              const logValue = (s) => typeof s === "string" && s.length > 50 ? s.substring(0, 47) + "..." : s;
              const logName = (param) => param.name + " [sql." + param.type.name + "]";
              const logParams = {};
              params.forEach((p) => {
                logParams[logName(p)] = logValue(p.value);
              });
              debug("request(%d): execute %s %O", IDS.get(this), procedure, logParams);
            }
            const req = new tds.Request(procedure, (err3) => {
              if (err3 && (!errors.length || errors.length && err3.message !== errors[errors.length - 1].message)) {
                err3 = new RequestError(err3, "EREQUEST");
                if (this.stream)
                  this.emit("error", err3);
                errors.push(err3);
              }
              delete this._cancel;
              let error;
              if (errors.length && !this.stream) {
                error = errors.pop();
                error.precedingErrors = errors;
              }
              if (!hasReturned) {
                for (const event in errorHandlers) {
                  connection.removeListener(event, errorHandlers[event]);
                }
                this.parent.release(connection);
                hasReturned = true;
                if (error) {
                  debug("request(%d): failed", IDS.get(this), error);
                } else {
                  debug("request(%d): complete", IDS.get(this));
                }
                if (this.stream) {
                  callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);
                } else {
                  callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);
                }
              }
            });
            this._setCurrentRequest(req);
            req.on("columnMetadata", (metadata) => {
              columns = createColumns(metadata, this.arrayRowMode);
              isChunkedRecordset = false;
              if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
                isChunkedRecordset = true;
                chunksBuffer = [];
              }
              if (this.stream)
                this.emit("recordset", columns);
              if (this.arrayRowMode)
                recordsetcolumns.push(columns);
            });
            req.on("row", (columns2) => {
              if (!recordset)
                recordset = [];
              if (isChunkedRecordset) {
                return chunksBuffer.push(columns2[0].value);
              }
              if (this.arrayRowMode) {
                row = [];
              } else {
                row = {};
              }
              for (const col of columns2) {
                col.value = valueCorrection(col.value, col.metadata);
                if (this.arrayRowMode) {
                  row.push(col.value);
                } else {
                  const exi = row[col.metadata.colName];
                  if (exi != null) {
                    if (exi instanceof Array) {
                      exi.push(col.value);
                    } else {
                      row[col.metadata.colName] = [exi, col.value];
                    }
                  } else {
                    row[col.metadata.colName] = col.value;
                  }
                }
              }
              if (this.stream) {
                this.emit("row", row);
              } else {
                recordset.push(row);
              }
            });
            req.on("doneInProc", (rowCount, more) => {
              if (rowCount != null) {
                rowsAffected.push(rowCount);
                if (this.stream) {
                  this.emit("rowsaffected", rowCount);
                }
              }
              if (Object.keys(columns).length === 0)
                return;
              if (isChunkedRecordset) {
                if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
                  try {
                    if (chunksBuffer.length === 0) {
                      row = null;
                    } else {
                      row = JSON.parse(chunksBuffer.join(""));
                    }
                  } catch (ex) {
                    row = null;
                    const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), "EJSON");
                    if (this.stream)
                      this.emit("error", ex2);
                    errors.push(ex2);
                  }
                } else {
                  row = {};
                  row[Object.keys(columns)[0]] = chunksBuffer.join("");
                }
                chunksBuffer = null;
                if (this.stream) {
                  this.emit("row", row);
                } else {
                  recordset.push(row);
                }
              }
              if (!this.stream) {
                Object.defineProperty(recordset, "columns", {
                  enumerable: false,
                  configurable: true,
                  value: columns
                });
                Object.defineProperty(recordset, "toTable", {
                  enumerable: false,
                  configurable: true,
                  value(name) {
                    return Table.fromRecordset(this, name);
                  }
                });
                recordsets.push(recordset);
              }
              recordset = [];
              columns = {};
            });
            req.on("doneProc", (rowCount, more, returnStatus) => {
              returnValue = returnStatus;
            });
            req.on("returnValue", (parameterName, value, metadata) => {
              output[parameterName] = value;
            });
            for (const name in this.parameters) {
              if (!objectHasProperty(this.parameters, name)) {
                continue;
              }
              const param = this.parameters[name];
              if (param.io === 1) {
                req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
              } else {
                req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
              }
            }
            connection.callProcedure(req);
          });
        });
      }
      _pause() {
        super._pause();
        if (this._currentRequest) {
          this._currentRequest.pause();
        }
      }
      _resume() {
        super._resume();
        if (this._currentRequest) {
          this._currentRequest.resume();
        }
      }
    };
    module2.exports = Request;
  }
});

// node_modules/mssql/lib/tedious/index.js
var require_tedious2 = __commonJS({
  "node_modules/mssql/lib/tedious/index.js"(exports2, module2) {
    "use strict";
    var base = require_base();
    var ConnectionPool2 = require_connection_pool2();
    var Transaction = require_transaction3();
    var Request = require_request3();
    module2.exports = Object.assign({
      ConnectionPool: ConnectionPool2,
      Transaction,
      Request,
      PreparedStatement: base.PreparedStatement
    }, base.exports);
    Object.defineProperty(module2.exports, "Promise", {
      enumerable: true,
      get: () => {
        return base.Promise;
      },
      set: (value) => {
        base.Promise = value;
      }
    });
    Object.defineProperty(module2.exports, "valueHandler", {
      enumerable: true,
      value: base.valueHandler,
      writable: false,
      configurable: false
    });
    base.driver.name = "tedious";
    base.driver.ConnectionPool = ConnectionPool2;
    base.driver.Transaction = Transaction;
    base.driver.Request = Request;
  }
});

// node_modules/mssql/index.js
var require_mssql = __commonJS({
  "node_modules/mssql/index.js"(exports2, module2) {
    module2.exports = require_tedious2();
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(extension_exports);
var vscode3 = __toESM(require("vscode"));

// src/connectionManager.ts
var vscode = __toESM(require("vscode"));
var log = vscode.window.createOutputChannel("Query Store Reports");
function extractFromTreeNode(node) {
  const connInfo = node.connectionInfo ?? node.connectionProfile ?? node.connection;
  if (!connInfo || typeof connInfo !== "object") {
    const ownKeys2 = Object.getOwnPropertyNames(node);
    const protoKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(node) ?? {});
    log.appendLine(`[tree-node] No connectionInfo found. Own keys: ${ownKeys2.join(", ")}; Proto keys: ${protoKeys.join(", ")}`);
    log.appendLine(`[tree-node] Raw: ${JSON.stringify(node, null, 2)}`);
    return void 0;
  }
  const info = connInfo;
  log.appendLine(`[tree-node] connectionInfo keys: ${Object.keys(info).join(", ")}`);
  log.appendLine(`[tree-node] authenticationType: ${info.authenticationType}`);
  const profile = {
    server: String(info.server ?? ""),
    authenticationType: String(info.authenticationType ?? ""),
    database: info.database != null ? String(info.database) : void 0,
    user: info.user != null ? String(info.user) : void 0,
    password: info.password != null ? String(info.password) : void 0,
    connectionName: (info.connectionName ?? info.profileName) != null ? String(info.connectionName ?? info.profileName) : void 0,
    profileName: info.profileName != null ? String(info.profileName) : void 0,
    encrypt: info.encrypt != null ? Boolean(info.encrypt) : void 0,
    trustServerCertificate: info.trustServerCertificate != null ? Boolean(info.trustServerCertificate) : void 0,
    port: info.port != null ? Number(info.port) : void 0
  };
  const database = node.label ?? profile.database;
  return { profile, database };
}
async function resolveConnection(context, treeNode) {
  let profile;
  let database;
  if (treeNode) {
    const extracted = extractFromTreeNode(treeNode);
    if (extracted?.profile.server) {
      profile = extracted.profile;
      database = extracted.database;
    }
  }
  if (!profile) {
    const picked = await pickConnection(context);
    if (!picked) {
      return void 0;
    }
    profile = picked.profile;
    database = picked.database;
  }
  if (!database) {
    database = await vscode.window.showInputBox({
      prompt: "Enter the database name",
      placeHolder: "MyDatabase"
    });
    if (!database) {
      return void 0;
    }
  }
  const config = await buildSqlConfig(context, profile, database);
  if (!config) {
    return void 0;
  }
  const label = profile.connectionName ?? profile.profileName ?? `${profile.server}/${database}`;
  return { config, label, database };
}
async function pickConnection(context) {
  const mssqlConfig = vscode.workspace.getConfiguration("mssql");
  const connections = mssqlConfig.get("connections") ?? [];
  if (connections.length === 0) {
    vscode.window.showErrorMessage(
      "No SQL Server connections found. Please add a connection in the SQL Server extension first."
    );
    return void 0;
  }
  const items = connections.map((c) => ({
    label: c.connectionName ?? c.profileName ?? c.server,
    description: c.database ? `${c.server} / ${c.database}` : c.server,
    profile: c
  }));
  const selected = await vscode.window.showQuickPick(items, {
    placeHolder: "Select a SQL Server connection",
    matchOnDescription: true
  });
  if (!selected) {
    return void 0;
  }
  const profile = selected.profile;
  let database = profile.database;
  if (!database) {
    database = await vscode.window.showInputBox({
      prompt: `Enter the database name on ${profile.server}`,
      placeHolder: "MyDatabase"
    });
    if (!database) {
      return void 0;
    }
  }
  return { profile, database };
}
async function buildSqlConfig(context, profile, database) {
  let server = profile.server;
  let port = profile.port;
  const commaIdx = server.indexOf(",");
  if (commaIdx !== -1) {
    const parsed = parseInt(server.substring(commaIdx + 1), 10);
    if (!isNaN(parsed)) {
      port = port ?? parsed;
      server = server.substring(0, commaIdx);
    }
  }
  const authType = (profile.authenticationType ?? "SqlLogin").toLowerCase();
  const baseOptions = {
    encrypt: profile.encrypt !== false,
    trustServerCertificate: profile.trustServerCertificate ?? true,
    database,
    port
  };
  if (authType === "integrated" || authType === "windows") {
    return {
      server,
      options: baseOptions,
      domain: void 0
    };
  }
  if (authType === "azuremfa" || authType === "azureactivedirectory-mfa" || authType === "azureactivedirectorymfa") {
    const session = await vscode.authentication.getSession("microsoft", [
      "https://database.windows.net/.default"
    ], { createIfNone: true });
    if (!session) {
      vscode.window.showErrorMessage("Azure authentication was cancelled.");
      return void 0;
    }
    return {
      server,
      authentication: {
        type: "azure-active-directory-access-token",
        options: { token: session.accessToken }
      },
      options: baseOptions
    };
  }
  const user = profile.user ?? "";
  if (!user) {
    vscode.window.showErrorMessage("No username configured for this connection.");
    return void 0;
  }
  const secretKey = `queryStore:${profile.server}:${user}`;
  let password = await context.secrets.get(secretKey);
  if (!password) {
    password = await vscode.window.showInputBox({
      prompt: `Password for ${user}@${profile.server}`,
      password: true,
      ignoreFocusOut: true
    });
    if (!password) {
      return void 0;
    }
    const save = await vscode.window.showQuickPick(["Save password", "Do not save"], {
      placeHolder: "Save password for this session?"
    });
    if (save === "Save password") {
      await context.secrets.store(secretKey, password);
    }
  }
  return {
    server,
    user,
    password,
    options: baseOptions
  };
}

// src/panels/QueryStorePanel.ts
var vscode2 = __toESM(require("vscode"));

// src/queries/topResourceConsuming.ts
var sql = __toESM(require_mssql());
var METRIC_EXPR = {
  duration: "ROUND(CONVERT(float, SUM(rs.avg_duration*rs.count_executions))*0.001,2)",
  cpu: "ROUND(CONVERT(float, SUM(rs.avg_cpu_time*rs.count_executions))*0.001,2)",
  logicalReads: "ROUND(CONVERT(float, SUM(rs.avg_logical_io_reads*rs.count_executions))*8,2)",
  logicalWrites: "ROUND(CONVERT(float, SUM(rs.avg_logical_io_writes*rs.count_executions))*8,2)",
  physicalReads: "ROUND(CONVERT(float, SUM(rs.avg_physical_io_reads*rs.count_executions))*8,2)",
  memory: "ROUND(CONVERT(float, SUM(rs.avg_query_max_used_memory*rs.count_executions))*8,2)",
  rowcount: "ROUND(CONVERT(float, SUM(rs.avg_rowcount*rs.count_executions))*1,0)"
};
async function executeTopResourceConsuming(pool, params) {
  const request = pool.request();
  request.input("results_row_count", sql.Int, params.resultsRowCount);
  request.input("interval_start_time", sql.DateTimeOffset, params.intervalStartTime);
  request.input("interval_end_time", sql.DateTimeOffset, params.intervalEndTime);
  request.input("replica_group_id", sql.BigInt, params.replicaGroupId);
  const metricExpr = METRIC_EXPR[params.metric];
  const querySql = `
SELECT TOP (@results_row_count)
    p.query_id,
    q.object_id,
    ISNULL(OBJECT_NAME(q.object_id),'') object_name,
    qt.query_sql_text,
    ${metricExpr} metric_value,
    ROUND(CONVERT(float, SUM(rs.avg_duration*rs.count_executions))*0.001,2) total_duration,
    SUM(rs.count_executions) count_executions,
    COUNT(distinct p.plan_id) num_plans
FROM sys.query_store_runtime_stats rs
    JOIN sys.query_store_plan p ON p.plan_id = rs.plan_id
    JOIN sys.query_store_query q ON q.query_id = p.query_id
    JOIN sys.query_store_query_text qt ON q.query_text_id = qt.query_text_id
WHERE
    NOT (rs.first_execution_time > @interval_end_time OR rs.last_execution_time < @interval_start_time)
    AND rs.replica_group_id = @replica_group_id
GROUP BY p.query_id, qt.query_sql_text, q.object_id
HAVING COUNT(distinct p.plan_id) >= 1
ORDER BY metric_value DESC`;
  const result = await request.query(querySql);
  return result.recordset;
}

// src/queries/regressedQueries.ts
var sql2 = __toESM(require_mssql());
async function executeRegressedQueries(pool, params) {
  const request = pool.request();
  request.input("results_row_count", sql2.Int, params.resultsRowCount);
  request.input("recent_start_time", sql2.DateTimeOffset, params.recentStartTime);
  request.input("recent_end_time", sql2.DateTimeOffset, params.recentEndTime);
  request.input("history_start_time", sql2.DateTimeOffset, params.historyStartTime);
  request.input("history_end_time", sql2.DateTimeOffset, params.historyEndTime);
  request.input("min_exec_count", sql2.BigInt, params.minExecCount);
  request.input("replica_group_id", sql2.BigInt, params.replicaGroupId);
  const querySql = `
WITH
hist AS
(
SELECT
    p.query_id query_id,
    ROUND(CONVERT(float, SUM(rs.avg_duration*rs.count_executions))*0.001,2) total_duration,
    SUM(rs.count_executions) count_executions,
    COUNT(distinct p.plan_id) num_plans
FROM sys.query_store_runtime_stats rs
    JOIN sys.query_store_plan p ON p.plan_id = rs.plan_id
WHERE
    NOT (rs.first_execution_time > @history_end_time OR rs.last_execution_time < @history_start_time)
    AND rs.replica_group_id = @replica_group_id
GROUP BY p.query_id
),
recent AS
(
SELECT
    p.query_id query_id,
    ROUND(CONVERT(float, SUM(rs.avg_duration*rs.count_executions))*0.001,2) total_duration,
    SUM(rs.count_executions) count_executions,
    COUNT(distinct p.plan_id) num_plans
FROM sys.query_store_runtime_stats rs
    JOIN sys.query_store_plan p ON p.plan_id = rs.plan_id
WHERE
    NOT (rs.first_execution_time > @recent_end_time OR rs.last_execution_time < @recent_start_time)
    AND rs.replica_group_id = @replica_group_id
GROUP BY p.query_id
)
SELECT TOP (@results_row_count)
    results.query_id query_id,
    results.object_id object_id,
    ISNULL(OBJECT_NAME(results.object_id),'') object_name,
    results.query_sql_text query_sql_text,
    results.additional_duration_workload additional_duration_workload,
    results.total_duration_recent total_duration_recent,
    results.total_duration_hist total_duration_hist,
    ISNULL(results.count_executions_recent, 0) count_executions_recent,
    ISNULL(results.count_executions_hist, 0) count_executions_hist,
    queries.num_plans num_plans
FROM
(
SELECT
    hist.query_id query_id,
    q.object_id object_id,
    qt.query_sql_text query_sql_text,
    ROUND(CONVERT(float, recent.total_duration/recent.count_executions-hist.total_duration/hist.count_executions)*(recent.count_executions), 2) additional_duration_workload,
    ROUND(recent.total_duration, 2) total_duration_recent,
    ROUND(hist.total_duration, 2) total_duration_hist,
    recent.count_executions count_executions_recent,
    hist.count_executions count_executions_hist
FROM hist
    JOIN recent ON hist.query_id = recent.query_id
    JOIN sys.query_store_query q ON q.query_id = hist.query_id
    JOIN sys.query_store_query_text qt ON q.query_text_id = qt.query_text_id
WHERE
    recent.count_executions >= @min_exec_count
) AS results
JOIN
(
SELECT
    p.query_id query_id,
    COUNT(distinct p.plan_id) num_plans
FROM sys.query_store_plan p
GROUP BY p.query_id
HAVING COUNT(distinct p.plan_id) >= 1
) AS queries ON queries.query_id = results.query_id
WHERE additional_duration_workload > 0
ORDER BY additional_duration_workload DESC
OPTION (MERGE JOIN)`;
  const result = await request.query(querySql);
  return result.recordset;
}

// src/queries/highVariation.ts
var sql3 = __toESM(require_mssql());
async function executeHighVariation(pool, params) {
  const request = pool.request();
  request.input("results_row_count", sql3.Int, params.resultsRowCount);
  request.input("interval_start_time", sql3.DateTimeOffset, params.intervalStartTime);
  request.input("interval_end_time", sql3.DateTimeOffset, params.intervalEndTime);
  request.input("replica_group_id", sql3.BigInt, params.replicaGroupId);
  const querySql = `
SELECT TOP (@results_row_count)
    p.query_id query_id,
    q.object_id object_id,
    ISNULL(OBJECT_NAME(q.object_id),'') object_name,
    qt.query_sql_text query_sql_text,
    ROUND(CONVERT(float, SQRT( SUM(rs.stdev_duration*rs.stdev_duration*rs.count_executions)/NULLIF(SUM(rs.count_executions), 0)))*0.001,2) stdev_duration,
    ROUND(CONVERT(float, SUM(rs.avg_duration*rs.count_executions))/NULLIF(SUM(rs.count_executions), 0)*0.001,2) avg_duration,
    ISNULL(ROUND(CONVERT(float, (SQRT( SUM(rs.stdev_duration*rs.stdev_duration*rs.count_executions)/NULLIF(SUM(rs.count_executions), 0))*SUM(rs.count_executions)) / NULLIF(SUM(rs.avg_duration*rs.count_executions), 0)),2), 0) variation_duration,
    SUM(rs.count_executions) count_executions,
    COUNT(distinct p.plan_id) num_plans
FROM sys.query_store_runtime_stats rs
    JOIN sys.query_store_plan p ON p.plan_id = rs.plan_id
    JOIN sys.query_store_query q ON q.query_id = p.query_id
    JOIN sys.query_store_query_text qt ON q.query_text_id = qt.query_text_id
WHERE
    NOT (rs.first_execution_time > @interval_end_time OR rs.last_execution_time < @interval_start_time)
    AND rs.replica_group_id = @replica_group_id
GROUP BY p.query_id, qt.query_sql_text, q.object_id
HAVING COUNT(distinct p.plan_id) >= 1 AND SUM(rs.count_executions) > 1
ORDER BY variation_duration DESC`;
  const result = await request.query(querySql);
  return result.recordset;
}

// src/queries/waitStats.ts
var sql4 = __toESM(require_mssql());
async function executeWaitStats(pool, params) {
  const request = pool.request();
  request.input("interval_start_time", sql4.DateTimeOffset, params.intervalStartTime);
  request.input("interval_end_time", sql4.DateTimeOffset, params.intervalEndTime);
  request.input("results_row_count", sql4.Int, params.resultsRowCount);
  request.input("replica_group_id", sql4.BigInt, params.replicaGroupId);
  const querySql = `
SELECT TOP (@results_row_count)
    ws.wait_category wait_category,
    ws.wait_category_desc wait_category_desc,
    ROUND(CONVERT(float, SUM(ws.total_query_wait_time_ms)/SUM(ws.total_query_wait_time_ms/ws.avg_query_wait_time_ms))*1,2) avg_query_wait_time,
    ROUND(CONVERT(float, MIN(ws.min_query_wait_time_ms))*1,2) min_query_wait_time,
    ROUND(CONVERT(float, MAX(ws.max_query_wait_time_ms))*1,2) max_query_wait_time,
    ROUND(CONVERT(float, SQRT( SUM(ws.stdev_query_wait_time_ms*ws.stdev_query_wait_time_ms*(ws.total_query_wait_time_ms/ws.avg_query_wait_time_ms))/SUM(ws.total_query_wait_time_ms/ws.avg_query_wait_time_ms)))*1,2) stdev_query_wait_time,
    ROUND(CONVERT(float, SUM(ws.total_query_wait_time_ms))*1,2) total_query_wait_time,
    CAST(ROUND(SUM(ws.total_query_wait_time_ms/ws.avg_query_wait_time_ms),0) AS BIGINT) count_executions
FROM sys.query_store_wait_stats ws
    JOIN sys.query_store_runtime_stats_interval itvl ON itvl.runtime_stats_interval_id = ws.runtime_stats_interval_id
WHERE
    NOT (itvl.start_time > @interval_end_time OR itvl.end_time < @interval_start_time)
    AND ws.replica_group_id = @replica_group_id
GROUP BY ws.wait_category, wait_category_desc
ORDER BY total_query_wait_time DESC`;
  const result = await request.query(querySql);
  return result.recordset;
}

// src/queries/forcedPlans.ts
var sql5 = __toESM(require_mssql());
async function executeForcedPlans(pool, params) {
  const request = pool.request();
  request.input("replica_group_id", sql5.BigInt, params.replicaGroupId);
  const querySql = `
WITH
A AS
(
SELECT
    p.query_id query_id,
    qt.query_sql_text query_sql_text,
    p.plan_id plan_id,
    p.force_failure_count force_failure_count,
    p.last_force_failure_reason_desc last_force_failure_reason_desc,
    p.last_execution_time last_execution_time,
    q.object_id object_id,
    ISNULL(OBJECT_NAME(q.object_id),'') object_name,
    p.last_compile_start_time last_compile_start_time
FROM sys.query_store_plan p
    JOIN sys.query_store_query q ON q.query_id = p.query_id
    JOIN sys.query_store_query_text qt ON q.query_text_id = qt.query_text_id
where p.is_forced_plan = 1
),
B AS
(
SELECT
    p.query_id query_id,
    MAX(p.last_execution_time) last_execution_time,
    COUNT(distinct p.plan_id) num_plans
FROM sys.query_store_plan p
GROUP BY p.query_id
HAVING MAX(CAST(p.is_forced_plan AS tinyint)) = 1
)
SELECT
    A.query_id,
    A.query_sql_text,
    A.plan_id,
    A.force_failure_count,
    A.last_compile_start_time,
    A.last_force_failure_reason_desc,
    B.num_plans,
    B.last_execution_time,
    A.object_id,
    A.object_name
FROM A JOIN B ON A.query_id = B.query_id
WHERE B.num_plans >= 1
ORDER BY force_failure_count DESC`;
  const result = await request.query(querySql);
  return result.recordset;
}

// src/queries/overallConsumption.ts
var sql6 = __toESM(require_mssql());
async function executeOverallConsumption(pool, params) {
  const request = pool.request();
  request.input("interval_start_time", sql6.DateTimeOffset, params.intervalStartTime);
  request.input("interval_end_time", sql6.DateTimeOffset, params.intervalEndTime);
  request.input("replica_group_id", sql6.BigInt, params.replicaGroupId);
  const querySql = `
WITH DateGenerator AS
(
SELECT CAST(@interval_start_time AS DATETIME) DatePlaceHolder
UNION ALL
SELECT  DATEADD(d, 1, DatePlaceHolder)
FROM    DateGenerator
WHERE   DATEADD(d, 1, DatePlaceHolder) < @interval_end_time
), WaitStats AS
(
SELECT
    ROUND(CONVERT(float, SUM(ws.total_query_wait_time_ms))*1,2) total_query_wait_time
FROM sys.query_store_wait_stats ws
    JOIN sys.query_store_runtime_stats_interval itvl ON itvl.runtime_stats_interval_id = ws.runtime_stats_interval_id
WHERE
    NOT (itvl.start_time > @interval_end_time OR itvl.end_time < @interval_start_time)
    AND ws.replica_group_id = @replica_group_id
GROUP BY DATEDIFF(d, 0, itvl.end_time)
),
UnionAll AS
(
SELECT
    CONVERT(float, SUM(rs.count_executions)) as total_count_executions,
    ROUND(CONVERT(float, SUM(rs.avg_duration*rs.count_executions))*0.001,2) as total_duration,
    ROUND(CONVERT(float, SUM(rs.avg_cpu_time*rs.count_executions))*0.001,2) as total_cpu_time,
    ROUND(CONVERT(float, SUM(rs.avg_logical_io_reads*rs.count_executions))*8,2) as total_logical_io_reads,
    ROUND(CONVERT(float, SUM(rs.avg_logical_io_writes*rs.count_executions))*8,2) as total_logical_io_writes,
    ROUND(CONVERT(float, SUM(rs.avg_physical_io_reads*rs.count_executions))*8,2) as total_physical_io_reads,
    ROUND(CONVERT(float, SUM(rs.avg_clr_time*rs.count_executions))*0.001,2) as total_clr_time,
    ROUND(CONVERT(float, SUM(rs.avg_dop*rs.count_executions))*1,0) as total_dop,
    ROUND(CONVERT(float, SUM(rs.avg_query_max_used_memory*rs.count_executions))*8,2) as total_query_max_used_memory,
    ROUND(CONVERT(float, SUM(rs.avg_rowcount*rs.count_executions))*1,0) as total_rowcount,
    ROUND(CONVERT(float, SUM(rs.avg_log_bytes_used*rs.count_executions))*0.0009765625,2) as total_log_bytes_used,
    ROUND(CONVERT(float, SUM(rs.avg_tempdb_space_used*rs.count_executions))*8,2) as total_tempdb_space_used,
    TODATETIMEOFFSET(DATEADD(d, ((DATEDIFF(d, 0, SWITCHOFFSET(rs.last_execution_time, DATEPART(tz, @interval_start_time))))), 0), DATEPART(tz, @interval_start_time)) as bucket_start,
    TODATETIMEOFFSET(DATEADD(d, (1 + (DATEDIFF(d, 0, SWITCHOFFSET(rs.last_execution_time, DATEPART(tz, @interval_start_time))))), 0), DATEPART(tz, @interval_start_time)) as bucket_end
FROM sys.query_store_runtime_stats rs
WHERE
    NOT (rs.first_execution_time > @interval_end_time OR rs.last_execution_time < @interval_start_time)
    AND rs.replica_group_id = @replica_group_id
GROUP BY DATEDIFF(d, 0, SWITCHOFFSET(rs.last_execution_time, DATEPART(tz, @interval_start_time)))
)
SELECT
    total_count_executions,
    total_duration,
    total_cpu_time,
    total_logical_io_reads,
    total_logical_io_writes,
    total_physical_io_reads,
    total_clr_time,
    total_dop,
    total_query_max_used_memory,
    total_rowcount,
    total_log_bytes_used,
    total_tempdb_space_used,
    total_query_wait_time,
    bucket_start,
    bucket_end
FROM
(
SELECT *, ROW_NUMBER() OVER (PARTITION BY bucket_start ORDER BY bucket_start, total_duration DESC) AS RowNumber
FROM UnionAll , WaitStats
) as UnionAllResults
WHERE UnionAllResults.RowNumber = 1
OPTION (MAXRECURSION 0)`;
  const result = await request.query(querySql);
  return result.recordset;
}

// src/queries/executionStats.ts
var sql7 = __toESM(require_mssql());
async function executeExecutionStats(pool, params) {
  const request = pool.request();
  request.input("query_id", sql7.BigInt, params.queryId);
  request.input("replica_group_id", sql7.BigInt, params.replicaGroupId);
  request.input("interval_start_time", sql7.DateTimeOffset, params.intervalStartTime);
  request.input("interval_end_time", sql7.DateTimeOffset, params.intervalEndTime);
  const querySql = `
WITH
    bucketizer as
    (
        SELECT
            rs.plan_id as plan_id,
            rs.execution_type as execution_type,
            SUM(rs.count_executions) count_executions,
            DATEADD(mi, ((DATEDIFF(mi, 0, rs.last_execution_time))),0 ) as bucket_start,
            DATEADD(mi, (1 + (DATEDIFF(mi, 0, rs.last_execution_time))), 0) as bucket_end,
            ROUND(CONVERT(float, SUM(rs.avg_duration*rs.count_executions))/NULLIF(SUM(rs.count_executions), 0)*0.001,2) as avg_duration,
            ROUND(CONVERT(float, MAX(rs.max_duration))*0.001,2) as max_duration,
            ROUND(CONVERT(float, MIN(rs.min_duration))*0.001,2) as min_duration,
            ROUND(CONVERT(float, SQRT( SUM(rs.stdev_duration*rs.stdev_duration*rs.count_executions)/NULLIF(SUM(rs.count_executions), 0)))*0.001,2) as stdev_duration,
            ISNULL(ROUND(CONVERT(float, (SQRT( SUM(rs.stdev_duration*rs.stdev_duration*rs.count_executions)/NULLIF(SUM(rs.count_executions), 0))*SUM(rs.count_executions)) / NULLIF(SUM(rs.avg_duration*rs.count_executions), 0)),2), 0) as variation_duration,
            ROUND(CONVERT(float, SUM(rs.avg_duration*rs.count_executions))*0.001,2) as total_duration
        FROM
            sys.query_store_runtime_stats rs
            JOIN sys.query_store_plan p ON p.plan_id = rs.plan_id
        WHERE
            p.query_id = @query_id
        AND NOT (rs.first_execution_time > @interval_end_time OR rs.last_execution_time < @interval_start_time)
            AND rs.replica_group_id = @replica_group_id
        GROUP BY
            rs.plan_id,
            rs.execution_type,
            DATEDIFF(mi, 0, rs.last_execution_time)
    ),
    is_forced as
    (
        SELECT is_forced_plan, plan_id
          FROM sys.query_store_plan
    )
SELECT b.plan_id as plan_id,
    is_forced_plan,
    execution_type,
    count_executions,
    SWITCHOFFSET(bucket_start, DATEPART(tz, @interval_start_time)) AS bucket_start,
    SWITCHOFFSET(bucket_end, DATEPART(tz, @interval_start_time)) AS bucket_end,
    avg_duration,
    max_duration,
    min_duration,
    stdev_duration,
    variation_duration,
    total_duration
FROM bucketizer b
JOIN is_forced f ON f.plan_id = b.plan_id`;
  const result = await request.query(querySql);
  return result.recordset;
}

// src/queries/queryPlan.ts
var sql8 = __toESM(require_mssql());
async function executeQueryPlan(pool, params) {
  const request = pool.request();
  request.input("query_id", sql8.BigInt, params.queryId);
  request.input("plan_id", sql8.BigInt, params.planId);
  const querySql = `
SELECT
    p.is_forced_plan,
    p.query_plan
FROM
    sys.query_store_plan p
WHERE
    p.query_id = @query_id
    AND p.plan_id = @plan_id`;
  const result = await request.query(querySql);
  return result.recordset;
}

// src/panels/QueryStorePanel.ts
var REPORT_TITLES = {
  ["topResources" /* TopResources */]: "Top Resource Consuming Queries",
  ["regressed" /* Regressed */]: "Regressed Queries",
  ["highVariation" /* HighVariation */]: "Queries with High Variation",
  ["waitStats" /* WaitStats */]: "Overall Wait Statistics",
  ["forcedPlans" /* ForcedPlans */]: "Forced Plans",
  ["overallConsumption" /* OverallConsumption */]: "Overall Resource Consumption"
};
function hoursAgo(h) {
  return new Date(Date.now() - h * 60 * 60 * 1e3);
}
function daysAgo(d) {
  return new Date(Date.now() - d * 24 * 60 * 60 * 1e3);
}
var QueryStorePanel = class _QueryStorePanel {
  constructor(panel, extensionUri, reportType, runner, connectionLabel, database, key) {
    this.reportType = reportType;
    this.runner = runner;
    this.connectionLabel = connectionLabel;
    this.database = database;
    this.key = key;
    this._panel = panel;
    _QueryStorePanel.currentPanels.set(key, this);
    this._panel.webview.html = this._getHtml(extensionUri);
    this._panel.webview.onDidReceiveMessage(
      (msg) => this._handleMessage(msg),
      void 0,
      this._disposables
    );
    this._panel.onDidDispose(() => this._dispose(), void 0, this._disposables);
  }
  static currentPanels = /* @__PURE__ */ new Map();
  _panel;
  _disposables = [];
  static createOrShow(extensionUri, reportType, runner, connectionLabel, database) {
    const key = `${connectionLabel}::${database}::${reportType}`;
    const existing = _QueryStorePanel.currentPanels.get(key);
    if (existing) {
      existing._panel.reveal(vscode2.ViewColumn.One);
      return;
    }
    const panel = vscode2.window.createWebviewPanel(
      "queryStoreReport",
      `${REPORT_TITLES[reportType]} \u2014 ${database}`,
      vscode2.ViewColumn.One,
      {
        enableScripts: true,
        localResourceRoots: [vscode2.Uri.joinPath(extensionUri, "media")],
        retainContextWhenHidden: true
      }
    );
    new _QueryStorePanel(panel, extensionUri, reportType, runner, connectionLabel, database, key);
  }
  _dispose() {
    _QueryStorePanel.currentPanels.delete(this.key);
    this._panel.dispose();
    for (const d of this._disposables) {
      d.dispose();
    }
    this._disposables = [];
  }
  async _handleMessage(msg) {
    switch (msg.type) {
      case "refresh": {
        const params = msg.params;
        await this._loadMainData(params);
        break;
      }
      case "drilldown": {
        const queryId = msg.queryId;
        const planId = msg.planId;
        await this._loadDrilldown(queryId, planId, msg.params);
        break;
      }
      case "getPlan": {
        const queryId = msg.queryId;
        const planId = msg.planId;
        await this._loadPlan(queryId, planId);
        break;
      }
      case "forcePlan": {
        const queryId = msg.queryId;
        const planId = msg.planId;
        await this._forcePlan(queryId, planId);
        break;
      }
      case "removeForcedPlan": {
        const queryId = msg.queryId;
        await this._removeForcedPlan(queryId);
        break;
      }
    }
  }
  _post(msg) {
    this._panel.webview.postMessage(msg).then(void 0, () => {
    });
  }
  async _loadMainData(params) {
    this._post({ type: "loading" });
    try {
      const pool = await this.runner.getPool();
      let rows;
      const p = params;
      const dt = (key, fallback) => {
        const v = p[key];
        return v ? new Date(v) : fallback;
      };
      switch (this.reportType) {
        case "topResources" /* TopResources */: {
          rows = await executeTopResourceConsuming(pool, {
            resultsRowCount: Number(p.resultsRowCount ?? 25),
            intervalStartTime: dt("intervalStartTime", hoursAgo(1)),
            intervalEndTime: dt("intervalEndTime", /* @__PURE__ */ new Date()),
            replicaGroupId: Number(p.replicaGroupId ?? 1),
            metric: p.metric ?? "duration"
          });
          break;
        }
        case "regressed" /* Regressed */: {
          rows = await executeRegressedQueries(pool, {
            resultsRowCount: Number(p.resultsRowCount ?? 25),
            recentStartTime: dt("recentStartTime", hoursAgo(1)),
            recentEndTime: dt("recentEndTime", /* @__PURE__ */ new Date()),
            historyStartTime: dt("historyStartTime", daysAgo(7)),
            historyEndTime: dt("historyEndTime", /* @__PURE__ */ new Date()),
            minExecCount: Number(p.minExecCount ?? 1),
            replicaGroupId: Number(p.replicaGroupId ?? 1)
          });
          break;
        }
        case "highVariation" /* HighVariation */: {
          rows = await executeHighVariation(pool, {
            resultsRowCount: Number(p.resultsRowCount ?? 25),
            intervalStartTime: dt("intervalStartTime", hoursAgo(1)),
            intervalEndTime: dt("intervalEndTime", /* @__PURE__ */ new Date()),
            replicaGroupId: Number(p.replicaGroupId ?? 1)
          });
          break;
        }
        case "waitStats" /* WaitStats */: {
          rows = await executeWaitStats(pool, {
            resultsRowCount: Number(p.resultsRowCount ?? 10),
            intervalStartTime: dt("intervalStartTime", hoursAgo(1)),
            intervalEndTime: dt("intervalEndTime", /* @__PURE__ */ new Date()),
            replicaGroupId: Number(p.replicaGroupId ?? 1)
          });
          break;
        }
        case "forcedPlans" /* ForcedPlans */: {
          rows = await executeForcedPlans(pool, {
            replicaGroupId: Number(p.replicaGroupId ?? 1)
          });
          break;
        }
        case "overallConsumption" /* OverallConsumption */: {
          rows = await executeOverallConsumption(pool, {
            intervalStartTime: dt("intervalStartTime", daysAgo(30)),
            intervalEndTime: dt("intervalEndTime", /* @__PURE__ */ new Date()),
            replicaGroupId: Number(p.replicaGroupId ?? 1)
          });
          break;
        }
        default:
          rows = [];
      }
      this._post({ type: "data", rows });
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      this._post({ type: "error", message });
    }
  }
  async _loadDrilldown(queryId, planId, mainParams) {
    try {
      const pool = await this.runner.getPool();
      const statsParams = {
        queryId,
        replicaGroupId: Number(mainParams?.replicaGroupId ?? 1),
        intervalStartTime: new Date(mainParams?.intervalStartTime ?? mainParams?.recentStartTime ?? hoursAgo(1)),
        intervalEndTime: new Date(mainParams?.intervalEndTime ?? mainParams?.recentEndTime ?? /* @__PURE__ */ new Date())
      };
      const statsRows = await executeExecutionStats(pool, statsParams);
      this._post({ type: "drilldownData", rows: statsRows });
      let effectivePlanId = planId;
      if ((!effectivePlanId || effectivePlanId <= 0) && statsRows.length > 0) {
        const latestRow = statsRows.reduce((a, b) => {
          const ta = new Date(a.bucket_start).getTime();
          const tb = new Date(b.bucket_start).getTime();
          return tb > ta ? b : a;
        });
        effectivePlanId = latestRow.plan_id;
      }
      if (effectivePlanId) {
        await this._loadPlan(queryId, effectivePlanId);
      } else {
        this._post({ type: "planData", xml: "", isForcedPlan: false, planId: 0 });
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      this._post({ type: "error", message });
    }
  }
  async _loadPlan(queryId, planId) {
    try {
      const pool = await this.runner.getPool();
      const planParams = { queryId, planId };
      const planRows = await executeQueryPlan(pool, planParams);
      if (planRows.length > 0 && planRows[0].query_plan) {
        this._post({ type: "planData", xml: planRows[0].query_plan, isForcedPlan: planRows[0].is_forced_plan, planId });
      } else {
        this._post({ type: "planData", xml: "", isForcedPlan: false, planId });
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      this._post({ type: "error", message });
    }
  }
  async _forcePlan(queryId, planId) {
    try {
      const pool = await this.runner.getPool();
      const request = pool.request();
      request.input("query_id", queryId);
      request.input("plan_id", planId);
      await request.query(
        `EXEC sp_query_store_force_plan @query_id = @query_id, @plan_id = @plan_id`
      );
      this._post({ type: "forcePlanResult", success: true, queryId, planId });
      vscode2.window.showInformationMessage(`Plan ${planId} forced for query ${queryId}.`);
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      this._post({ type: "forcePlanResult", success: false, message });
    }
  }
  async _removeForcedPlan(queryId) {
    try {
      const pool = await this.runner.getPool();
      const request = pool.request();
      request.input("query_id", queryId);
      await request.query(
        `EXEC sp_query_store_unforce_plan @query_id = @query_id, @plan_id = NULL`
      );
      this._post({ type: "removeForcedPlanResult", success: true, queryId });
      vscode2.window.showInformationMessage(`Forced plan removed for query ${queryId}.`);
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      this._post({ type: "removeForcedPlanResult", success: false, message });
    }
  }
  _getHtml(extensionUri) {
    const webview = this._panel.webview;
    const chartUri = webview.asWebviewUri(vscode2.Uri.joinPath(extensionUri, "media", "chart.umd.min.js"));
    const scriptUri = webview.asWebviewUri(vscode2.Uri.joinPath(extensionUri, "media", "webview.js"));
    const styleUri = webview.asWebviewUri(vscode2.Uri.joinPath(extensionUri, "media", "style.css"));
    const csp = webview.cspSource;
    const defaultNow = (/* @__PURE__ */ new Date()).toISOString();
    const defaultMinus1h = hoursAgo(1).toISOString();
    const defaultMinus7d = daysAgo(7).toISOString();
    const defaultMinus30d = daysAgo(30).toISOString();
    const reportTitle = REPORT_TITLES[this.reportType];
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; script-src ${csp}; style-src ${csp} 'unsafe-inline'; img-src ${csp} data:;">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="${styleUri}">
  <title>${reportTitle}</title>
</head>
<body>
  <div id="app"
    data-report-type="${this.reportType}"
    data-connection="${escapeHtml(this.connectionLabel)}"
    data-database="${escapeHtml(this.database)}"
    data-title="${escapeHtml(reportTitle)}"
    data-default-now="${defaultNow}"
    data-default-minus1h="${defaultMinus1h}"
    data-default-minus7d="${defaultMinus7d}"
    data-default-minus30d="${defaultMinus30d}"
  >
    <header class="qs-header">
      <div class="qs-header-title">
        <span class="qs-report-name">${escapeHtml(reportTitle)}</span>
        <span class="qs-connection-label">${escapeHtml(this.connectionLabel)} / ${escapeHtml(this.database)}</span>
      </div>
    </header>
    <div id="toolbar" class="qs-toolbar"></div>
    <div id="status-bar" class="qs-status hidden"></div>
    <div id="main-content" class="qs-main">
      <div id="chart-section" class="qs-chart-section">
        <canvas id="main-chart"></canvas>
      </div>
      <div id="grid-section" class="qs-grid-section">
        <div id="grid-container" class="qs-grid-container"></div>
      </div>
    </div>
    <div id="drilldown-section" class="qs-drilldown hidden">
      <div class="qs-drilldown-header">
        <span id="drilldown-title" class="qs-drilldown-title"></span>
        <button id="drilldown-close" class="qs-btn-icon" title="Close">\u2715</button>
      </div>
      <div id="drilldown-stats-section" class="qs-drilldown-chart-section">
        <canvas id="drilldown-chart"></canvas>
      </div>
      <div id="plan-section" class="qs-plan-section">
        <div class="qs-plan-toolbar">
          <span class="qs-plan-label">Query Execution Plan</span>
          <button id="force-plan-btn" class="qs-btn qs-btn-sm" style="display:none">Force This Plan</button>
          <button id="unforce-plan-btn" class="qs-btn qs-btn-sm qs-btn-danger" style="display:none">Remove Forced Plan</button>
          <button id="plan-zoom-fit" class="qs-btn qs-btn-sm">Fit</button>
          <button id="plan-zoom-in"  class="qs-btn qs-btn-sm">+</button>
          <button id="plan-zoom-out" class="qs-btn qs-btn-sm">\u2212</button>
        </div>
        <div id="plan-container" class="qs-plan-container">
          <div id="plan-canvas"></div>
        </div>
        <div id="plan-tooltip" class="qs-plan-tooltip hidden"></div>
      </div>
    </div>
  </div>
  <script src="${chartUri}"></script>
  <script src="${scriptUri}"></script>
</body>
</html>`;
  }
};
function escapeHtml(s) {
  return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// src/queryRunner.ts
var sql9 = __toESM(require_mssql());
var QueryRunner = class {
  constructor(config) {
    this.config = config;
  }
  pool = null;
  connectPromise = null;
  async getPool() {
    if (this.pool?.connected) {
      return this.pool;
    }
    if (!this.connectPromise) {
      this.connectPromise = new sql9.ConnectionPool(this.config).connect().then((p) => {
        this.pool = p;
        this.connectPromise = null;
        return p;
      }).catch((err) => {
        this.connectPromise = null;
        throw err;
      });
    }
    return this.connectPromise;
  }
  async close() {
    if (this.pool) {
      await this.pool.close();
      this.pool = null;
    }
  }
};

// src/extension.ts
var runners = /* @__PURE__ */ new Map();
function activate(context) {
  const registerCommand = (reportType) => {
    return vscode3.commands.registerCommand(`queryStore.${reportType}`, async (treeNode) => {
      try {
        const resolved = await resolveConnection(context, treeNode);
        if (!resolved) {
          return;
        }
        const { config, label, database } = resolved;
        const runnerKey = `${config.server}:${database}`;
        let runner = runners.get(runnerKey);
        if (!runner) {
          runner = new QueryRunner(config);
          runners.set(runnerKey, runner);
        }
        QueryStorePanel.createOrShow(context.extensionUri, reportType, runner, label, database);
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        vscode3.window.showErrorMessage(`Query Store: ${message}`);
      }
    });
  };
  context.subscriptions.push(
    registerCommand("topResources" /* TopResources */),
    registerCommand("regressed" /* Regressed */),
    registerCommand("highVariation" /* HighVariation */),
    registerCommand("waitStats" /* WaitStats */),
    registerCommand("forcedPlans" /* ForcedPlans */),
    registerCommand("overallConsumption" /* OverallConsumption */)
  );
  context.subscriptions.push({
    dispose: () => {
      for (const runner of runners.values()) {
        runner.close().catch(() => {
        });
      }
      runners.clear();
    }
  });
}
function deactivate() {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
/*! Bundled license information:

@azure/msal-common/lib/index-node-BtzY9XyU.js:
  (*! @azure/msal-common v15.15.0 2026-02-23 *)

@azure/msal-common/lib/index-browser.cjs:
  (*! @azure/msal-common v15.15.0 2026-02-23 *)

@azure/msal-common/lib/index.cjs:
  (*! @azure/msal-common v15.15.0 2026-02-23 *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@azure/msal-node/lib/msal-node.cjs:
  (*! @azure/msal-node v3.8.8 2026-02-23 *)
  (*! @azure/msal-common v15.15.0 2026-02-23 *)

js-md4/src/md4.js:
  (**
   * [js-md4]{@link https://github.com/emn178/js-md4}
   *
   * @namespace md4
   * @version 0.3.2
   * @author Yi-Cyuan Chen [emn178@gmail.com]
   * @copyright Yi-Cyuan Chen 2015-2027
   * @license MIT
   *)

@js-joda/core/dist/js-joda.js:
  (*! @version @js-joda/core - 5.7.0 *)
  (*! @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors *)
  (*! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos *)
  (*! @license BSD-3-Clause (see LICENSE in the root directory of this source tree) *)
  (**
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (**
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thrwchter, Pattrick Hper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
*/
//# sourceMappingURL=extension.js.map
